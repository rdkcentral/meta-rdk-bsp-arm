##########################################
Date: Apr 10, 2025 2:08 PM
From:
Subject: Applying MTK patches for Hostapd 2.12 on top of 2.11 for wifi 7 MLO
Source: https://git01.mediatek.com
Upstream-Status: Pending
Signed-off-by: ssiras826 <ssiras826@cable.comcast.com>
##########################################
diff --git a/afc/.gitignore b/afc/.gitignore
new file mode 100644
index 0000000..8d8cca9
--- /dev/null
+++ b/afc/.gitignore
@@ -0,0 +1 @@
+afcd
diff --git a/afc/Makefile b/afc/Makefile
new file mode 100644
index 0000000..a83bd01
--- /dev/null
+++ b/afc/Makefile
@@ -0,0 +1,31 @@
+ALL=afcd
+
+include ../src/build.rules
+
+CFLAGS += -I../src/utils
+CFLAGS += -I../src
+
+OBJS=afcd.o
+OBJS += ../src/utils/common.o
+OBJS += ../src/utils/wpa_debug.o
+OBJS += ../src/utils/wpabuf.o
+
+ifndef CONFIG_OS
+ifdef CONFIG_NATIVE_WINDOWS
+CONFIG_OS=win32
+else
+CONFIG_OS=unix
+endif
+endif
+OBJS += ../src/utils/os_$(CONFIG_OS).o
+
+LIBS += -lcurl
+
+_OBJS_VAR := OBJS
+include ../src/objs.mk
+afcd: $(OBJS)
+	$(Q)$(LDO) $(LDFLAGS) -o afcd $(OBJS) $(LIBS)
+	@$(E) "  LD " $@
+
+clean: common-clean
+	rm -f core *~
diff --git a/afc/afc-reply.txt b/afc/afc-reply.txt
new file mode 100644
index 0000000..aaa4f89
--- /dev/null
+++ b/afc/afc-reply.txt
@@ -0,0 +1,219 @@
+HTTP/1.1 200 OK
+Content-Type: application/json
+Content-Length: 4843
+
+{
+   "availableSpectrumInquiryResponses":[
+      {
+         "availabilityExpireTime":"2023-02-23T12:53:18Z",
+         "availableChannelInfo":[
+            {
+               "channelCfi":[
+                  1,
+                  5,
+                  9,
+                  13,
+                  17,
+                  21,
+                  25,
+                  29,
+                  33,
+                  37,
+                  41,
+                  45,
+                  49,
+                  53,
+                  57,
+                  61,
+                  65,
+                  69,
+                  73,
+                  77,
+                  81,
+                  85,
+                  89,
+                  93,
+                  117,
+                  121,
+                  125,
+                  129,
+                  133,
+                  137,
+                  141,
+                  145,
+                  149,
+                  153,
+                  157,
+                  161,
+                  165,
+                  169,
+                  173,
+                  177,
+                  181
+               ],
+               "globalOperatingClass":131,
+               "maxEirp":[
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5
+               ]
+            },
+            {
+               "channelCfi":[
+                  3,
+                  11,
+                  19,
+                  27,
+                  35,
+                  43,
+                  51,
+                  59,
+                  67,
+                  75,
+                  83,
+                  91,
+                  123,
+                  131,
+                  139,
+                  147,
+                  155,
+                  163,
+                  171,
+                  179
+               ],
+               "globalOperatingClass":132,
+               "maxEirp":[
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5
+               ]
+            },
+            {
+               "channelCfi":[
+                  7,
+                  23,
+                  39,
+                  55,
+                  71,
+                  87,
+                  135,
+                  151,
+                  167
+               ],
+               "globalOperatingClass":133,
+               "maxEirp":[
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5,
+                  5
+               ]
+            },
+            {
+               "channelCfi":[
+                  15,
+                  47,
+                  79,
+                  143
+               ],
+               "globalOperatingClass":134,
+               "maxEirp":[
+                  5,
+                  5,
+                  5,
+                  5
+               ]
+            },
+            {
+               "channelCfi":[
+               ],
+               "globalOperatingClass":135,
+               "maxEirp":[
+               ]
+            }
+         ],
+         "availableFrequencyInfo":[
+            {
+               "frequencyRange":{
+                  "highFrequency":6425,
+                  "lowFrequency":5925
+               },
+               "maxPSD":3.98970004336019
+            },
+            {
+               "frequencyRange":{
+                  "highFrequency":6865,
+                  "lowFrequency":6525
+               },
+               "maxPSD":3.98970004336019
+            }
+         ],
+         "requestId":"11235813",
+         "response":{
+            "responseCode":0,
+            "shortDescription":"Success"
+         },
+         "rulesetId":"US_47_CFR_PART_15_SUBPART_E"
+      }
+   ],
+   "version":"1.1"
+}
diff --git a/afc/afcd.c b/afc/afcd.c
new file mode 100644
index 0000000..2b99940
--- /dev/null
+++ b/afc/afcd.c
@@ -0,0 +1,305 @@
+/*
+ * Automated Frequency Coordination Daemon
+ * Copyright (c) 2024, Lorenzo Bianconi <lorenzo@kernel.org>
+ *
+ * This software may be distributed under the terms of the BSD license.
+ * See README for more details.
+ */
+
+#include <curl/curl.h>
+#include <sys/un.h>
+#include <sys/stat.h>
+
+#include "utils/includes.h"
+#include "utils/common.h"
+
+#define CURL_TIMEOUT	60
+#define AFCD_SOCK	"afcd.sock"
+
+struct curl_ctx {
+	char *buf;
+	size_t buf_len;
+};
+
+static volatile bool exiting;
+
+static char *path = "/var/run";
+static char *bearer_token;
+static char *url;
+static int port = 443;
+
+
+static size_t afcd_curl_cb_write(void *ptr, size_t size, size_t nmemb,
+				 void *userdata)
+{
+	struct curl_ctx *ctx = userdata;
+	char *buf;
+
+	buf = os_realloc(ctx->buf, ctx->buf_len + size * nmemb + 1);
+	if (!buf)
+		return 0;
+
+	ctx->buf = buf;
+	os_memcpy(buf + ctx->buf_len, ptr, size * nmemb);
+	buf[ctx->buf_len + size * nmemb] = '\0';
+	ctx->buf_len += size * nmemb;
+
+	return size * nmemb;
+}
+
+
+static int afcd_send_request(struct curl_ctx *ctx, unsigned char *request)
+{
+	struct curl_slist *headers = NULL, *tmp;
+	int ret = CURLE_FAILED_INIT;
+	CURL *curl;
+
+	wpa_printf(MSG_DEBUG, "Sending AFC request to %s", url);
+
+	curl_global_init(CURL_GLOBAL_ALL);
+	curl = curl_easy_init();
+	if (!curl)
+		goto out_global_cleanup;
+
+	headers  = curl_slist_append(headers, "Accept: application/json");
+	if (!headers)
+		goto out_easy_cleanup;
+
+	tmp = curl_slist_append(headers, "Content-Type: application/json");
+	if (!tmp)
+		goto out_slist_free_all;
+	headers = tmp;
+
+	tmp = curl_slist_append(headers, "charset: utf-8");
+	if (!tmp)
+		goto out_slist_free_all;
+	headers = tmp;
+
+	curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
+	curl_easy_setopt(curl, CURLOPT_URL, url);
+	curl_easy_setopt(curl, CURLOPT_PORT, port);
+	curl_easy_setopt(curl, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);
+	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION,
+			 afcd_curl_cb_write);
+	curl_easy_setopt(curl, CURLOPT_WRITEDATA, ctx);
+	curl_easy_setopt(curl, CURLOPT_USERAGENT, "libcrp/0.1");
+	curl_easy_setopt(curl, CURLOPT_TIMEOUT, CURL_TIMEOUT);
+	curl_easy_setopt(curl, CURLOPT_SSLVERSION, CURL_SSLVERSION_TLSv1_2);
+	if (bearer_token)
+		curl_easy_setopt(curl, CURLOPT_XOAUTH2_BEARER, bearer_token);
+	curl_easy_setopt(curl, CURLOPT_HTTPAUTH, CURLAUTH_BEARER);
+	curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1L);
+	curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 1L);
+	curl_easy_setopt(curl, CURLOPT_POSTFIELDS, request);
+	curl_easy_setopt(curl, CURLOPT_SSL_VERIFYSTATUS, 1L);
+
+	ret = curl_easy_perform(curl);
+	if (ret != CURLE_OK)
+		wpa_printf(MSG_ERROR, "curl_easy_perform failed: %s",
+			   curl_easy_strerror(ret));
+
+out_slist_free_all:
+	curl_slist_free_all(headers);
+out_easy_cleanup:
+	curl_easy_cleanup(curl);
+out_global_cleanup:
+	curl_global_cleanup();
+
+	return ret == CURLE_OK ? 0 : -EINVAL;
+}
+
+
+static void handle_term(int sig)
+{
+	wpa_printf(MSG_ERROR, "Received signal %d", sig);
+	exiting = true;
+}
+
+
+static void usage(void)
+{
+	wpa_printf(MSG_ERROR,
+		   "%s:\n"
+		   "afcd -u<url> [-p<port>][-t<token>][-D<unix-sock dir>][-P<PID file>][-dB]",
+		   __func__);
+}
+
+
+#define BUFSIZE		8192
+static int afcd_server_run(void)
+{
+	size_t len = os_strlen(path) + 1 + os_strlen(AFCD_SOCK);
+	struct sockaddr_un addr = {
+		.sun_family = AF_UNIX,
+#ifdef __FreeBSD__
+		.sun_len = sizeof(addr),
+#endif /* __FreeBSD__ */
+	};
+	int sockfd, ret = 0;
+	char *fname = NULL;
+	unsigned char *buf;
+	fd_set read_set;
+
+	if (len >= sizeof(addr.sun_path))
+		return -EINVAL;
+
+	if (mkdir(path, S_IRWXU | S_IRWXG) < 0 && errno != EEXIST)
+		return -EINVAL;
+
+	buf = os_malloc(BUFSIZE);
+	if (!buf)
+		return -ENOMEM;
+
+	fname = os_malloc(len + 1);
+	if (!fname) {
+		ret = -ENOMEM;
+		goto free_buf;
+	}
+
+	os_snprintf(fname, len + 1, "%s/%s", path, AFCD_SOCK);
+	fname[len] = '\0';
+	os_strlcpy(addr.sun_path, fname, sizeof(addr.sun_path));
+
+	sockfd = socket(AF_UNIX, SOCK_STREAM, 0);
+	if (sockfd < 0) {
+		wpa_printf(MSG_ERROR, "Failed creating socket");
+		ret = -errno;
+		goto unlink;
+	}
+
+	if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+		wpa_printf(MSG_ERROR, "Failed to bind socket");
+		ret = -errno;
+		goto close;
+	}
+
+	if (listen(sockfd, 10) < 0) {
+		wpa_printf(MSG_ERROR, "Failed to listen on socket");
+		ret = -errno;
+		goto close;
+	}
+
+	FD_ZERO(&read_set);
+	while (!exiting) {
+		socklen_t addr_len = sizeof(addr);
+		struct sockaddr_in6 c_addr;
+		struct timeval timeout = {
+			.tv_sec = 1,
+		};
+		struct curl_ctx ctx = {};
+		int fd;
+
+		FD_SET(sockfd, &read_set);
+		if (select(sockfd + 1, &read_set, NULL, NULL, &timeout) < 0) {
+			if (errno != EINTR) {
+				wpa_printf(MSG_ERROR,
+					   "Select failed on socket");
+				ret = -errno;
+				break;
+			}
+			continue;
+		}
+
+		if (!FD_ISSET(sockfd, &read_set))
+			continue;
+
+		fd = accept(sockfd, (struct sockaddr *)&c_addr,
+			    &addr_len);
+		if (fd < 0) {
+			if (errno != EINTR) {
+				wpa_printf(MSG_ERROR,
+					   "Failed accepting connections");
+				ret = -errno;
+				break;
+			}
+			continue;
+		}
+
+		os_memset(buf, 0, BUFSIZE);
+		if (recv(fd, buf, BUFSIZE - 1, 0) <= 0) {
+			close(fd);
+			continue;
+		}
+
+		wpa_printf(MSG_DEBUG, "Received request: %s", buf);
+		if (!afcd_send_request(&ctx, buf)) {
+			wpa_printf(MSG_DEBUG, "Received reply: %s", ctx.buf);
+			send(fd, ctx.buf, ctx.buf_len, MSG_NOSIGNAL);
+			free(ctx.buf);
+		}
+		close(fd);
+	}
+close:
+	close(sockfd);
+unlink:
+	unlink(fname);
+	os_free(fname);
+free_buf:
+	os_free(buf);
+
+	return ret;
+}
+
+
+int main(int argc, char **argv)
+{
+	bool daemonize = false;
+	char *pid_file = NULL;
+
+	if (os_program_init())
+		return -1;
+
+	for (;;) {
+		int c = getopt(argc, argv, "u:p:t:D:P:hdB");
+
+		if (c < 0)
+			break;
+
+		switch (c) {
+		case 'h':
+			usage();
+			return 0;
+		case 'B':
+			daemonize = true;
+			break;
+		case 'D':
+			path = optarg;
+			break;
+		case 'P':
+			os_free(pid_file);
+			pid_file = os_rel2abs_path(optarg);
+			break;
+		case 'u':
+			url = optarg;
+			break;
+		case 'p':
+			port = atoi(optarg);
+			break;
+		case 'd':
+			if (wpa_debug_level > 0)
+				wpa_debug_level--;
+			break;
+		case 't':
+			bearer_token = optarg;
+			break;
+		default:
+			usage();
+			return -EINVAL;
+		}
+	}
+
+	if (!url) {
+		usage();
+		return -EINVAL;
+	}
+
+	if (daemonize && os_daemonize(pid_file)) {
+		wpa_printf(MSG_ERROR, "daemon: %s", strerror(errno));
+		return -EINVAL;
+	}
+
+	signal(SIGTERM, handle_term);
+	signal(SIGINT, handle_term);
+
+	return afcd_server_run();
+}
diff --git a/hostapd/Makefile b/hostapd/Makefile
index ca44392..233176a 100644
--- a/hostapd/Makefile
+++ b/hostapd/Makefile
@@ -1,6 +1,7 @@
 ALL=hostapd hostapd_cli
 CONFIG_FILE = .config
 
+-include $(if $(MULTICALL), ../wpa_supplicant/.config)
 include ../src/build.rules
 
 ifdef LIBS
@@ -62,6 +63,10 @@ endif
 OBJS += main.o
 OBJS += config_file.o
 
+ifdef CONFIG_RADIUS_SERVER
+OBJS += radius.o
+endif
+
 OBJS += ../src/ap/hostapd.o
 OBJS += ../src/ap/wpa_auth_glue.o
 OBJS += ../src/ap/drv_callbacks.o
@@ -104,6 +109,14 @@ CFLAGS += -DCONFIG_TAXONOMY
 OBJS += ../src/ap/taxonomy.o
 endif
 
+ifdef CONFIG_IEEE80211AX
+ifdef CONFIG_AFC
+CFLAGS += -DCONFIG_AFC
+OBJS += ../src/ap/afc.o
+LIBS += -ljson-c
+endif
+endif
+
 ifdef CONFIG_MODULE_TESTS
 CFLAGS += -DCONFIG_MODULE_TESTS
 OBJS += hapd_module_tests.o
@@ -166,6 +179,24 @@ OBJS += ../src/common/hw_features_common.o
 
 OBJS += ../src/eapol_auth/eapol_auth_sm.o
 
+ifdef CONFIG_UBUS
+CFLAGS += -DUBUS_SUPPORT
+OBJS += ../src/ap/ubus.o
+LIBS += -lubus
+NEED_ULOOP:=y
+endif
+
+ifdef CONFIG_UCODE
+CFLAGS += -DUCODE_SUPPORT
+OBJS += ../src/utils/ucode.o
+OBJS += ../src/ap/ucode.o
+NEED_ULOOP:=y
+endif
+
+ifdef NEED_ULOOP
+OBJS += ../src/utils/uloop.o
+LIBS += -lubox
+endif
 
 ifdef CONFIG_CODE_COVERAGE
 CFLAGS += -O0 -fprofile-arcs -ftest-coverage -U_FORTIFY_SOURCE
@@ -200,7 +231,8 @@ endif
 
 ifdef CONFIG_NO_VLAN
 CFLAGS += -DCONFIG_NO_VLAN
-else
+endif
+ifneq ($(findstring CONFIG_NO_VLAN,$(CFLAGS)), CONFIG_NO_VLAN)
 OBJS += ../src/ap/vlan_init.o
 OBJS += ../src/ap/vlan_ifconfig.o
 OBJS += ../src/ap/vlan.o
@@ -220,6 +252,9 @@ endif
 ifdef CONFIG_NO_CTRL_IFACE
 CFLAGS += -DCONFIG_NO_CTRL_IFACE
 else
+ifdef CONFIG_CTRL_IFACE_MIB
+CFLAGS += -DCONFIG_CTRL_IFACE_MIB
+endif
 ifeq ($(CONFIG_CTRL_IFACE), udp)
 CFLAGS += -DCONFIG_CTRL_IFACE_UDP
 else
@@ -347,6 +382,7 @@ ifdef CONFIG_IEEE80211BE
 CONFIG_IEEE80211AX=y
 CFLAGS += -DCONFIG_IEEE80211BE
 OBJS += ../src/ap/ieee802_11_eht.o
+OBJS += ../src/ap/scs.o
 endif
 
 ifdef CONFIG_IEEE80211AX
@@ -359,10 +395,14 @@ CFLAGS += -DCONFIG_MBO
 OBJS += ../src/ap/mbo_ap.o
 endif
 
+ifndef MULTICALL
+CFLAGS += -DNO_SUPPLICANT
+endif
+
 include ../src/drivers/drivers.mak
-OBJS += $(DRV_AP_OBJS)
-CFLAGS += $(DRV_AP_CFLAGS)
-LDFLAGS += $(DRV_AP_LDFLAGS)
+OBJS += $(sort $(DRV_AP_OBJS) $(if $(MULTICALL),$(DRV_WPA_OBJS)))
+CFLAGS += $(DRV_AP_CFLAGS) $(if $(MULTICALL),$(DRV_WPA_CFLAGS))
+LDFLAGS += $(DRV_AP_LDFLAGS) $(if $(MULTICALL),$(DRV_WPA_LDFLAGS))
 LIBS += $(DRV_AP_LIBS)
 
 ifdef CONFIG_L2_PACKET
@@ -708,6 +748,7 @@ CFLAGS += -DCONFIG_TLSV12
 endif
 
 ifeq ($(CONFIG_TLS), wolfssl)
+CFLAGS += -DCONFIG_TLS_WOLFSSL
 CONFIG_CRYPTO=wolfssl
 ifdef TLS_FUNCS
 OBJS += ../src/crypto/tls_wolfssl.o
@@ -728,6 +769,7 @@ endif
 endif
 
 ifeq ($(CONFIG_TLS), openssl)
+CFLAGS += -DCONFIG_TLS_OPENSSL
 CFLAGS += -DCRYPTO_RSA_OAEP_SHA256
 CONFIG_CRYPTO=openssl
 ifdef TLS_FUNCS
@@ -757,7 +799,39 @@ endif
 CFLAGS += -DTLS_DEFAULT_CIPHERS=\"$(CONFIG_TLS_DEFAULT_CIPHERS)\"
 endif
 
+ifeq ($(CONFIG_TLS), mbedtls)
+CFLAGS += -DCONFIG_TLS_MBEDTLS
+ifndef CONFIG_CRYPTO
+CONFIG_CRYPTO=mbedtls
+endif
+ifdef TLS_FUNCS
+OBJS += ../src/crypto/tls_mbedtls.o
+LIBS += -lmbedtls
+ifndef CONFIG_DPP
+LIBS += -lmbedx509
+endif
+endif
+OBJS += ../src/crypto/crypto_$(CONFIG_CRYPTO).o
+HOBJS += ../src/crypto/crypto_$(CONFIG_CRYPTO).o
+SOBJS += ../src/crypto/crypto_$(CONFIG_CRYPTO).o
+ifeq ($(CONFIG_CRYPTO), mbedtls)
+ifdef CONFIG_DPP
+LIBS += -lmbedx509
+LIBS_h += -lmbedx509
+LIBS_n += -lmbedx509
+LIBS_s += -lmbedx509
+endif
+LIBS += -lmbedcrypto
+LIBS_h += -lmbedcrypto
+LIBS_n += -lmbedcrypto
+LIBS_s += -lmbedcrypto
+# XXX: create a config option?
+CFLAGS += -DCRYPTO_RSA_OAEP_SHA256
+endif
+endif
+
 ifeq ($(CONFIG_TLS), gnutls)
+CFLAGS += -DCONFIG_TLS_GNUTLS
 ifndef CONFIG_CRYPTO
 # default to libgcrypt
 CONFIG_CRYPTO=gnutls
@@ -788,6 +862,7 @@ endif
 endif
 
 ifeq ($(CONFIG_TLS), internal)
+CFLAGS += -DCONFIG_TLS_INTERNAL
 ifndef CONFIG_CRYPTO
 CONFIG_CRYPTO=internal
 endif
@@ -866,6 +941,7 @@ endif
 endif
 
 ifeq ($(CONFIG_TLS), linux)
+CFLAGS += -DCONFIG_TLS_INTERNAL
 OBJS += ../src/crypto/crypto_linux.o
 ifdef TLS_FUNCS
 OBJS += ../src/crypto/crypto_internal-rsa.o
@@ -936,9 +1012,11 @@ endif
 
 ifneq ($(CONFIG_TLS), openssl)
 ifneq ($(CONFIG_TLS), wolfssl)
+ifneq ($(CONFIG_TLS), mbedtls)
 AESOBJS += ../src/crypto/aes-wrap.o
 endif
 endif
+endif
 ifdef NEED_AES_EAX
 AESOBJS += ../src/crypto/aes-eax.o
 NEED_AES_CTR=y
@@ -948,38 +1026,48 @@ AESOBJS += ../src/crypto/aes-siv.o
 NEED_AES_CTR=y
 endif
 ifdef NEED_AES_CTR
+ifneq ($(CONFIG_TLS), mbedtls)
 AESOBJS += ../src/crypto/aes-ctr.o
 endif
+endif
 ifdef NEED_AES_ENCBLOCK
+ifneq ($(CONFIG_TLS), mbedtls)
 AESOBJS += ../src/crypto/aes-encblock.o
 endif
+endif
 ifneq ($(CONFIG_TLS), openssl)
 ifneq ($(CONFIG_TLS), linux)
 ifneq ($(CONFIG_TLS), wolfssl)
+ifneq ($(CONFIG_TLS), mbedtls)
 AESOBJS += ../src/crypto/aes-omac1.o
 endif
 endif
 endif
+endif
 ifdef NEED_AES_UNWRAP
 ifneq ($(CONFIG_TLS), openssl)
 ifneq ($(CONFIG_TLS), linux)
 ifneq ($(CONFIG_TLS), wolfssl)
+ifneq ($(CONFIG_TLS), mbedtls)
 NEED_AES_DEC=y
 AESOBJS += ../src/crypto/aes-unwrap.o
 endif
 endif
 endif
 endif
+endif
 ifdef NEED_AES_CBC
 NEED_AES_DEC=y
 ifneq ($(CONFIG_TLS), openssl)
 ifneq ($(CONFIG_TLS), linux)
 ifneq ($(CONFIG_TLS), wolfssl)
+ifneq ($(CONFIG_TLS), mbedtls)
 AESOBJS += ../src/crypto/aes-cbc.o
 endif
 endif
 endif
 endif
+endif
 ifdef NEED_AES_DEC
 ifdef CONFIG_INTERNAL_AES
 AESOBJS += ../src/crypto/aes-internal-dec.o
@@ -994,12 +1082,16 @@ ifneq ($(CONFIG_TLS), openssl)
 ifneq ($(CONFIG_TLS), linux)
 ifneq ($(CONFIG_TLS), gnutls)
 ifneq ($(CONFIG_TLS), wolfssl)
+ifneq ($(CONFIG_TLS), mbedtls)
 SHA1OBJS += ../src/crypto/sha1.o
 endif
 endif
 endif
 endif
+endif
+ifneq ($(CONFIG_TLS), mbedtls)
 SHA1OBJS += ../src/crypto/sha1-prf.o
+endif
 ifdef CONFIG_INTERNAL_SHA1
 SHA1OBJS += ../src/crypto/sha1-internal.o
 ifdef NEED_FIPS186_2_PRF
@@ -1008,16 +1100,22 @@ endif
 endif
 ifneq ($(CONFIG_TLS), openssl)
 ifneq ($(CONFIG_TLS), wolfssl)
+ifneq ($(CONFIG_TLS), mbedtls)
 SHA1OBJS += ../src/crypto/sha1-pbkdf2.o
 endif
 endif
+endif
 ifdef NEED_T_PRF
+ifneq ($(CONFIG_TLS), mbedtls)
 SHA1OBJS += ../src/crypto/sha1-tprf.o
 endif
+endif
 ifdef NEED_TLS_PRF
+ifneq ($(CONFIG_TLS), mbedtls)
 SHA1OBJS += ../src/crypto/sha1-tlsprf.o
 endif
 endif
+endif
 
 ifdef NEED_SHA1
 OBJS += $(SHA1OBJS)
@@ -1027,11 +1125,13 @@ ifneq ($(CONFIG_TLS), openssl)
 ifneq ($(CONFIG_TLS), linux)
 ifneq ($(CONFIG_TLS), gnutls)
 ifneq ($(CONFIG_TLS), wolfssl)
+ifneq ($(CONFIG_TLS), mbedtls)
 OBJS += ../src/crypto/md5.o
 endif
 endif
 endif
 endif
+endif
 
 ifdef NEED_MD5
 ifdef CONFIG_INTERNAL_MD5
@@ -1070,56 +1170,81 @@ ifneq ($(CONFIG_TLS), openssl)
 ifneq ($(CONFIG_TLS), linux)
 ifneq ($(CONFIG_TLS), gnutls)
 ifneq ($(CONFIG_TLS), wolfssl)
+ifneq ($(CONFIG_TLS), mbedtls)
 OBJS += ../src/crypto/sha256.o
 endif
 endif
 endif
 endif
+endif
+ifneq ($(CONFIG_TLS), mbedtls)
 OBJS += ../src/crypto/sha256-prf.o
+endif
 ifdef CONFIG_INTERNAL_SHA256
 OBJS += ../src/crypto/sha256-internal.o
 endif
 ifdef NEED_TLS_PRF_SHA256
+ifneq ($(CONFIG_TLS), mbedtls)
 OBJS += ../src/crypto/sha256-tlsprf.o
 endif
+endif
 ifdef NEED_TLS_PRF_SHA384
+ifneq ($(CONFIG_TLS), mbedtls)
 OBJS += ../src/crypto/sha384-tlsprf.o
 endif
+endif
 ifdef NEED_HMAC_SHA256_KDF
+CFLAGS += -DCONFIG_HMAC_SHA256_KDF
+ifneq ($(CONFIG_TLS), mbedtls)
 OBJS += ../src/crypto/sha256-kdf.o
 endif
+endif
 ifdef NEED_HMAC_SHA384_KDF
+CFLAGS += -DCONFIG_HMAC_SHA384_KDF
+ifneq ($(CONFIG_TLS), mbedtls)
 OBJS += ../src/crypto/sha384-kdf.o
 endif
+endif
 ifdef NEED_HMAC_SHA512_KDF
+CFLAGS += -DCONFIG_HMAC_SHA512_KDF
+ifneq ($(CONFIG_TLS), mbedtls)
 OBJS += ../src/crypto/sha512-kdf.o
 endif
+endif
 ifdef NEED_SHA384
 CFLAGS += -DCONFIG_SHA384
 ifneq ($(CONFIG_TLS), openssl)
 ifneq ($(CONFIG_TLS), linux)
 ifneq ($(CONFIG_TLS), gnutls)
 ifneq ($(CONFIG_TLS), wolfssl)
+ifneq ($(CONFIG_TLS), mbedtls)
 OBJS += ../src/crypto/sha384.o
 endif
 endif
 endif
 endif
+endif
+ifneq ($(CONFIG_TLS), mbedtls)
 OBJS += ../src/crypto/sha384-prf.o
 endif
+endif
 ifdef NEED_SHA512
 CFLAGS += -DCONFIG_SHA512
 ifneq ($(CONFIG_TLS), openssl)
 ifneq ($(CONFIG_TLS), linux)
 ifneq ($(CONFIG_TLS), gnutls)
 ifneq ($(CONFIG_TLS), wolfssl)
+ifneq ($(CONFIG_TLS), mbedtls)
 OBJS += ../src/crypto/sha512.o
 endif
 endif
 endif
 endif
+endif
+ifneq ($(CONFIG_TLS), mbedtls)
 OBJS += ../src/crypto/sha512-prf.o
 endif
+endif
 
 ifdef CONFIG_INTERNAL_SHA384
 CFLAGS += -DCONFIG_INTERNAL_SHA384
@@ -1164,11 +1289,13 @@ HOBJS += $(SHA1OBJS)
 ifneq ($(CONFIG_TLS), openssl)
 ifneq ($(CONFIG_TLS), linux)
 ifneq ($(CONFIG_TLS), wolfssl)
+ifneq ($(CONFIG_TLS), mbedtls)
 HOBJS += ../src/crypto/md5.o
 endif
 endif
 endif
 endif
+endif
 
 ifdef CONFIG_RADIUS_SERVER
 CFLAGS += -DRADIUS_SERVER
@@ -1298,6 +1425,11 @@ ifdef CONFIG_NO_TKIP
 CFLAGS += -DCONFIG_NO_TKIP
 endif
 
+ifdef CONFIG_APUP
+CFLAGS += -DCONFIG_APUP
+OBJS += ../src/ap/apup.o
+endif
+
 $(DESTDIR)$(BINDIR)/%: %
 	install -D $(<) $(@)
 
@@ -1306,8 +1438,14 @@ install: $(addprefix $(DESTDIR)$(BINDIR)/,$(ALL))
 _OBJS_VAR := OBJS
 include ../src/objs.mk
 
+hostapd_multi.a: $(BCHECK) $(OBJS)
+	$(Q)$(CC) -c -o hostapd_multi.o -Dmain=hostapd_main $(CFLAGS) main.c
+	@$(E) "  CC " $<
+	@rm -f $@
+	@$(AR) cr $@ hostapd_multi.o $(OBJS)
+
 hostapd: $(OBJS)
-	$(Q)$(CC) $(LDFLAGS) -o hostapd $(OBJS) $(LIBS)
+	+$(Q)$(CC) $(LDFLAGS) -o hostapd $(OBJS) $(LIBS)
 	@$(E) "  LD " $@
 
 ifdef CONFIG_WPA_TRACE
@@ -1318,7 +1456,7 @@ _OBJS_VAR := OBJS_c
 include ../src/objs.mk
 
 hostapd_cli: $(OBJS_c)
-	$(Q)$(CC) $(LDFLAGS) -o hostapd_cli $(OBJS_c) $(LIBS_c)
+	+$(Q)$(CC) $(LDFLAGS) -o hostapd_cli $(OBJS_c) $(LIBS_c)
 	@$(E) "  LD " $@
 
 NOBJS = nt_password_hash.o ../src/crypto/ms_funcs.o $(SHA1OBJS)
@@ -1342,7 +1480,9 @@ NOBJS += ../src/utils/trace.o
 endif
 
 HOBJS += hlr_auc_gw.o ../src/utils/common.o ../src/utils/wpa_debug.o ../src/utils/os_$(CONFIG_OS).o ../src/utils/wpabuf.o ../src/crypto/milenage.o
+ifneq ($(CONFIG_TLS), mbedtls)
 HOBJS += ../src/crypto/aes-encblock.o
+endif
 ifdef CONFIG_INTERNAL_AES
 HOBJS += ../src/crypto/aes-internal.o
 HOBJS += ../src/crypto/aes-internal-enc.o
@@ -1365,13 +1505,17 @@ SOBJS += ../src/common/sae.o
 SOBJS += ../src/common/sae_pk.o
 SOBJS += ../src/common/dragonfly.o
 SOBJS += $(AESOBJS)
+ifneq ($(CONFIG_TLS), mbedtls)
 SOBJS += ../src/crypto/sha256-prf.o
 SOBJS += ../src/crypto/sha384-prf.o
 SOBJS += ../src/crypto/sha512-prf.o
+endif
 SOBJS += ../src/crypto/dh_groups.o
+ifneq ($(CONFIG_TLS), mbedtls)
 SOBJS += ../src/crypto/sha256-kdf.o
 SOBJS += ../src/crypto/sha384-kdf.o
 SOBJS += ../src/crypto/sha512-kdf.o
+endif
 
 _OBJS_VAR := NOBJS
 include ../src/objs.mk
@@ -1380,6 +1524,12 @@ include ../src/objs.mk
 _OBJS_VAR := SOBJS
 include ../src/objs.mk
 
+dump_cflags:
+	@printf "%s " "$(CFLAGS)"
+
+dump_ldflags:
+	@printf "%s " "$(LDFLAGS) $(LIBS) $(EXTRALIBS)"
+
 nt_password_hash: $(NOBJS)
 	$(Q)$(CC) $(LDFLAGS) -o nt_password_hash $(NOBJS) $(LIBS_n)
 	@$(E) "  LD " $@
diff --git a/hostapd/config_file.c b/hostapd/config_file.c
index 96f1b17..12bf3a8 100644
--- a/hostapd/config_file.c
+++ b/hostapd/config_file.c
@@ -1190,6 +1190,9 @@ static int hostapd_config_vht_capab(struct hostapd_config *conf,
 	if (os_strstr(capab, "[BF-ANTENNA-4]") &&
 	    (conf->vht_capab & VHT_CAP_SU_BEAMFORMEE_CAPABLE))
 		conf->vht_capab |= (3 << VHT_CAP_BEAMFORMEE_STS_OFFSET);
+	if (os_strstr(capab, "[BF-ANTENNA-5]") &&
+	    (conf->vht_capab & VHT_CAP_SU_BEAMFORMEE_CAPABLE))
+		conf->vht_capab |= (4 << VHT_CAP_BEAMFORMEE_STS_OFFSET);
 	if (os_strstr(capab, "[SOUNDING-DIMENSION-2]") &&
 	    (conf->vht_capab & VHT_CAP_SU_BEAMFORMER_CAPABLE))
 		conf->vht_capab |= (1 << VHT_CAP_SOUNDING_DIMENSION_OFFSET);
@@ -1229,6 +1232,8 @@ static int hostapd_config_vht_capab(struct hostapd_config *conf,
 		conf->vht_capab |= VHT_CAP_RX_ANTENNA_PATTERN;
 	if (os_strstr(capab, "[TX-ANTENNA-PATTERN]"))
 		conf->vht_capab |= VHT_CAP_TX_ANTENNA_PATTERN;
+	if (os_strstr(capab, "[EXT-NSS-BW-SUPP]"))
+		conf->vht_capab |= VHT_CAP_EXTENDED_NSS_BW_SUPPORT;
 	return 0;
 }
 #endif /* CONFIG_IEEE80211AC */
@@ -1281,6 +1286,190 @@ static int hostapd_parse_he_srg_bitmap(u8 *bitmap, char *val)
 	return 0;
 }
 
+
+#ifdef CONFIG_AFC
+static int hostapd_afc_parse_cert_ids(struct hostapd_config *conf, char *pos)
+{
+	struct cert_id *c = NULL;
+	int i, count = 0;
+
+	while (pos && pos[0]) {
+		char *p;
+
+		c = os_realloc_array(c, count + 1, sizeof(*c));
+		if (!c)
+			return -ENOMEM;
+
+		i = count;
+		count++;
+
+		p = os_strchr(pos, ':');
+		if (!p)
+			goto error;
+
+		*p++ = '\0';
+		if (!p || !p[0])
+			goto error;
+
+		c[i].rulset = os_malloc(os_strlen(pos) + 1);
+		if (!c[i].rulset)
+			goto error;
+
+		os_strlcpy(c[i].rulset, pos, os_strlen(pos) + 1);
+		pos = p;
+		p = os_strchr(pos, ',');
+		if (p)
+			*p++ = '\0';
+
+		c[i].id = os_malloc(os_strlen(pos) + 1);
+		if (!c[i].id)
+			goto error;
+
+		os_strlcpy(c[i].id, pos, os_strlen(pos) + 1);
+		pos = p;
+	}
+
+	conf->afc.n_cert_ids = count;
+	conf->afc.cert_ids = c;
+
+	return 0;
+
+error:
+	for (i = 0; i < count; i++) {
+		os_free(c[i].rulset);
+		os_free(c[i].id);
+	}
+	os_free(c);
+
+	return -ENOMEM;
+}
+
+
+static int hostapd_afc_parse_position_data(struct afc_linear_polygon **data,
+					   unsigned int *n_linear_polygon_data,
+					   char *pos)
+{
+	struct afc_linear_polygon *d = NULL;
+	int i, count = 0;
+
+	while (pos && pos[0]) {
+		char *p, *end;
+
+		d = os_realloc_array(d, count + 1, sizeof(*d));
+		if (!d)
+			return -ENOMEM;
+
+		i = count;
+		count++;
+
+		p = os_strchr(pos, ':');
+		if (!p)
+			goto error;
+
+		*p++ = '\0';
+		if (!p || !p[0])
+			goto error;
+
+		d[i].longitude = strtod(pos, &end);
+		if (*end)
+			goto error;
+
+		pos = p;
+		p = os_strchr(pos, ',');
+		if (p)
+			*p++ = '\0';
+
+		d[i].latitude = strtod(pos, &end);
+		if (*end)
+			goto error;
+
+		pos = p;
+	}
+
+	*n_linear_polygon_data = count;
+	*data = d;
+
+	return 0;
+
+error:
+	os_free(d);
+	return -ENOMEM;
+}
+
+
+static int hostapd_afc_parse_freq_range(struct hostapd_config *conf, char *pos)
+{
+	struct afc_freq_range *f = NULL;
+	int i, count = 0;
+
+	while (pos && pos[0]) {
+		char *p;
+
+		f = os_realloc_array(f, count + 1, sizeof(*f));
+		if (!f)
+			return -ENOMEM;
+
+		i = count;
+		count++;
+
+		p = os_strchr(pos, ':');
+		if (!p)
+			goto error;
+
+		*p++ = '\0';
+		if (!p || !p[0])
+			goto error;
+
+		f[i].low_freq = atoi(pos);
+		pos = p;
+		p = os_strchr(pos, ',');
+		if (p)
+			*p++ = '\0';
+
+		f[i].high_freq = atoi(pos);
+		pos = p;
+	}
+
+	conf->afc.n_freq_range = count;
+	conf->afc.freq_range = f;
+
+	return 0;
+
+error:
+	os_free(f);
+	return -ENOMEM;
+}
+
+
+static int hostapd_afc_parse_op_class(struct hostapd_config *conf, char *pos)
+{
+	unsigned int *oc = NULL;
+	int i, count = 0;
+
+	while (pos && pos[0]) {
+		char *p;
+
+		oc = os_realloc_array(oc, count + 1, sizeof(*oc));
+		if (!oc)
+			return -ENOMEM;
+
+		i = count;
+		count++;
+
+		p = os_strchr(pos, ',');
+		if (p)
+			*p++ = '\0';
+
+		oc[i] = atoi(pos);
+		pos = p;
+	}
+
+	conf->afc.n_op_class = count;
+	conf->afc.op_class = oc;
+
+	return 0;
+}
+#endif /* CONFIG_AFC */
 #endif /* CONFIG_IEEE80211AX */
 
 
@@ -2470,8 +2659,12 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 			   sizeof(conf->bss[0]->iface));
 	} else if (os_strcmp(buf, "bridge") == 0) {
 		os_strlcpy(bss->bridge, pos, sizeof(bss->bridge));
+		if (!bss->wds_bridge[0])
+			os_strlcpy(bss->wds_bridge, pos, sizeof(bss->wds_bridge));
 	} else if (os_strcmp(buf, "bridge_hairpin") == 0) {
 		bss->bridge_hairpin = atoi(pos);
+	} else if (os_strcmp(buf, "snoop_iface") == 0) {
+		os_strlcpy(bss->snoop_iface, pos, sizeof(bss->snoop_iface));
 	} else if (os_strcmp(buf, "vlan_bridge") == 0) {
 		os_strlcpy(bss->vlan_bridge, pos, sizeof(bss->vlan_bridge));
 	} else if (os_strcmp(buf, "wds_bridge") == 0) {
@@ -2859,6 +3052,8 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 	} else if (os_strcmp(buf, "iapp_interface") == 0) {
 		wpa_printf(MSG_INFO, "DEPRECATED: iapp_interface not used");
 #endif /* CONFIG_IAPP */
+	} else if (os_strcmp(buf, "dynamic_own_ip_addr") == 0) {
+		bss->dynamic_own_ip_addr = atoi(pos);
 	} else if (os_strcmp(buf, "own_ip_addr") == 0) {
 		if (hostapd_parse_ip_addr(pos, &bss->own_ip_addr)) {
 			wpa_printf(MSG_ERROR,
@@ -3086,6 +3281,14 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 				   line, bss->max_num_sta, MAX_STA_COUNT);
 			return 1;
 		}
+	} else if (os_strcmp(buf, "iface_max_num_sta") == 0) {
+		conf->max_num_sta = atoi(pos);
+		if (conf->max_num_sta < 0 ||
+		    conf->max_num_sta > MAX_STA_COUNT) {
+			wpa_printf(MSG_ERROR, "Line %d: Invalid max_num_sta=%d; allowed range 0..%d",
+				   line, conf->max_num_sta, MAX_STA_COUNT);
+			return 1;
+		}
 	} else if (os_strcmp(buf, "wpa") == 0) {
 		bss->wpa = atoi(pos);
 	} else if (os_strcmp(buf, "extended_key_id") == 0) {
@@ -3275,6 +3478,8 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 		wpa_printf(MSG_INFO,
 			   "Line %d: Obsolete peerkey parameter ignored", line);
 #ifdef CONFIG_IEEE80211R_AP
+	} else if (os_strcmp(buf, "ft_iface") == 0) {
+		os_strlcpy(bss->ft_iface, pos, sizeof(bss->ft_iface));
 	} else if (os_strcmp(buf, "mobility_domain") == 0) {
 		if (os_strlen(pos) != 2 * MOBILITY_DOMAIN_ID_LEN ||
 		    hexstr2bin(pos, bss->mobility_domain,
@@ -3460,6 +3665,8 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 		conf->acs_exclude_6ghz_non_psc = atoi(pos);
 	} else if (os_strcmp(buf, "enable_background_radar") == 0) {
 		conf->enable_background_radar = atoi(pos);
+	} else if (os_strcmp(buf, "background_radar_mode") == 0) {
+		conf->background_radar_mode = atoi(pos);
 	} else if (os_strcmp(buf, "min_tx_power") == 0) {
 		int val = atoi(pos);
 
@@ -3644,6 +3851,8 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 #ifndef CONFIG_NO_VLAN
 	} else if (os_strcmp(buf, "dynamic_vlan") == 0) {
 		bss->ssid.dynamic_vlan = atoi(pos);
+	} else if (os_strcmp(buf, "vlan_no_bridge") == 0) {
+		bss->ssid.vlan_no_bridge = atoi(pos);
 	} else if (os_strcmp(buf, "per_sta_vif") == 0) {
 		bss->ssid.per_sta_vif = atoi(pos);
 	} else if (os_strcmp(buf, "vlan_file") == 0) {
@@ -3745,6 +3954,10 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 		if (bss->ocv && !bss->ieee80211w)
 			bss->ieee80211w = 1;
 #endif /* CONFIG_OCV */
+	} else if (os_strcmp(buf, "noscan") == 0) {
+		conf->noscan = atoi(pos);
+	} else if (os_strcmp(buf, "ht_coex") == 0) {
+		conf->no_ht_coex = !atoi(pos);
 	} else if (os_strcmp(buf, "ieee80211n") == 0) {
 		conf->ieee80211n = atoi(pos);
 	} else if (os_strcmp(buf, "ht_capab") == 0) {
@@ -3792,9 +4005,13 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 		conf->he_phy_capab.he_su_beamformee = atoi(pos);
 	} else if (os_strcmp(buf, "he_mu_beamformer") == 0) {
 		conf->he_phy_capab.he_mu_beamformer = atoi(pos);
+	} else if (os_strcmp(buf, "he_ldpc") == 0) {
+		conf->he_phy_capab.he_ldpc = atoi(pos);
 	} else if (os_strcmp(buf, "he_bss_color") == 0) {
 		conf->he_op.he_bss_color = atoi(pos) & 0x3f;
 		conf->he_op.he_bss_color_disabled = 0;
+		if (atoi(pos) > 63)
+			conf->he_op.he_bss_color = os_random() % 63 + 1;
 	} else if (os_strcmp(buf, "he_bss_color_partial") == 0) {
 		conf->he_op.he_bss_color_partial = atoi(pos);
 	} else if (os_strcmp(buf, "he_default_pe_duration") == 0) {
@@ -3955,6 +4172,85 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 			return 1;
 		}
 		bss->unsol_bcast_probe_resp_interval = val;
+#ifdef CONFIG_AFC
+	} else if (os_strcmp(buf, "afcd_sock") == 0) {
+		conf->afc.socket = os_malloc(os_strlen(pos) + 1);
+		if (!conf->afc.socket)
+			return 1;
+
+		os_strlcpy(conf->afc.socket, pos, os_strlen(pos) + 1);
+	} else if (os_strcmp(buf, "afc_request_version") == 0) {
+		conf->afc.request.version = os_malloc(os_strlen(pos) + 1);
+		if (!conf->afc.request.version)
+			return 1;
+
+		os_strlcpy(conf->afc.request.version, pos, os_strlen(pos) + 1);
+	} else if (os_strcmp(buf, "afc_request_id") == 0) {
+		conf->afc.request.id = os_malloc(os_strlen(pos) + 1);
+		if (!conf->afc.request.id)
+			return 1;
+
+		os_strlcpy(conf->afc.request.id, pos, os_strlen(pos) + 1);
+	} else if (os_strcmp(buf, "afc_serial_number") == 0) {
+		conf->afc.request.sn = os_malloc(os_strlen(pos) + 1);
+		if (!conf->afc.request.sn)
+			return 1;
+
+		os_strlcpy(conf->afc.request.sn, pos, os_strlen(pos) + 1);
+	} else if (os_strcmp(buf, "afc_cert_ids") == 0) {
+		if (hostapd_afc_parse_cert_ids(conf, pos))
+			return 1;
+	} else if (os_strcmp(buf, "afc_location_type") == 0) {
+		conf->afc.location.type = atoi(pos);
+		if (conf->afc.location.type != ELLIPSE &&
+		    conf->afc.location.type != LINEAR_POLYGON &&
+		    conf->afc.location.type != RADIAL_POLYGON)
+			return 1;
+	} else if (os_strcmp(buf, "afc_linear_polygon") == 0) {
+		if (hostapd_afc_parse_position_data(
+			&conf->afc.location.linear_polygon_data,
+			&conf->afc.location.n_linear_polygon_data,
+			pos))
+			return 1;
+	} else if (os_strcmp(buf, "afc_radial_polygon") == 0) {
+		if (hostapd_afc_parse_position_data(
+			(struct afc_linear_polygon **)
+			&conf->afc.location.radial_polygon_data,
+			&conf->afc.location.n_radial_polygon_data,
+			pos))
+			return 1;
+	} else if (os_strcmp(buf, "afc_major_axis") == 0) {
+		conf->afc.location.major_axis = atoi(pos);
+	} else if (os_strcmp(buf, "afc_minor_axis") == 0) {
+		conf->afc.location.minor_axis = atoi(pos);
+	} else if (os_strcmp(buf, "afc_orientation") == 0) {
+		conf->afc.location.orientation = atoi(pos);
+	} else if (os_strcmp(buf, "afc_height") == 0) {
+		char *end;
+
+		conf->afc.location.height = strtod(pos, &end);
+		if (*end)
+			return 1;
+	} else if (os_strcmp(buf, "afc_height_type") == 0) {
+		conf->afc.location.height_type = os_malloc(os_strlen(pos) + 1);
+		if (!conf->afc.location.height_type)
+			return 1;
+
+		os_strlcpy(conf->afc.location.height_type, pos,
+			   os_strlen(pos) + 1);
+	} else if (os_strcmp(buf, "afc_vertical_tolerance") == 0) {
+		conf->afc.location.vertical_tolerance = atoi(pos);
+	} else if (os_strcmp(buf, "afc_min_power") == 0) {
+		conf->afc.min_power = atoi(pos);
+	} else if (os_strcmp(buf, "afc_freq_range") == 0) {
+		if (hostapd_afc_parse_freq_range(conf, pos))
+			return 1;
+	} else if (os_strcmp(buf, "afc_op_class") == 0) {
+		if (hostapd_afc_parse_op_class(conf, pos))
+			return 1;
+	} else if (os_strcmp(buf, "afc_max_timeout") == 0) {
+		conf->afc.max_timeout = atoi(pos);
+#endif /* CONFIG_AFC */
 	} else if (os_strcmp(buf, "mbssid") == 0) {
 		int mbssid = atoi(pos);
 		if (mbssid < 0 || mbssid > ENHANCED_MBSSID_ENABLED) {
@@ -3964,6 +4260,15 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 			return 1;
 		}
 		conf->mbssid = mbssid;
+	} else if (os_strcmp(buf, "mu_onoff") == 0) {
+		int val = atoi(pos);
+		if (val < 0 || val > 15) {
+			wpa_printf(MSG_ERROR,
+				   "Line %d: invalid mu_onoff value",
+				   line);
+			return 1;
+		}
+		conf->mu_onoff = val;
 #endif /* CONFIG_IEEE80211AX */
 	} else if (os_strcmp(buf, "max_listen_interval") == 0) {
 		bss->max_listen_interval = atoi(pos);
@@ -3983,6 +4288,8 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 		bss->wps_independent = atoi(pos);
 	} else if (os_strcmp(buf, "ap_setup_locked") == 0) {
 		bss->ap_setup_locked = atoi(pos);
+	} else if (os_strcmp(buf, "ap_pin_lockout_time") == 0) {
+		bss->ap_pin_lockout_time = atoi(pos);
 	} else if (os_strcmp(buf, "uuid") == 0) {
 		if (uuid_str2bin(pos, bss->uuid)) {
 			wpa_printf(MSG_ERROR, "Line %d: invalid UUID", line);
@@ -5146,6 +5453,7 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 	} else if (os_strcmp(buf, "punct_bitmap") == 0) {
 		if (get_u16(pos, line, &conf->punct_bitmap))
 			return 1;
+		conf->punct_bitmap = atoi(pos);
 	} else if (os_strcmp(buf, "punct_acs_threshold") == 0) {
 		int val = atoi(pos);
 
@@ -5158,6 +5466,12 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 		conf->punct_acs_threshold = val;
 	} else if (os_strcmp(buf, "mld_ap") == 0) {
 		bss->mld_ap = !!atoi(pos);
+	} else if (os_strcmp(buf, "mld_primary") == 0) {
+		bss->mld_primary = !!atoi(pos);
+	} else if (os_strcmp(buf, "mld_allowed_links") == 0) {
+		bss->mld_allowed_links = atoi(pos);
+	} else if (os_strcmp(buf, "mld_radio_mask") == 0) {
+		bss->mld_radio_mask = atoi(pos);
 	} else if (os_strcmp(buf, "mld_addr") == 0) {
 		if (hwaddr_aton(pos, bss->mld_addr)) {
 			wpa_printf(MSG_ERROR, "Line %d: Invalid mld_addr",
@@ -5166,14 +5480,103 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 		}
 	} else if (os_strcmp(buf, "eht_bw320_offset") == 0) {
 		conf->eht_bw320_offset = atoi(pos);
+	} else if (os_strcmp(buf, "eml_disable") == 0) {
+		conf->eml_disable = atoi(pos);
+	} else if (os_strcmp(buf, "eml_resp") == 0) {
+		conf->eml_resp = atoi(pos);
 #ifdef CONFIG_TESTING_OPTIONS
 	} else if (os_strcmp(buf, "eht_oper_puncturing_override") == 0) {
 		if (get_u16(pos, line, &bss->eht_oper_puncturing_override))
 			return 1;
 	} else if (os_strcmp(buf, "mld_indicate_disabled") == 0) {
 		bss->mld_indicate_disabled = atoi(pos);
+	} else if (os_strcmp(buf, "mld_link_id") == 0) {
+		bss->mld_link_id = atoi(pos);
 #endif /* CONFIG_TESTING_OPTIONS */
 #endif /* CONFIG_IEEE80211BE */
+#ifdef CONFIG_APUP
+	} else if (os_strcmp(buf, "apup") == 0) {
+		bss->apup = !!atoi(pos);
+		if (bss->apup)
+			bss->wds_sta = 1;
+	} else if (os_strcmp(buf, "apup_peer_ifname_prefix") == 0) {
+		os_strlcpy(bss->apup_peer_ifname_prefix,
+		           pos, sizeof(bss->apup_peer_ifname_prefix));
+#endif // def CONFIG_APUP
+	} else if (os_strcmp(buf, "edcca_threshold") == 0) {
+		if (hostapd_parse_intlist(&conf->edcca_threshold, pos) ||
+		    conf->edcca_threshold[0] < EDCCA_MIN_CONFIG_THRES ||
+		    conf->edcca_threshold[0] > EDCCA_MAX_CONFIG_THRES ||
+		    conf->edcca_threshold[1] < EDCCA_MIN_CONFIG_THRES ||
+		    conf->edcca_threshold[1] > EDCCA_MAX_CONFIG_THRES ||
+		    conf->edcca_threshold[2] < EDCCA_MIN_CONFIG_THRES ||
+		    conf->edcca_threshold[2] > EDCCA_MAX_CONFIG_THRES ||
+		    conf->edcca_threshold[3] < EDCCA_MIN_CONFIG_THRES ||
+		    conf->edcca_threshold[3] > EDCCA_MAX_CONFIG_THRES) {
+			wpa_printf(MSG_ERROR, "Line %d: invalid edcca threshold",
+				   line);
+			return 1;
+		}
+	} else if (os_strcmp(buf, "edcca_enable") == 0) {
+		int mode = atoi(pos);
+		if (mode < EDCCA_MODE_FORCE_DISABLE || mode > EDCCA_MODE_AUTO) {
+			wpa_printf(MSG_ERROR, "Line %d: Invalid edcca_enable %d;"
+				  " allowed value 0 (Force Disable) or 1(Auto) ",
+				   line, mode);
+			return 1;
+		}
+		conf->edcca_enable = (u8) mode;
+	} else if (os_strcmp(buf, "edcca_compensation") == 0) {
+		int val = atoi(pos);
+		if (val < EDCCA_MIN_COMPENSATION ||
+		    val > EDCCA_MAX_COMPENSATION) {
+			wpa_printf(MSG_ERROR, "Line %d: Invalid compensation"
+				   " value %d; allowed value %d ~ %d.",
+				   line, val, EDCCA_MIN_COMPENSATION,
+				   EDCCA_MAX_COMPENSATION);
+			return 1;
+		}
+		conf->edcca_compensation = (s8) val;
+	} else if (os_strcmp(buf, "three_wire_enable") == 0) {
+		u8 en = atoi(pos);
+
+		conf->three_wire_enable = en;
+	} else if (os_strcmp(buf, "ibf_enable") == 0) { /*ibf setting is per device*/
+		int val = atoi(pos);
+		conf->ibf_enable = !!val;
+	} else if (os_strcmp(buf, "dfs_detect_mode") == 0) { /*bypass channel switch*/
+		u8 en = strtol(pos, NULL, 10);
+
+		conf->dfs_detect_mode = en;
+	} else if (os_strcmp(buf, "amsdu") == 0) {
+		int val = atoi(pos);
+		if (val < 0 || val > 1) {
+			wpa_printf(MSG_ERROR,
+					 "Line %d: invalid amsdu value",
+					 line);
+			return 1;
+		}
+		conf->amsdu = val;
+	} else if (os_strcmp(buf, "pp_mode") == 0) {
+		int val = atoi(pos);
+
+		if ((val != PP_USR_MODE && conf->punct_bitmap) ||
+		    val < PP_DISABLE || val > PP_USR_MODE) {
+			wpa_printf(MSG_ERROR, "Line %d: invalid pp_mode value",
+				   line);
+			return 1;
+		}
+		conf->pp_mode = (u8) val;
+	} else if (os_strcmp(buf, "lpi_psd") == 0) {
+		u8 en = strtol(pos, NULL, 10);
+		conf->lpi_psd = !!en;
+	} else if (os_strcmp(buf, "sku_idx") == 0) {
+		conf->sku_idx = strtol(pos, NULL, 10);
+	} else if (os_strcmp(buf, "lpi_sku_idx") == 0) {
+		conf->lpi_sku_idx = strtol(pos, NULL, 10);
+	} else if (os_strcmp(buf, "lpi_bcn_enhance") == 0) {
+		u8 en = strtol(pos, NULL, 10);
+		conf->lpi_bcn_enhance = !!en;
 	} else {
 		wpa_printf(MSG_ERROR,
 			   "Line %d: unknown configuration item '%s'",
@@ -5199,7 +5602,12 @@ struct hostapd_config * hostapd_config_read(const char *fname)
 	int errors = 0;
 	size_t i;
 
-	f = fopen(fname, "r");
+	if (!strncmp(fname, "data:", 5)) {
+		f = fmemopen((void *)(fname + 5), strlen(fname + 5), "r");
+		fname = "<inline>";
+	} else {
+		f = fopen(fname, "r");
+	}
 	if (f == NULL) {
 		wpa_printf(MSG_ERROR, "Could not open configuration file '%s' "
 			   "for reading.", fname);
diff --git a/hostapd/ctrl_iface.c b/hostapd/ctrl_iface.c
index 1fcefb3..717edf5 100644
--- a/hostapd/ctrl_iface.c
+++ b/hostapd/ctrl_iface.c
@@ -19,6 +19,7 @@
 #include <netinet/ip.h>
 #endif /* CONFIG_TESTING_OPTIONS */
 
+#include <math.h>
 #include <sys/un.h>
 #include <sys/stat.h>
 #include <stddef.h>
@@ -70,7 +71,9 @@
 #include "fst/fst_ctrl_iface.h"
 #include "config_file.h"
 #include "ctrl_iface.h"
+#include "crypto/dh_groups.h"
 
+#include "common/mtk_vendor.h"
 
 #define HOSTAPD_CLI_DUP_VALUE_MAX_LEN 256
 
@@ -544,6 +547,19 @@ static const char * pbc_status_str(enum pbc_status status)
 }
 
 
+static const char *edcca_mode_str(enum edcca_mode status)
+{
+	switch (status) {
+		case EDCCA_MODE_FORCE_DISABLE:
+			return "Force Disable";
+		case EDCCA_MODE_AUTO:
+			return "Auto";
+		default:
+			return "Unknown";
+	}
+}
+
+
 static int hostapd_ctrl_iface_wps_get_status(struct hostapd_data *hapd,
 					     char *buf, size_t buflen)
 {
@@ -772,6 +788,69 @@ static int hostapd_ctrl_iface_send_qos_map_conf(struct hostapd_data *hapd,
 
 #endif /* CONFIG_INTERWORKING */
 
+static int hostapd_ctrl_iface_inband_discovery(struct hostapd_data *hapd,
+					       const char *cmd)
+{
+	struct hostapd_bss_config *conf = hapd->conf;
+	const char *pos = cmd;
+	int tx_type, interval, ret;
+
+	tx_type = atoi(pos);
+	if (tx_type < 0 || tx_type > 2) {
+		wpa_printf(MSG_ERROR, "Invalid tx type\n");
+		return -1;
+	}
+
+	pos = os_strchr(pos, ' ');
+	if(!pos)
+		return -1;
+	pos++;
+	interval = atoi(pos);
+	if (interval < 0 || interval > 20) {
+		wpa_printf(MSG_ERROR, "Invalid interval value\n");
+		return -1;
+	}
+
+	wpa_printf(MSG_ERROR, "Set inband discovery type:%d, interval:%d\n",
+			      tx_type, interval);
+
+#define DISABLE_INBAND_DISC 0
+#define UNSOL_PROBE_RESP 1
+#define FILS_DISCOVERY 2
+
+#ifdef CONFIG_FILS
+	conf->fils_discovery_max_int = 0;
+	conf->fils_discovery_min_int = 0;
+#endif /* CONFIG_FILS */
+	conf->unsol_bcast_probe_resp_interval = 0;
+
+	switch (tx_type) {
+	case DISABLE_INBAND_DISC:
+	default:
+		/* Disable both Unsolicited probe response and FILS discovery*/
+		break;
+	case UNSOL_PROBE_RESP:
+		/* Enable Unsolicited probe response */
+		conf->unsol_bcast_probe_resp_interval = interval;
+		break;
+#ifdef CONFIG_FILS
+	case FILS_DISCOVERY:
+		/* Enable FILS discovery */
+		conf->fils_discovery_min_int = interval;
+		conf->fils_discovery_max_int = interval;
+		break;
+#endif /* CONFIG_FILS */
+	}
+
+	ret = ieee802_11_update_beacons(hapd->iface);
+	if(ret) {
+		wpa_printf(MSG_DEBUG,
+			"Failed to update with inband discovery parameters\n");
+		return -1;
+	}
+
+	return 0;
+}
 
 #ifdef CONFIG_WNM_AP
 
@@ -981,6 +1060,7 @@ static int hostapd_ctrl_iface_get_config(struct hostapd_data *hapd,
 {
 	int ret;
 	char *pos, *end;
+	int i;
 
 	pos = buf;
 	end = buf + buflen;
@@ -1160,6 +1240,64 @@ static int hostapd_ctrl_iface_get_config(struct hostapd_data *hapd,
 		pos += ret;
 	}
 
+	/* dump chanlist */
+	if (hapd->iface->conf->acs_ch_list.num > 0) {
+		ret = os_snprintf(pos, end - pos, "chanlist=");
+		if (os_snprintf_error(end - pos, ret))
+			return pos - buf;
+		pos += ret;
+
+		for (i = 0; i < hapd->iface->conf->acs_ch_list.num; i++) {
+			if (i > 0) {
+				ret = os_snprintf(pos, end - pos, ", ");
+				if (os_snprintf_error(end - pos, ret))
+					return pos - buf;
+				pos += ret;
+			}
+
+			ret = os_snprintf(pos, end - pos, "%d-%d",
+				hapd->iface->conf->acs_ch_list.range[i].min,
+				hapd->iface->conf->acs_ch_list.range[i].max);
+			if (os_snprintf_error(end - pos, ret))
+				return pos - buf;
+			pos += ret;
+		}
+
+		ret = os_snprintf(pos, end - pos, "\n");
+		if (os_snprintf_error(end - pos, ret))
+			return pos - buf;
+		pos += ret;
+	}
+
+	/* dump freqlist */
+	if (hapd->iface->conf->acs_freq_list.num > 0) {
+		ret = os_snprintf(pos, end - pos, "freqlist=");
+		if (os_snprintf_error(end - pos, ret))
+			return pos - buf;
+		pos += ret;
+
+		for (i = 0; i < hapd->iface->conf->acs_freq_list.num; i++) {
+			if (i > 0) {
+				ret = os_snprintf(pos, end - pos, ", ");
+				if (os_snprintf_error(end - pos, ret))
+					return pos - buf;
+				pos += ret;
+			}
+
+			ret = os_snprintf(pos, end - pos, "%d-%d",
+				hapd->iface->conf->acs_freq_list.range[i].min,
+				hapd->iface->conf->acs_freq_list.range[i].max);
+			if (os_snprintf_error(end - pos, ret))
+				return pos - buf;
+			pos += ret;
+		}
+
+		ret = os_snprintf(pos, end - pos, "\n");
+		if (os_snprintf_error(end - pos, ret))
+			return pos - buf;
+		pos += ret;
+	}
+
 	return pos - buf;
 }
 
@@ -1300,6 +1438,11 @@ static int hostapd_ctrl_iface_set(struct hostapd_data *hapd, char *cmd)
 #endif /* CONFIG_DPP */
 	} else if (os_strcasecmp(cmd, "setband") == 0) {
 		ret = hostapd_ctrl_iface_set_band(hapd, value);
+	} else if (os_strcasecmp(cmd, "bss_termination_tsf") == 0) {
+		int termination_sec = atoi(value);
+		hapd->conf->bss_termination_tsf = termination_sec;
+		wpa_printf(MSG_DEBUG, "BSS Termination TSF: value = %d",
+                termination_sec);
 	} else {
 		ret = hostapd_set_iface(hapd->iconf, hapd->conf, cmd, value);
 		if (ret)
@@ -1327,6 +1470,18 @@ static int hostapd_ctrl_iface_set(struct hostapd_data *hapd, char *cmd)
 							hapd->conf->transition_disable);
 		}
 
+#ifdef CONFIG_IEEE80211BE
+		/* workaround before hostapd cli support per link configuration */
+		if (hapd->conf->mld_ap) {
+			struct hostapd_data *h;
+
+			for_each_mld_link(h, hapd) {
+				if (os_strcasecmp(cmd, "ap_max_inactivity") == 0)
+					h->conf->ap_max_inactivity = hapd->conf->ap_max_inactivity;
+			}
+		}
+#endif /* CONFIG_IEEE80211BE */
+
 #ifdef CONFIG_TESTING_OPTIONS
 		if (os_strcmp(cmd, "ft_rsnxe_used") == 0)
 			wpa_auth_set_ft_rsnxe_used(hapd->wpa_auth,
@@ -1371,6 +1526,19 @@ static int hostapd_ctrl_iface_get(struct hostapd_data *hapd, char *cmd,
 		if (os_snprintf_error(buflen, res))
 			return -1;
 		return res;
+	} else if (os_strcmp(cmd, "sae_group_capability") == 0) {
+#ifdef CONFIG_SAE
+		/* see sae_set_group() */
+		res = os_snprintf(buf, buflen, "%s%s%s%s19 20 21",
+				  dh_groups_get(15) ? "15 ": "",
+				  dh_groups_get(16) ? "16 ": "",
+				  dh_groups_get(17) ? "17 ": "",
+				  dh_groups_get(18) ? "18 ": "");
+
+		if (os_snprintf_error(buflen, res))
+			return -1;
+		return res;
+#endif /* CONFIG_SAE */
 	}
 
 	return -1;
@@ -1387,6 +1555,24 @@ static int hostapd_ctrl_iface_enable(struct hostapd_iface *iface)
 }
 
 
+static int hostapd_ctrl_iface_enable_bss(struct hostapd_data *hapd)
+{
+#ifdef CONFIG_IEEE80211BE
+	if (hostapd_is_mld_ap(hapd)) {
+		wpa_printf(MSG_ERROR, "Cannot enable AP MLD");
+		return -1;
+	}
+#endif /* CONFIG_IEEE80211BE */
+
+	if (hostapd_enable_bss(hapd) < 0) {
+		wpa_printf(MSG_ERROR, "Enabling of BSS failed");
+		return -1;
+	}
+
+	return 0;
+}
+
+
 static int hostapd_ctrl_iface_reload(struct hostapd_iface *iface)
 {
 	if (hostapd_reload_iface(iface) < 0) {
@@ -1417,6 +1603,24 @@ static int hostapd_ctrl_iface_disable(struct hostapd_iface *iface)
 }
 
 
+static int hostapd_ctrl_iface_disable_bss(struct hostapd_data *hapd)
+{
+#ifdef CONFIG_IEEE80211BE
+	if (hostapd_is_mld_ap(hapd)) {
+		wpa_printf(MSG_ERROR, "Cannot disable AP MLD");
+		return -1;
+	}
+#endif /* CONFIG_IEEE80211BE */
+
+	if (hostapd_disable_bss(hapd) < 0) {
+		wpa_printf(MSG_ERROR, "Disabling of BSS failed");
+		return -1;
+	}
+
+	return 0;
+}
+
+
 static int
 hostapd_ctrl_iface_kick_mismatch_psk_sta_iter(struct hostapd_data *hapd,
 					      struct sta_info *sta, void *ctx)
@@ -2531,14 +2735,14 @@ static int hostapd_ctrl_check_freq_params(struct hostapd_freq_params *params,
 		if (params->center_freq2 || params->sec_channel_offset)
 			return -1;
 
-		if (punct_bitmap)
+		if (params->punct_bitmap)
 			return -1;
 		break;
 	case 40:
 		if (params->center_freq2 || !params->sec_channel_offset)
 			return -1;
 
-		if (punct_bitmap)
+		if (params->punct_bitmap)
 			return -1;
 
 		if (!params->center_freq1)
@@ -2575,7 +2779,7 @@ static int hostapd_ctrl_check_freq_params(struct hostapd_freq_params *params,
 			return -1;
 		}
 
-		if (params->center_freq2 && punct_bitmap)
+		if (params->center_freq2 && params->punct_bitmap)
 			return -1;
 
 		/* Adjacent and overlapped are not allowed for 80+80 */
@@ -2642,7 +2846,7 @@ static int hostapd_ctrl_check_freq_params(struct hostapd_freq_params *params,
 		return -1;
 	}
 
-	if (!punct_bitmap)
+	if (!params->punct_bitmap)
 		return 0;
 
 	if (!params->eht_enabled) {
@@ -2660,7 +2864,7 @@ static int hostapd_ctrl_check_freq_params(struct hostapd_freq_params *params,
 	start_freq = params->center_freq1 - (params->bandwidth / 2);
 	if (!is_punct_bitmap_valid(params->bandwidth,
 				   (params->freq - start_freq) / 20,
-				   punct_bitmap)) {
+				   params->punct_bitmap)) {
 		wpa_printf(MSG_ERROR, "Invalid preamble puncturing bitmap");
 		return -1;
 	}
@@ -2674,12 +2878,14 @@ static int hostapd_ctrl_iface_chan_switch(struct hostapd_iface *iface,
 					  char *pos)
 {
 #ifdef NEED_AP_MLME
-	struct csa_settings settings;
+	struct hostapd_hw_modes *mode = iface->current_mode;
+	struct csa_settings settings, background_settings;
+	struct hostapd_data *hapd;
 	int ret;
-	int dfs_range = 0;
+	int freq, state;
+	int bandwidth, oper_chwidth;
+	bool background_radar, bw_changed, cac_required = false;
 	unsigned int i;
-	int bandwidth;
-	u8 chan;
 	unsigned int num_err = 0;
 	int err = 0;
 
@@ -2699,11 +2905,16 @@ static int hostapd_ctrl_iface_chan_switch(struct hostapd_iface *iface,
 					   settings.freq_params.freq)) {
 		wpa_printf(MSG_INFO,
 			   "chanswitch: Invalid frequency settings provided for multi band phy");
+	}
+
+	if (!mode ||
+	    !is_same_band(mode->channels->freq, settings.freq_params.freq)) {
+		wpa_printf(MSG_ERROR, "Invalid band for current mode");
 		return -1;
 	}
 
 	ret = hostapd_ctrl_check_freq_params(&settings.freq_params,
-					     settings.punct_bitmap);
+					     settings.freq_params.punct_bitmap);
 	if (ret) {
 		wpa_printf(MSG_INFO,
 			   "chanswitch: invalid frequency settings provided");
@@ -2713,60 +2924,65 @@ static int hostapd_ctrl_iface_chan_switch(struct hostapd_iface *iface,
 	switch (settings.freq_params.bandwidth) {
 	case 40:
 		bandwidth = CHAN_WIDTH_40;
+		oper_chwidth = CONF_OPER_CHWIDTH_USE_HT;
 		break;
 	case 80:
-		if (settings.freq_params.center_freq2)
+		if (settings.freq_params.center_freq2) {
 			bandwidth = CHAN_WIDTH_80P80;
-		else
+			oper_chwidth = CONF_OPER_CHWIDTH_80P80MHZ;
+		} else {
 			bandwidth = CHAN_WIDTH_80;
+			oper_chwidth = CONF_OPER_CHWIDTH_80MHZ;
+		}
 		break;
 	case 160:
 		bandwidth = CHAN_WIDTH_160;
+		oper_chwidth = CONF_OPER_CHWIDTH_160MHZ;
 		break;
 	case 320:
 		bandwidth = CHAN_WIDTH_320;
+		oper_chwidth = CONF_OPER_CHWIDTH_320MHZ;
 		break;
 	default:
 		bandwidth = CHAN_WIDTH_20;
+		oper_chwidth = CONF_OPER_CHWIDTH_USE_HT;
 		break;
 	}
 
+	if (settings.freq_params.radar_background) {
+		hostapd_dfs_sta_update_state(iface,
+			settings.freq_params.freq,
+			settings.freq_params.ht_enabled,
+			settings.freq_params.sec_channel_offset,
+			bandwidth, settings.freq_params.center_freq1,
+			settings.freq_params.center_freq2,
+			HOSTAPD_CHAN_DFS_AVAILABLE);
+	}
+
 	if (settings.freq_params.center_freq1)
-		dfs_range += hostapd_is_dfs_overlap(
-			iface, bandwidth, settings.freq_params.center_freq1);
+		freq = settings.freq_params.center_freq1;
 	else
-		dfs_range += hostapd_is_dfs_overlap(
-			iface, bandwidth, settings.freq_params.freq);
-
-	if (settings.freq_params.center_freq2)
-		dfs_range += hostapd_is_dfs_overlap(
-			iface, bandwidth, settings.freq_params.center_freq2);
-
-	if (dfs_range) {
-		ret = ieee80211_freq_to_chan(settings.freq_params.freq, &chan);
-		if (ret == NUM_HOSTAPD_MODES) {
-			wpa_printf(MSG_ERROR,
-				   "Failed to get channel for (freq=%d, sec_channel_offset=%d, bw=%d)",
-				   settings.freq_params.freq,
-				   settings.freq_params.sec_channel_offset,
-				   settings.freq_params.bandwidth);
-			return -1;
-		}
-
-		settings.freq_params.channel = chan;
-
-		wpa_printf(MSG_DEBUG,
-			   "DFS/CAC to (channel=%u, freq=%d, sec_channel_offset=%d, bw=%d, center_freq1=%d)",
-			   settings.freq_params.channel,
-			   settings.freq_params.freq,
-			   settings.freq_params.sec_channel_offset,
-			   settings.freq_params.bandwidth,
-			   settings.freq_params.center_freq1);
-
-		/* Perform CAC and switch channel */
-		iface->is_ch_switch_dfs = true;
-		hostapd_switch_channel_fallback(iface, &settings.freq_params);
-		return 0;
+		freq = settings.freq_params.freq;
+
+	bw_changed = oper_chwidth != hostapd_get_oper_chwidth(iface->conf);
+	state = hostapd_dfs_get_target_state(iface, bandwidth, freq,
+					     settings.freq_params.center_freq2);
+	switch (state) {
+	case HOSTAPD_CHAN_DFS_USABLE:
+		cac_required = true;
+		/* fallthrough */
+	case HOSTAPD_CHAN_DFS_AVAILABLE:
+		background_radar = hostapd_dfs_handle_csa(iface, &settings,
+							  &background_settings,
+							  cac_required,
+							  bw_changed);
+		break;
+	case HOSTAPD_CHAN_DFS_UNAVAILABLE:
+		wpa_printf(MSG_INFO,
+			   "chanswitch: target channel is UNAVAILABLE, so stop switching");
+		return -1;
+	default:
+		break;
 	}
 
 	if (iface->cac_started) {
@@ -2775,6 +2991,17 @@ static int hostapd_ctrl_iface_chan_switch(struct hostapd_iface *iface,
 		return hostapd_force_channel_switch(iface, &settings);
 	}
 
+#ifdef CONFIG_IEEE80211BE
+	hapd = iface->bss[0];
+	if (hapd->iconf->punct_bitmap != settings.freq_params.punct_bitmap &&
+	    hapd->iconf->pp_mode != PP_USR_MODE) {
+		hapd->iconf->pp_mode = PP_USR_MODE;
+		ret = hostapd_drv_pp_mode_set(hapd);
+		if (ret)
+			return ret;
+	}
+#endif /* CONFIG_IEEE80211BE */
+
 	for (i = 0; i < iface->num_bss; i++) {
 
 		/* Save CHAN_SWITCH VHT, HE, and EHT config */
@@ -2786,6 +3013,41 @@ static int hostapd_ctrl_iface_chan_switch(struct hostapd_iface *iface,
 			ret = err;
 			num_err++;
 		}
+
+#ifdef CONFIG_IEEE80211BE
+		if (iface->bss[i]->conf->mld_ap)
+			hostapd_update_aff_link_beacon(iface->bss[i], settings.cs_count);
+#endif /* CONFIG_IEEE80211BE */
+	}
+
+	if (background_radar) {
+		u8 seg0 = 0, seg1 = 0;
+
+		ieee80211_freq_to_chan(background_settings.freq_params.center_freq1, &seg0);
+		ieee80211_freq_to_chan(background_settings.freq_params.center_freq2, &seg1);
+		ret = hostapd_start_dfs_cac(iface, iface->conf->hw_mode,
+					    background_settings.freq_params.freq,
+					    background_settings.freq_params.channel,
+					    background_settings.freq_params.ht_enabled,
+					    background_settings.freq_params.vht_enabled,
+					    background_settings.freq_params.he_enabled,
+					    background_settings.freq_params.eht_enabled,
+					    background_settings.freq_params.sec_channel_offset,
+					    oper_chwidth, seg0, seg1, true);
+		if (ret) {
+			wpa_printf(MSG_ERROR, "Background radar start dfs cac failed, %d",
+				   ret);
+			iface->radar_background.channel = -1;
+			return -1;
+		}
+
+		/* Cache background radar parameters. */
+		iface->radar_background.channel = background_settings.freq_params.channel;
+		iface->radar_background.secondary_channel =
+			background_settings.freq_params.sec_channel_offset;
+		iface->radar_background.freq = background_settings.freq_params.freq;
+		iface->radar_background.centr_freq_seg0_idx = seg0;
+		iface->radar_background.centr_freq_seg1_idx = seg1;
 	}
 
 	return (iface->num_bss == num_err) ? ret : 0;
@@ -3631,77 +3893,32 @@ static int hostapd_ctrl_iface_driver_cmd(struct hostapd_data *hapd, char *cmd,
 
 
 #ifdef CONFIG_IEEE80211BE
-
-static int hostapd_ctrl_iface_enable_mld(struct hostapd_iface *iface)
+static int hostapd_ctrl_iface_enable_mld(struct hostapd_data *hapd)
 {
-	unsigned int i;
-
-	if (!iface || !iface->bss[0]->conf->mld_ap) {
-		wpa_printf(MSG_ERROR,
-			   "Trying to enable AP MLD on an interface that is not affiliated with an AP MLD");
+	if (!hostapd_is_mld_ap(hapd)) {
+		wpa_printf(MSG_ERROR, "Cannot enable leagacy BSS");
 		return -1;
 	}
 
-	for (i = 0; i < iface->interfaces->count; ++i) {
-		struct hostapd_iface *h_iface = iface->interfaces->iface[i];
-		struct hostapd_data *h_hapd = h_iface->bss[0];
-
-		if (!hostapd_is_ml_partner(h_hapd, iface->bss[0]))
-			continue;
-
-		if (hostapd_enable_iface(h_iface)) {
-			wpa_printf(MSG_ERROR, "Enabling of AP MLD failed");
-			return -1;
-		}
+	if (hostapd_enable_mld(hapd) < 0) {
+		wpa_printf(MSG_ERROR, "Enabling of MLD failed");
+		return -1;
 	}
-	return 0;
-}
 
-
-static void hostapd_disable_iface_bss(struct hostapd_iface *iface)
-{
-	unsigned int i;
-
-	for (i = 0; i < iface->num_bss; i++)
-		hostapd_bss_deinit_no_free(iface->bss[i]);
+	return 0;
 }
 
 
-static int hostapd_ctrl_iface_disable_mld(struct hostapd_iface *iface)
+static int hostapd_ctrl_iface_disable_mld(struct hostapd_data *hapd)
 {
-	unsigned int i;
-
-	if (!iface || !iface->bss[0]->conf->mld_ap) {
-		wpa_printf(MSG_ERROR,
-			   "Trying to disable AP MLD on an interface that is not affiliated with an AP MLD.");
+	if (!hostapd_is_mld_ap(hapd)) {
+		wpa_printf(MSG_ERROR, "Cannot disable legacy BSS");
 		return -1;
 	}
 
-	/* First, disable BSSs before stopping beaconing and doing driver
-	 * deinit so that the broadcast Deauthentication frames go out. */
-
-	for (i = 0; i < iface->interfaces->count; ++i) {
-		struct hostapd_iface *h_iface = iface->interfaces->iface[i];
-		struct hostapd_data *h_hapd = h_iface->bss[0];
-
-		if (!hostapd_is_ml_partner(h_hapd, iface->bss[0]))
-			continue;
-
-		hostapd_disable_iface_bss(iface);
-	}
-
-	/* Then, fully disable interfaces */
-	for (i = 0; i < iface->interfaces->count; ++i) {
-		struct hostapd_iface *h_iface = iface->interfaces->iface[i];
-		struct hostapd_data *h_hapd = h_iface->bss[0];
-
-		if (!hostapd_is_ml_partner(h_hapd, iface->bss[0]))
-			continue;
-
-		if (hostapd_disable_iface(h_iface)) {
-			wpa_printf(MSG_ERROR, "Disabling AP MLD failed");
-			return -1;
-		}
+	if (hostapd_disable_mld(hapd) < 0) {
+		wpa_printf(MSG_ERROR, "Disabling of MLD failed");
+		return -1;
 	}
 
 	return 0;
@@ -3712,11 +3929,31 @@ static int hostapd_ctrl_iface_disable_mld(struct hostapd_iface *iface)
 static int hostapd_ctrl_iface_link_remove(struct hostapd_data *hapd, char *cmd,
 					  char *buf, size_t buflen)
 {
+	char *token, *context = NULL;
+	u32 count = 0;
 	int ret;
-	u32 count = atoi(cmd);
 
-	if (!count)
-		count = 1;
+	while ((token = str_token(cmd, " ", &context))) {
+		if (os_strncmp(token, "count=", 6) == 0) {
+			count = atoi(token + 6);
+			continue;
+		}
+
+		wpa_printf(MSG_ERROR, "CTRL: Invalid LINK_REMOVE parameter: %s",
+			   token);
+		return -1;
+	}
+
+	if (!count) {
+		wpa_printf(MSG_ERROR, "Invalid ap removal count");
+		return -1;
+	}
+
+	/* limit total countdown time to be multiple of second */
+	if ((hapd->iconf->beacon_int * count) % 1000) {
+		wpa_printf(MSG_ERROR, "Total countdown time should be multiple of second");
+		return -1;
+	}
 
 	ret = hostapd_link_remove(hapd, count);
 	if (ret == 0) {
@@ -3729,68 +3966,335 @@ static int hostapd_ctrl_iface_link_remove(struct hostapd_data *hapd, char *cmd,
 
 	return ret;
 }
-#endif /* CONFIG_TESTING_OPTIONS */
-#endif /* CONFIG_IEEE80211BE */
 
 
-#ifdef CONFIG_NAN_USD
-
-static int hostapd_ctrl_nan_publish(struct hostapd_data *hapd, char *cmd,
-				    char *buf, size_t buflen)
+static int hostapd_ctrl_iface_link_add(struct hostapd_data *hapd, char *cmd,
+				       char *buf, size_t buflen)
 {
-	char *token, *context = NULL;
-	int publish_id;
-	struct nan_publish_params params;
-	const char *service_name = NULL;
-	struct wpabuf *ssi = NULL;
-	int ret = -1;
-	enum nan_service_protocol_type srv_proto_type = 0;
-	bool p2p = false;
+	struct hapd_interfaces *interfaces = hapd->iface->interfaces;
+	struct hostapd_iface *iface = NULL;
+	struct hostapd_data *h;
+	struct hostapd_config *conf;
+	const char *ifname, *conf_file, *phy;
+	u16 old_valid_links = 0;
+	bool hapd_existed = false;
+	char *pos, *tmp;
+	int i, ret = -1;
+	size_t len;
 
-	os_memset(&params, 0, sizeof(params));
-	/* USD shall use both solicited and unsolicited transmissions */
-	params.unsolicited = true;
-	params.solicited = true;
-	/* USD shall require FSD without GAS */
-	params.fsd = true;
+	if (!hapd || !hapd->conf->mld_ap || !hapd->mld) {
+		wpa_printf(MSG_ERROR,
+			   "Trying to add link to non-MLD AP or non-existed AP");
+		return -1;
+	}
 
-	while ((token = str_token(cmd, " ", &context))) {
-		if (os_strncmp(token, "service_name=", 13) == 0) {
-			service_name = token + 13;
-			continue;
-		}
+	if (os_strncmp(cmd, "bss_config=", 11))
+		return -1;
 
-		if (os_strncmp(token, "ttl=", 4) == 0) {
-			params.ttl = atoi(token + 4);
-			continue;
-		}
+	len = os_strlen(cmd) + 1;
+	tmp = os_malloc(len);
+	if (!tmp)
+		return -1;
 
-		if (os_strncmp(token, "srv_proto_type=", 15) == 0) {
-			srv_proto_type = atoi(token + 15);
-			continue;
-		}
+	os_snprintf(tmp, len, "%s", cmd);
+	phy = tmp + 11;
+	pos = os_strchr(phy, ':');
+	if (!pos)
+		goto out;
+	*pos++ = '\0';
+	conf_file = pos;
+	if (!os_strlen(conf_file))
+		goto out;
 
-		if (os_strncmp(token, "ssi=", 4) == 0) {
-			if (ssi)
-				goto fail;
-			ssi = wpabuf_parse_bin(token + 4);
-			if (!ssi)
-				goto fail;
-			continue;
-		}
+	conf = interfaces->config_read_cb(conf_file);
+	if (!conf)
+		goto out;
 
-		if (os_strcmp(token, "p2p=1") == 0) {
-			p2p = true;
-			continue;
-		}
+	ifname = conf->bss[0]->iface;
+	if (ifname[0] != '\0' &&
+	    os_strncmp(ifname, hapd->conf->iface, sizeof(hapd->conf->iface))) {
+		wpa_printf(MSG_ERROR,
+			   "Interface name %s mismatch (expected %s)",
+			   ifname, hapd->conf->iface);
+		hostapd_config_free(conf);
+		goto out;
+	}
 
-		if (os_strcmp(token, "solicited=0") == 0) {
-			params.solicited = false;
-			continue;
-		}
+	if (!conf->bss[0]->mld_ap) {
+		wpa_printf(MSG_ERROR, "The added interface is not MLD AP");
+		hostapd_config_free(conf);
+		goto out;
+	}
 
-		if (os_strcmp(token, "unsolicited=0") == 0) {
-			params.unsolicited = false;
+	for (i = 0; i < interfaces->count; i++) {
+		if (os_strcmp(interfaces->iface[i]->phy, phy) == 0) {
+			iface = interfaces->iface[i];
+			break;
+		}
+	}
+	if (iface && iface->state == HAPD_IFACE_DISABLED) {
+		for (i = 0; i < iface->num_bss; i++) {
+			h = iface->bss[i];
+			if (ifname[0] != '\0' &&
+			    !os_strncmp(ifname, h->conf->iface, sizeof(h->conf->iface)))
+				hapd_existed = true;
+		}
+	}
+	hostapd_config_free(conf);
+
+	for_each_mld_link(h, hapd)
+		old_valid_links |= BIT(h->mld_link_id);
+	hapd->mld->link_reconf_in_progress = old_valid_links;
+
+	if (hapd_existed)
+		ret = hostapd_enable_iface(iface);
+	else
+		ret = hostapd_add_iface(interfaces, cmd);
+	if (ret < 0)
+		goto out;
+
+	ret = os_snprintf(buf, buflen, "%s\n", "OK");
+	if (os_snprintf_error(buflen, ret))
+		ret = -1;
+	else
+		ret = 0;
+
+out:
+	os_free(tmp);
+
+	return ret;
+}
+
+static int hostapd_ctrl_iface_set_attlm(struct hostapd_data *hapd, char *cmd,
+					char *buf, size_t buflen)
+{
+#define MAX_SWITCH_TIME_MS 30000
+#define MAX_DURATION_MS 16000000
+	struct attlm_settings *attlm;
+	struct hostapd_data *h;
+	char *token, *context = NULL;
+	u16 switch_time, disabled_links, valid_links = 0;
+	u32 duration;
+	int ret, i;
+
+	if (!hapd->conf->mld_ap || !hapd->mld)
+		return -1;
+
+	attlm = &hapd->mld->new_attlm;
+	if (attlm->valid) {
+		wpa_printf(MSG_ERROR, "Busy: A-TTLM is on-going");
+		return -1;
+	}
+
+	for_each_mld_link(h, hapd)
+		valid_links |= BIT(h->mld_link_id);
+
+	while ((token = str_token(cmd, " ", &context))) {
+		if (os_strncmp(token, "switch_time=", 12) == 0) {
+			switch_time = atoi(token + 12);
+			if (switch_time > 0 && switch_time <= MAX_SWITCH_TIME_MS)
+				continue;
+		}
+
+		if (os_strncmp(token, "disabled_links=", 15) == 0) {
+			disabled_links = atoi(token + 15);
+
+			if ((disabled_links & valid_links) &&
+			    !(disabled_links & ~valid_links))
+				continue;
+		}
+
+		if (os_strncmp(token, "duration=", 9) == 0) {
+			duration = atoi(token + 9);
+			if (duration > 0 && duration <= MAX_DURATION_MS)
+				continue;
+		}
+
+		wpa_printf(MSG_INFO, "CTRL: Invalid SET_ATTLM parameter: %s",
+			   token);
+		return -1;
+	}
+
+	wpa_printf(MSG_DEBUG,
+		   "MLD: set A-TTLM disabled_links=%u, switch_time=%u, duration=%u",
+		   disabled_links, switch_time, duration);
+
+	attlm->valid = true;
+	attlm->direction = IEEE80211_TTLM_DIRECTION_BOTH;
+	attlm->duration = duration;
+	attlm->switch_time = switch_time;
+	attlm->disabled_links = hapd->conf->mld_allowed_links & disabled_links;
+
+	return hostapd_mld_set_attlm(hapd);
+}
+#endif /* CONFIG_TESTING_OPTIONS */
+#endif /* CONFIG_IEEE80211BE */
+
+static int
+hostapd_ctrl_iface_set_edcca(struct hostapd_data *hapd, char *cmd,
+					 char *buf, size_t buflen)
+{
+	char *pos, *config, *value;
+	u8 mode;
+
+	config = cmd;
+	pos = os_strchr(config, ' ');
+	if (pos == NULL)
+		return -1;
+	*pos++ = '\0';
+
+	if (pos == NULL)
+		return -1;
+	value = pos;
+
+	if (os_strcmp(config, "enable") == 0) {
+		int mode = atoi(value);
+		if (mode < EDCCA_MODE_FORCE_DISABLE || mode > EDCCA_MODE_AUTO) {
+			wpa_printf(MSG_ERROR, "Invalid value for edcca enable");
+			return -1;
+		}
+		hapd->iconf->edcca_enable = (u8) mode;
+		if (hostapd_drv_configure_edcca_enable(hapd) != 0)
+			return -1;
+	} else if (os_strcmp(config, "compensation") == 0) {
+		int compensation = atoi(value);
+		if (compensation < EDCCA_MIN_COMPENSATION ||
+		    compensation > EDCCA_MAX_COMPENSATION) {
+			wpa_printf(MSG_ERROR, "Invalid value for edcca compensation");
+			return -1;
+		}
+		hapd->iconf->edcca_compensation = (s8) compensation;
+		if (hostapd_drv_configure_edcca_enable(hapd) != 0)
+			return -1;
+	} else if (os_strcmp(config, "threshold") == 0) {
+		char *thres_value;
+		thres_value = os_strchr(value, ':');
+		if (thres_value == NULL)
+			return -1;
+		*thres_value++ = '\0';
+
+		if (thres_value == NULL)
+			return -1;
+		int bw_idx = atoi(value);
+		int threshold = atoi(thres_value);
+
+		if (bw_idx < EDCCA_BW_20 || bw_idx > EDCCA_BW_160) {
+			wpa_printf(MSG_ERROR,
+				   "Unsupported Bandwidth idx %d for SET_EDCCA",
+				   bw_idx);
+			return -1;
+		}
+		if (threshold < EDCCA_MIN_CONFIG_THRES ||
+		    threshold > EDCCA_MAX_CONFIG_THRES) {
+			wpa_printf(MSG_ERROR,
+				   "Unsupported threshold %d for SET_EDCCA",
+				   threshold);
+			return -1;
+		}
+
+		int threshold_arr[EDCCA_MAX_BW_NUM];
+		/* 0x7f means keep the origival value in firmware */
+		os_memset(threshold_arr, 0x7f, sizeof(threshold_arr));
+		threshold_arr[bw_idx] = threshold;
+
+		if (hostapd_drv_configure_edcca_threshold(hapd, threshold_arr) != 0)
+			return -1;
+	} else {
+		wpa_printf(MSG_ERROR,
+			"Unsupported parameter %s for SET_EDCCA", config);
+		return -1;
+	}
+	return os_snprintf(buf, buflen, "OK\n");
+}
+
+
+static int
+hostapd_ctrl_iface_get_edcca(struct hostapd_data *hapd, char *cmd, char *buf,
+			     size_t buflen)
+{
+	char *pos, *end;
+
+	pos = buf;
+	end = buf + buflen;
+	u8 value[EDCCA_MAX_BW_NUM] = {0};
+
+	if (os_strcmp(cmd, "enable") == 0) {
+		return os_snprintf(pos, end - pos, "Enable: %s\n",
+				   edcca_mode_str(hapd->iconf->edcca_enable));
+	} else if (os_strcmp(cmd, "compensation") == 0) {
+		return os_snprintf(pos, end - pos, "Compensation: %d\n",
+				  hapd->iconf->edcca_compensation);
+	} else if (os_strcmp(cmd, "threshold") == 0) {
+		if (hostapd_drv_get_edcca(hapd, EDCCA_CTRL_GET_THRES, value) != 0)
+			return -1;
+		return os_snprintf(pos, end - pos,
+				   "Threshold BW20: 0x%x, BW40: 0x%x, BW80: 0x%x, BW160: 0x%x\n",
+				   value[0], value[1], value[2], value[3]);
+	} else {
+		wpa_printf(MSG_ERROR,
+			"Unsupported parameter %s for GET_EDCCA", cmd);
+		return -1;
+	}
+}
+
+#ifdef CONFIG_NAN_USD
+
+static int hostapd_ctrl_nan_publish(struct hostapd_data *hapd, char *cmd,
+				    char *buf, size_t buflen)
+{
+	char *token, *context = NULL;
+	int publish_id;
+	struct nan_publish_params params;
+	const char *service_name = NULL;
+	struct wpabuf *ssi = NULL;
+	int ret = -1;
+	enum nan_service_protocol_type srv_proto_type = 0;
+	bool p2p = false;
+
+	os_memset(&params, 0, sizeof(params));
+	/* USD shall use both solicited and unsolicited transmissions */
+	params.unsolicited = true;
+	params.solicited = true;
+	/* USD shall require FSD without GAS */
+	params.fsd = true;
+
+	while ((token = str_token(cmd, " ", &context))) {
+		if (os_strncmp(token, "service_name=", 13) == 0) {
+			service_name = token + 13;
+			continue;
+		}
+
+		if (os_strncmp(token, "ttl=", 4) == 0) {
+			params.ttl = atoi(token + 4);
+			continue;
+		}
+
+		if (os_strncmp(token, "srv_proto_type=", 15) == 0) {
+			srv_proto_type = atoi(token + 15);
+			continue;
+		}
+
+		if (os_strncmp(token, "ssi=", 4) == 0) {
+			if (ssi)
+				goto fail;
+			ssi = wpabuf_parse_bin(token + 4);
+			if (!ssi)
+				goto fail;
+			continue;
+		}
+
+		if (os_strcmp(token, "p2p=1") == 0) {
+			p2p = true;
+			continue;
+		}
+
+		if (os_strcmp(token, "solicited=0") == 0) {
+			params.solicited = false;
+			continue;
+		}
+
+		if (os_strcmp(token, "unsolicited=0") == 0) {
+			params.unsolicited = false;
 			continue;
 		}
 
@@ -3829,207 +4333,1267 @@ static int hostapd_ctrl_nan_cancel_publish(struct hostapd_data *hapd,
 		return -1;
 	}
 
-	if (publish_id <= 0) {
-		wpa_printf(MSG_INFO,
-			   "CTRL: Invalid or missing NAN_CANCEL_PUBLISH publish_id");
+	if (publish_id <= 0) {
+		wpa_printf(MSG_INFO,
+			   "CTRL: Invalid or missing NAN_CANCEL_PUBLISH publish_id");
+		return -1;
+	}
+
+	hostapd_nan_usd_cancel_publish(hapd, publish_id);
+	return 0;
+}
+
+
+static int hostapd_ctrl_nan_update_publish(struct hostapd_data *hapd,
+					   char *cmd)
+{
+	char *token, *context = NULL;
+	int publish_id = 0;
+	struct wpabuf *ssi = NULL;
+	int ret = -1;
+
+	while ((token = str_token(cmd, " ", &context))) {
+		if (sscanf(token, "publish_id=%i", &publish_id) == 1)
+			continue;
+		if (os_strncmp(token, "ssi=", 4) == 0) {
+			if (ssi)
+				goto fail;
+			ssi = wpabuf_parse_bin(token + 4);
+			if (!ssi)
+				goto fail;
+			continue;
+		}
+		wpa_printf(MSG_INFO,
+			   "CTRL: Invalid NAN_UPDATE_PUBLISH parameter: %s",
+			   token);
+		goto fail;
+	}
+
+	if (publish_id <= 0) {
+		wpa_printf(MSG_INFO,
+			   "CTRL: Invalid or missing NAN_UPDATE_PUBLISH publish_id");
+		goto fail;
+	}
+
+	ret = hostapd_nan_usd_update_publish(hapd, publish_id, ssi);
+fail:
+	wpabuf_free(ssi);
+	return ret;
+}
+
+
+static int hostapd_ctrl_nan_subscribe(struct hostapd_data *hapd, char *cmd,
+				      char *buf, size_t buflen)
+{
+	char *token, *context = NULL;
+	int subscribe_id;
+	struct nan_subscribe_params params;
+	const char *service_name = NULL;
+	struct wpabuf *ssi = NULL;
+	int ret = -1;
+	enum nan_service_protocol_type srv_proto_type = 0;
+	bool p2p = false;
+
+	os_memset(&params, 0, sizeof(params));
+
+	while ((token = str_token(cmd, " ", &context))) {
+		if (os_strncmp(token, "service_name=", 13) == 0) {
+			service_name = token + 13;
+			continue;
+		}
+
+		if (os_strcmp(token, "active=1") == 0) {
+			params.active = true;
+			continue;
+		}
+
+		if (os_strncmp(token, "ttl=", 4) == 0) {
+			params.ttl = atoi(token + 4);
+			continue;
+		}
+
+		if (os_strncmp(token, "srv_proto_type=", 15) == 0) {
+			srv_proto_type = atoi(token + 15);
+			continue;
+		}
+
+		if (os_strncmp(token, "ssi=", 4) == 0) {
+			if (ssi)
+				goto fail;
+			ssi = wpabuf_parse_bin(token + 4);
+			if (!ssi)
+				goto fail;
+			continue;
+		}
+
+		if (os_strcmp(token, "p2p=1") == 0) {
+			p2p = true;
+			continue;
+		}
+
+		wpa_printf(MSG_INFO,
+			   "CTRL: Invalid NAN_SUBSCRIBE parameter: %s",
+			   token);
+		goto fail;
+	}
+
+	subscribe_id = hostapd_nan_usd_subscribe(hapd, service_name,
+						 srv_proto_type, ssi,
+						 &params, p2p);
+	if (subscribe_id > 0)
+		ret = os_snprintf(buf, buflen, "%d", subscribe_id);
+fail:
+	wpabuf_free(ssi);
+	return ret;
+}
+
+
+static int hostapd_ctrl_nan_cancel_subscribe(struct hostapd_data *hapd,
+					     char *cmd)
+{
+	char *token, *context = NULL;
+	int subscribe_id = 0;
+
+	while ((token = str_token(cmd, " ", &context))) {
+		if (sscanf(token, "subscribe_id=%i", &subscribe_id) == 1)
+			continue;
+		wpa_printf(MSG_INFO,
+			   "CTRL: Invalid NAN_CANCEL_SUBSCRIBE parameter: %s",
+			   token);
+		return -1;
+	}
+
+	if (subscribe_id <= 0) {
+		wpa_printf(MSG_INFO,
+			   "CTRL: Invalid or missing NAN_CANCEL_SUBSCRIBE subscribe_id");
+		return -1;
+	}
+
+	hostapd_nan_usd_cancel_subscribe(hapd, subscribe_id);
+	return 0;
+}
+
+
+static int hostapd_ctrl_nan_transmit(struct hostapd_data *hapd, char *cmd)
+{
+	char *token, *context = NULL;
+	int handle = 0;
+	int req_instance_id = 0;
+	struct wpabuf *ssi = NULL;
+	u8 peer_addr[ETH_ALEN];
+	int ret = -1;
+
+	os_memset(peer_addr, 0, ETH_ALEN);
+
+	while ((token = str_token(cmd, " ", &context))) {
+		if (sscanf(token, "handle=%i", &handle) == 1)
+			continue;
+
+		if (sscanf(token, "req_instance_id=%i", &req_instance_id) == 1)
+			continue;
+
+		if (os_strncmp(token, "address=", 8) == 0) {
+			if (hwaddr_aton(token + 8, peer_addr) < 0)
+				return -1;
+			continue;
+		}
+
+		if (os_strncmp(token, "ssi=", 4) == 0) {
+			if (ssi)
+				goto fail;
+			ssi = wpabuf_parse_bin(token + 4);
+			if (!ssi)
+				goto fail;
+			continue;
+		}
+
+		wpa_printf(MSG_INFO,
+			   "CTRL: Invalid NAN_TRANSMIT parameter: %s",
+			   token);
+		goto fail;
+	}
+
+	if (handle <= 0) {
+		wpa_printf(MSG_INFO,
+			   "CTRL: Invalid or missing NAN_TRANSMIT handle");
+		goto fail;
+	}
+
+	if (is_zero_ether_addr(peer_addr)) {
+		wpa_printf(MSG_INFO,
+			   "CTRL: Invalid or missing NAN_TRANSMIT address");
+		goto fail;
+	}
+
+	ret = hostapd_nan_usd_transmit(hapd, handle, ssi, NULL, peer_addr,
+				       req_instance_id);
+fail:
+	wpabuf_free(ssi);
+	return ret;
+}
+
+#endif /* CONFIG_NAN_USD */
+
+
+static int
+hostapd_parse_argument_helper(char *value, u16 **ptr_input)
+{
+#define MAX_MU_CTRL_NUM 17
+	u16 *input;
+	char *endptr;
+	int cnt = 0;
+
+	input = os_zalloc(MAX_MU_CTRL_NUM * sizeof(u16));
+	if (input == NULL) {
+		wpa_printf(MSG_ERROR, "Failed to allocate memory.\n");
+		return -1;
+	}
+	while (value) {
+		u8 val = strtol(value, &endptr, 10);
+
+		if (value != endptr) {
+			input[cnt++] = val;
+			value = os_strchr(endptr, ':');
+			if (value)
+				value++;
+		} else {
+			break;
+		}
+	}
+
+	*ptr_input = input;
+	return cnt;
+}
+
+#define MURU_CFG_DEPENDENCE_CHECK(_val, _mask) do {				\
+		if ((le_to_host32(_val) & (_mask)) != _mask) {			\
+			wpa_printf(MSG_ERROR, "Set %s first\n", #_mask);	\
+			goto fail;						\
+		}								\
+	} while(0)
+
+static int
+hostapd_ctrl_iface_set_mu(struct hostapd_data *hapd, char *cmd,
+			  char *buf, size_t buflen)
+{
+	char *pos, *config, *value;
+	u8 i;
+	int cnt = 0, ret;
+	u16 *val;
+	struct connac3_muru *muru;
+	struct connac3_muru_dl *dl;
+	struct connac3_muru_ul *ul;
+	struct connac3_muru_comm *comm;
+
+	config = cmd;
+	pos = os_strchr(config, ' ');
+	if (pos != NULL)
+		*pos++ = '\0';
+
+	value = pos;
+
+	if (os_strcmp(config, "onoff") == 0) {
+		cnt = hostapd_parse_argument_helper(value, &val);
+		if (cnt == -1)
+			goto fail;
+		if (cnt < 1 || val[0] > 15)
+			goto para_fail;
+
+		hapd->iconf->mu_onoff = val[0];
+		os_free(val);
+		if (hostapd_drv_mu_ctrl(hapd, MU_CTRL_ONOFF) != 0)
+			goto fail;
+
+		return os_snprintf(buf, buflen, "OK\n");
+	}
+
+	if (hapd->iconf->muru_config == NULL)
+		hapd->iconf->muru_config = os_zalloc(sizeof(struct connac3_muru));
+
+	muru = hapd->iconf->muru_config;
+	dl = &muru->dl;
+	ul = &muru->ul;
+	comm = &muru->comm;
+
+	if (os_strncmp(config, "update", 6) == 0) {
+		ret = hostapd_drv_mu_ctrl(hapd, MU_CTRL_UPDATE);
+
+		os_free(hapd->iconf->muru_config);
+		hapd->iconf->muru_config = NULL;
+
+		if (ret)
+			goto fail;
+	} else if (os_strcmp(config, "ul_comm_user_cnt") == 0) {
+		ul->user_num = (u8)atoi(value);
+		comm->ppdu_format |= MURU_PPDU_HE_TRIG;
+		comm->sch_type |= MURU_OFDMA_SCH_TYPE_UL;
+		muru->cfg_comm |= host_to_le32(MURU_COMM_SET);
+		muru->cfg_ul |= host_to_le32(MURU_FIXED_UL_TOTAL_USER_CNT);
+	} else if (os_strcmp(config, "dl_comm_user_cnt") == 0) {
+		dl->user_num = (u8)atoi(value);
+		comm->ppdu_format |= MURU_PPDU_HE_MU;
+		comm->sch_type |= MURU_OFDMA_SCH_TYPE_DL;
+		muru->cfg_comm |= host_to_le32(MURU_COMM_SET);
+		muru->cfg_dl |= host_to_le32(MURU_FIXED_DL_TOTAL_USER_CNT);
+	} else if (os_strcmp(config, "dl_comm_bw") == 0) {
+		dl->bw = (u8)atoi(value);
+		muru->cfg_dl |= host_to_le32(MURU_FIXED_DL_BW);
+	} else if (os_strcmp(config, "ul_comm_bw") == 0) {
+		ul->bw = (u8)atoi(value);
+		muru->cfg_ul |= host_to_le32(MURU_FIXED_UL_BW);
+	} else if (os_strcmp(config, "dl_user_ru_alloc") == 0) {
+		MURU_CFG_DEPENDENCE_CHECK(muru->cfg_dl, MURU_FIXED_DL_TOTAL_USER_CNT);
+		cnt = hostapd_parse_argument_helper(value, &val);
+		if (cnt == -1)
+			goto fail;
+		if (cnt != (dl->user_num * 2))
+			goto para_fail;
+		for (i = 0; i < dl->user_num; i++) {
+			dl->usr[i].ru_alloc_seg = (val[2 * i] & 0x1);
+			dl->usr[i].ru_allo_ps160 = ((val[2 * i] & 0x2) >> 1);
+			dl->usr[i].ru_idx = val[(2 * i) + 1];
+		}
+		os_free(val);
+		muru->cfg_dl |= host_to_le32(MURU_FIXED_USER_DL_RU_ALLOC);
+	} else if (os_strcmp(config, "ul_user_ru_alloc") == 0) {
+		MURU_CFG_DEPENDENCE_CHECK(muru->cfg_ul, MURU_FIXED_UL_TOTAL_USER_CNT);
+		cnt = hostapd_parse_argument_helper(value, &val);
+		if (cnt == -1)
+			goto fail;
+		if (cnt != (ul->user_num * 2))
+			goto para_fail;
+		for (i = 0; i < ul->user_num; i++) {
+			ul->usr[i].ru_alloc_seg = (val[2 * i] & 0x1);
+			ul->usr[i].ru_allo_ps160 = ((val[2 * i] & 0x2) >> 1);
+			ul->usr[i].ru_idx = val[(2 * i) + 1];
+		}
+		os_free(val);
+		muru->cfg_ul |= host_to_le32(MURU_FIXED_USER_UL_RU_ALLOC);
+	} else if (os_strcmp(config, "dl_user_mcs") == 0) {
+		MURU_CFG_DEPENDENCE_CHECK(muru->cfg_dl, MURU_FIXED_DL_TOTAL_USER_CNT);
+		cnt = hostapd_parse_argument_helper(value, &val);
+		if (cnt == -1)
+			goto fail;
+		if (cnt != dl->user_num)
+			goto para_fail;
+		for (i = 0; i < cnt; i++)
+			dl->usr[i].mcs = (u8) val[i];
+		os_free(val);
+		muru->cfg_dl |= host_to_le32(MURU_FIXED_USER_DL_MCS);
+	} else if (os_strcmp(config, "ul_user_mcs") == 0) {
+		MURU_CFG_DEPENDENCE_CHECK(muru->cfg_ul, MURU_FIXED_UL_TOTAL_USER_CNT);
+		cnt = hostapd_parse_argument_helper(value, &val);
+		if (cnt == -1)
+			goto fail;
+		if (cnt != ul->user_num)
+			goto para_fail;
+		for (i = 0; i < cnt; i++)
+			ul->usr[i].mcs = (u8) val[i];
+		os_free(val);
+		muru->cfg_ul |= host_to_le32(MURU_FIXED_USER_UL_MCS);
+	} else if (os_strcmp(config, "dl_user_cod") == 0) {
+		MURU_CFG_DEPENDENCE_CHECK(muru->cfg_dl, MURU_FIXED_DL_TOTAL_USER_CNT);
+		cnt = hostapd_parse_argument_helper(value, &val);
+		if (cnt == -1)
+			goto fail;
+		if (cnt != dl->user_num)
+			goto para_fail;
+		for (i = 0; i < cnt; i++)
+			dl->usr[i].ldpc = (u8) val[i];
+		os_free(val);
+		muru->cfg_dl |= host_to_le32(MURU_FIXED_USER_DL_COD);
+	} else if (os_strcmp(config, "ul_user_cod") == 0) {
+		MURU_CFG_DEPENDENCE_CHECK(muru->cfg_ul, MURU_FIXED_UL_TOTAL_USER_CNT);
+		cnt = hostapd_parse_argument_helper(value, &val);
+		if (cnt == -1)
+			goto fail;
+		if (cnt != ul->user_num)
+			goto para_fail;
+		for (i = 0; i < cnt; i++)
+			ul->usr[i].ldpc = (u8) val[i];
+		os_free(val);
+		muru->cfg_ul |= host_to_le32(MURU_FIXED_USER_UL_COD);
+	} else if (os_strcmp(config, "ul_user_ssAlloc_raru") == 0) {
+		MURU_CFG_DEPENDENCE_CHECK(muru->cfg_ul, MURU_FIXED_UL_TOTAL_USER_CNT);
+		cnt = hostapd_parse_argument_helper(value, &val);
+		if (cnt == -1)
+			goto fail;
+		if (cnt != ul->user_num)
+			goto para_fail;
+		for (i = 0; i < cnt; i++)
+			ul->usr[i].nss = (u8) val[i];
+		os_free(val);
+		muru->cfg_ul |= host_to_le32(MURU_FIXED_USER_UL_NSS);
+	} else if (os_strcmp(config, "dl_comm_gi") == 0) {
+		dl->gi = (u8)atoi(value);
+		muru->cfg_dl |= host_to_le32(MURU_FIXED_DL_GI);
+	} else if (os_strcmp(config, "dl_comm_ltf") == 0) {
+		dl->ltf = (u8)atoi(value);
+		muru->cfg_dl |= host_to_le32(MURU_FIXED_DL_LTF);
+	} else if (os_strcmp(config, "ul_comm_gi_ltf") == 0) {
+		ul->gi_ltf = (u8)atoi(value);
+		muru->cfg_ul |= host_to_le32(MURU_FIXED_UL_GILTF);
+	} else if (os_strcmp(config, "dl_comm_ack_policy") == 0) {
+		dl->ack_policy = (u8)atoi(value);
+		muru->cfg_dl |= host_to_le32(MURU_FIXED_DL_ACK_PLY);
+	} else if (os_strcmp(config, "dl_comm_toneplan") == 0) {
+		MURU_CFG_DEPENDENCE_CHECK(muru->cfg_dl, MURU_FIXED_DL_BW);
+		cnt = hostapd_parse_argument_helper(value, &val);
+		if (cnt == -1)
+			goto fail;
+		i = pow(2, dl->bw);
+		if (cnt != i)
+			goto para_fail;
+		for (i = 0; i < cnt; i++)
+			dl->ru[i] = host_to_le16(val[i]);
+		os_free(val);
+		muru->cfg_dl |= host_to_le32(MURU_FIXED_DL_TONE_PLAN);
+	} else if (os_strcmp(config, "global_comm_band") == 0) {
+		comm->band = (u8)atoi(value);
+		muru->cfg_comm |= host_to_le32(MURU_COMM_BAND);
+	} else {
+		wpa_printf(MSG_ERROR,
+			   "Unsupported parameter %s for SET_MU", config);
+		goto fail;
+	}
+
+	return os_snprintf(buf, buflen, "OK\n");
+
+para_fail:
+	os_free(val);
+	wpa_printf(MSG_ERROR, "Input number or value is incorrect\n");
+fail:
+	return os_snprintf(buf, buflen, "FAIL\n");
+}
+
+static int
+hostapd_ctrl_iface_get_mu(struct hostapd_data *hapd, char *buf, size_t buflen)
+{
+	u8 mu_onoff, radio_idx = 0;
+	char *pos, *end;
+	int ret;
+
+	pos = buf;
+	end = buf + buflen;
+
+	if (hapd->iface->state != HAPD_IFACE_ENABLED)
+		return os_snprintf(pos, end - pos,
+				   "Not allowed to get_mu when current state is %s\n",
+				   hostapd_state_text(hapd->iface->state));
+
+	if (hostapd_drv_mu_dump(hapd, &mu_onoff)) {
+		wpa_printf(MSG_INFO, "ctrl iface failed to call");
+		return -1;
+	}
+
+	hapd->iconf->mu_onoff = mu_onoff;
+	if (hapd->iface->current_hw_info)
+		radio_idx = hapd->iface->current_hw_info->hw_idx;
+	ret = os_snprintf(pos, end - pos,
+			  "Radio %u: UL MU-MIMO: %d, DL MU-MIMO: %d, UL OFDMA: %d, DL OFDMA: %d\n",
+			  radio_idx, !!(mu_onoff & BIT(3)), !!(mu_onoff & BIT(2)),
+			  !!(mu_onoff & BIT(1)), !!(mu_onoff & BIT(0)));
+	return ret;
+}
+
+
+static int
+hostapd_ctrl_iface_get_ibf(struct hostapd_data *hapd, char *buf,
+					 size_t buflen)
+{
+	u8 ibf_enable;
+	int ret;
+	char *pos, *end;
+
+	pos = buf;
+	end = buf + buflen;
+
+	if (hostapd_drv_ibf_dump(hapd, &ibf_enable) == 0) {
+		hapd->iconf->ibf_enable = ibf_enable;
+		ret = os_snprintf(pos, end - pos, "ibf_enable: %u\n",
+			  ibf_enable);
+	}
+
+	if (os_snprintf_error(end - pos, ret))
+		return 0;
+
+	return ret;
+}
+
+
+static int
+hostapd_ctrl_iface_set_dfs_detect_mode(struct hostapd_data *hapd, char *value,
+				       char *buf, size_t buflen)
+{
+	u8 dfs_detect_mode;
+
+	if (!value)
+		return -1;
+
+	dfs_detect_mode = strtol(value, NULL, 10);
+	if (dfs_detect_mode > DFS_DETECT_MODE_MAX) {
+		wpa_printf(MSG_ERROR, "Invalid value for dfs detect mode");
+		return -1;
+	}
+	hapd->iconf->dfs_detect_mode = dfs_detect_mode;
+
+	return os_snprintf(buf, buflen, "OK\n");
+}
+
+
+static int
+hostapd_ctrl_iface_set_offchan_ctrl(struct hostapd_data *hapd, char *cmd,
+				    char *buf, size_t buflen)
+{
+	struct hostapd_iface *iface = hapd->iface;
+	char *pos, *param;
+	enum hostapd_hw_mode hw_mode;
+	bool chan_found = false;
+	int i, num_available_chandefs, channel, chan_width, sec = 0;
+	int sec_chan_idx_80p80 = -1;
+	u8 oper_centr_freq_seg0_idx, oper_centr_freq_seg1_idx;
+	struct hostapd_channel_data *chan;
+	enum dfs_channel_type type = DFS_NO_CAC_YET;
+
+	param = os_strchr(cmd, ' ');
+	if (!param)
+		return -1;
+	*param++ = '\0';
+
+	pos = os_strstr(param, "chan=");
+	if (pos)
+		channel = strtol(pos + 5, NULL, 10);
+	else
+		return -1;
+
+	num_available_chandefs = dfs_find_channel(iface, NULL, 0, 0, type);
+	for (i = 0; i < num_available_chandefs; i++) {
+		dfs_find_channel(iface, &chan, 0, i, type);
+		if (chan->chan == channel) {
+			chan_found = true;
+			break;
+		}
+	}
+
+	if (!chan_found)
+		return -1;
+
+	if (iface->conf->secondary_channel)
+		sec = 1;
+
+	dfs_adjust_center_freq(iface, chan,
+			       sec,
+			       sec_chan_idx_80p80,
+			       &oper_centr_freq_seg0_idx,
+			       &oper_centr_freq_seg1_idx);
+
+	if (hostapd_start_dfs_cac(iface, iface->conf->hw_mode,
+				  chan->freq, chan->chan,
+				  iface->conf->ieee80211n,
+				  iface->conf->ieee80211ac,
+				  iface->conf->ieee80211ax,
+				  iface->conf->ieee80211be,
+				  sec, hostapd_get_oper_chwidth(iface->conf),
+				  oper_centr_freq_seg0_idx,
+				  oper_centr_freq_seg1_idx, true)) {
+		wpa_printf(MSG_ERROR, "DFS failed to start CAC offchannel");
+		iface->radar_background.channel = -1;
+		return -1;
+	}
+
+	iface->radar_background.channel = chan->chan;
+	iface->radar_background.freq = chan->freq;
+	iface->radar_background.secondary_channel = sec;
+	iface->radar_background.centr_freq_seg0_idx = oper_centr_freq_seg0_idx;
+	iface->radar_background.centr_freq_seg1_idx = oper_centr_freq_seg1_idx;
+
+	return os_snprintf(buf, buflen, "OK\n");
+}
+
+
+static int
+hostapd_ctrl_iface_get_amsdu(struct hostapd_data *hapd, char *buf,
+					 size_t buflen)
+{
+	u8 amsdu;
+	int ret;
+	char *pos, *end;
+
+	pos = buf;
+	end = buf + buflen;
+
+	if (hostapd_drv_amsdu_dump(hapd, &amsdu) == 0) {
+		hapd->iconf->amsdu = amsdu;
+		ret = os_snprintf(pos, end - pos, "[hostapd_cli] AMSDU: %u\n",
+					hapd->iconf->amsdu);
+	}
+
+	if (os_snprintf_error(end - pos, ret))
+		return 0;
+
+	return ret;
+}
+
+static int
+hostapd_ctrl_iface_get_bss_color(struct hostapd_data *hapd, char *buf,
+		size_t buflen)
+{
+	int ret;
+	char *pos, *end;
+	int i;
+
+	pos = buf;
+	end = buf + buflen;
+
+	if (hapd->iface->conf->he_op.he_bss_color_disabled)
+		ret = os_snprintf(buf, buflen, "BSS Color disabled\n");
+	else
+		ret = os_snprintf(buf, buflen, "BSS Color=%u\n",
+				  hapd->iface->conf->he_op.he_bss_color);
+
+	pos += ret;
+
+	return pos - buf;
+}
+
+
+static int
+hostapd_ctrl_iface_get_aval_color_bmp(struct hostapd_data *hapd, char *buf,
+		size_t buflen)
+{
+	int ret;
+	char *pos, *end;
+	int i;
+	u64 aval_color_bmp = 0;
+
+	hostapd_drv_get_aval_bss_color_bmp(hapd, &aval_color_bmp);
+	hapd->color_collision_bitmap = ~aval_color_bmp;
+
+	pos = buf;
+	end = buf + buflen;
+
+	ret = os_snprintf(buf, buflen,
+			  "available color bitmap=0x%lx\n",
+			  aval_color_bmp);
+	if (os_snprintf_error(end - pos, ret))
+		return pos - buf;
+	pos += ret;
+
+	for (i = 0; i < HE_OPERATION_BSS_COLOR_MAX; i++) {
+		int bit = !!((aval_color_bmp >> i) & 1LLU);
+
+		if (i % 8 == 0) {
+			ret = os_snprintf(pos, end - pos, "%2d: ", i);
+			if (os_snprintf_error(end - pos, ret))
+				return pos - buf;
+			pos += ret;
+		}
+
+		ret = os_snprintf(pos, end - pos, "%d ", bit);
+		if (os_snprintf_error(end - pos, ret))
+			return pos - buf;
+		pos += ret;
+
+		if (i % 8 == 7) {
+			ret = os_snprintf(pos, end - pos, "\n");
+			if (os_snprintf_error(end - pos, ret))
+				return pos - buf;
+			pos += ret;
+		}
+	}
+	return pos - buf;
+}
+
+static int
+hostapd_ctrl_iface_ap_wireless(struct hostapd_data *hapd, char *cmd,
+					 char *buf, size_t buflen)
+{
+	char *pos, *value, *config = cmd;
+	enum mtk_vendor_attr_wireless_ctrl sub_cmd;
+
+	pos = os_strchr(config, '=');
+	if (pos == NULL)
+		return -1;
+	*pos++ = '\0';
+
+	if(pos == NULL)
+		return -1;
+	value = pos;
+
+	if (os_strncmp(config, "fixed_mcs", 9) == 0)
+		sub_cmd = MTK_VENDOR_ATTR_WIRELESS_CTRL_FIXED_MCS;
+	else if (os_strncmp(config, "ofdma", 5) == 0)
+		sub_cmd = MTK_VENDOR_ATTR_WIRELESS_CTRL_FIXED_OFDMA;
+	else if (os_strncmp(config, "ppdu_type", 9) == 0)
+		sub_cmd = MTK_VENDOR_ATTR_WIRELESS_CTRL_PPDU_TX_TYPE;
+	else if (os_strncmp(config, "nusers_ofdma", 12) == 0)
+		sub_cmd = MTK_VENDOR_ATTR_WIRELESS_CTRL_NUSERS_OFDMA;
+	else if (os_strncmp(config, "add_ba_req_bufsize", 18) == 0)
+		sub_cmd = MTK_VENDOR_ATTR_WIRELESS_CTRL_BA_BUFFER_SIZE;
+	else if (os_strncmp(config, "mimo", 4) == 0)
+		sub_cmd = MTK_VENDOR_ATTR_WIRELESS_CTRL_MIMO;
+	else if (os_strncmp(config, "cert", 4) == 0)
+		sub_cmd = MTK_VENDOR_ATTR_WIRELESS_CTRL_CERT ;
+	else if (os_strncmp(config, "amsdu", 5) == 0)
+		sub_cmd = MTK_VENDOR_ATTR_WIRELESS_CTRL_AMSDU;
+	else if (os_strncmp(config, "rts_sigta", 9) == 0)
+		sub_cmd = MTK_VENDOR_ATTR_WIRELESS_CTRL_RTS_SIGTA;
+	else {
+		wpa_printf(MSG_ERROR,
+			"Unsupported parameter %s for ap_wireless", config);
+		return -1;
+	}
+
+	if (hostapd_drv_ap_wireless(hapd, (u8) sub_cmd, atoi(value)) != 0)
+		return -1;
+	return os_snprintf(buf, buflen, "OK\n");
+}
+
+static int
+hostapd_ctrl_iface_set_amnt(struct hostapd_data *hapd, char *cmd,
+					char *buf, size_t buflen)
+{
+	char *tmp, sta_mac[ETH_ALEN] = {0};
+	int amnt_idx = 0;
+
+	tmp = strtok_r(cmd, " ", &cmd);
+
+	if (!tmp) {
+		wpa_printf(MSG_ERROR, "Error in command format\n");
+		return -1;
+	}
+
+	amnt_idx = strtol(tmp, &tmp, 10);
+
+	if (amnt_idx < 0 || amnt_idx > 15) {
+		wpa_printf(MSG_ERROR, "Wrong AMNT index %d\n", amnt_idx);
+		return -1;
+	}
+
+	if (!cmd) {
+		wpa_printf(MSG_ERROR, "Error in command format\n");
+		return -1;
+	}
+
+	if (hwaddr_aton(cmd, sta_mac) < 0) {
+		wpa_printf(MSG_ERROR, "station mac is not right.\n");
+		return -1;
+	}
+
+	if (hostapd_drv_amnt_set(hapd, amnt_idx, sta_mac)) {
+		wpa_printf(MSG_ERROR, "Not able to set amnt index\n");
+		return -1;
+	}
+
+	return os_snprintf(buf, buflen, "OK\n");
+}
+
+static int
+hostapd_ctrl_iface_ap_rfeatures(struct hostapd_data *hapd, char *cmd,
+					 char *buf, size_t buflen)
+{
+	char *pos, *value, *type, *config = cmd;
+	enum mtk_vendor_attr_rfeature_ctrl sub_cmd;
+
+	pos = os_strchr(config, '=');
+	if (pos == NULL)
+		return -1;
+	*pos++ = '\0';
+
+	if(pos == NULL)
+		return -1;
+	value = pos;
+
+	if (os_strncmp(config, "he_gi", 5) == 0)
+		sub_cmd = MTK_VENDOR_ATTR_RFEATURE_CTRL_HE_GI;
+	else if (os_strncmp(config, "he_ltf", 6) == 0)
+		sub_cmd = MTK_VENDOR_ATTR_RFEATURE_CTRL_HE_LTF;
+	else if (os_strncmp(config, "trig_type", 9) == 0) {
+		pos = os_strchr(value, ',');
+		if (pos == NULL)
+			return -1;
+		*pos++ = '\0';
+		if(pos == NULL)
+			return -1;
+		type = pos;
+		goto trigtype;
+	} else if (os_strcmp(config, "ack_policy") == 0)
+		sub_cmd = MTK_VENDOR_ATTR_RFEATURE_CTRL_ACK_PLCY;
+	else if (os_strcmp(config, "trig_variant") == 0)
+		sub_cmd = MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_VARIANT_TYPE;
+	else if (os_strcmp(config, "coding_type") == 0)
+		sub_cmd = MTK_VENDOR_ATTR_RFEATURE_CTRL_CODING_TYPE;
+	else {
+		wpa_printf(MSG_ERROR,
+			"Unsupported parameter %s for ap_rfeatures", config);
+		return -1;
+	}
+
+	if (hostapd_drv_ap_rfeatures(hapd, (u8) sub_cmd, atoi(value)) != 0)
+		return -1;
+	goto exit;
+
+trigtype:
+	if (hostapd_drv_ap_trig_type(hapd, atoi(value), atoi(type)) != 0)
+		return -1;
+
+exit:
+	return os_snprintf(buf, buflen, "OK\n");
+}
+
+static int
+hostapd_ctrl_iface_dump_amnt(struct hostapd_data *hapd, char *cmd,
+				char *buf, size_t buflen)
+{
+	char *tmp;
+	int amnt_idx = 0, ret = 0;
+	struct amnt_resp_data *resp_buf;
+	char *pos, *end;
+	struct amnt_data *res;
+
+	pos = buf;
+	end = buf + buflen;
+
+	tmp = strtok_r(cmd, " ", &cmd);
+
+	if (!tmp) {
+		wpa_printf(MSG_ERROR, "Error in command format\n");
+		return -1;
+	}
+
+	amnt_idx = strtoul(tmp, &tmp, 0);
+
+	if ((amnt_idx < 0 || amnt_idx > 15) && amnt_idx != 0xff) {
+		wpa_printf(MSG_ERROR, "Wrong AMNT index\n");
+		return -1;
+	}
+
+	if (amnt_idx == 0xff)
+		resp_buf = (struct amnt_resp_data *) os_zalloc(AIR_MONITOR_MAX_ENTRY
+							* sizeof(struct amnt_data) + 1);
+	else
+		resp_buf = (struct amnt_resp_data *) os_zalloc(sizeof(struct amnt_data) + 1);
+
+	if (resp_buf == NULL) {
+		wpa_printf(MSG_ERROR, "Error in memory allocation\n");
+		return -1;
+	}
+
+	if (hostapd_drv_amnt_dump(hapd, amnt_idx, (u8 *)resp_buf)) {
+		wpa_printf(MSG_ERROR, "Not able to set amnt index\n");
+		os_free(resp_buf);
+		return -1;
+	}
+
+	for (int i = 0; i < resp_buf->sta_num && i < AIR_MONITOR_MAX_ENTRY; i++) {
+		res = &resp_buf->resp_data[i];
+		ret = os_snprintf(pos, end - pos,
+				"[hostapd_cli] amnt_idx: %d, addr="MACSTR
+				", rssi=%d/%d/%d/%d, last_seen=%u\n",
+				res->idx,
+				MAC2STR(res->addr), res->rssi[0],
+				res->rssi[1], res->rssi[2],
+				res->rssi[3], res->last_seen);
+		if (os_snprintf_error(end - pos, ret)) {
+			os_free(resp_buf);
+			return 0;
+		}
+		pos = pos + ret;
+	}
+
+	os_free(resp_buf);
+
+	if (pos == buf)
+		return os_snprintf(buf, buflen, "Index %d is not monitored\n",
+				amnt_idx);
+	else
+		return pos - buf;
+}
+
+static int
+hostapd_ctrl_iface_set_background_radar_mode(struct hostapd_data *hapd, char *cmd,
+					     char *buf, size_t buflen)
+{
+	struct hostapd_iface *iface = hapd->iface;
+	char *pos, *param;
+
+	param = os_strchr(cmd, ' ');
+	if (!param)
+		return -1;
+	*param++ = '\0';
+
+	pos = os_strstr(param, "mode=");
+	if (!pos)
+		return -1;
+
+	if (os_strncmp(pos + 5, "cert", 4) == 0)
+		iface->conf->background_radar_mode = BACKGROUND_RADAR_CERT_MODE;
+	else if (os_strncmp(pos + 5, "normal", 6) == 0)
+		iface->conf->background_radar_mode = BACKGROUND_RADAR_NORMAL_MODE;
+
+	if (hostapd_drv_background_radar_mode(hapd) < 0)
+		return -1;
+
+	return os_snprintf(buf, buflen, "OK\n");
+}
+
+static int
+hostapd_ctrl_iface_set_pp(struct hostapd_data *hapd, char *cmd, char *buf,
+			  size_t buflen)
+{
+	char *config, *value;
+
+	config = cmd;
+
+	value = os_strchr(config, ' ');
+	if (value == NULL)
+		return -1;
+	*value++ = '\0';
+
+	if (os_strcmp(config, "mode") == 0) {
+		int val = strtol(value, NULL, 10);
+
+		switch(val) {
+		case PP_DISABLE:
+		case PP_FW_MODE:
+			break;
+		case PP_USR_MODE:
+		default:
+			wpa_printf(MSG_ERROR, "Invalid value for SET_PP");
+			return -1;
+		}
+		hapd->iconf->pp_mode = (u8) val;
+		hapd->iconf->punct_bitmap = 0;
+		if (hostapd_drv_pp_mode_set(hapd) != 0)
+			return -1;
+	} else {
+		wpa_printf(MSG_ERROR,
+			   "Unsupported parameter %s for SET_PP"
+			   "Usage: set_pp mode <value>", config);
+		return -1;
+	}
+	return os_snprintf(buf, buflen, "OK\n");
+}
+
+static int
+hostapd_ctrl_iface_get_pp(struct hostapd_data *hapd, char *cmd, char *buf,
+			  size_t buflen)
+{
+	return os_snprintf(buf, buflen, "pp_mode: %d, punct_bitmap: 0x%04x\n",
+			   hapd->iconf->pp_mode, hapd->iconf->punct_bitmap);
+}
+
+static int
+hostapd_ctrl_iface_disable_beacon(struct hostapd_data *hapd, char *value,
+				  char *buf, size_t buflen)
+{
+	int disable_beacon = atoi(value);
+
+	if (disable_beacon < 0) {
+		wpa_printf(MSG_ERROR, "Invalid value for beacon ctrl");
+		return -1;
+	}
+
+	if (hostapd_drv_beacon_ctrl(hapd, !disable_beacon) == 0)
+		return os_snprintf(buf, buflen, "OK\n");
+	else
 		return -1;
-	}
 
-	hostapd_nan_usd_cancel_publish(hapd, publish_id);
-	return 0;
 }
 
-
-static int hostapd_ctrl_nan_update_publish(struct hostapd_data *hapd,
-					   char *cmd)
+static int
+hostapd_ctrl_iface_set_eml_resp(struct hostapd_data *hapd, char *value,
+				char *buf, size_t buflen)
 {
-	char *token, *context = NULL;
-	int publish_id = 0;
-	struct wpabuf *ssi = NULL;
-	int ret = -1;
+	struct hostapd_data *link;
+	int cnt = 0;
+	u16 *val;
 
-	while ((token = str_token(cmd, " ", &context))) {
-		if (sscanf(token, "publish_id=%i", &publish_id) == 1)
-			continue;
-		if (os_strncmp(token, "ssi=", 4) == 0) {
-			if (ssi)
-				goto fail;
-			ssi = wpabuf_parse_bin(token + 4);
-			if (!ssi)
-				goto fail;
-			continue;
-		}
-		wpa_printf(MSG_INFO,
-			   "CTRL: Invalid NAN_UPDATE_PUBLISH parameter: %s",
-			   token);
-		goto fail;
-	}
+	if (!hostapd_is_mld_ap(hapd))
+		return -1;
 
-	if (publish_id <= 0) {
-		wpa_printf(MSG_INFO,
-			   "CTRL: Invalid or missing NAN_UPDATE_PUBLISH publish_id");
+	cnt = hostapd_parse_argument_helper(value, &val);
+	if (cnt == -1)
 		goto fail;
+	if (cnt != 1 || val[0] < 0)
+		goto para_fail;
+
+	for_each_mld_link(link, hapd) {
+		link->iconf->eml_resp = val[0];
+		wpa_printf(MSG_ERROR, "Link:%d, Response EML:%d\n",
+			   link->mld_link_id, link->iconf->eml_resp);
 	}
 
-	ret = hostapd_nan_usd_update_publish(hapd, publish_id, ssi);
+	os_free(val);
+
+	return os_snprintf(buf, buflen, "OK\n");
+
+para_fail:
+	os_free(val);
+	wpa_printf(MSG_ERROR, "Input number or value is incorrect\n");
 fail:
-	wpabuf_free(ssi);
-	return ret;
+	return os_snprintf(buf, buflen, "FAIL\n");
 }
 
-
-static int hostapd_ctrl_nan_subscribe(struct hostapd_data *hapd, char *cmd,
-				      char *buf, size_t buflen)
+static int
+hostapd_ctrl_iface_set_csi(struct hostapd_data *hapd, char *cmd,
+			   char *buf, size_t buflen)
 {
-	char *token, *context = NULL;
-	int subscribe_id;
-	struct nan_subscribe_params params;
-	const char *service_name = NULL;
-	struct wpabuf *ssi = NULL;
-	int ret = -1;
-	enum nan_service_protocol_type srv_proto_type = 0;
-	bool p2p = false;
+	char *tmp;
+	u8 sta_mac[ETH_ALEN] = {0};
+	u32 csi_para[4] = {0};
+	char mac_str[18] = {0};
+	u8 csi_para_cnt = 0;
 
-	os_memset(&params, 0, sizeof(params));
+	tmp = strtok_r(cmd, ",", &cmd);
 
-	while ((token = str_token(cmd, " ", &context))) {
-		if (os_strncmp(token, "service_name=", 13) == 0) {
-			service_name = token + 13;
-			continue;
+	while (tmp) {
+		csi_para_cnt++;
+
+		if (csi_para_cnt <= 4)
+			csi_para[csi_para_cnt - 1] = strtol(tmp, &tmp, 10);
+		else if (csi_para_cnt == 5) {
+			memcpy(mac_str, tmp, sizeof(mac_str) - 1);
+			break;
 		}
 
-		if (os_strcmp(token, "active=1") == 0) {
-			params.active = true;
-			continue;
+		tmp = strtok_r(NULL, ",", &cmd);
+	}
+
+	if (strlen(mac_str)) {	/* user input mac string */
+		if (hwaddr_aton(mac_str, sta_mac) < 0) {
+			wpa_printf(MSG_ERROR, "station mac is not right.\n");
+			return -1;
 		}
 
-		if (os_strncmp(token, "ttl=", 4) == 0) {
-			params.ttl = atoi(token + 4);
-			continue;
+		if (hostapd_drv_csi_set(hapd, csi_para[0], csi_para[1], csi_para[2], csi_para[3], sta_mac)) {
+			wpa_printf(MSG_ERROR, "Not able to set csi, %d,%d,%d,%d,%s\n",
+					csi_para[0], csi_para[1], csi_para[2], csi_para[3], mac_str);
+			return -1;
+		}
+	} else {
+		if (hostapd_drv_csi_set(hapd, csi_para[0], csi_para[1], csi_para[2], csi_para[3], NULL)) {
+			wpa_printf(MSG_ERROR, "Not able to set csi, %d,%d,%d,%d\n",
+					csi_para[0], csi_para[1], csi_para[2], csi_para[3]);
+			return -1;
 		}
+	}
 
-		if (os_strncmp(token, "srv_proto_type=", 15) == 0) {
-			srv_proto_type = atoi(token + 15);
-			continue;
+	return os_snprintf(buf, buflen, "OK\n");
+}
+
+static int mt76_csi_to_json(char *fname, struct csi_resp_data *resp_buf)
+{
+#define MAX_BUF_SIZE	10000
+	FILE *f;
+	int i;
+
+	if (!fname) {
+		wpa_printf(MSG_ERROR, "csi dump file name is null!\n");
+		return -1;
+	}
+
+	f = fopen(fname, "a+");
+	if (!f) {
+		wpa_printf(MSG_ERROR, "open csi dump file %s failed\n", fname);
+		return -1;
+	}
+
+	if (fwrite("[", 1, 1, f) != 1) {
+		fclose(f);
+		return -1;
+	}
+
+	for (i = 0; i < resp_buf->buf_cnt; i++) {
+		struct csi_data *c = &resp_buf->csi_buf[i];
+		char *pos, *buf;
+		int j;
+
+		buf = malloc(MAX_BUF_SIZE);
+		if (!buf) {
+			fclose(f);
+			return -1;
 		}
 
-		if (os_strncmp(token, "ssi=", 4) == 0) {
-			if (ssi)
-				goto fail;
-			ssi = wpabuf_parse_bin(token + 4);
-			if (!ssi)
-				goto fail;
-			continue;
+		pos = buf;
+		pos += snprintf(pos, MAX_BUF_SIZE, "%c", '[');
+
+		pos += snprintf(pos, MAX_BUF_SIZE, "%d,", c->ts);
+		pos += snprintf(pos, MAX_BUF_SIZE, "\"%02x%02x%02x%02x%02x%02x\",", c->ta[0], c->ta[1], c->ta[2], c->ta[3], c->ta[4], c->ta[5]);
+
+		pos += snprintf(pos, MAX_BUF_SIZE, "%d,", c->rssi);
+		pos += snprintf(pos, MAX_BUF_SIZE, "%u,", c->snr);
+		pos += snprintf(pos, MAX_BUF_SIZE, "%u,", c->data_bw);
+		pos += snprintf(pos, MAX_BUF_SIZE, "%u,", c->pri_ch_idx);
+		pos += snprintf(pos, MAX_BUF_SIZE, "%u,", c->rx_mode);
+		pos += snprintf(pos, MAX_BUF_SIZE, "%d,", c->tx_idx);
+		pos += snprintf(pos, MAX_BUF_SIZE, "%d,", c->rx_idx);
+		pos += snprintf(pos, MAX_BUF_SIZE, "%d,", c->chain_info);
+		pos += snprintf(pos, MAX_BUF_SIZE, "%d,", c->ext_info);
+
+		pos += snprintf(pos, MAX_BUF_SIZE, "%c", '[');
+		for (j = 0; j < c->data_num; j++) {
+			pos += snprintf(pos, MAX_BUF_SIZE, "%d", c->data_i[j]);
+			if (j != (c->data_num - 1))
+				pos += snprintf(pos, MAX_BUF_SIZE, ",");
 		}
+		pos += snprintf(pos, MAX_BUF_SIZE, "%c,", ']');
 
-		if (os_strcmp(token, "p2p=1") == 0) {
-			p2p = true;
-			continue;
+		pos += snprintf(pos, MAX_BUF_SIZE, "%c", '[');
+		for (j = 0; j < c->data_num; j++) {
+			pos += snprintf(pos, MAX_BUF_SIZE, "%d", c->data_q[j]);
+			if (j != (c->data_num - 1))
+				pos += snprintf(pos, MAX_BUF_SIZE, ",");
 		}
+		pos += snprintf(pos, MAX_BUF_SIZE, "%c", ']');
 
-		wpa_printf(MSG_INFO,
-			   "CTRL: Invalid NAN_SUBSCRIBE parameter: %s",
-			   token);
-		goto fail;
+		pos += snprintf(pos, MAX_BUF_SIZE, "%c", ']');
+		if (i != resp_buf->buf_cnt - 1)
+			pos += snprintf(pos, MAX_BUF_SIZE, ",");
+
+		if (fwrite(buf, 1, pos - buf, f) != (pos - buf)) {
+			perror("fwrite");
+			free(buf);
+			fclose(f);
+			return -1;
+		}
+
+		free(buf);
 	}
 
-	subscribe_id = hostapd_nan_usd_subscribe(hapd, service_name,
-						 srv_proto_type, ssi,
-						 &params, p2p);
-	if (subscribe_id > 0)
-		ret = os_snprintf(buf, buflen, "%d", subscribe_id);
-fail:
-	wpabuf_free(ssi);
-	return ret;
-}
+	if (fwrite("]", 1, 1, f) != 1) {
+		fclose(f);
+		return -1;
+	}
 
+	fclose(f);
 
-static int hostapd_ctrl_nan_cancel_subscribe(struct hostapd_data *hapd,
-					     char *cmd)
+	return 0;
+}
+
+static int
+hostapd_ctrl_iface_dump_csi(struct hostapd_data *hapd, char *cmd,
+			    char *buf, size_t buflen)
 {
-	char *token, *context = NULL;
-	int subscribe_id = 0;
+	char *tmp, *fname;
+	int data_cnt = 0, ret = 0;
+	struct csi_resp_data resp_buf;
 
-	while ((token = str_token(cmd, " ", &context))) {
-		if (sscanf(token, "subscribe_id=%i", &subscribe_id) == 1)
-			continue;
-		wpa_printf(MSG_INFO,
-			   "CTRL: Invalid NAN_CANCEL_SUBSCRIBE parameter: %s",
-			   token);
+	tmp = strtok_r(cmd, ",", &cmd);
+
+	if (!tmp) {
+		wpa_printf(MSG_ERROR, "Error in command format\n");
 		return -1;
 	}
 
-	if (subscribe_id <= 0) {
-		wpa_printf(MSG_INFO,
-			   "CTRL: Invalid or missing NAN_CANCEL_SUBSCRIBE subscribe_id");
+	data_cnt = strtoul(tmp, &tmp, 0);
+
+	if (data_cnt > 3000) {
+		wpa_printf(MSG_ERROR, "Wrong input csi data cnt\n");
 		return -1;
 	}
 
-	hostapd_nan_usd_cancel_subscribe(hapd, subscribe_id);
+	fname = strtok_r(NULL, ",", &cmd);
+
+	if (!fname) {
+		wpa_printf(MSG_ERROR, "Error in command format, csi_filename.\n");
+		return -1;
+	}
+
+	resp_buf.csi_buf = (struct csi_data *)os_zalloc(sizeof(struct csi_data) * data_cnt);
+
+	if (resp_buf.csi_buf == NULL) {
+		wpa_printf(MSG_ERROR, "Error in memory allocation\n");
+		return -1;
+	}
+
+	resp_buf.usr_need_cnt = data_cnt;
+	resp_buf.buf_cnt = 0;
+
+	if (hostapd_drv_csi_dump(hapd, (void *)&resp_buf)) {
+		wpa_printf(MSG_ERROR, "Not able to set csi dump\n");
+		os_free(resp_buf.csi_buf);
+		return -1;
+	}
+
+	mt76_csi_to_json(fname, &resp_buf);
+
+	os_free(resp_buf.csi_buf);
 	return 0;
 }
 
-
-static int hostapd_ctrl_nan_transmit(struct hostapd_data *hapd, char *cmd)
+static int
+hostapd_ctrl_iface_wmm(struct hostapd_data *hapd, char *cmd, char *buf,
+		       size_t buflen)
 {
-	char *token, *context = NULL;
-	int handle = 0;
-	int req_instance_id = 0;
-	struct wpabuf *ssi = NULL;
-	u8 peer_addr[ETH_ALEN];
-	int ret = -1;
+	char *pos = cmd, *ac, *token, *context = NULL;
+	struct hostapd_wmm_ac_params *acp;
+	int num;
 
-	os_memset(peer_addr, 0, ETH_ALEN);
+	if (!hapd->conf->mld_ap)
+		return -1;
 
-	while ((token = str_token(cmd, " ", &context))) {
-		if (sscanf(token, "handle=%i", &handle) == 1)
-			continue;
+	ac = pos;
+	pos = os_strchr(pos, ' ');
+	if (pos)
+		*pos++ = '\0';
 
-		if (sscanf(token, "req_instance_id=%i", &req_instance_id) == 1)
+	if (os_strncmp(ac, "BE", 2) == 0) {
+		num = 0;
+	} else if (os_strncmp(ac, "BK", 2) == 0) {
+		num = 1;
+	} else if (os_strncmp(ac, "VI", 2) == 0) {
+		num = 2;
+	} else if (os_strncmp(ac, "VO", 2) == 0) {
+		num = 3;
+	} else {
+		wpa_printf(MSG_ERROR, "Unknown AC name '%s'", ac);
+		return -1;
+	}
+
+	acp = &hapd->iconf->wmm_ac_params[num];
+
+	/* if only ac is provied, show wmm params */
+	if (!pos)
+		return os_snprintf(buf, buflen,
+				   "link=%d ac=%s cwmin=%d cwmax=%d aifs=%d txop_limit=%d\n",
+				   hapd->mld_link_id, ac, acp->cwmin, acp->cwmax, acp->aifs, acp->txop_limit);
+
+	while ((token = str_token(pos, " ", &context))) {
+		if (os_strncmp(token, "cwmin=", 6) == 0) {
+			acp->cwmin = atoi(token + 6);
 			continue;
+		}
 
-		if (os_strncmp(token, "address=", 8) == 0) {
-			if (hwaddr_aton(token + 8, peer_addr) < 0)
-				return -1;
+		if (os_strncmp(token, "cwmax=", 6) == 0) {
+			acp->cwmax = atoi(token + 6);
 			continue;
 		}
 
-		if (os_strncmp(token, "ssi=", 4) == 0) {
-			if (ssi)
-				goto fail;
-			ssi = wpabuf_parse_bin(token + 4);
-			if (!ssi)
-				goto fail;
+		if (os_strncmp(token, "aifs=", 5) == 0) {
+			acp->aifs = atoi(token + 5);
 			continue;
 		}
 
-		wpa_printf(MSG_INFO,
-			   "CTRL: Invalid NAN_TRANSMIT parameter: %s",
-			   token);
-		goto fail;
-	}
+		if (os_strncmp(token, "txop_limit=", 11) == 0) {
+			acp->txop_limit = atoi(token + 11);
+			continue;
+		}
 
-	if (handle <= 0) {
-		wpa_printf(MSG_INFO,
-			   "CTRL: Invalid or missing NAN_TRANSMIT handle");
-		goto fail;
+		wpa_printf(MSG_ERROR, "CTRL: Invalid WMM parameter: %s", token);
+		return -1;
 	}
 
-	if (is_zero_ether_addr(peer_addr)) {
-		wpa_printf(MSG_INFO,
-			   "CTRL: Invalid or missing NAN_TRANSMIT address");
-		goto fail;
-	}
+	if (acp->cwmin > acp->cwmax)
+		return -1;
 
-	ret = hostapd_nan_usd_transmit(hapd, handle, ssi, NULL, peer_addr,
-				       req_instance_id);
-fail:
-	wpabuf_free(ssi);
-	return ret;
-}
+	ieee802_11_set_bss_critical_update(hapd, BSS_CRIT_UPDATE_EVENT_EDCA);
 
-#endif /* CONFIG_NAN_USD */
+	if (ieee802_11_set_beacon(hapd))
+		return -1;
 
+	return os_snprintf(buf, buflen, "OK\n");
+}
 
 static int hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 					      char *buf, char *reply,
@@ -4057,6 +5621,7 @@ static int hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 						      reply_size);
 	} else if (os_strcmp(buf, "STATUS-DRIVER") == 0) {
 		reply_len = hostapd_drv_status(hapd, reply, reply_size);
+#ifdef CONFIG_CTRL_IFACE_MIB
 	} else if (os_strcmp(buf, "MIB") == 0) {
 		reply_len = ieee802_11_get_mib(hapd, reply, reply_size);
 		if (reply_len >= 0) {
@@ -4098,6 +5663,7 @@ static int hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 	} else if (os_strncmp(buf, "STA-NEXT ", 9) == 0) {
 		reply_len = hostapd_ctrl_iface_sta_next(hapd, buf + 9, reply,
 							reply_size);
+#endif
 	} else if (os_strcmp(buf, "ATTACH") == 0) {
 		if (hostapd_ctrl_iface_attach(hapd, from, fromlen, NULL))
 			reply_len = -1;
@@ -4206,6 +5772,9 @@ static int hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 		if (hostapd_ctrl_iface_coloc_intf_req(hapd, buf + 15))
 			reply_len = -1;
 #endif /* CONFIG_WNM_AP */
+	} else if (os_strncmp(buf, "INBAND_DISCOVERY ", 17) == 0) {
+		if (hostapd_ctrl_iface_inband_discovery(hapd, buf + 17))
+			reply_len = -1;
 	} else if (os_strcmp(buf, "GET_CONFIG") == 0) {
 		reply_len = hostapd_ctrl_iface_get_config(hapd, reply,
 							  reply_size);
@@ -4218,6 +5787,9 @@ static int hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 	} else if (os_strcmp(buf, "ENABLE") == 0) {
 		if (hostapd_ctrl_iface_enable(hapd->iface))
 			reply_len = -1;
+	} else if (os_strncmp(buf, "ENABLE_BSS", 10) == 0) {
+		if (hostapd_ctrl_iface_enable_bss(hapd))
+			reply_len = -1;
 	} else if (os_strcmp(buf, "RELOAD_WPA_PSK") == 0) {
 		if (hostapd_ctrl_iface_reload_wpa_psk(hapd))
 			reply_len = -1;
@@ -4241,6 +5813,9 @@ static int hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 	} else if (os_strcmp(buf, "DISABLE") == 0) {
 		if (hostapd_ctrl_iface_disable(hapd->iface))
 			reply_len = -1;
+	} else if (os_strncmp(buf, "DISABLE_BSS", 11) == 0) {
+		if (hostapd_ctrl_iface_disable_bss(hapd))
+			reply_len = -1;
 	} else if (os_strcmp(buf, "UPDATE_BEACON") == 0) {
 		if (ieee802_11_set_beacon(hapd))
 			reply_len = -1;
@@ -4622,18 +6197,90 @@ static int hostapd_ctrl_iface_receive_process(struct hostapd_data *hapd,
 #endif /* ANDROID */
 #ifdef CONFIG_IEEE80211BE
 	} else if (os_strcmp(buf, "ENABLE_MLD") == 0) {
-		if (hostapd_ctrl_iface_enable_mld(hapd->iface))
+		if (hostapd_ctrl_iface_enable_mld(hapd))
 			reply_len = -1;
 	} else if (os_strcmp(buf, "DISABLE_MLD") == 0) {
-		if (hostapd_ctrl_iface_disable_mld(hapd->iface))
+		if (hostapd_ctrl_iface_disable_mld(hapd))
 			reply_len = -1;
 #ifdef CONFIG_TESTING_OPTIONS
 	} else if (os_strncmp(buf, "LINK_REMOVE ", 12) == 0) {
 		if (hostapd_ctrl_iface_link_remove(hapd, buf + 12,
 						   reply, reply_size))
 			reply_len = -1;
+	} else if (os_strncmp(buf, "LINK_ADD ", 9) == 0) {
+		if (hostapd_ctrl_iface_link_add(hapd, buf + 9,
+						reply, reply_size))
+			reply_len = -1;
+	} else if (os_strncmp(buf, "SET_ATTLM ", 10) == 0) {
+		if (hostapd_ctrl_iface_set_attlm(hapd, buf + 10, reply,
+						 reply_size))
+			reply_len = -1;
 #endif /* CONFIG_TESTING_OPTIONS */
 #endif /* CONFIG_IEEE80211BE */
+	} else if (os_strncmp(buf, "SET_EDCCA ", 10) == 0) {
+		reply_len = hostapd_ctrl_iface_set_edcca(hapd, buf+10, reply,
+							  reply_size);
+	} else if (os_strncmp(buf, "GET_EDCCA ", 10) == 0) {
+		reply_len = hostapd_ctrl_iface_get_edcca(hapd, buf+10, reply,
+							  reply_size);
+	} else if (os_strncmp(buf, "SET_MU ", 7) == 0) {
+		reply_len = hostapd_ctrl_iface_set_mu(hapd, buf + 7, reply, reply_size);
+	} else if (os_strncmp(buf, "GET_MU ", 7) == 0) {
+		reply_len = hostapd_ctrl_iface_get_mu(hapd, reply, reply_size);
+	} else if (os_strncmp(buf, "GET_IBF", 7) == 0) {
+		reply_len = hostapd_ctrl_iface_get_ibf(hapd, reply, reply_size);
+	} else if (os_strncmp(buf, "DFS_DETECT_MODE ", 16) == 0) {
+		reply_len = hostapd_ctrl_iface_set_dfs_detect_mode(hapd, buf + 16,
+								   reply, reply_size);
+	} else if (os_strncmp(buf, "SET_OFFCHAN_CTRL", 16) == 0) {
+		reply_len = hostapd_ctrl_iface_set_offchan_ctrl(hapd, buf + 16, reply, reply_size);
+	} else if (os_strncmp(buf, "GET_AMSDU", 9) == 0) {
+		reply_len = hostapd_ctrl_iface_get_amsdu(hapd, reply, reply_size);
+	} else if (os_strncmp(buf, "GET_BSS_COLOR", 13) == 0) {
+		reply_len = hostapd_ctrl_iface_get_bss_color(hapd, reply, reply_size);
+	} else if (os_strncmp(buf, "AVAL_COLOR_BMP", 14) == 0) {
+		reply_len = hostapd_ctrl_iface_get_aval_color_bmp(hapd, reply, reply_size);
+	} else if (os_strncmp(buf, "ap_wireless ", 12) == 0) {
+		reply_len = hostapd_ctrl_iface_ap_wireless(hapd, buf + 12, reply, reply_size);
+	} else if (os_strncmp(buf, "ap_rfeatures ", 13) == 0) {
+		reply_len = hostapd_ctrl_iface_ap_rfeatures(hapd, buf + 13, reply, reply_size);
+	} else if (os_strncmp(buf, "SET_AMNT", 8) == 0) {
+		reply_len = hostapd_ctrl_iface_set_amnt(hapd, buf+9,
+							reply, reply_size);
+	} else if (os_strncmp(buf, "DUMP_AMNT", 9) == 0) {
+		reply_len = hostapd_ctrl_iface_dump_amnt(hapd, buf+10,
+							reply, reply_size);
+	} else if (os_strncmp(buf, "set_pp", 6) == 0) {
+		reply_len = hostapd_ctrl_iface_set_pp(hapd, buf + 7, reply,
+						      reply_size);
+	} else if (os_strncmp(buf, "get_pp", 6) == 0) {
+		reply_len = hostapd_ctrl_iface_get_pp(hapd, buf + 7, reply,
+						      reply_size);
+	} else if (os_strncmp(buf, "set_muru_manual_config=", 23) == 0) {
+		// Replace first ':' with a single space ' '
+		char *pos = buf + 23;
+
+		pos = os_strchr(pos, ':');
+		if (pos)
+			*pos = ' ';
+		reply_len = hostapd_ctrl_iface_set_mu(hapd, buf + 23, reply, reply_size);
+	} else if (os_strncmp(buf, "SET_BACKGROUND_RADAR_MODE", 25) == 0) {
+		reply_len = hostapd_ctrl_iface_set_background_radar_mode(hapd, buf + 25,
+									 reply, reply_size);
+	} else if (os_strncmp(buf, "NO_BEACON ", 10) == 0) {
+		reply_len = hostapd_ctrl_iface_disable_beacon(hapd, buf + 10, reply,
+							      reply_size);
+	} else if (os_strncmp(buf, "SET_CSI ", 7) == 0) {
+		reply_len = hostapd_ctrl_iface_set_csi(hapd, buf + 8,
+						       reply, reply_size);
+	} else if (os_strncmp(buf, "DUMP_CSI ", 8) == 0) {
+		reply_len = hostapd_ctrl_iface_dump_csi(hapd, buf + 9,
+							reply, reply_size);
+	} else if (os_strncmp(buf, "WMM", 3) == 0) {
+		reply_len = hostapd_ctrl_iface_wmm(hapd, buf + 4,
+						   reply, reply_size);
+	} else if (os_strncmp(buf, "EML_RESP ", 9) == 0) {
+		reply_len = hostapd_ctrl_iface_set_eml_resp(hapd, buf + 9, reply, reply_size);
 	} else {
 		os_memcpy(reply, "UNKNOWN COMMAND\n", 16);
 		reply_len = 16;
@@ -5408,6 +7055,7 @@ void hostapd_ctrl_iface_deinit(struct hostapd_data *hapd)
 static int hostapd_ctrl_iface_add(struct hapd_interfaces *interfaces,
 				  char *buf)
 {
+	/* TODO: handle link add via global ADD command */
 	if (hostapd_add_iface(interfaces, buf) < 0) {
 		wpa_printf(MSG_ERROR, "Adding interface %s failed", buf);
 		return -1;
@@ -5416,6 +7064,28 @@ static int hostapd_ctrl_iface_add(struct hapd_interfaces *interfaces,
 }
 
 
+static int hostapd_ctrl_bss_remove(struct hapd_interfaces *interfaces,
+				   char *buf)
+{
+	if (hostapd_remove_bss(interfaces, buf) < 0) {
+		wpa_printf(MSG_ERROR, "Removing interface %s failed", buf);
+		return -1;
+	}
+	return 0;
+}
+
+
+static int hostapd_ctrl_mld_remove(struct hapd_interfaces *interfaces,
+				   char *buf)
+{
+	if (hostapd_remove_mld(interfaces, buf) < 0) {
+		wpa_printf(MSG_ERROR, "Removing AP MLD %s failed", buf);
+		return -1;
+	}
+	return 0;
+}
+
+
 static int hostapd_ctrl_iface_remove(struct hapd_interfaces *interfaces,
 				     char *buf)
 {
@@ -5833,6 +7503,12 @@ static void hostapd_global_ctrl_iface_receive(int sock, void *eloop_ctx,
 	} else if (os_strncmp(buf, "REMOVE ", 7) == 0) {
 		if (hostapd_ctrl_iface_remove(interfaces, buf + 7) < 0)
 			reply_len = -1;
+	} else if (os_strncmp(buf, "REMOVE_BSS ", 11) == 0) {
+		if (hostapd_ctrl_bss_remove(interfaces, buf + 11) < 0)
+			reply_len = -1;
+	} else if (os_strncmp(buf, "REMOVE_MLD ", 11) == 0) {
+		if (hostapd_ctrl_mld_remove(interfaces, buf + 11) < 0)
+			reply_len = -1;
 	} else if (os_strcmp(buf, "ATTACH") == 0) {
 		if (hostapd_global_ctrl_iface_attach(interfaces, &from,
 						     fromlen, NULL))
@@ -5996,6 +7672,7 @@ try_again:
 		return -1;
 	}
 
+	interface->ctrl_iface_recv = hostapd_ctrl_iface_receive_process;
 	wpa_msg_register_cb(hostapd_ctrl_iface_msg_cb);
 
 	return 0;
@@ -6097,6 +7774,7 @@ fail:
 	os_free(fname);
 
 	interface->global_ctrl_sock = s;
+	interface->ctrl_iface_recv = hostapd_ctrl_iface_receive_process;
 	eloop_register_read_sock(s, hostapd_global_ctrl_iface_receive,
 				 interface, NULL);
 
diff --git a/hostapd/ctrl_iface.h b/hostapd/ctrl_iface.h
index 6ce209d..06a8483 100644
--- a/hostapd/ctrl_iface.h
+++ b/hostapd/ctrl_iface.h
@@ -37,5 +37,4 @@ hostapd_global_ctrl_iface_deinit(struct hapd_interfaces *interface)
 {
 }
 #endif /* CONFIG_NO_CTRL_IFACE */
-
 #endif /* CTRL_IFACE_H */
diff --git a/hostapd/defconfig b/hostapd/defconfig
index 550db69..f716553 100644
--- a/hostapd/defconfig
+++ b/hostapd/defconfig
@@ -6,9 +6,21 @@
 # just setting VARIABLE=n is not disabling that variable.
 #
 # This file is included in Makefile, so variables like CFLAGS and LIBS can also
-# be modified from here. In most cass, these lines should use += in order not
+# be modified from here. In most cases, these lines should use += in order not
 # to override previous values of the variables.
 
+
+# Uncomment following two lines and fix the paths if you have installed TLS
+# libraries in a non-default location
+#CFLAGS += -I/usr/local/openssl/include
+#LIBS += -L/usr/local/openssl/lib
+
+# Some Red Hat versions seem to include kerberos header files from OpenSSL, but
+# the kerberos files are not in the default include path. Following line can be
+# used to fix build issues on such systems (krb5.h not found).
+#CFLAGS += -I/usr/include/kerberos
+
+
 # Driver interface for Host AP driver
 CONFIG_DRIVER_HOSTAP=y
 
@@ -281,6 +293,7 @@ CONFIG_IPV6=y
 # openssl = OpenSSL (default)
 # gnutls = GnuTLS
 # internal = Internal TLSv1 implementation (experimental)
+# mbedtls = mbed TLS
 # linux = Linux kernel AF_ALG and internal TLSv1 implementation (experimental)
 # none = Empty template
 #CONFIG_TLS=openssl
@@ -425,3 +438,6 @@ CONFIG_DPP2=y
 
 # Wi-Fi Aware unsynchronized service discovery (NAN USD)
 #CONFIG_NAN_USD=y
+
+# Enable Automated Frequency Coordination for 6GHz outdoor
+#CONFIG_AFC=y
diff --git a/hostapd/hostapd.conf b/hostapd/hostapd.conf
index 93524cf..d0830ee 100644
--- a/hostapd/hostapd.conf
+++ b/hostapd/hostapd.conf
@@ -858,6 +858,11 @@ wmm_ac_vo_acm=0
 # 1 = supported
 #he_mu_beamformer=1
 
+#he_ldpc: HE LDPC support
+# 0 = not supported
+# 1 = supported (default)
+#he_ldpc=1
+
 # he_bss_color: BSS color (1-63)
 #he_bss_color=1
 
@@ -1030,6 +1035,48 @@ wmm_ac_vo_acm=0
 # Valid range: 0..20 TUs; default is 0 (disabled)
 #unsol_bcast_probe_resp_interval=0
 
+##### Automated Frequency Coordination for 6GHz UNII-5 and UNII-7 bands #######
+
+# AFC daemon connection socket
+#afcd_sock=/var/run/afcd.sock
+
+# AFC request identification parameters
+#afc_request_version=1.1
+#afc_request_id=11235813
+#afc_serial_number=abcdefg
+#afc_cert_ids=US_47_CFR_PART_15_SUBPART_E:CID000
+#
+# AFC location type:
+# 0 = ellipse
+# 1 = linear polygon
+# 2 = radial polygon
+#afc_location_type=0
+#
+# AFC ellipse or linear polygon coordinations
+#afc_linear_polygon=-122.984157:37.425056
+#
+# AFC radial polygon coordinations
+#afc_radial_polygon=118.8:92.76,76.44:87.456,98.56:123.33
+#
+# AFC ellipse major/minor axis and orientation
+#afc_major_axis=100
+#afc_minor_axis=50
+#afc_orientation=70
+#
+# AFC device elevation parameters
+#afc_height=3.0
+#afc_height_type=AGL
+#afc_vertical_tolerance=7
+#
+# AFC minimum desired TX power (dbm)
+#afc_min_power=24
+#
+# AFC request frequency ranges
+#afc_freq_range=5925:6425,6525:6875
+#
+# AFC request operation classes
+#afc_op_class=131,132,133,134,136
+
 ##### IEEE 802.11be related configuration #####################################
 
 #ieee80211be: Whether IEEE 802.11be (EHT) is enabled
@@ -1102,6 +1149,16 @@ wmm_ac_vo_acm=0
 # will be used as the AP MLD MAC address.
 #mld_addr=02:03:04:05:06:07
 
+# EML Capabilities
+# 0 = Enable EML capabilities in Multi-Link Control subfield
+# 1 = Disable EML capabilitites in Multi-Link Control subfield
+#eml_disable=0
+
+# EML Operating Mode Notification frame
+# 0 = AP does not send EML Operating Mode Notification frame to the station
+# 1 = AP sends EML Operating Mode Notification frame to the station
+#eml_resp=1
+
 ##### IEEE 802.1X-2004 related configuration ##################################
 
 # Require IEEE 802.1X authorization
diff --git a/hostapd/hostapd_cli.c b/hostapd/hostapd_cli.c
index 57702d9..53ce14d 100644
--- a/hostapd/hostapd_cli.c
+++ b/hostapd/hostapd_cli.c
@@ -409,7 +409,6 @@ static int hostapd_cli_cmd_disassociate(struct wpa_ctrl *ctrl, int argc,
 }
 
 
-#ifdef CONFIG_TAXONOMY
 static int hostapd_cli_cmd_signature(struct wpa_ctrl *ctrl, int argc,
 				     char *argv[])
 {
@@ -422,7 +421,6 @@ static int hostapd_cli_cmd_signature(struct wpa_ctrl *ctrl, int argc,
 	os_snprintf(buf, sizeof(buf), "SIGNATURE %s", argv[0]);
 	return wpa_ctrl_command(ctrl, buf);
 }
-#endif /* CONFIG_TAXONOMY */
 
 
 static int hostapd_cli_cmd_sa_query(struct wpa_ctrl *ctrl, int argc,
@@ -439,7 +437,6 @@ static int hostapd_cli_cmd_sa_query(struct wpa_ctrl *ctrl, int argc,
 }
 
 
-#ifdef CONFIG_WPS
 static int hostapd_cli_cmd_wps_pin(struct wpa_ctrl *ctrl, int argc,
 				   char *argv[])
 {
@@ -665,8 +662,25 @@ static int hostapd_cli_cmd_wps_config(struct wpa_ctrl *ctrl, int argc,
 			 ssid_hex, argv[1]);
 	return wpa_ctrl_command(ctrl, buf);
 }
-#endif /* CONFIG_WPS */
 
+static int hostapd_cli_cmd_inband_discovery(struct wpa_ctrl *ctrl, int argc,
+					    char *argv[])
+{
+	char buf[300];
+	int res;
+
+	if (argc < 2) {
+		printf("Invalid 'inband_discovery' command - two arguments"
+		       "tx_type interval\n");
+		return -1;
+	}
+
+	res = os_snprintf(buf, sizeof(buf), "INBAND_DISCOVERY %s %s",
+			  argv[0], argv[1]);
+	if (os_snprintf_error(sizeof(buf), res))
+		return -1;
+	return wpa_ctrl_command(ctrl, buf);
+}
 
 static int hostapd_cli_cmd_disassoc_imminent(struct wpa_ctrl *ctrl, int argc,
 					     char *argv[])
@@ -765,7 +779,7 @@ static int wpa_ctrl_command_sta(struct wpa_ctrl *ctrl, const char *cmd,
 	}
 
 	buf[len] = '\0';
-	if (memcmp(buf, "FAIL", 4) == 0)
+	if (memcmp(buf, "FAIL", 4) == 0 || memcmp(buf, "UNKNOWN COMMAND", 15) == 0)
 		return -1;
 	if (print)
 		printf("%s", buf);
@@ -1238,6 +1252,13 @@ static int hostapd_cli_cmd_enable(struct wpa_ctrl *ctrl, int argc,
 }
 
 
+static int hostapd_cli_cmd_enable_bss(struct wpa_ctrl *ctrl, int argc,
+				      char *argv[])
+{
+	return wpa_ctrl_command(ctrl, "ENABLE_BSS");
+}
+
+
 static int hostapd_cli_cmd_reload(struct wpa_ctrl *ctrl, int argc,
 				  char *argv[])
 {
@@ -1266,6 +1287,13 @@ static int hostapd_cli_cmd_disable(struct wpa_ctrl *ctrl, int argc,
 }
 
 
+static int hostapd_cli_cmd_disable_bss(struct wpa_ctrl *ctrl, int argc,
+				       char *argv[])
+{
+	return wpa_ctrl_command(ctrl, "DISABLE_BSS");
+}
+
+
 static int hostapd_cli_cmd_enable_mld(struct wpa_ctrl *ctrl, int argc,
 				      char *argv[])
 {
@@ -1294,6 +1322,15 @@ static int hostapd_cli_cmd_stop_ap(struct wpa_ctrl *ctrl, int argc,
 }
 
 
+#ifdef CONFIG_TESTING_OPTIONS
+static int hostapd_cli_cmd_rekey_gtk(struct wpa_ctrl *ctrl, int argc,
+				      char *argv[])
+{
+	return wpa_ctrl_command(ctrl, "REKEY_GTK");
+}
+#endif
+
+
 static int hostapd_cli_cmd_vendor(struct wpa_ctrl *ctrl, int argc, char *argv[])
 {
 	char cmd[256];
@@ -1445,6 +1482,31 @@ static int hostapd_cli_cmd_driver_flags2(struct wpa_ctrl *ctrl, int argc,
 }
 
 
+static int hostapd_cli_cmd_set_mu(struct wpa_ctrl *ctrl, int argc,
+					   char *argv[])
+{
+	return hostapd_cli_cmd(ctrl, "SET_MU", 1, argc, argv);
+}
+
+
+static int hostapd_cli_cmd_get_mu(struct wpa_ctrl *ctrl, int argc,
+					   char *argv[])
+{
+	return hostapd_cli_cmd(ctrl, "GET_MU", 0, argc, argv);
+}
+
+static int hostapd_cli_cmd_disable_beacon(struct wpa_ctrl *ctrl, int argc,
+					   char *argv[])
+{
+	return hostapd_cli_cmd(ctrl, "NO_BEACON", 1, argc, argv);
+}
+
+static int hostapd_cli_cmd_set_eml_resp(struct wpa_ctrl *ctrl, int argc,
+					char *argv[])
+{
+	return hostapd_cli_cmd(ctrl, "EML_RESP", 1, argc, argv);
+}
+
 #ifdef CONFIG_DPP
 
 static int hostapd_cli_cmd_dpp_qr_code(struct wpa_ctrl *ctrl, int argc,
@@ -1654,6 +1716,20 @@ static int hostapd_cli_cmd_reload_rxkhs(struct wpa_ctrl *ctrl, int argc,
 #endif /* CONFIG_IEEE80211R_AP */
 
 
+static int hostapd_cli_cmd_get_bss_color(struct wpa_ctrl *ctrl, int argc,
+					  char *argv[])
+{
+	return wpa_ctrl_command(ctrl, "GET_BSS_COLOR");
+}
+
+
+static int hostapd_cli_cmd_get_aval_color_bmp(struct wpa_ctrl *ctrl, int argc,
+					  char *argv[])
+{
+	return wpa_ctrl_command(ctrl, "AVAL_COLOR_BMP");
+}
+
+
 #ifdef ANDROID
 static int hostapd_cli_cmd_driver(struct wpa_ctrl *ctrl, int argc, char *argv[])
 {
@@ -1662,6 +1738,78 @@ static int hostapd_cli_cmd_driver(struct wpa_ctrl *ctrl, int argc, char *argv[])
 #endif /* ANDROID */
 
 
+static int hostapd_cli_cmd_get_ibf(struct wpa_ctrl *ctrl, int argc,
+					   char *argv[])
+{
+	return hostapd_cli_cmd(ctrl, "GET_IBF", 0, NULL, NULL);
+}
+
+
+static int hostapd_cli_cmd_get_amsdu(struct wpa_ctrl *ctrl, int argc,
+					   char *argv[])
+{
+	return hostapd_cli_cmd(ctrl, "GET_AMSDU", 0, NULL, NULL);
+}
+
+static int hostapd_cli_cmd_set_amnt(struct wpa_ctrl *ctrl, int argc,
+					   char *argv[])
+{
+	return hostapd_cli_cmd(ctrl, "SET_AMNT", 2, argc, argv);
+}
+
+static int hostapd_cli_cmd_dump_amnt(struct wpa_ctrl *ctrl, int argc,
+					   char *argv[])
+{
+	return hostapd_cli_cmd(ctrl, "DUMP_AMNT", 1, argc, argv);
+}
+
+static int hostapd_cli_cmd_set_csi(struct wpa_ctrl *ctrl, int argc,
+					   char *argv[])
+{
+	return hostapd_cli_cmd(ctrl, "SET_CSI", 1, argc, argv);
+}
+
+static int hostapd_cli_cmd_dump_csi(struct wpa_ctrl *ctrl, int argc,
+					   char *argv[])
+{
+	return hostapd_cli_cmd(ctrl, "DUMP_CSI", 1, argc, argv);
+}
+static int hostapd_cli_cmd_set_pp(struct wpa_ctrl *ctrl, int argc,
+					   char *argv[])
+{
+	return hostapd_cli_cmd(ctrl, "set_pp", 2, argc, argv);
+}
+
+static int hostapd_cli_cmd_get_pp(struct wpa_ctrl *ctrl, int argc,
+					   char *argv[])
+{
+	return hostapd_cli_cmd(ctrl, "get_pp", 0, argc, argv);
+}
+
+static int hostapd_cli_cmd_wmm(struct wpa_ctrl *ctrl, int argc,
+			       char *argv[])
+{
+	return hostapd_cli_cmd(ctrl, "WMM", 1, argc, argv);
+}
+
+static int hostapd_cli_cmd_link_add(struct wpa_ctrl *ctrl, int argc,
+				    char *argv[])
+{
+	return hostapd_cli_cmd(ctrl, "LINK_ADD", 1, argc, argv);
+}
+
+static int hostapd_cli_cmd_link_remove(struct wpa_ctrl *ctrl, int argc,
+				       char *argv[])
+{
+	return hostapd_cli_cmd(ctrl, "LINK_REMOVE", 1, argc, argv);
+}
+
+static int hostapd_cli_cmd_set_attlm(struct wpa_ctrl *ctrl, int argc,
+				     char *argv[])
+{
+	return hostapd_cli_cmd(ctrl, "SET_ATTLM", 1, argc, argv);
+}
+
 struct hostapd_cli_cmd {
 	const char *cmd;
 	int (*handler)(struct wpa_ctrl *ctrl, int argc, char *argv[]);
@@ -1694,13 +1842,10 @@ static const struct hostapd_cli_cmd hostapd_cli_commands[] = {
 	{ "disassociate", hostapd_cli_cmd_disassociate,
 	  hostapd_complete_stations,
 	  "<addr> = disassociate a station" },
-#ifdef CONFIG_TAXONOMY
 	{ "signature", hostapd_cli_cmd_signature, hostapd_complete_stations,
 	  "<addr> = get taxonomy signature for a station" },
-#endif /* CONFIG_TAXONOMY */
 	{ "sa_query", hostapd_cli_cmd_sa_query, hostapd_complete_stations,
 	  "<addr> = send SA Query to a station" },
-#ifdef CONFIG_WPS
 	{ "wps_pin", hostapd_cli_cmd_wps_pin, NULL,
 	  "<uuid> <pin> [timeout] [addr] = add WPS Enrollee PIN" },
 	{ "wps_check_pin", hostapd_cli_cmd_wps_check_pin, NULL,
@@ -1725,7 +1870,6 @@ static const struct hostapd_cli_cmd hostapd_cli_commands[] = {
 	  "<SSID> <auth> <encr> <key> = configure AP" },
 	{ "wps_get_status", hostapd_cli_cmd_wps_get_status, NULL,
 	  "= show current WPS status" },
-#endif /* CONFIG_WPS */
 	{ "disassoc_imminent", hostapd_cli_cmd_disassoc_imminent, NULL,
 	  "= send Disassociation Imminent notification" },
 	{ "ess_disassoc", hostapd_cli_cmd_ess_disassoc, NULL,
@@ -1761,7 +1905,7 @@ static const struct hostapd_cli_cmd hostapd_cli_commands[] = {
 	  "<addr> = send QoS Map Configure frame" },
 	{ "chan_switch", hostapd_cli_cmd_chan_switch, NULL,
 	  "<cs_count> <freq> [sec_channel_offset=] [center_freq1=]\n"
-	  "  [center_freq2=] [bandwidth=] [blocktx] [ht|vht]\n"
+	  "  [center_freq2=] [bandwidth=] [blocktx] [ht|vht] [skip_cac]\n"
 	  "  = initiate channel switch announcement" },
 #ifdef CONFIG_IEEE80211AX
 	{ "color_change", hostapd_cli_cmd_color_change, NULL,
@@ -1781,6 +1925,8 @@ static const struct hostapd_cli_cmd hostapd_cli_commands[] = {
 	  "  = send vendor driver command" },
 	{ "enable", hostapd_cli_cmd_enable, NULL,
 	  "= enable hostapd on current interface" },
+	{ "enable_bss", hostapd_cli_cmd_enable_bss, NULL,
+	  "= enable hostapd on current BSS" },
 	{ "reload", hostapd_cli_cmd_reload, NULL,
 	  "= reload configuration for current interface" },
 	{ "reload_bss", hostapd_cli_cmd_reload_bss, NULL,
@@ -1789,6 +1935,8 @@ static const struct hostapd_cli_cmd hostapd_cli_commands[] = {
 	  "= reload configuration for current interface" },
 	{ "disable", hostapd_cli_cmd_disable, NULL,
 	  "= disable hostapd on current interface" },
+	{ "disable_bss", hostapd_cli_cmd_disable_bss, NULL,
+	  "= disable hostapd on current BSS" },
 	{ "enable_mld", hostapd_cli_cmd_enable_mld, NULL,
 	  "= enable AP MLD to which the interface is affiliated" },
 	{ "disable_mld", hostapd_cli_cmd_disable_mld, NULL,
@@ -1797,6 +1945,10 @@ static const struct hostapd_cli_cmd hostapd_cli_commands[] = {
 	  "= update Beacon frame contents\n"},
 	{ "stop_ap", hostapd_cli_cmd_stop_ap, NULL,
 	  "= stop AP\n"},
+#ifdef CONFIG_TESTING_OPTIONS
+	{ "rekey_gtk", hostapd_cli_cmd_rekey_gtk, NULL,
+	  "= rekey gtk\n"},
+#endif
 	{ "erp_flush", hostapd_cli_cmd_erp_flush, NULL,
 	  "= drop all ERP keys"},
 	{ "log_level", hostapd_cli_cmd_log_level, NULL,
@@ -1820,6 +1972,14 @@ static const struct hostapd_cli_cmd hostapd_cli_commands[] = {
 	  " = show supported driver flags"},
 	{ "driver_flags2", hostapd_cli_cmd_driver_flags2, NULL,
 	  " = show supported driver flags2"},
+	{ "set_mu", hostapd_cli_cmd_set_mu, NULL,
+		"<value> [0-15] bitmap- UL MU-MIMO(bit3), DL MU-MIMO(bit2), UL OFDMA(bit1), DL OFDMA(bit0)"},
+	{ "get_mu", hostapd_cli_cmd_get_mu, NULL,
+		" = show mu onoff value in 0-15 bitmap"},
+	{ "no_beacon", hostapd_cli_cmd_disable_beacon, NULL,
+		"<value> 0: Enable beacon, 1: Disable beacon"},
+	{ "eml_resp", hostapd_cli_cmd_set_eml_resp, NULL,
+		"<value> 0: AP does not send EML Operating Mode Notification frame, 1: AP sends EML OMN frame"},
 #ifdef CONFIG_DPP
 	{ "dpp_qr_code", hostapd_cli_cmd_dpp_qr_code, NULL,
 	  "report a scanned DPP URI from a QR Code" },
@@ -1886,10 +2046,40 @@ static const struct hostapd_cli_cmd hostapd_cli_commands[] = {
 	{ "get_rxkhs", hostapd_cli_cmd_get_rxkhs, NULL,
 	  "= get R0KHs and R1KHs" },
 #endif /* CONFIG_IEEE80211R_AP */
+	{ "get_bss_color", hostapd_cli_cmd_get_bss_color, NULL,
+	  "= get current BSS color" },
+	{ "get_color_bmp", hostapd_cli_cmd_get_aval_color_bmp, NULL,
+	  "= get available BSS color bitmap" },
 #ifdef ANDROID
 	{ "driver", hostapd_cli_cmd_driver, NULL,
 	  "<driver sub command> [<hex formatted data>] = send driver command data" },
 #endif /* ANDROID */
+	{ "inband_discovery", hostapd_cli_cmd_inband_discovery, NULL,
+          "<tx type(0/1/2)> <interval> = runtime set inband discovery" },
+	{ "get_ibf", hostapd_cli_cmd_get_ibf, NULL,
+	  " = show iBF state (enabled/disabled)"},
+	{ "get_amsdu", hostapd_cli_cmd_get_amsdu, NULL,
+		" = show AMSDU state"},
+	{ "set_amnt", hostapd_cli_cmd_set_amnt, NULL,
+		" = Set Station index and mac to monitor"},
+	{ "dump_amnt", hostapd_cli_cmd_dump_amnt, NULL,
+		" = Dump RSSI of monitoring Station"},
+	{ "set_csi", hostapd_cli_cmd_set_csi, NULL,
+		" = Set csi configuaration"},
+	{ "dump_csi", hostapd_cli_cmd_dump_csi, NULL,
+		" = Dump csi data to a json file"},
+	{ "set_pp", hostapd_cli_cmd_set_pp, NULL,
+		" = Set preamble puncture mode"},
+	{ "get_pp", hostapd_cli_cmd_get_pp, NULL,
+		" = Get preamble puncture status"},
+	{ "wmm", hostapd_cli_cmd_wmm, NULL,
+		" = <ac> [cwmin=] [cwmax=] [aifs=] [txop_limit=]"},
+	{ "link_add", hostapd_cli_cmd_link_add, NULL,
+		" = Add a new link to a MLD AP"},
+	{ "link_remove", hostapd_cli_cmd_link_remove, NULL,
+		" [count=<count>] = Remove affiliated link of a MLD AP"},
+	{ "set_attlm", hostapd_cli_cmd_set_attlm, NULL,
+		" = Disable the affiliated AP of a MLD AP" },
 	{ NULL, NULL, NULL, NULL }
 };
 
diff --git a/hostapd/main.c b/hostapd/main.c
index 512cd89..925fb6c 100644
--- a/hostapd/main.c
+++ b/hostapd/main.c
@@ -31,7 +31,7 @@
 #include "config_file.h"
 #include "eap_register.h"
 #include "ctrl_iface.h"
-
+#include "build_features.h"
 
 struct hapd_global {
 	void **drv_priv;
@@ -40,6 +40,7 @@ struct hapd_global {
 
 static struct hapd_global global;
 
+extern int radius_main(int argc, char **argv);
 
 #ifndef CONFIG_NO_HOSTAPD_LOGGER
 static void hostapd_logger_cb(void *ctx, const u8 *addr, unsigned int module,
@@ -327,8 +328,8 @@ setup_mld:
 			return -1;
 		}
 
-		/* Initialize the BSS parameter change to 1 */
-		hapd->eht_mld_bss_param_change = 1;
+		/* Initialize the BSS parameter change to 0 */
+		hapd->eht_mld_bss_param_change = 0;
 
 		wpa_printf(MSG_DEBUG,
 			   "MLD: Set link_id=%u, mld_addr=" MACSTR
@@ -696,6 +697,11 @@ fail:
 	return -1;
 }
 
+void hostapd_wpa_event(void *ctx, enum wpa_event_type event,
+                       union wpa_event_data *data);
+
+void hostapd_wpa_event_global(void *ctx, enum wpa_event_type event,
+ 				 union wpa_event_data *data);
 
 #ifdef CONFIG_WPS
 static int gen_uuid(const char *txt_addr)
@@ -788,6 +794,11 @@ int main(int argc, char *argv[])
 	if (os_program_init())
 		return -1;
 
+#ifdef RADIUS_SERVER
+	if (strstr(argv[0], "radius"))
+		return radius_main(argc, argv);
+#endif
+
 	os_memset(&interfaces, 0, sizeof(interfaces));
 	interfaces.reload_config = hostapd_reload_config;
 	interfaces.config_read_cb = hostapd_config_read;
@@ -817,8 +828,10 @@ int main(int argc, char *argv[])
 		return -1;
 #endif /* CONFIG_DPP */
 
+	wpa_supplicant_event = hostapd_wpa_event;
+	wpa_supplicant_event_global = hostapd_wpa_event_global;
 	for (;;) {
-		c = getopt(argc, argv, "b:Bde:f:hi:KP:sSTtu:vg:G:q");
+		c = getopt(argc, argv, "b:Bde:f:hi:KP:sSTtu:g:G:qv::");
 		if (c < 0)
 			break;
 		switch (c) {
@@ -855,6 +868,8 @@ int main(int argc, char *argv[])
 			break;
 #endif /* CONFIG_DEBUG_LINUX_TRACING */
 		case 'v':
+			if (optarg)
+				exit(!has_feature(optarg));
 			show_version();
 			exit(1);
 		case 'g':
@@ -1024,6 +1039,7 @@ int main(int argc, char *argv[])
 	}
 
 	hostapd_global_ctrl_iface_init(&interfaces);
+	hostapd_ucode_init(&interfaces);
 
 	if (hostapd_global_run(&interfaces, daemonize, pid_file)) {
 		wpa_printf(MSG_ERROR, "Failed to start eloop");
@@ -1033,6 +1049,7 @@ int main(int argc, char *argv[])
 	ret = 0;
 
  out:
+	hostapd_ucode_free();
 	hostapd_global_ctrl_iface_deinit(&interfaces);
 	/* Deinitialize all interfaces */
 	for (i = 0; i < interfaces.count; i++) {
diff --git a/hostapd/radius.c b/hostapd/radius.c
new file mode 100644
index 0000000..362a22c
--- /dev/null
+++ b/hostapd/radius.c
@@ -0,0 +1,715 @@
+#include "utils/includes.h"
+#include "utils/common.h"
+#include "utils/eloop.h"
+#include "crypto/crypto.h"
+#include "crypto/tls.h"
+
+#include "ap/ap_config.h"
+#include "eap_server/eap.h"
+#include "radius/radius.h"
+#include "radius/radius_server.h"
+#include "eap_register.h"
+
+#include <libubox/blobmsg_json.h>
+#include <libubox/blobmsg.h>
+#include <libubox/avl.h>
+#include <libubox/avl-cmp.h>
+#include <libubox/kvlist.h>
+
+#include <sys/stat.h>
+#include <fnmatch.h>
+
+#define VENDOR_ID_WISPR 14122
+#define VENDOR_ATTR_SIZE 6
+
+struct radius_parse_attr_data {
+	unsigned int vendor;
+	u8 type;
+	int size;
+	char format;
+	const char *data;
+};
+
+struct radius_parse_attr_state {
+	struct hostapd_radius_attr *prev;
+	struct hostapd_radius_attr *attr;
+	struct wpabuf *buf;
+	void *attrdata;
+};
+
+struct radius_user_state {
+	struct avl_node node;
+	struct eap_user data;
+};
+
+struct radius_user_data {
+	struct kvlist users;
+	struct avl_tree user_state;
+	struct blob_attr *wildcard;
+};
+
+struct radius_state {
+	struct radius_server_data *radius;
+	struct eap_config eap;
+
+	struct radius_user_data phase1, phase2;
+	const char *user_file;
+	time_t user_file_ts;
+
+	int n_attrs;
+	struct hostapd_radius_attr *attrs;
+};
+
+struct radius_config {
+	struct tls_connection_params tls;
+	struct radius_server_conf radius;
+};
+
+enum {
+	USER_ATTR_PASSWORD,
+	USER_ATTR_HASH,
+	USER_ATTR_SALT,
+	USER_ATTR_METHODS,
+	USER_ATTR_RADIUS,
+	USER_ATTR_VLAN,
+	USER_ATTR_MAX_RATE_UP,
+	USER_ATTR_MAX_RATE_DOWN,
+	__USER_ATTR_MAX
+};
+
+static void radius_tls_event(void *ctx, enum tls_event ev,
+			      union tls_event_data *data)
+{
+	switch (ev) {
+	case TLS_CERT_CHAIN_SUCCESS:
+		wpa_printf(MSG_DEBUG, "radius: remote certificate verification success");
+		break;
+	case TLS_CERT_CHAIN_FAILURE:
+		wpa_printf(MSG_INFO, "radius: certificate chain failure: reason=%d depth=%d subject='%s' err='%s'",
+			   data->cert_fail.reason,
+			   data->cert_fail.depth,
+			   data->cert_fail.subject,
+			   data->cert_fail.reason_txt);
+		break;
+	case TLS_PEER_CERTIFICATE:
+		wpa_printf(MSG_DEBUG, "radius: peer certificate: depth=%d serial_num=%s subject=%s",
+			   data->peer_cert.depth,
+			   data->peer_cert.serial_num ? data->peer_cert.serial_num : "N/A",
+			   data->peer_cert.subject);
+		break;
+	case TLS_ALERT:
+		if (data->alert.is_local)
+			wpa_printf(MSG_DEBUG, "radius: local TLS alert: %s",
+				   data->alert.description);
+		else
+			wpa_printf(MSG_DEBUG, "radius: remote TLS alert: %s",
+				   data->alert.description);
+		break;
+	case TLS_UNSAFE_RENEGOTIATION_DISABLED:
+		/* Not applicable to TLS server */
+		break;
+	}
+}
+
+static void radius_userdata_init(struct radius_user_data *u)
+{
+	kvlist_init(&u->users, kvlist_blob_len);
+	avl_init(&u->user_state, avl_strcmp, false, NULL);
+}
+
+static void radius_userdata_free(struct radius_user_data *u)
+{
+	struct radius_user_state *s, *tmp;
+
+	kvlist_free(&u->users);
+	free(u->wildcard);
+	u->wildcard = NULL;
+	avl_remove_all_elements(&u->user_state, s, node, tmp)
+		free(s);
+}
+
+static void
+radius_userdata_load(struct radius_user_data *u, struct blob_attr *data)
+{
+	enum {
+		USERSTATE_USERS,
+		USERSTATE_WILDCARD,
+		__USERSTATE_MAX,
+	};
+	static const struct blobmsg_policy policy[__USERSTATE_MAX] = {
+		[USERSTATE_USERS] = { "users", BLOBMSG_TYPE_TABLE },
+		[USERSTATE_WILDCARD] = { "wildcard", BLOBMSG_TYPE_ARRAY },
+	};
+	struct blob_attr *tb[__USERSTATE_MAX], *cur;
+	int rem;
+
+	if (!data)
+		return;
+
+	blobmsg_parse(policy, __USERSTATE_MAX, tb, blobmsg_data(data), blobmsg_len(data));
+
+	blobmsg_for_each_attr(cur, tb[USERSTATE_USERS], rem)
+		kvlist_set(&u->users, blobmsg_name(cur), cur);
+
+	if (tb[USERSTATE_WILDCARD])
+		u->wildcard = blob_memdup(tb[USERSTATE_WILDCARD]);
+}
+
+static void
+load_userfile(struct radius_state *s)
+{
+	enum {
+		USERDATA_PHASE1,
+		USERDATA_PHASE2,
+		__USERDATA_MAX
+	};
+	static const struct blobmsg_policy policy[__USERDATA_MAX] = {
+		[USERDATA_PHASE1] = { "phase1", BLOBMSG_TYPE_TABLE },
+		[USERDATA_PHASE2] = { "phase2", BLOBMSG_TYPE_TABLE },
+	};
+	struct blob_attr *tb[__USERDATA_MAX], *cur;
+	static struct blob_buf b;
+	struct stat st;
+	int rem;
+
+	if (stat(s->user_file, &st))
+		return;
+
+	if (s->user_file_ts == st.st_mtime)
+		return;
+
+	s->user_file_ts = st.st_mtime;
+	radius_userdata_free(&s->phase1);
+	radius_userdata_free(&s->phase2);
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_json_from_file(&b, s->user_file);
+	blobmsg_parse(policy, __USERDATA_MAX, tb, blob_data(b.head), blob_len(b.head));
+	radius_userdata_load(&s->phase1, tb[USERDATA_PHASE1]);
+	radius_userdata_load(&s->phase2, tb[USERDATA_PHASE2]);
+
+	blob_buf_free(&b);
+}
+
+static struct blob_attr *
+radius_user_get(struct radius_user_data *s, const char *name)
+{
+	struct blob_attr *cur;
+	int rem;
+
+	cur = kvlist_get(&s->users, name);
+	if (cur)
+		return cur;
+
+	blobmsg_for_each_attr(cur, s->wildcard, rem) {
+		static const struct blobmsg_policy policy = {
+			"name", BLOBMSG_TYPE_STRING
+		};
+		struct blob_attr *pattern;
+
+		if (blobmsg_type(cur) != BLOBMSG_TYPE_TABLE)
+			continue;
+
+		blobmsg_parse(&policy, 1, &pattern, blobmsg_data(cur), blobmsg_len(cur));
+		if (!name)
+			continue;
+
+		if (!fnmatch(blobmsg_get_string(pattern), name, 0))
+			return cur;
+	}
+
+	return NULL;
+}
+
+static struct radius_parse_attr_data *
+radius_parse_attr(struct blob_attr *attr)
+{
+	static const struct blobmsg_policy policy[4] = {
+		{ .type = BLOBMSG_TYPE_INT32 },
+		{ .type = BLOBMSG_TYPE_INT32 },
+		{ .type = BLOBMSG_TYPE_STRING },
+		{ .type = BLOBMSG_TYPE_STRING },
+	};
+	static struct radius_parse_attr_data data;
+	struct blob_attr *tb[4];
+	const char *format;
+
+	blobmsg_parse_array(policy, ARRAY_SIZE(policy), tb, blobmsg_data(attr), blobmsg_len(attr));
+
+	if (!tb[0] || !tb[1] || !tb[2] || !tb[3])
+		return NULL;
+
+	format = blobmsg_get_string(tb[2]);
+	if (strlen(format) != 1)
+		return NULL;
+
+	data.vendor = blobmsg_get_u32(tb[0]);
+	data.type = blobmsg_get_u32(tb[1]);
+	data.format = format[0];
+	data.data = blobmsg_get_string(tb[3]);
+	data.size = strlen(data.data);
+
+	switch (data.format) {
+	case 's':
+		break;
+	case 'x':
+		if (data.size & 1)
+			return NULL;
+		data.size /= 2;
+		break;
+	case 'd':
+		data.size = 4;
+		break;
+	default:
+		return NULL;
+	}
+
+	return &data;
+}
+
+static void
+radius_count_attrs(struct blob_attr **tb, int *n_attr, size_t *attr_size)
+{
+	struct blob_attr *data = tb[USER_ATTR_RADIUS];
+	struct blob_attr *cur;
+	int rem;
+
+	blobmsg_for_each_attr(cur, data, rem) {
+		struct radius_parse_attr_data *data;
+		size_t prev = *attr_size;
+
+		data = radius_parse_attr(cur);
+		if (!data)
+			continue;
+
+		*attr_size += data->size;
+		if (data->vendor)
+			*attr_size += VENDOR_ATTR_SIZE;
+
+		(*n_attr)++;
+	}
+
+	*n_attr += !!tb[USER_ATTR_VLAN] * 3 +
+		   !!tb[USER_ATTR_MAX_RATE_UP] +
+		   !!tb[USER_ATTR_MAX_RATE_DOWN];
+	*attr_size += !!tb[USER_ATTR_VLAN] * (4 + 4 + 5) +
+		      !!tb[USER_ATTR_MAX_RATE_UP] * (4 + VENDOR_ATTR_SIZE) +
+		      !!tb[USER_ATTR_MAX_RATE_DOWN] * (4 + VENDOR_ATTR_SIZE);
+}
+
+static void *
+radius_add_attr(struct radius_parse_attr_state *state,
+		u32 vendor, u8 type, u8 len)
+{
+	struct hostapd_radius_attr *attr;
+	struct wpabuf *buf;
+	void *val;
+
+	val = state->attrdata;
+
+	buf = state->buf++;
+	buf->buf = val;
+
+	attr = state->attr++;
+	attr->val = buf;
+	attr->type = type;
+
+	if (state->prev)
+		state->prev->next = attr;
+	state->prev = attr;
+
+	if (vendor) {
+		u8 *vendor_hdr = val + 4;
+
+		WPA_PUT_BE32(val, vendor);
+		vendor_hdr[0] = type;
+		vendor_hdr[1] = len + 2;
+
+		len += VENDOR_ATTR_SIZE;
+		val += VENDOR_ATTR_SIZE;
+		attr->type = RADIUS_ATTR_VENDOR_SPECIFIC;
+	}
+
+	buf->size = buf->used = len;
+	state->attrdata += len;
+
+	return val;
+}
+
+static void
+radius_parse_attrs(struct blob_attr **tb, struct radius_parse_attr_state *state)
+{
+	struct blob_attr *data = tb[USER_ATTR_RADIUS];
+	struct hostapd_radius_attr *prev = NULL;
+	struct blob_attr *cur;
+	int len, rem;
+	void *val;
+
+	if ((cur = tb[USER_ATTR_VLAN]) != NULL && blobmsg_get_u32(cur) < 4096) {
+		char buf[5];
+
+		val = radius_add_attr(state, 0, RADIUS_ATTR_TUNNEL_TYPE, 4);
+		WPA_PUT_BE32(val, RADIUS_TUNNEL_TYPE_VLAN);
+
+		val = radius_add_attr(state, 0, RADIUS_ATTR_TUNNEL_MEDIUM_TYPE, 4);
+		WPA_PUT_BE32(val, RADIUS_TUNNEL_MEDIUM_TYPE_802);
+
+		len = snprintf(buf, sizeof(buf), "%d", blobmsg_get_u32(cur));
+		val = radius_add_attr(state, 0, RADIUS_ATTR_TUNNEL_PRIVATE_GROUP_ID, len);
+		memcpy(val, buf, len);
+	}
+
+	if ((cur = tb[USER_ATTR_MAX_RATE_UP]) != NULL) {
+		val = radius_add_attr(state, VENDOR_ID_WISPR, 7, 4);
+		WPA_PUT_BE32(val, blobmsg_get_u32(cur));
+	}
+
+	if ((cur = tb[USER_ATTR_MAX_RATE_DOWN]) != NULL) {
+		val = radius_add_attr(state, VENDOR_ID_WISPR, 8, 4);
+		WPA_PUT_BE32(val, blobmsg_get_u32(cur));
+	}
+
+	blobmsg_for_each_attr(cur, data, rem) {
+		struct radius_parse_attr_data *data;
+		void *val;
+		int size;
+
+		data = radius_parse_attr(cur);
+		if (!data)
+			continue;
+
+		val = radius_add_attr(state, data->vendor, data->type, data->size);
+		switch (data->format) {
+		case 's':
+			memcpy(val, data->data, data->size);
+			break;
+		case 'x':
+			hexstr2bin(data->data, val, data->size);
+			break;
+		case 'd':
+			WPA_PUT_BE32(val, atoi(data->data));
+			break;
+		}
+	}
+}
+
+static void
+radius_user_parse_methods(struct eap_user *eap, struct blob_attr *data)
+{
+	struct blob_attr *cur;
+	int rem, n = 0;
+
+	if (!data)
+		return;
+
+	blobmsg_for_each_attr(cur, data, rem) {
+		const char *method;
+
+		if (blobmsg_type(cur) != BLOBMSG_TYPE_STRING)
+			continue;
+
+		if (n == EAP_MAX_METHODS)
+			break;
+
+		method = blobmsg_get_string(cur);
+		eap->methods[n].method = eap_server_get_type(method, &eap->methods[n].vendor);
+		if (eap->methods[n].vendor == EAP_VENDOR_IETF &&
+		    eap->methods[n].method == EAP_TYPE_NONE) {
+			if (!strcmp(method, "TTLS-PAP")) {
+				eap->ttls_auth |= EAP_TTLS_AUTH_PAP;
+				continue;
+			}
+			if (!strcmp(method, "TTLS-CHAP")) {
+				eap->ttls_auth |= EAP_TTLS_AUTH_CHAP;
+				continue;
+			}
+			if (!strcmp(method, "TTLS-MSCHAP")) {
+				eap->ttls_auth |= EAP_TTLS_AUTH_MSCHAP;
+				continue;
+			}
+			if (!strcmp(method, "TTLS-MSCHAPV2")) {
+				eap->ttls_auth |= EAP_TTLS_AUTH_MSCHAPV2;
+				continue;
+			}
+		}
+		n++;
+	}
+}
+
+static struct eap_user *
+radius_user_get_state(struct radius_user_data *u, struct blob_attr *data,
+		      const char *id)
+{
+	static const struct blobmsg_policy policy[__USER_ATTR_MAX] = {
+		[USER_ATTR_PASSWORD] = { "password", BLOBMSG_TYPE_STRING },
+		[USER_ATTR_HASH] = { "hash", BLOBMSG_TYPE_STRING },
+		[USER_ATTR_SALT] = { "salt", BLOBMSG_TYPE_STRING },
+		[USER_ATTR_METHODS] = { "methods", BLOBMSG_TYPE_ARRAY },
+		[USER_ATTR_RADIUS] = { "radius", BLOBMSG_TYPE_ARRAY },
+		[USER_ATTR_VLAN] = { "vlan-id", BLOBMSG_TYPE_INT32 },
+		[USER_ATTR_MAX_RATE_UP] = { "max-rate-up", BLOBMSG_TYPE_INT32 },
+		[USER_ATTR_MAX_RATE_DOWN] = { "max-rate-down", BLOBMSG_TYPE_INT32 },
+	};
+	struct blob_attr *tb[__USER_ATTR_MAX], *cur;
+	char *password_buf, *salt_buf, *name_buf;
+	struct radius_parse_attr_state astate = {};
+	struct hostapd_radius_attr *attr;
+	struct radius_user_state *state;
+	int pw_len = 0, salt_len = 0;
+	struct eap_user *eap;
+	struct wpabuf *val;
+	size_t attrsize = 0;
+	void *attrdata;
+	int n_attr = 0;
+
+	state = avl_find_element(&u->user_state, id, state, node);
+	if (state)
+		return &state->data;
+
+	blobmsg_parse(policy, __USER_ATTR_MAX, tb, blobmsg_data(data), blobmsg_len(data));
+
+	if ((cur = tb[USER_ATTR_SALT]) != NULL)
+		salt_len = strlen(blobmsg_get_string(cur)) / 2;
+	if ((cur = tb[USER_ATTR_HASH]) != NULL)
+		pw_len = strlen(blobmsg_get_string(cur)) / 2;
+	else if ((cur = tb[USER_ATTR_PASSWORD]) != NULL)
+		pw_len = blobmsg_len(cur) - 1;
+	radius_count_attrs(tb, &n_attr, &attrsize);
+
+	state = calloc_a(sizeof(*state), &name_buf, strlen(id) + 1,
+			 &password_buf, pw_len,
+			 &salt_buf, salt_len,
+			 &astate.attr, n_attr * sizeof(*astate.attr),
+			 &astate.buf, n_attr * sizeof(*astate.buf),
+			 &astate.attrdata, attrsize);
+	eap = &state->data;
+	eap->salt = salt_len ? salt_buf : NULL;
+	eap->salt_len = salt_len;
+	eap->password = pw_len ? password_buf : NULL;
+	eap->password_len = pw_len;
+	eap->force_version = -1;
+
+	if ((cur = tb[USER_ATTR_SALT]) != NULL)
+		hexstr2bin(blobmsg_get_string(cur), salt_buf, salt_len);
+	if ((cur = tb[USER_ATTR_PASSWORD]) != NULL)
+		memcpy(password_buf, blobmsg_get_string(cur), pw_len);
+	else if ((cur = tb[USER_ATTR_HASH]) != NULL) {
+		hexstr2bin(blobmsg_get_string(cur), password_buf, pw_len);
+		eap->password_hash = 1;
+	}
+	radius_user_parse_methods(eap, tb[USER_ATTR_METHODS]);
+
+	if (n_attr > 0) {
+		cur = tb[USER_ATTR_RADIUS];
+		eap->accept_attr = astate.attr;
+		radius_parse_attrs(tb, &astate);
+	}
+
+	state->node.key = strcpy(name_buf, id);
+	avl_insert(&u->user_state, &state->node);
+
+	return &state->data;
+
+free:
+	free(state);
+	return NULL;
+}
+
+static int radius_get_eap_user(void *ctx, const u8 *identity,
+			       size_t identity_len, int phase2,
+			       struct eap_user *user)
+{
+	struct radius_state *s = ctx;
+	struct radius_user_data *u = phase2 ? &s->phase2 : &s->phase1;
+	struct blob_attr *entry;
+	struct eap_user *data;
+	char *id;
+
+	if (identity_len > 512)
+		return -1;
+
+	load_userfile(s);
+
+	id = alloca(identity_len + 1);
+	memcpy(id, identity, identity_len);
+	id[identity_len] = 0;
+
+	entry = radius_user_get(u, id);
+	if (!entry)
+		return -1;
+
+	if (!user)
+		return 0;
+
+	data = radius_user_get_state(u, entry, id);
+	if (!data)
+		return -1;
+
+	*user = *data;
+	if (user->password_len > 0)
+		user->password = os_memdup(user->password, user->password_len);
+	if (user->salt_len > 0)
+		user->salt = os_memdup(user->salt, user->salt_len);
+	user->phase2 = phase2;
+
+	return 0;
+}
+
+static int radius_setup(struct radius_state *s, struct radius_config *c)
+{
+	struct eap_config *eap = &s->eap;
+	struct tls_config conf = {
+		.event_cb = radius_tls_event,
+		.tls_flags = TLS_CONN_DISABLE_TLSv1_3,
+		.cb_ctx = s,
+	};
+
+	eap->eap_server = 1;
+	eap->max_auth_rounds = 100;
+	eap->max_auth_rounds_short = 50;
+	eap->ssl_ctx = tls_init(&conf);
+	if (!eap->ssl_ctx) {
+		wpa_printf(MSG_INFO, "TLS init failed\n");
+		return 1;
+	}
+
+	if (tls_global_set_params(eap->ssl_ctx, &c->tls)) {
+		wpa_printf(MSG_INFO, "failed to set TLS parameters\n");
+		return 1;
+	}
+
+	c->radius.eap_cfg = eap;
+	c->radius.conf_ctx = s;
+	c->radius.get_eap_user = radius_get_eap_user;
+	s->radius = radius_server_init(&c->radius);
+	if (!s->radius) {
+		wpa_printf(MSG_INFO, "failed to initialize radius server\n");
+		return 1;
+	}
+
+	return 0;
+}
+
+static int radius_init(struct radius_state *s)
+{
+	memset(s, 0, sizeof(*s));
+	radius_userdata_init(&s->phase1);
+	radius_userdata_init(&s->phase2);
+}
+
+static void radius_deinit(struct radius_state *s)
+{
+	if (s->radius)
+		radius_server_deinit(s->radius);
+
+	if (s->eap.ssl_ctx)
+		tls_deinit(s->eap.ssl_ctx);
+
+	radius_userdata_free(&s->phase1);
+	radius_userdata_free(&s->phase2);
+}
+
+static int usage(const char *progname)
+{
+	fprintf(stderr, "Usage: %s <options>\n",
+		progname);
+}
+
+int radius_main(int argc, char **argv)
+{
+	static struct radius_state state = {};
+	static struct radius_config config = {};
+	const char *progname = argv[0];
+	int ret = 0;
+	int ch;
+
+	wpa_debug_setup_stdout();
+	wpa_debug_level = 0;
+
+	if (eloop_init()) {
+		wpa_printf(MSG_ERROR, "Failed to initialize event loop");
+		return 1;
+	}
+
+	eap_server_register_methods();
+	radius_init(&state);
+
+	while ((ch = getopt(argc, argv, "6C:c:d:i:k:K:p:P:s:u:")) != -1) {
+		switch (ch) {
+		case '6':
+			config.radius.ipv6 = 1;
+			break;
+		case 'C':
+			config.tls.ca_cert = optarg;
+			break;
+		case 'c':
+			if (config.tls.client_cert2)
+				return usage(progname);
+
+			if (config.tls.client_cert)
+				config.tls.client_cert2 = optarg;
+			else
+				config.tls.client_cert = optarg;
+			break;
+		case 'd':
+			config.tls.dh_file = optarg;
+			break;
+		case 'i':
+			state.eap.server_id = optarg;
+			state.eap.server_id_len = strlen(optarg);
+			break;
+		case 'k':
+			if (config.tls.private_key2)
+				return usage(progname);
+
+			if (config.tls.private_key)
+				config.tls.private_key2 = optarg;
+			else
+				config.tls.private_key = optarg;
+			break;
+		case 'K':
+			if (config.tls.private_key_passwd2)
+				return usage(progname);
+
+			if (config.tls.private_key_passwd)
+				config.tls.private_key_passwd2 = optarg;
+			else
+				config.tls.private_key_passwd = optarg;
+			break;
+		case 'p':
+			config.radius.auth_port = atoi(optarg);
+			break;
+		case 'P':
+			config.radius.acct_port = atoi(optarg);
+			break;
+		case 's':
+			config.radius.client_file = optarg;
+			break;
+		case 'u':
+			state.user_file = optarg;
+			break;
+		default:
+			return usage(progname);
+		}
+	}
+
+	if (!config.tls.client_cert || !config.tls.private_key ||
+	    !config.radius.client_file || !state.eap.server_id ||
+	    !state.user_file) {
+		wpa_printf(MSG_INFO, "missing options\n");
+		goto out;
+	}
+
+	ret = radius_setup(&state, &config);
+	if (ret)
+		goto out;
+
+	load_userfile(&state);
+	eloop_run();
+
+out:
+	radius_deinit(&state);
+	os_program_deinit();
+
+	return ret;
+}
diff --git a/src/ap/Makefile b/src/ap/Makefile
index a1e9b7c..49c6d4a 100644
--- a/src/ap/Makefile
+++ b/src/ap/Makefile
@@ -55,6 +55,7 @@ LIB_OBJS= \
 	wpa_auth_glue.o \
 	wpa_auth_ie.o \
 	wps_hostapd.o \
-	x_snoop.o
+	x_snoop.o \
+	scs.o
 
 include ../lib.rules
diff --git a/src/ap/acs.c b/src/ap/acs.c
index f5b36d3..f7e7f15 100644
--- a/src/ap/acs.c
+++ b/src/ap/acs.c
@@ -471,17 +471,17 @@ static int acs_get_bw_center_chan(int freq, enum bw_type bw)
 static int acs_survey_is_sufficient(struct freq_survey *survey)
 {
 	if (!(survey->filled & SURVEY_HAS_NF)) {
+		survey->nf = -95;
 		wpa_printf(MSG_INFO,
 			   "ACS: Survey for freq %d is missing noise floor",
 			   survey->freq);
-		return 0;
 	}
 
 	if (!(survey->filled & SURVEY_HAS_CHAN_TIME)) {
+		survey->channel_time = 0;
 		wpa_printf(MSG_INFO,
 			   "ACS: Survey for freq %d is missing channel time",
 			   survey->freq);
-		return 0;
 	}
 
 	if (!(survey->filled & SURVEY_HAS_CHAN_TIME_BUSY) &&
@@ -489,7 +489,6 @@ static int acs_survey_is_sufficient(struct freq_survey *survey)
 		wpa_printf(MSG_INFO,
 			   "ACS: Survey for freq %d is missing RX and busy time (at least one is required)",
 			   survey->freq);
-		return 0;
 	}
 
 	return 1;
@@ -600,12 +599,6 @@ static void acs_survey_mode_interference_factor(
 		    iface->conf->acs_exclude_dfs)
 			continue;
 
-		if (!is_in_chanlist(iface, chan))
-			continue;
-
-		if (!is_in_freqlist(iface, chan))
-			continue;
-
 		if (chan->max_tx_power < iface->conf->min_tx_power)
 			continue;
 
@@ -1371,12 +1364,6 @@ static int * acs_request_scan_add_freqs(struct hostapd_iface *iface,
 		     iface->conf->acs_exclude_dfs))
 			continue;
 
-		if (!is_in_chanlist(iface, chan))
-			continue;
-
-		if (!is_in_freqlist(iface, chan))
-			continue;
-
 		if (chan->max_tx_power < iface->conf->min_tx_power)
 			continue;
 
diff --git a/src/ap/afc.c b/src/ap/afc.c
new file mode 100644
index 0000000..c3a5d63
--- /dev/null
+++ b/src/ap/afc.c
@@ -0,0 +1,1465 @@
+/*
+ * Automated Frequency Coordination
+ * Copyright (c) 2024, Lorenzo Bianconi <lorenzo@kernel.org>
+ *
+ * This software may be distributed under the terms of the BSD license.
+ * See README for more details.
+ */
+
+#include <json-c/json.h>
+#include <sys/un.h>
+#include <time.h>
+
+#include "utils/includes.h"
+#include "utils/common.h"
+#include "utils/eloop.h"
+#include "common/hw_features_common.h"
+#include "hostapd.h"
+#include "acs.h"
+#include "hw_features.h"
+#include "ap_drv_ops.h"
+
+#define HOSTAPD_AFC_RETRY_TIMEOUT	180
+#define HOSTAPD_AFC_TIMEOUT		86400 /* 24h */
+#define HOSTAPD_AFC_BUFSIZE		8192
+
+static void hostapd_afc_timeout_handler(void *eloop_ctx, void *timeout_ctx);
+
+
+static struct json_object *
+hostapd_afc_build_location_request(struct hostapd_iface *iface)
+{
+	struct json_object *location_obj, *center_obj, *ellipse_obj;
+	struct json_object *elevation_obj, *str_obj;
+	struct hostapd_config *iconf = iface->conf;
+	bool is_ap_indoor = he_reg_is_indoor(iconf->he_6ghz_reg_pwr_type);
+
+	location_obj = json_object_new_object();
+	if (!location_obj)
+		return NULL;
+
+	if (iconf->afc.location.type != LINEAR_POLYGON) {
+		struct afc_linear_polygon *lp =
+			&iconf->afc.location.linear_polygon_data[0];
+
+		if (!lp)
+			goto error;
+
+		ellipse_obj = json_object_new_object();
+		if (!ellipse_obj)
+			goto error;
+
+		center_obj = json_object_new_object();
+		if (!center_obj)
+			goto error;
+
+		json_object_object_add(ellipse_obj, "center", center_obj);
+
+		str_obj = json_object_new_double(lp->longitude);
+		if (!str_obj)
+			goto error;
+
+		json_object_object_add(center_obj, "longitude", str_obj);
+		str_obj = json_object_new_double(lp->latitude);
+		if (!str_obj)
+			goto error;
+
+		json_object_object_add(center_obj, "latitude", str_obj);
+	}
+
+	switch (iconf->afc.location.type) {
+	case LINEAR_POLYGON: {
+		struct json_object *outer_boundary_obj;
+		int i;
+
+		outer_boundary_obj = json_object_new_object();
+		if (!outer_boundary_obj)
+			goto error;
+
+		json_object_object_add(location_obj, "linearPolygon",
+				       outer_boundary_obj);
+		ellipse_obj = json_object_new_array();
+		if (!ellipse_obj)
+			goto error;
+
+		json_object_object_add(outer_boundary_obj, "outerBoundary",
+				       ellipse_obj);
+		for (i = 0;
+		     i < iconf->afc.location.n_linear_polygon_data; i++) {
+			struct afc_linear_polygon *lp =
+				&iconf->afc.location.linear_polygon_data[i];
+
+			center_obj = json_object_new_object();
+			if (!center_obj)
+				goto error;
+
+			json_object_array_add(ellipse_obj, center_obj);
+			str_obj = json_object_new_double(lp->longitude);
+			if (!str_obj)
+				goto error;
+
+			json_object_object_add(center_obj, "longitude",
+					       str_obj);
+			str_obj = json_object_new_double(lp->latitude);
+			if (!str_obj)
+				goto error;
+
+			json_object_object_add(center_obj, "latitude",
+					       str_obj);
+		}
+		break;
+	}
+	case RADIAL_POLYGON: {
+		struct json_object *outer_boundary_obj;
+		int i;
+
+		json_object_object_add(location_obj, "radialPolygon",
+				       ellipse_obj);
+
+		outer_boundary_obj = json_object_new_array();
+		if (!outer_boundary_obj)
+			goto error;
+
+		json_object_object_add(ellipse_obj, "outerBoundary",
+				       outer_boundary_obj);
+		for (i = 0;
+		     i < iconf->afc.location.n_radial_polygon_data; i++) {
+			struct afc_radial_polygon *rp =
+				&iconf->afc.location.radial_polygon_data[i];
+			struct json_object *angle_obj;
+
+			angle_obj = json_object_new_object();
+			if (!angle_obj)
+				goto error;
+
+			json_object_array_add(outer_boundary_obj, angle_obj);
+
+			str_obj = json_object_new_double(rp->angle);
+			if (!str_obj)
+				goto error;
+
+			json_object_object_add(angle_obj, "angle", str_obj);
+			str_obj = json_object_new_double(rp->length);
+			if (!str_obj)
+				goto error;
+
+			json_object_object_add(angle_obj, "length", str_obj);
+		}
+		break;
+	}
+	case ELLIPSE:
+	default:
+		json_object_object_add(location_obj, "ellipse", ellipse_obj);
+
+		str_obj = json_object_new_int(iconf->afc.location.major_axis);
+		if (!str_obj)
+			goto error;
+
+		json_object_object_add(ellipse_obj, "majorAxis", str_obj);
+		str_obj = json_object_new_int(iconf->afc.location.minor_axis);
+		if (!str_obj)
+			goto error;
+
+		json_object_object_add(ellipse_obj, "minorAxis", str_obj);
+		str_obj = json_object_new_int(iconf->afc.location.orientation);
+		if (!str_obj)
+			goto error;
+
+		json_object_object_add(ellipse_obj, "orientation", str_obj);
+		break;
+	}
+
+	elevation_obj = json_object_new_object();
+	if (!elevation_obj)
+		goto error;
+
+	json_object_object_add(location_obj, "elevation",
+			       elevation_obj);
+	str_obj = json_object_new_double(iconf->afc.location.height);
+	if (!str_obj)
+		goto error;
+
+	json_object_object_add(elevation_obj, "height", str_obj);
+	if (iconf->afc.location.height_type) {
+		str_obj = json_object_new_string(iconf->afc.location.height_type);
+		if (!str_obj)
+			goto error;
+
+		json_object_object_add(elevation_obj, "heightType", str_obj);
+	}
+
+	str_obj = json_object_new_int(iconf->afc.location.vertical_tolerance);
+	if (!str_obj)
+		goto error;
+
+	json_object_object_add(elevation_obj, "verticalUncertainty",
+			       str_obj);
+	str_obj = json_object_new_int(is_ap_indoor);
+	if (!str_obj)
+		goto error;
+
+	json_object_object_add(location_obj, "indoorDeployment", str_obj);
+
+	return location_obj;
+
+error:
+	json_object_put(location_obj);
+	return NULL;
+}
+
+
+static struct json_object * hostapd_afc_get_opclass_chan_list(u8 op_class)
+{
+	struct json_object *chan_list_obj, *str_obj;
+	const struct oper_class_map *oper_class;
+	int chan_offset, chan;
+
+	oper_class = get_oper_class(NULL, op_class);
+	if (!oper_class)
+		return NULL;
+
+	chan_list_obj = json_object_new_array();
+	if (!chan_list_obj)
+		return NULL;
+
+	switch (op_class) {
+	case 132: /*  40MHz */
+		chan_offset = 2;
+		break;
+	case 133: /*  80MHz */
+		chan_offset = 6;
+		break;
+	case 134: /* 160MHz */
+		chan_offset = 14;
+		break;
+	case 137: /* 320MHz */
+		chan_offset = 30;
+		break;
+	default:
+		chan_offset = 0;
+		break;
+	}
+
+	for (chan = oper_class->min_chan; chan <= oper_class->max_chan;
+	     chan += oper_class->inc) {
+		if (chan + chan_offset > oper_class->max_chan)
+			break;
+		str_obj = json_object_new_int(chan + chan_offset);
+		if (!str_obj) {
+			json_object_put(chan_list_obj);
+			return NULL;
+		}
+
+		json_object_array_add(chan_list_obj, str_obj);
+		if (op_class == 137) { /* 320MHz */
+			int c = chan + chan_offset + oper_class->inc / 2;
+
+			if (c > oper_class->max_chan)
+				break;
+
+			str_obj = json_object_new_int(c);
+			if (!str_obj) {
+				json_object_put(chan_list_obj);
+				return NULL;
+			}
+
+			json_object_array_add(chan_list_obj, str_obj);
+		}
+	}
+
+	return chan_list_obj;
+}
+
+
+static struct json_object *
+hostapd_afc_build_req_chan_list(struct hostapd_iface *iface)
+{
+	struct json_object *op_class_list_obj, *str_obj;
+	struct hostapd_config *iconf = iface->conf;
+	int i;
+
+	op_class_list_obj = json_object_new_array();
+	if (!op_class_list_obj)
+		return NULL;
+
+	for (i = 0; i < iconf->afc.n_op_class; i++) {
+		struct json_object *op_class_obj, *chan_list_obj;
+		u8 op_class = iconf->afc.op_class[i];
+
+		if (!is_6ghz_op_class(op_class))
+			continue;
+
+		op_class_obj = json_object_new_object();
+		if (!op_class_obj)
+			goto error;
+
+		json_object_array_add(op_class_list_obj, op_class_obj);
+		str_obj = json_object_new_int(op_class);
+		if (!str_obj)
+			goto error;
+
+		json_object_object_add(op_class_obj, "globalOperatingClass",
+				       str_obj);
+
+		chan_list_obj = hostapd_afc_get_opclass_chan_list(op_class);
+		if (!chan_list_obj)
+			goto error;
+
+		json_object_object_add(op_class_obj, "channelCfi",
+				       chan_list_obj);
+	}
+
+	return op_class_list_obj;
+
+error:
+	json_object_put(op_class_list_obj);
+	return NULL;
+}
+
+
+static struct json_object *
+hostapd_afc_build_request(struct hostapd_iface *iface)
+{
+	struct json_object *l1_obj, *l2_obj, *la1_obj, *la2_obj;
+	struct json_object *s2_obj, *str_obj, *location_obj;
+	struct hostapd_config *iconf = iface->conf;
+	struct json_object *op_class_list_obj;
+	int i;
+
+	l1_obj = json_object_new_object();
+	if (!l1_obj)
+		return NULL;
+
+	if (iconf->afc.request.version) {
+		str_obj = json_object_new_string(iconf->afc.request.version);
+		if (!str_obj)
+			goto error;
+
+		json_object_object_add(l1_obj, "version", str_obj);
+	}
+
+	la1_obj = json_object_new_array();
+	if (!la1_obj)
+		goto error;
+
+	json_object_object_add(l1_obj, "availableSpectrumInquiryRequests",
+			       la1_obj);
+	l2_obj = json_object_new_object();
+	if (!l2_obj)
+		goto error;
+
+	json_object_array_add(la1_obj, l2_obj);
+	if (iconf->afc.request.id) {
+		str_obj = json_object_new_string(iconf->afc.request.id);
+		if (!str_obj)
+			goto error;
+
+		json_object_object_add(l2_obj, "requestId", str_obj);
+	}
+
+	s2_obj = json_object_new_object();
+	if (!s2_obj)
+		goto error;
+
+	json_object_object_add(l2_obj, "deviceDescriptor", s2_obj);
+	if (iconf->afc.request.sn) {
+		str_obj = json_object_new_string(iconf->afc.request.sn);
+		if (!str_obj)
+			goto error;
+
+		json_object_object_add(s2_obj, "serialNumber", str_obj);
+	}
+
+	la2_obj = json_object_new_array();
+	if (!la2_obj)
+		goto error;
+
+	json_object_object_add(s2_obj, "certificationId", la2_obj);
+	for (i = 0; i < iconf->afc.n_cert_ids; i++) {
+		struct json_object *obj;
+
+		obj = json_object_new_object();
+		if (!obj)
+			goto error;
+
+		json_object_array_add(la2_obj, obj);
+		str_obj =
+			json_object_new_string(iconf->afc.cert_ids[i].rulset);
+		if (!str_obj)
+			goto error;
+
+		json_object_object_add(obj, "rulesetId", str_obj);
+		str_obj = json_object_new_string(iconf->afc.cert_ids[i].id);
+		if (!str_obj)
+			goto error;
+
+		json_object_object_add(obj, "id", str_obj);
+	}
+
+	location_obj = hostapd_afc_build_location_request(iface);
+	if (!location_obj)
+		goto error;
+
+	json_object_object_add(l2_obj, "location", location_obj);
+	str_obj = json_object_new_int(iconf->afc.min_power);
+	if (!str_obj)
+		goto error;
+
+	json_object_object_add(l2_obj, "minDesiredPower", str_obj);
+
+	if (iconf->afc.n_freq_range) {
+		struct json_object *freq_obj;
+
+		freq_obj = json_object_new_array();
+		if (!freq_obj)
+			goto error;
+
+		json_object_object_add(l2_obj, "inquiredFrequencyRange",
+				       freq_obj);
+		for (i = 0; i < iconf->afc.n_freq_range; i++) {
+			struct afc_freq_range *fr = &iconf->afc.freq_range[i];
+			struct json_object *obj;
+
+			obj = json_object_new_object();
+			if (!obj)
+				goto error;
+
+			json_object_array_add(freq_obj, obj);
+			str_obj = json_object_new_int(fr->low_freq);
+			if (!str_obj)
+				goto error;
+
+			json_object_object_add(obj, "lowFrequency", str_obj);
+			str_obj = json_object_new_int(fr->high_freq);
+			if (!str_obj)
+				goto error;
+
+			json_object_object_add(obj, "highFrequency", str_obj);
+		}
+	}
+
+	op_class_list_obj = hostapd_afc_build_req_chan_list(iface);
+	if (!op_class_list_obj)
+		goto error;
+
+	json_object_object_add(l2_obj, "inquiredChannels", op_class_list_obj);
+
+	wpa_printf(MSG_DEBUG, "Pending AFC request: %s",
+		   json_object_get_string(l1_obj));
+
+	return l1_obj;
+
+error:
+	json_object_put(l1_obj);
+
+	return NULL;
+}
+
+
+static int
+hostad_afc_parse_available_freq_info(struct hostapd_iface *iface,
+				     struct json_object *reply_elem_obj)
+{
+	struct afc_freq_range_elem *f = NULL;
+	struct json_object *obj;
+	int i, count = 0;
+
+	if (!json_object_object_get_ex(reply_elem_obj,
+				       "availableFrequencyInfo", &obj))
+		return 0;
+
+	for (i = 0; i < json_object_array_length(obj); i++) {
+		struct json_object *range_elem_obj, *freq_range_obj;
+		struct json_object *high_freq_obj, *low_freq_obj;
+		struct json_object *max_psd_obj;
+
+		range_elem_obj = json_object_array_get_idx(obj, i);
+		if (!range_elem_obj)
+			continue;
+
+		if (!json_object_object_get_ex(range_elem_obj,
+					       "frequencyRange",
+					       &freq_range_obj))
+			continue;
+
+		if (!json_object_object_get_ex(freq_range_obj,
+					       "lowFrequency",
+					       &low_freq_obj))
+			continue;
+
+		if (!json_object_object_get_ex(freq_range_obj,
+					       "highFrequency",
+					       &high_freq_obj))
+			continue;
+
+		if (!json_object_object_get_ex(range_elem_obj, "maxPsd",
+					       &max_psd_obj) &&
+		    !json_object_object_get_ex(range_elem_obj, "maxPSD",
+					       &max_psd_obj))
+			continue;
+
+		f = os_realloc_array(f, count + 1, sizeof(*f));
+		if (!f)
+			return -ENOMEM;
+
+		f[count].low_freq = json_object_get_int(low_freq_obj);
+		f[count].high_freq = json_object_get_int(high_freq_obj);
+		f[count++].max_psd = json_object_get_int(max_psd_obj);
+	}
+	iface->afc.freq_range = f;
+	iface->afc.num_freq_range = count;
+
+	return 0;
+}
+
+
+static int hostad_afc_update_chan_info(struct afc_chan_info_elem **chan_list,
+				       int *chan_list_size, u8 op_class,
+				       int center_chan, int power)
+{
+	int op_class_pwr_index, num_low_subchan, ch, count = *chan_list_size;
+	struct afc_chan_info_elem *c = *chan_list;
+
+	switch (op_class) {
+	case 132: /*  40MHz */
+		op_class_pwr_index = 1;
+		num_low_subchan = 2;
+		break;
+	case 133: /*  80MHz */
+		op_class_pwr_index = 2;
+		num_low_subchan = 6;
+		break;
+	case 134: /* 160MHz */
+		op_class_pwr_index = 3;
+		num_low_subchan = 14;
+		break;
+	case 137: /* 320MHz */
+		op_class_pwr_index = 4;
+		num_low_subchan = 30;
+		break;
+	default:
+		op_class_pwr_index = 0;
+		num_low_subchan = 0;
+		break;
+	}
+
+	for (ch = center_chan - num_low_subchan;
+	     ch <= center_chan + num_low_subchan; ch += 4) {
+		int i;
+
+		for (i = 0; i < count; i++) {
+			if (c[i].chan == ch)
+				break;
+		}
+
+		if (i == count) {
+			c = os_realloc_array(c, count + 1, sizeof(*c));
+			if (!c)
+				return -ENOMEM;
+
+			c[count].chan = ch;
+			for (int j = 0; j < 5; j++)
+				c[count].power[j] = AFC_INVALID_POWER;
+			count++;
+		}
+		c[i].power[op_class_pwr_index] = power;
+	}
+
+	*chan_list_size = count;
+	*chan_list = c;
+
+	return 0;
+}
+
+
+static int
+hostad_afc_parse_available_chan_info(struct hostapd_iface *iface,
+				     struct json_object *reply_elem_obj)
+{
+	struct afc_chan_info_elem *c = NULL;
+	struct json_object *obj;
+	int i, count = 0;
+
+	if (!json_object_object_get_ex(reply_elem_obj,
+				       "availableChannelInfo", &obj))
+		return 0;
+
+	for (i = 0; i < json_object_array_length(obj); i++) {
+		struct json_object *range_elem_obj, *op_class_obj;
+		struct json_object *chan_cfi_obj, *max_eirp_obj;
+		int ch, op_class;
+
+		range_elem_obj = json_object_array_get_idx(obj, i);
+		if (!range_elem_obj)
+			continue;
+
+		if (!json_object_object_get_ex(range_elem_obj,
+					       "globalOperatingClass",
+					       &op_class_obj))
+			continue;
+
+		if (!json_object_object_get_ex(range_elem_obj, "maxEirp",
+					       &max_eirp_obj))
+			continue;
+
+		if (!json_object_object_get_ex(range_elem_obj, "channelCfi",
+					       &chan_cfi_obj))
+			continue;
+
+		op_class = json_object_get_int(op_class_obj);
+		for (ch = 0;
+		     ch < json_object_array_length(chan_cfi_obj); ch++) {
+			struct json_object *pwr_obj;
+			struct json_object *ch_obj;
+			int channel, power;
+
+			ch_obj = json_object_array_get_idx(chan_cfi_obj, ch);
+			if (!ch_obj)
+				continue;
+
+			pwr_obj = json_object_array_get_idx(max_eirp_obj, ch);
+			if (!pwr_obj)
+				continue;
+
+			channel = json_object_get_int(ch_obj);
+			power = json_object_get_int(pwr_obj);
+
+			hostad_afc_update_chan_info(&c, &count, op_class,
+						    channel, power);
+		}
+		iface->afc.chan_info_list = c;
+		iface->afc.num_chan_info = count;
+	}
+
+	return 0;
+}
+
+
+static int hostad_afc_get_timeout(struct json_object *obj)
+{
+	time_t t, now;
+	struct tm tm;
+
+	if (sscanf(json_object_get_string(obj), "%d-%d-%dT%d:%d:%dZ",
+		   &tm.tm_year, &tm.tm_mon, &tm.tm_mday, &tm.tm_hour,
+		   &tm.tm_min, &tm.tm_sec) <= 0)
+		return HOSTAPD_AFC_TIMEOUT;
+
+	tm.tm_year -= 1900;
+	tm.tm_mon -= 1;
+	tm.tm_isdst = -1;
+	t = mktime(&tm);
+	time(&now);
+
+	return now > t ? HOSTAPD_AFC_RETRY_TIMEOUT : (t - now) * 80 / 100;
+}
+
+
+static int hostapd_afc_parse_reply(struct hostapd_iface *iface, char *reply)
+{
+	struct json_object *payload_obj, *reply_obj, *version_obj;
+	struct hostapd_config *iconf = iface->conf;
+	int i, request_timeout = -1, ret = -EINVAL;
+
+	wpa_printf(MSG_DEBUG, "Received AFC reply: %s", reply);
+	payload_obj = json_tokener_parse(reply);
+	if (!payload_obj) {
+		wpa_printf(MSG_ERROR, "Failed to parse AFC reply payload");
+		return -EINVAL;
+	}
+
+	if (!json_object_object_get_ex(payload_obj, "version", &version_obj)) {
+		wpa_printf(MSG_ERROR, "Missing version in AFC reply");
+		return -EINVAL;
+	}
+
+	if (iconf->afc.request.version &&
+	    os_strcmp(iconf->afc.request.version,
+		      json_object_get_string(version_obj))) {
+		wpa_printf(MSG_ERROR, "Mismatch in AFC reply version");
+		return -EINVAL;
+	}
+
+	if (!json_object_object_get_ex(payload_obj,
+				       "availableSpectrumInquiryResponses",
+				       &reply_obj)) {
+		wpa_printf(MSG_ERROR,
+			   "Missing availableSpectrumInquiry in AFC reply");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < json_object_array_length(reply_obj); i++) {
+		struct json_object *reply_elem_obj, *obj, *status_obj;
+		int j, status = -EINVAL;
+
+		reply_elem_obj = json_object_array_get_idx(reply_obj, i);
+		if (!reply_elem_obj) {
+			wpa_printf(MSG_DEBUG,
+				   "Failed to get reply element at index %d",
+				   i);
+			continue;
+		}
+
+		if (!json_object_object_get_ex(reply_elem_obj, "requestId",
+					       &obj)) {
+			wpa_printf(MSG_DEBUG,
+				   "Missing requestId in reply element %d", i);
+			continue;
+		}
+
+		if (iconf->afc.request.id &&
+		    os_strcmp(iconf->afc.request.id,
+			      json_object_get_string(obj))) {
+			wpa_printf(MSG_DEBUG,
+				   "RequestId mismatch in reply element %d",
+				   i);
+			continue;
+		}
+
+		if (!json_object_object_get_ex(reply_elem_obj, "rulesetId",
+					       &obj)) {
+			wpa_printf(MSG_DEBUG,
+				   "Missing rulesetId in reply element %d", i);
+			continue;
+		}
+
+		for (j = 0; j < iconf->afc.n_cert_ids; j++) {
+			if (!os_strcmp(iconf->afc.cert_ids[j].rulset,
+				       json_object_get_string(obj)))
+				break;
+		}
+
+		if (j == iconf->afc.n_cert_ids) {
+			wpa_printf(MSG_DEBUG,
+				   "RulesetId mismatch in reply element %d",
+				   i);
+			continue;
+		}
+
+		if (!json_object_object_get_ex(reply_elem_obj, "response",
+					       &obj)) {
+			wpa_printf(MSG_DEBUG,
+				   "Missing response field in reply element %d",
+				   i);
+			continue;
+		}
+
+		if (json_object_object_get_ex(obj, "shortDescription",
+					      &status_obj))
+			wpa_printf(MSG_DEBUG, "AFC reply element %d: %s",
+				   i, json_object_get_string(status_obj));
+
+		if (json_object_object_get_ex(obj, "responseCode",
+					      &status_obj))
+			status = json_object_get_int(status_obj);
+
+		if (status < 0) {
+			wpa_printf(MSG_DEBUG,
+				   "Reply element %d invalid responseCode: %d",
+				   i, status);
+			continue;
+		}
+
+		if (hostad_afc_parse_available_freq_info(iface,
+							 reply_elem_obj) ||
+		    hostad_afc_parse_available_chan_info(iface,
+							 reply_elem_obj))
+			continue;
+
+		if (json_object_object_get_ex(reply_elem_obj,
+					      "availabilityExpireTime",
+					      &obj)) {
+			int timeout = hostad_afc_get_timeout(obj);
+
+			if (request_timeout < 0 || timeout < request_timeout)
+				request_timeout = timeout;
+		}
+
+		ret = status;
+	}
+
+	iface->afc.data_valid = true;
+	iface->afc.timeout = request_timeout;
+	if (iface->afc.timeout < 0)
+		iface->afc.timeout = HOSTAPD_AFC_RETRY_TIMEOUT;
+	else if (iface->afc.timeout > iconf->afc.max_timeout &&
+		 iconf->afc.max_timeout >= HOSTAPD_AFC_RETRY_TIMEOUT)
+		iface->afc.timeout = iconf->afc.max_timeout;
+
+	return ret;
+}
+
+
+static int hostapd_afc_send_receive(struct hostapd_iface *iface)
+{
+	struct hostapd_config *iconf = iface->conf;
+	json_object *request_obj = NULL;
+	struct timeval sock_timeout = {
+		.tv_sec = 10,
+	};
+	struct sockaddr_un addr = {
+		.sun_family = AF_UNIX,
+#ifdef __FreeBSD__
+		.sun_len = sizeof(addr),
+#endif /* __FreeBSD__ */
+	};
+	const char *request;
+	char *buf = NULL;
+	int sockfd, ret;
+	fd_set read_set;
+
+	if (iface->afc.data_valid) {
+		/* AFC data already downloaded from the server */
+		return 0;
+	}
+
+	iface->afc.timeout = HOSTAPD_AFC_RETRY_TIMEOUT;
+	if (!iconf->afc.socket) {
+		wpa_printf(MSG_ERROR, "Missing AFC socket string");
+		return -EINVAL;
+	}
+
+	if (os_strlen(iconf->afc.socket) >= sizeof(addr.sun_path)) {
+		wpa_printf(MSG_ERROR, "Malformed AFC socket string %s",
+			   iconf->afc.socket);
+		return -EINVAL;
+	}
+
+	os_strlcpy(addr.sun_path, iconf->afc.socket, sizeof(addr.sun_path));
+	sockfd = socket(AF_UNIX, SOCK_STREAM, 0);
+	if (sockfd < 0) {
+		wpa_printf(MSG_ERROR, "Failed creating AFC socket");
+		return sockfd;
+	}
+
+	if (connect(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+		wpa_printf(MSG_ERROR, "Failed connecting AFC socket");
+		ret = -EIO;
+		goto close_sock;
+	}
+
+	request_obj = hostapd_afc_build_request(iface);
+	if (!request_obj) {
+		ret = -ENOMEM;
+		goto close_sock;
+	}
+
+	request = json_object_to_json_string(request_obj);
+	if (send(sockfd, request, strlen(request), 0) < 0) {
+		wpa_printf(MSG_ERROR, "Failed sending AFC request");
+		ret = -EIO;
+		goto close_sock;
+	}
+
+	FD_ZERO(&read_set);
+	FD_SET(sockfd, &read_set);
+	if (select(sockfd + 1, &read_set, NULL, NULL, &sock_timeout) < 0) {
+		wpa_printf(MSG_ERROR, "Select failed on AFC socket");
+		ret = -errno;
+		goto close_sock;
+	}
+
+	if (!FD_ISSET(sockfd, &read_set)) {
+		ret = -EIO;
+		goto close_sock;
+	}
+
+	buf = os_zalloc(HOSTAPD_AFC_BUFSIZE);
+	if (!buf) {
+		ret = -ENOMEM;
+		goto close_sock;
+	}
+
+	ret = recv(sockfd, buf, HOSTAPD_AFC_BUFSIZE - 1, 0);
+	if (!ret)
+		ret = -EIO;
+	if (ret < 0)
+		goto close_sock;
+
+	ret = hostapd_afc_parse_reply(iface, buf);
+	if (ret)
+		wpa_printf(MSG_ERROR, "Failed parsing AFC reply: %d", ret);
+close_sock:
+	os_free(buf);
+	json_object_put(request_obj);
+	close(sockfd);
+
+	return ret;
+}
+
+
+static bool hostapd_afc_has_usable_chans(struct hostapd_iface *iface)
+{
+	const struct oper_class_map *oper_class;
+	int ch, chan_num;
+
+	oper_class = get_oper_class(NULL, iface->conf->op_class);
+	if (!oper_class)
+		return false;
+
+	switch (iface->conf->op_class) {
+	case 132: /*  40MHz */
+		chan_num = 2;
+		break;
+	case 133: /*  80MHz */
+		chan_num = 4;
+		break;
+	case 134: /* 160MHz */
+		chan_num = 8;
+		break;
+	case 137: /* 320MHz */
+		chan_num = 16;
+		break;
+	default:
+		chan_num = 1;
+		break;
+	}
+
+	for (ch = oper_class->min_chan; ch <= oper_class->max_chan;
+	     ch += oper_class->inc) {
+		struct hostapd_hw_modes *mode = iface->current_mode;
+		struct hostapd_channel_data *chan = NULL;
+		int i;
+
+		for (i = 0; i < chan_num; i++) {
+			chan = hw_get_channel_chan(mode, ch + i * 4, NULL);
+
+			if (!chan || chan->flag & HOSTAPD_CHAN_DISABLED)
+				break;
+		}
+
+		if (i == chan_num)
+			return true;
+
+		if (iface->conf->op_class != 137 || ch < 33 || ch > 193)
+			continue;
+
+		/* 320-2 */
+		for (i = 0; i < chan_num; i++) {
+			chan = hw_get_channel_chan(mode, ch + i * 4 - 32,
+						   NULL);
+
+			if (!chan || chan->flag & HOSTAPD_CHAN_DISABLED)
+				break;
+		}
+
+		if (i == chan_num)
+			return true;
+	}
+
+	return false;
+}
+
+
+int hostapd_afc_handle_request(struct hostapd_iface *iface)
+{
+	struct hostapd_config *iconf = iface->conf;
+	bool lpi_mode;
+	int ret;
+	int afc_status = AFC_CONTINUE;
+
+	lpi_mode = he_reg_is_indoor(iconf->he_6ghz_reg_pwr_type);
+	if (lpi_mode && !he_reg_is_sp(iconf->he_6ghz_reg_pwr_type)) {
+		iface->afc.lpi_mode = true;
+		return 1;
+	}
+
+	if (strncmp(iconf->country, "US", 2) != 0 &&
+	    strncmp(iconf->country, "CA", 2) != 0)
+		return 1;
+
+	/* AFC is required just for standard power AP */
+	if (!he_reg_is_sp(iconf->he_6ghz_reg_pwr_type))
+		return 1;
+
+	if (!is_6ghz_op_class(iconf->op_class) || !is_6ghz_freq(iface->freq))
+		return 1;
+
+	if (iface->state == HAPD_IFACE_ACS)
+		return 1;
+
+	ret = hostapd_afc_send_receive(iface);
+	if (ret < 0) {
+		afc_status = lpi_mode ? AFC_LPI : AFC_DISABLE;
+		goto resched;
+	}
+
+	hostap_afc_disable_channels(iface);
+	if (!hostapd_afc_has_usable_chans(iface)) {
+		afc_status = lpi_mode ? AFC_LPI : AFC_DISABLE;
+		goto resched;
+	}
+
+	ret = hostapd_is_usable_chans(iface);
+	if (ret != 1) {
+		/* Trigger an ACS freq scan */
+		afc_status = AFC_RESTART_IFACE;
+		iconf->channel = 0;
+		iface->freq = 0;
+		hostapd_set_and_check_bw320_offset(iface->conf, 0);
+
+		if (!ret && acs_init(iface) != HOSTAPD_CHAN_ACS) {
+			wpa_printf(MSG_ERROR, "Could not start ACS");
+			afc_status = AFC_DISABLE;
+			ret = -EINVAL;
+		}
+	} else
+		ret = 1;
+
+resched:
+	switch(afc_status) {
+	case AFC_LPI:
+		iface->afc.lpi_mode = true;
+		hostapd_get_hw_features(iface);
+		ret = 1;
+		break;
+	/* Disable and restart iface would be finished in hostapd setup flow. */
+	case AFC_DISABLE:
+		if (ret == -EIO)
+			ret = 0;
+		break;
+	case AFC_RESTART_IFACE:
+	case AFC_CONTINUE:
+		break;
+	default:
+		break;
+	}
+
+	eloop_cancel_timeout(hostapd_afc_timeout_handler, iface, NULL);
+	eloop_register_timeout(iface->afc.timeout, 0,
+			       hostapd_afc_timeout_handler, iface, NULL);
+
+	return ret;
+}
+
+
+static void hostapd_afc_delete_data_from_server(struct hostapd_iface *iface)
+{
+	os_free(iface->afc.chan_info_list);
+	os_free(iface->afc.freq_range);
+
+	iface->afc.num_freq_range = 0;
+	iface->afc.num_chan_info = 0;
+
+	iface->afc.chan_info_list = NULL;
+	iface->afc.freq_range = NULL;
+
+	iface->afc.data_valid = false;
+}
+
+
+static void hostapd_afc_timeout_handler(void *eloop_ctx, void *timeout_ctx)
+{
+	struct hostapd_iface *iface = eloop_ctx;
+	bool lpi_mode;
+	int afc_status = AFC_CONTINUE, ret;
+
+	lpi_mode = he_reg_is_indoor(iface->conf->he_6ghz_reg_pwr_type);
+	iface->afc.lpi_mode = false;
+
+	hostapd_afc_delete_data_from_server(iface);
+	if (iface->state != HAPD_IFACE_ENABLED) {
+		afc_status = AFC_RESTART_IFACE;
+		/* Hostapd is not fully enabled yet, toggle the interface */
+		goto resched;
+	}
+
+
+	if (hostapd_afc_send_receive(iface) < 0 ||
+	    hostapd_get_hw_features(iface)) {
+		afc_status = lpi_mode ? AFC_LPI : AFC_DISABLE;
+		goto resched;
+	}
+
+	hostap_afc_disable_channels(iface);
+	if (hostapd_is_usable_chans(iface) == 1)
+		goto resched;
+
+	ret = hostapd_afc_has_usable_chans(iface);
+	if (ret) {
+		/* Trigger an ACS freq scan */
+		afc_status = AFC_RESTART_IFACE;
+		iface->conf->channel = 0;
+		iface->freq = 0;
+		hostapd_set_and_check_bw320_offset(iface->conf, 0);
+	} else
+		afc_status = lpi_mode ? AFC_LPI : AFC_DISABLE;
+
+resched:
+	switch(afc_status) {
+	case AFC_DISABLE:
+		hostapd_drv_txpower_ctrl(iface->bss[0]);
+		hostapd_disable_iface(iface);
+		break;
+	case AFC_RESTART_IFACE:
+		hostapd_disable_iface(iface);
+		hostapd_enable_iface(iface);
+		break;
+	case AFC_LPI:
+		iface->afc.lpi_mode = true;
+		hostapd_get_hw_features(iface);
+		fallthrough;
+	case AFC_CONTINUE:
+		hostapd_drv_txpower_ctrl(iface->bss[0]);
+		break;
+	default:
+		break;
+	}
+	eloop_register_timeout(iface->afc.timeout, 0,
+			       hostapd_afc_timeout_handler, iface, NULL);
+}
+
+
+void hostapd_afc_stop(struct hostapd_iface *iface)
+{
+	eloop_cancel_timeout(hostapd_afc_timeout_handler, iface, NULL);
+}
+
+
+void hostap_afc_disable_channels(struct hostapd_iface *iface)
+{
+	struct hostapd_hw_modes *mode = NULL;
+	int i;
+
+	for (i = 0; i < iface->num_hw_features; i++) {
+		mode = &iface->hw_features[i];
+		if (mode->mode == HOSTAPD_MODE_IEEE80211A &&
+		    mode->is_6ghz)
+			break;
+	}
+
+	if (i == iface->num_hw_features)
+		return;
+
+	if (!he_reg_is_sp(iface->conf->he_6ghz_reg_pwr_type))
+		return;
+
+	if (!iface->afc.data_valid)
+		return;
+
+	for (i = 0; i < mode->num_channels; i++) {
+		struct hostapd_channel_data *chan = &mode->channels[i];
+		int j;
+
+		if (!is_6ghz_freq(chan->freq))
+			continue;
+
+		for (j = 0; j < iface->afc.num_freq_range; j++) {
+			if (chan->freq >= iface->afc.freq_range[j].low_freq &&
+			    chan->freq <= iface->afc.freq_range[j].high_freq)
+				break;
+		}
+
+		if (j != iface->afc.num_freq_range)
+			continue;
+
+		for (j = 0; j < iface->afc.num_chan_info; j++) {
+			if (chan->chan == iface->afc.chan_info_list[j].chan)
+				break;
+		}
+
+		if (j != iface->afc.num_chan_info)
+			continue;
+
+		chan->flag |= HOSTAPD_CHAN_DISABLED;
+		wpa_printf(MSG_MSGDUMP,
+			   "Disabling freq=%d MHz (not allowed by AFC)",
+			   chan->freq);
+	}
+}
+
+
+int hostap_afc_get_chan_max_eirp_power(struct hostapd_iface *iface, bool psd,
+				       int *power)
+{
+	int i;
+
+	if (!he_reg_is_sp(iface->conf->he_6ghz_reg_pwr_type))
+		return -EINVAL;
+
+	if (!iface->afc.data_valid)
+		return -EINVAL;
+
+	if (psd) {
+		for (i = 0; i < iface->afc.num_freq_range; i++) {
+			struct afc_freq_range_elem *f;
+
+			f = &iface->afc.freq_range[i];
+			if (iface->freq >= f->low_freq &&
+			    iface->freq <= f->high_freq) {
+				*power = 2 * f->max_psd;
+				return 0;
+			}
+		}
+	} else {
+		for (i = 0; i < iface->afc.num_chan_info; i++) {
+			struct afc_chan_info_elem *c;
+
+			c = &iface->afc.chan_info_list[i];
+			if (c->chan == iface->conf->channel) {
+				int j;
+
+				*power = 0;
+				for (j = 0; j < 5; j++) {
+					if (c->power[j] != AFC_INVALID_POWER)
+						*power = MAX(*power, 2 * c->power[j]);
+				}
+
+				return 0;
+			}
+		}
+	}
+	return -EINVAL;
+}
+
+void hostapd_afc_init_power_table(s8 ***power_table)
+{
+	int table_idx, bw;
+	s8 *chan_power_list;
+
+	/* init power table */
+	for (table_idx = 0; table_idx < MAX_CHANNEL_NUM_6G; table_idx++) {
+		chan_power_list = (*power_table)[table_idx];
+		for (bw = 0; bw < afc_power_table_num; bw++)
+			chan_power_list[bw] = AFC_INVALID_POWER;
+	}
+}
+
+void hostapd_afc_parse_bw320(int table_idx, s8 *power_list)
+{
+	if (table_idx > 7)
+		power_list[afc_power_bw320_2] =
+			power_list[afc_power_bw320_1];
+	if (table_idx > 47)
+		power_list[afc_power_bw320_1] = AFC_INVALID_POWER;
+}
+
+int hostapd_afc_parse_psd_to_dbm(struct hostapd_iface *iface, s8 ***power_table)
+{
+	int i, freq, channel, bw, table_idx, target_power;
+	s8 *chan_power_list;
+
+	for (i = 0; i < iface->afc.num_freq_range; i++) {
+		struct afc_freq_range_elem *freq_range = &iface->afc.freq_range[i];
+
+		freq = freq_range->low_freq + 10;
+		channel = hostapd_hw_get_channel(iface->bss[0], freq);
+		if (channel == 0)
+			continue;
+
+		table_idx = channel / 4;
+
+		if (table_idx >= MAX_CHANNEL_NUM_6G)
+			return -EINVAL;
+
+		chan_power_list = (*power_table)[table_idx];
+		for (bw = afc_power_bw20; bw < afc_power_bw320_2; bw++) {
+			target_power = freq_range->max_psd * 2 + PSD_TO_DBM_OFFSET +
+				bw * DOUBLE_BW_POWER;
+			target_power = MIN(AFC_MAXIMUM_POWER, target_power);
+			chan_power_list[bw] = MIN(chan_power_list[bw],
+						  target_power);
+		}
+		hostapd_afc_parse_bw320(table_idx, chan_power_list);
+	}
+	return 0;
+}
+
+int hostapd_afc_parse_eirp_to_dbm(struct hostapd_iface *iface, s8 ***power_table)
+{
+	int i, bw, table_idx, target_power;
+	s8 *chan_power_list;
+
+	for (i = 0; i < iface->afc.num_chan_info; i++) {
+		struct afc_chan_info_elem *chan_info = &iface->afc.chan_info_list[i];
+
+		table_idx = chan_info->chan / 4;
+
+		if (table_idx >= MAX_CHANNEL_NUM_6G)
+			return -EINVAL;
+
+		chan_power_list = (*power_table)[table_idx];
+		for (bw = afc_power_bw20; bw <= afc_power_bw320_1; bw++) {
+			if (chan_info->power[bw] == AFC_INVALID_POWER)
+				continue;
+			target_power = MIN(AFC_MAXIMUM_POWER, chan_info->power[bw] * 2);
+			chan_power_list[bw] = MIN(chan_power_list[bw], target_power);
+		}
+		hostapd_afc_parse_bw320(table_idx, chan_power_list);
+	}
+	return 0;
+}
+
+int afc_get_ru_be_offset(int bw, int *target_bw, int *offset)
+{
+	switch (bw) {
+	case afc_power_ru26:
+		*target_bw = afc_power_bw20;
+		*offset = RU26_OFFSET_20MHZ;
+		break;
+	case afc_power_ru52:
+		*target_bw = afc_power_bw20;
+		*offset = RU52_OFFSET_20MHZ;
+		break;
+	case afc_power_ru78:
+		*target_bw = afc_power_bw20;
+		*offset = RU78_OFFSET_20MHZ;
+		break;
+	case afc_power_ru106:
+		*target_bw = afc_power_bw20;
+		*offset = RU106_OFFSET_20MHZ;
+		break;
+	case afc_power_ru132:
+		*target_bw = afc_power_bw20;
+		*offset = RU132_OFFSET_20MHZ;
+		break;
+	case afc_power_ru726:
+		*target_bw = afc_power_bw80;
+		*offset = RU726_OFFSET_80MHZ;
+		break;
+	case afc_power_ru1480:
+		*target_bw = afc_power_bw160;
+		*offset = RU1480_OFFSET_160MHZ;
+		break;
+	case afc_power_ru1772:
+		*target_bw = afc_power_bw160;
+		*offset = RU1772_OFFSET_160MHZ;
+		break;
+	case afc_power_ru2476:
+		*target_bw = afc_power_bw320_1;
+		*offset = RU2476_OFFSET_320MHZ;
+		break;
+	case afc_power_ru2988:
+		*target_bw = afc_power_bw320_1;
+		*offset = RU2988_OFFSET_320MHZ;
+		break;
+	case afc_power_ru3472:
+		*target_bw = afc_power_bw320_1;
+		*offset = RU3472_OFFSET_320MHZ;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+int hostapd_afc_fill_wide_bandwidth_power(s8 ***power_table)
+{
+	int table_idx, bw;
+	s8 *chan_power_list;
+
+	for (table_idx = 0; table_idx < MAX_CHANNEL_NUM_6G; table_idx++) {
+		int target_power, ru26_power;
+
+		if ((*power_table)[table_idx][afc_power_bw20] == AFC_INVALID_POWER)
+			continue;
+
+		chan_power_list = (*power_table)[table_idx];
+
+		/* Check wide bandwidth power minimum or valid. */
+		for (bw = afc_power_bw40; bw <= afc_power_bw320_2; bw++) {
+			int bw_ch_num, first_ch, last_ch;
+
+			target_power = AFC_INVALID_POWER;
+			switch (bw) {
+			case afc_power_bw40:
+				bw_ch_num = 2;
+				break;
+			case afc_power_bw80:
+				bw_ch_num = 4;
+				break;
+			case afc_power_bw160:
+				bw_ch_num = 8;
+				break;
+			case afc_power_bw320_1:
+			case afc_power_bw320_2:
+				bw_ch_num = 16;
+				break;
+			default:
+				continue;
+			}
+			if ((bw == afc_power_bw320_1 && table_idx > 47) ||
+			    (bw == afc_power_bw320_2 && table_idx < 8))
+				continue;
+
+			if (bw == afc_power_bw320_2)
+				first_ch = table_idx - (table_idx + 8) % bw_ch_num;
+			else
+				first_ch = table_idx - table_idx % bw_ch_num;
+			last_ch = first_ch + bw_ch_num;
+			for (int ch = first_ch; ch < last_ch; ch++) {
+				if ((*power_table)[ch][bw] == AFC_INVALID_POWER) {
+					target_power = AFC_INVALID_POWER;
+					break;
+				}
+				target_power = MIN((*power_table)[ch][bw], target_power);
+			}
+			chan_power_list[bw] = target_power;
+		}
+
+		/* Update remain ru */
+		for (bw = afc_power_ru26; bw < afc_power_table_num; bw++) {
+			int target_bw, offset;
+
+			if (afc_get_ru_be_offset(bw, &target_bw, &offset))
+				return -EINVAL;
+
+			if (target_bw == afc_power_bw320_1 &&
+			    chan_power_list[target_bw] == AFC_INVALID_POWER)
+			    target_bw++;
+
+			if (chan_power_list[target_bw] == AFC_INVALID_POWER) {
+				chan_power_list[bw] = AFC_INVALID_POWER;
+				continue;
+			}
+
+			target_power = chan_power_list[target_bw] - offset;
+			chan_power_list[bw] = target_power;
+		}
+	}
+	return 0;
+}
+
+
+int hostapd_afc_translate_table(struct hostapd_iface *iface,
+				s8 ***power_table)
+{
+	int i, ret;
+
+	if (!iface->afc.data_valid)
+		return -EINVAL;
+
+	/* afc response that there is no avialible bandwidth to use */
+	if (!hostapd_afc_has_usable_chans(iface))
+		return 0;
+
+	*power_table = (s8**)os_zalloc(MAX_CHANNEL_NUM_6G * sizeof(s8*));
+
+	if (!(*power_table))
+		return -ENOMEM;
+
+	for (i = 0; i < MAX_CHANNEL_NUM_6G; i++) {
+		(*power_table)[i] = (s8*)os_zalloc(afc_power_table_num * sizeof(s8));
+		if (!(*power_table)[i]) {
+			ret = -ENOMEM;
+			goto out;
+		}
+	}
+
+	hostapd_afc_init_power_table(power_table);
+
+	ret = hostapd_afc_parse_psd_to_dbm(iface, power_table);
+	if (ret)
+		goto out;
+
+	ret = hostapd_afc_parse_eirp_to_dbm(iface, power_table);
+	if (ret)
+		goto out;
+
+	ret = hostapd_afc_fill_wide_bandwidth_power(power_table);
+	if (ret)
+		goto out;
+
+out:
+	return ret;
+}
diff --git a/src/ap/airtime_policy.c b/src/ap/airtime_policy.c
index 6844311..26f11ad 100644
--- a/src/ap/airtime_policy.c
+++ b/src/ap/airtime_policy.c
@@ -112,8 +112,14 @@ static void set_sta_weights(struct hostapd_data *hapd, unsigned int weight)
 {
 	struct sta_info *sta;
 
-	for (sta = hapd->sta_list; sta; sta = sta->next)
-		sta_set_airtime_weight(hapd, sta, weight);
+	for (sta = hapd->sta_list; sta; sta = sta->next) {
+		unsigned int sta_weight = weight;
+
+		if (sta->dyn_airtime_weight)
+			sta_weight = (weight * sta->dyn_airtime_weight) / 256;
+
+		sta_set_airtime_weight(hapd, sta, sta_weight);
+	}
 }
 
 
@@ -244,7 +250,10 @@ int airtime_policy_new_sta(struct hostapd_data *hapd, struct sta_info *sta)
 	unsigned int weight;
 
 	if (hapd->iconf->airtime_mode == AIRTIME_MODE_STATIC) {
-		weight = get_weight_for_sta(hapd, sta->addr);
+		if (sta->dyn_airtime_weight)
+			weight = sta->dyn_airtime_weight;
+		else
+			weight = get_weight_for_sta(hapd, sta->addr);
 		if (weight)
 			return sta_set_airtime_weight(hapd, sta, weight);
 	}
diff --git a/src/ap/ap_config.c b/src/ap/ap_config.c
index 160809a..ff58721 100644
--- a/src/ap/ap_config.c
+++ b/src/ap/ap_config.c
@@ -170,6 +170,7 @@ void hostapd_config_defaults_bss(struct hostapd_bss_config *bss)
 #ifdef CONFIG_TESTING_OPTIONS
 	bss->sae_commit_status = -1;
 	bss->test_assoc_comeback_type = -1;
+	bss->mld_link_id = -1;
 #endif /* CONFIG_TESTING_OPTIONS */
 
 #ifdef CONFIG_PASN
@@ -177,6 +178,7 @@ void hostapd_config_defaults_bss(struct hostapd_bss_config *bss)
 	bss->pasn_comeback_after = 10;
 	bss->pasn_noauth = 1;
 #endif /* CONFIG_PASN */
+	bss->bss_termination_tsf = 0;
 }
 
 
@@ -274,6 +276,7 @@ struct hostapd_config * hostapd_config_defaults(void)
 #endif /* CONFIG_ACS */
 
 #ifdef CONFIG_IEEE80211AX
+	conf->he_phy_capab.he_ldpc = 1;
 	conf->he_op.he_rts_threshold = HE_OPERATION_RTS_THRESHOLD_MASK >>
 		HE_OPERATION_RTS_THRESHOLD_OFFSET;
 	/* Set default basic MCS/NSS set to single stream MCS 0-7 */
@@ -286,10 +289,11 @@ struct hostapd_config * hostapd_config_defaults(void)
 	conf->he_6ghz_max_ampdu_len_exp = 7;
 	conf->he_6ghz_rx_ant_pat = 1;
 	conf->he_6ghz_tx_ant_pat = 1;
-	conf->he_6ghz_reg_pwr_type = HE_REG_INFO_6GHZ_AP_TYPE_VLP;
+	conf->he_6ghz_reg_pwr_type = HE_REG_INFO_6GHZ_AP_TYPE_INDOOR;
 	conf->reg_def_cli_eirp_psd = -1;
 	conf->reg_sub_cli_eirp_psd = -1;
 	conf->reg_def_cli_eirp = -1;
+	conf->mu_onoff = 15;
 #endif /* CONFIG_IEEE80211AX */
 
 	/* The third octet of the country string uses an ASCII space character
@@ -304,6 +308,18 @@ struct hostapd_config * hostapd_config_defaults(void)
 	conf->airtime_update_interval = AIRTIME_DEFAULT_UPDATE_INTERVAL;
 #endif /* CONFIG_AIRTIME_POLICY */
 
+	conf->edcca_enable = EDCCA_MODE_AUTO;
+	conf->edcca_compensation = EDCCA_DEFAULT_COMPENSATION;
+	conf->three_wire_enable = THREE_WIRE_MODE_DISABLE;
+	conf->ibf_enable = IBF_DEFAULT_ENABLE;
+	conf->amsdu = 1;
+	conf->pp_mode = PP_FW_MODE;
+
+	conf->lpi_psd = 0;
+	conf->sku_idx = 0;
+	conf->lpi_sku_idx = 0;
+	conf->lpi_bcn_enhance = 0;
+
 	hostapd_set_and_check_bw320_offset(conf, 0);
 
 	return conf;
@@ -1053,8 +1069,25 @@ void hostapd_config_free(struct hostapd_config *conf)
 #ifdef CONFIG_ACS
 	os_free(conf->acs_chan_bias);
 #endif /* CONFIG_ACS */
+	os_free(conf->edcca_threshold);
 	wpabuf_free(conf->lci);
 	wpabuf_free(conf->civic);
+#ifdef CONFIG_AFC
+	os_free(conf->afc.socket);
+	os_free(conf->afc.request.version);
+	os_free(conf->afc.request.id);
+	os_free(conf->afc.request.sn);
+	for (i = 0; i < conf->afc.n_cert_ids; i++) {
+		os_free(conf->afc.cert_ids[i].rulset);
+		os_free(conf->afc.cert_ids[i].id);
+	}
+	os_free(conf->afc.cert_ids);
+	os_free(conf->afc.location.height_type);
+	os_free(conf->afc.location.linear_polygon_data);
+	os_free(conf->afc.location.radial_polygon_data);
+	os_free(conf->afc.freq_range);
+	os_free(conf->afc.op_class);
+#endif /* CONFIG_AFC */
 
 	os_free(conf);
 }
@@ -1511,6 +1544,14 @@ static int hostapd_config_check_bss(struct hostapd_bss_config *bss,
 		wpa_printf(MSG_INFO,
 			   "Disabling IEEE 802.11be as IEEE 802.11ax is disabled for this BSS");
 	}
+
+#ifdef CONFIG_TESTING_OPTIONS
+	if (full_config && (bss->mld_link_id < -1 ||
+	    bss->mld_link_id > MAX_NUM_MLD_LINKS)) {
+		wpa_printf(MSG_ERROR, "Invalid MLD link ID");
+		return -1;
+	}
+#endif /* CONFIG_TESTING_OPTIONS */
 #endif /* CONFIG_IEEE80211BE */
 
 	if (full_config && bss->ignore_broadcast_ssid && conf->mbssid) {
diff --git a/src/ap/ap_config.h b/src/ap/ap_config.h
index d420767..04e4342 100644
--- a/src/ap/ap_config.h
+++ b/src/ap/ap_config.h
@@ -121,6 +121,7 @@ struct hostapd_ssid {
 #define DYNAMIC_VLAN_OPTIONAL 1
 #define DYNAMIC_VLAN_REQUIRED 2
 	int dynamic_vlan;
+	int vlan_no_bridge;
 #define DYNAMIC_VLAN_NAMING_WITHOUT_DEVICE 0
 #define DYNAMIC_VLAN_NAMING_WITH_DEVICE 1
 #define DYNAMIC_VLAN_NAMING_END 2
@@ -282,6 +283,8 @@ struct airtime_sta_weight {
 struct hostapd_bss_config {
 	char iface[IFNAMSIZ + 1];
 	char bridge[IFNAMSIZ + 1];
+	char ft_iface[IFNAMSIZ + 1];
+	char snoop_iface[IFNAMSIZ + 1];
 	char vlan_bridge[IFNAMSIZ + 1];
 	char wds_bridge[IFNAMSIZ + 1];
 	int bridge_hairpin; /* hairpin_mode on bridge members */
@@ -307,6 +310,7 @@ struct hostapd_bss_config {
 	unsigned int eap_sim_db_timeout;
 	int eap_server_erp; /* Whether ERP is enabled on internal EAP server */
 	struct hostapd_ip_addr own_ip_addr;
+	int dynamic_own_ip_addr;
 	char *nas_identifier;
 	struct hostapd_radius_servers *radius;
 	int radius_require_message_authenticator;
@@ -501,6 +505,7 @@ struct hostapd_bss_config {
 #ifdef CONFIG_WPS
 	int wps_independent;
 	int ap_setup_locked;
+	unsigned int ap_pin_lockout_time;
 	u8 uuid[16];
 	char *wps_pin_requests;
 	char *device_name;
@@ -568,6 +573,7 @@ struct hostapd_bss_config {
 	int wnm_sleep_mode;
 	int wnm_sleep_mode_no_keys;
 	int bss_transition;
+	unsigned int bss_termination_tsf;
 
 	/* IEEE 802.11u - Interworking */
 	int interworking;
@@ -981,6 +987,12 @@ struct hostapd_bss_config {
 	/* The AP is part of an AP MLD */
 	u8 mld_ap;
 
+	/* The AP is the primary AP of an AP MLD */
+	u8 mld_primary;
+	/* Allowed link bitmap of the AP MLD to which the AP is affiliated */
+	u16 mld_allowed_links;
+	u32 mld_radio_mask;
+
 	/* The MLD ID to which the AP MLD is affiliated with */
 	u8 mld_id;
 
@@ -993,14 +1005,47 @@ struct hostapd_bss_config {
 	 * other APs in the AP MLD.
 	 */
 	bool mld_indicate_disabled;
+
+	/* Link ID of this affiliated AP of the AP MLD */
+	int mld_link_id;
 #endif /* CONFIG_TESTING_OPTIONS */
 #endif /* CONFIG_IEEE80211BE */
+
+#ifdef CONFIG_APUP
+	/**
+	 * Access Point Micro Peering
+	 * A simpler and more useful successor to Ad Hoc,
+	 * Wireless Distribution System, 802.11s mesh mode, Multi-AP and EasyMesh.
+	 *
+	 * Almost plain APs communicate between them via 4-address mode, like in WDS
+	 * but all of them are AP, so they can eventually communicate also with
+	 * plain stations and more AP nodes in sight.
+	 * Low hardware requirements, just AP mode support + 4-address mode, and no
+	 * more unnecessary complications, like hardcoded bridging or routing
+	 * algorithm in WiFi stack.
+	 * For each AP in sight an interface is created, and then it can be used as
+	 * convenient in each case, bridging, routing etc.
+	 */
+	bool apup;
+
+	/**
+	 * In 4-address mode each peer AP in sight is associated to its own
+	 * interface so we have more flexibility in "user-space".
+	 * Those interfaces could be simply bridged in a trivial topology (which
+	 * happens automatically if wds_bridge is not an empty string), or feeded to
+	 * a routing daemon.
+	 *
+	 * If not defined interface names are generated following the WDS convention.
+	 */
+	char apup_peer_ifname_prefix[IFNAMSIZ + 1];
+#endif /* CONFIG_APUP */
 };
 
 /**
  * struct he_phy_capabilities_info - HE PHY capabilities
  */
 struct he_phy_capabilities_info {
+	bool he_ldpc;
 	bool he_su_beamformer;
 	bool he_su_beamformee;
 	bool he_mu_beamformer;
@@ -1066,6 +1111,7 @@ struct hostapd_config {
 	bool hw_mode_set;
 	int acs_exclude_6ghz_non_psc;
 	int enable_background_radar;
+	int background_radar_mode;
 	enum {
 		LONG_PREAMBLE = 0,
 		SHORT_PREAMBLE = 1
@@ -1085,6 +1131,8 @@ struct hostapd_config {
 	unsigned int track_sta_max_num;
 	unsigned int track_sta_max_age;
 
+	int max_num_sta;
+
 	char country[3]; /* first two octets: country code as described in
 			  * ISO/IEC 3166-1. Third octet:
 			  * ' ' (ascii 32): all environments
@@ -1122,6 +1170,8 @@ struct hostapd_config {
 
 	int ht_op_mode_fixed;
 	u16 ht_capab;
+	int noscan;
+	int no_ht_coex;
 	int ieee80211n;
 	int secondary_channel;
 	int no_pri_sec_switch;
@@ -1197,6 +1247,7 @@ struct hostapd_config {
 	int reg_def_cli_eirp;
 
 	bool require_he;
+	u8 mu_onoff;
 #endif /* CONFIG_IEEE80211AX */
 
 	/* VHT enable/disable config from CHAN_SWITCH */
@@ -1234,6 +1285,8 @@ struct hostapd_config {
 	u8 punct_acs_threshold;
 	u8 eht_default_pe_duration;
 	u8 eht_bw320_offset;
+	u8 eml_disable;
+	u8 eml_resp;
 #endif /* CONFIG_IEEE80211BE */
 
 	/* EHT enable/disable config from CHAN_SWITCH */
@@ -1249,8 +1302,131 @@ struct hostapd_config {
 
 	/* Whether to enable TWT responder in HT and VHT modes */
 	bool ht_vht_twt_responder;
+
+#ifdef CONFIG_AFC
+	struct {
+		char *socket;
+		struct {
+			char *version;
+			char *id;
+			char *sn;
+		} request;
+		unsigned int n_cert_ids;
+		struct cert_id {
+			char *rulset;
+			char *id;
+		} *cert_ids;
+		struct {
+			enum afc_location_type {
+				ELLIPSE,
+				LINEAR_POLYGON,
+				RADIAL_POLYGON,
+			} type;
+			unsigned int n_linear_polygon_data;
+			struct afc_linear_polygon {
+				double longitude;
+				double latitude;
+			} *linear_polygon_data;
+			unsigned int n_radial_polygon_data;
+			struct afc_radial_polygon {
+				double length;
+				double angle;
+			} *radial_polygon_data;
+			int major_axis;
+			int minor_axis;
+			int orientation;
+			double height;
+			char *height_type;
+			int vertical_tolerance;
+		} location;
+		unsigned int n_freq_range;
+		struct afc_freq_range {
+			int low_freq;
+			int high_freq;
+		} *freq_range;
+		unsigned int n_op_class;
+		unsigned int *op_class;
+		int min_power;
+		int max_timeout;
+	} afc;
+#endif /* CONFIG_AFC */
+
+	u8 edcca_enable;
+	s8 edcca_compensation;
+	int *edcca_threshold;
+	u8 three_wire_enable;
+	u8 ibf_enable;
+	u8 dfs_detect_mode;
+	u8 amsdu;
+	void *muru_config;
+	u8 pp_mode;
+	u8 lpi_psd;
+	u8 sku_idx;
+	u8 lpi_sku_idx;
+	u8 lpi_bcn_enhance;
+};
+
+enum three_wire_mode {
+	THREE_WIRE_MODE_DISABLE,
+	THREE_WIRE_MODE_EXT0_ENABLE,
+	THREE_WIRE_MODE_EXT1_ENABLE,
+	THREE_WIRE_MODE_ALL_ENABLE,
+
+	/* keep last */
+	NUM_THREE_WIRE_MODE,
+	THREE_WIRE_MODE_MAX =
+		NUM_THREE_WIRE_MODE - 1
+};
+
+enum background_radar_mode {
+	BACKGROUND_RADAR_NORMAL_MODE,
+	BACKGROUND_RADAR_CERT_MODE,
+};
+
+enum dfs_mode {
+	DFS_DETECT_MODE_DISABLE,
+	DFS_DETECT_MODE_AP_ENABLE,
+	DFS_DETECT_MODE_BACKGROUND_ENABLE,
+	DFS_DETECT_MODE_ALL_ENABLE,
+
+	/* keep last */
+	NUM_DFS_DETECT_MODE,
+	DFS_DETECT_MODE_MAX =
+		NUM_DFS_DETECT_MODE - 1
+};
+
+enum edcca_mode {
+	EDCCA_MODE_FORCE_DISABLE = 0,
+	EDCCA_MODE_AUTO = 1,
+};
+
+enum edcca_bw_id {
+	EDCCA_BW_20 = 0,
+	EDCCA_BW_40,
+	EDCCA_BW_80,
+	EDCCA_BW_160,
+	EDCCA_MAX_BW_NUM,
+};
+
+enum mtk_vendor_attr_edcca_ctrl_mode {
+	EDCCA_CTRL_SET_EN = 0,
+	EDCCA_CTRL_SET_THRES,
+	EDCCA_CTRL_GET_EN,
+	EDCCA_CTRL_GET_THRES,
+	EDCCA_CTRL_NUM,
+};
+
+enum pp_mode {
+	PP_DISABLE = 0,
+	PP_FW_MODE,
+	PP_USR_MODE,
 };
 
+#define EDCCA_DEFAULT_COMPENSATION -6
+#define EDCCA_MIN_COMPENSATION -126
+#define EDCCA_MAX_COMPENSATION 126
+#define EDCCA_MIN_CONFIG_THRES -126
+#define EDCCA_MAX_CONFIG_THRES 0
 
 static inline enum oper_chan_width
 hostapd_get_oper_chwidth(struct hostapd_config *conf)
@@ -1374,6 +1550,7 @@ hostapd_set_and_check_bw320_offset(struct hostapd_config *conf,
 #endif /* CONFIG_IEEE80211BE */
 }
 
+#define IBF_DEFAULT_ENABLE 0
 
 int hostapd_mac_comp(const void *a, const void *b);
 struct hostapd_config * hostapd_config_defaults(void);
diff --git a/src/ap/ap_drv_ops.c b/src/ap/ap_drv_ops.c
index dc1f748..ecf95c1 100644
--- a/src/ap/ap_drv_ops.c
+++ b/src/ap/ap_drv_ops.c
@@ -23,6 +23,10 @@
 #include "wpa_auth.h"
 #include "ap_drv_ops.h"
 
+#ifdef CONFIG_IEEE80211BE
+#include "scs.h"
+#endif
+
 
 u32 hostapd_sta_flags_to_drv(u32 flags)
 {
@@ -332,6 +336,13 @@ int hostapd_set_sta_flags(struct hostapd_data *hapd, struct sta_info *sta)
 		return 0;
 	}
 
+	if (hapd->conf->mld_ap && hapd->mld->removed_links) {
+		wpa_printf(MSG_DEBUG,
+			   "%s: Do not update station flags (" MACSTR ")",
+			   " during ap link removal", __func__, MAC2STR(sta->addr));
+		return 0;
+	}
+
 	flags_or = total_flags & set_flags;
 	flags_and = total_flags | ~set_flags;
 	return hostapd_sta_set_flags(hapd, sta->addr, total_flags,
@@ -370,8 +381,19 @@ int hostapd_vlan_if_add(struct hostapd_data *hapd, const char *ifname)
 {
 	char force_ifname[IFNAMSIZ];
 	u8 if_addr[ETH_ALEN];
+	u32 radio_mask = 0;
+
+#ifdef CONFIG_IEEE80211BE
+	if (hapd->iface->current_hw_info) {
+		if (hapd->conf->mld_ap)
+			radio_mask = hapd->conf->mld_radio_mask;
+		else
+			radio_mask = 1 << hapd->iface->current_hw_info->hw_idx;
+	}
+#endif /* CONFIG_IEEE80211BE */
+
 	return hostapd_if_add(hapd, WPA_IF_AP_VLAN, ifname, hapd->own_addr,
-			      NULL, NULL, force_ifname, if_addr, NULL, 0);
+			      NULL, NULL, force_ifname, if_addr, NULL, 0, hapd->iface->freq, radio_mask);
 }
 
 
@@ -385,15 +407,39 @@ int hostapd_set_wds_sta(struct hostapd_data *hapd, char *ifname_wds,
 			const u8 *addr, int aid, int val)
 {
 	const char *bridge = NULL;
+	char ifName[IFNAMSIZ + 1] = {0};
+
+	int mRet = 0;
 
 	if (hapd->driver == NULL || hapd->driver->set_wds_sta == NULL)
 		return -1;
+
+#ifdef CONFIG_APUP
+	if (hapd->conf->apup && hapd->conf->apup_peer_ifname_prefix[0]) {
+		mRet = os_snprintf(
+		            ifName, sizeof(ifName), "%s%d",
+		            hapd->conf->apup_peer_ifname_prefix, aid);
+	}
+	else
+#endif // def CONFIG_APUP
+		mRet = os_snprintf(
+		            ifName, sizeof(ifName), "%s.sta%d",
+		            hapd->conf->iface, aid);
+
+	if (mRet >= (int) sizeof(ifName))
+		wpa_printf(MSG_WARNING,
+		           "nl80211: WDS interface name was truncated");
+	else if (mRet < 0)
+		return mRet;
+
+	// Pass back to the caller the resulting interface name
+	if (ifname_wds)
+		os_strlcpy(ifname_wds, ifName, IFNAMSIZ + 1);
+
 	if (hapd->conf->wds_bridge[0])
 		bridge = hapd->conf->wds_bridge;
-	else if (hapd->conf->bridge[0])
-		bridge = hapd->conf->bridge;
 	return hapd->driver->set_wds_sta(hapd->drv_priv, addr, aid, val,
-					 bridge, ifname_wds);
+					 bridge, ifName);
 }
 
 
@@ -472,7 +518,8 @@ int hostapd_sta_add(struct hostapd_data *hapd,
 		    size_t eht_capab_len,
 		    const struct ieee80211_he_6ghz_band_cap *he_6ghz_capab,
 		    u32 flags, u8 qosinfo, u8 vht_opmode, int supp_p2p_ps,
-		    int set, const u8 *link_addr, bool mld_link_sta)
+		    int set, const u8 *link_addr, bool mld_link_sta,
+		    u16 eml_capa)
 {
 	struct hostapd_sta_add_params params;
 
@@ -512,6 +559,7 @@ int hostapd_sta_add(struct hostapd_data *hapd,
 		params.mld_link_id = hapd->mld_link_id;
 		params.mld_link_addr = link_addr;
 		params.mld_link_sta = mld_link_sta;
+		params.eml_capa = eml_capa;
 	}
 #endif /* CONFIG_IEEE80211BE */
 
@@ -565,13 +613,13 @@ int hostapd_set_ssid(struct hostapd_data *hapd, const u8 *buf, size_t len)
 int hostapd_if_add(struct hostapd_data *hapd, enum wpa_driver_if_type type,
 		   const char *ifname, const u8 *addr, void *bss_ctx,
 		   void **drv_priv, char *force_ifname, u8 *if_addr,
-		   const char *bridge, int use_existing)
+		   const char *bridge, int use_existing, int freq, u32 radio_mask)
 {
 	if (hapd->driver == NULL || hapd->driver->if_add == NULL)
 		return -1;
 	return hapd->driver->if_add(hapd->drv_priv, type, ifname, addr,
 				    bss_ctx, drv_priv, force_ifname, if_addr,
-				    bridge, use_existing, 1);
+				    bridge, use_existing, 1, freq, radio_mask);
 }
 
 
@@ -586,6 +634,15 @@ int hostapd_if_link_remove(struct hostapd_data *hapd,
 	return hapd->driver->link_remove(hapd->drv_priv, type, ifname,
 					 hapd->mld_link_id);
 }
+
+
+int hostapd_drv_set_attlm(struct hostapd_data *hapd)
+{
+	if (!hapd->driver || !hapd->drv_priv || !hapd->driver->set_attlm)
+		return -1;
+
+	return hapd->driver->set_attlm(hapd->drv_priv, &hapd->mld->new_attlm);
+}
 #endif /* CONFIG_IEEE80211BE */
 
 
@@ -878,8 +935,12 @@ int hostapd_drv_sta_deauth(struct hostapd_data *hapd,
 	if (hapd->conf->mld_ap) {
 		struct sta_info *sta = ap_get_sta(hapd, addr);
 
-		link_id = hapd->mld_link_id;
-		if (ap_sta_is_mld(hapd, sta))
+		if (sta)
+			link_id = sta->mld_assoc_link_id;
+		else
+			link_id = hapd->mld_link_id;
+
+		if (ap_sta_is_mld(hapd, sta) || is_multicast_ether_addr(addr))
 			own_addr = hapd->mld->mld_addr;
 	}
 #endif /* CONFIG_IEEE80211BE */
@@ -900,7 +961,7 @@ int hostapd_drv_sta_disassoc(struct hostapd_data *hapd,
 	if (hapd->conf->mld_ap) {
 		struct sta_info *sta = ap_get_sta(hapd, addr);
 
-		if (ap_sta_is_mld(hapd, sta))
+		if (ap_sta_is_mld(hapd, sta) || is_multicast_ether_addr(addr))
 			own_addr = hapd->mld->mld_addr;
 	}
 #endif /* CONFIG_IEEE80211BE */
@@ -1039,6 +1100,15 @@ int hostapd_start_dfs_cac(struct hostapd_iface *iface,
 		return -1;
 	}
 	data.radar_background = radar_background;
+	data.link_id = -1;
+
+#ifdef CONFIG_IEEE80211BE
+	if (hapd->conf->mld_ap) {
+		data.link_id = hapd->mld_link_id;
+		wpa_printf(MSG_DEBUG,
+			   "hostapd_start_dfs_cac: link_id=%d", data.link_id);
+	}
+#endif /* CONFIG_IEEE80211BE */
 
 	data.link_id = -1;
 #ifdef CONFIG_IEEE80211BE
@@ -1289,3 +1359,303 @@ hostapd_get_multi_hw_info(struct hostapd_data *hapd,
 
 	return hapd->driver->get_multi_hw_info(hapd->drv_priv, num_multi_hws);
 }
+
+
+int hostapd_drv_configure_edcca_enable(struct hostapd_data *hapd)
+{
+	if (!hapd->driver || !hapd->driver->configure_edcca_enable)
+		return 0;
+	return hapd->driver->configure_edcca_enable(hapd->drv_priv,
+			hapd->iconf->edcca_enable,
+				hapd->iconf->edcca_compensation);
+}
+
+int hostapd_drv_configure_edcca_threshold(struct hostapd_data *hapd,
+					  const int *threshold)
+{
+	if (!hapd->driver || !hapd->driver->configure_edcca_threshold)
+		return 0;
+	return hapd->driver->configure_edcca_threshold(hapd->drv_priv, threshold);
+}
+
+int hostapd_drv_get_edcca(struct hostapd_data *hapd, const u8 mode, u8 *value)
+{
+	if (!hapd->driver || !hapd->driver->get_edcca)
+		return 0;
+	return hapd->driver->get_edcca(hapd->drv_priv, mode, value);
+}
+
+int hostapd_drv_mu_ctrl(struct hostapd_data *hapd, u8 mode)
+{
+	s8 link_id = -1;
+
+	if (!hapd->driver || !hapd->driver->mu_ctrl)
+		return 0;
+
+	if (hapd->conf->mld_ap)
+		link_id = hapd->mld_link_id;
+
+	return hapd->driver->mu_ctrl(hapd->drv_priv, mode, link_id);
+}
+
+int hostapd_drv_mu_dump(struct hostapd_data *hapd, u8 *mu_onoff)
+{
+	s8 link_id = -1;
+
+	if (!hapd->driver || !hapd->driver->mu_dump)
+		return 0;
+
+	if (hapd->conf->mld_ap)
+		link_id = hapd->mld_link_id;
+
+	return hapd->driver->mu_dump(hapd->drv_priv, mu_onoff, link_id);
+}
+
+int hostapd_drv_three_wire_ctrl(struct hostapd_data *hapd)
+{
+	if (!hapd->driver || !hapd->driver->three_wire_ctrl)
+		return 0;
+	if (hapd->iconf->three_wire_enable > THREE_WIRE_MODE_MAX) {
+		wpa_printf(MSG_INFO, "Invalid value for three wire enable\n");
+		return 0;
+	}
+	return hapd->driver->three_wire_ctrl(hapd->drv_priv, hapd->iconf->three_wire_enable);
+}
+
+int hostapd_drv_ibf_ctrl(struct hostapd_data *hapd)
+{
+	if (!hapd->driver || !hapd->driver->ibf_ctrl)
+		return 0;
+	return hapd->driver->ibf_ctrl(hapd->drv_priv, hapd->iconf->ibf_enable);
+}
+
+int hostapd_drv_ibf_dump(struct hostapd_data *hapd, u8 *ibf_enable)
+{
+	if (!hapd->driver || !hapd->driver->ibf_dump)
+		return 0;
+	return hapd->driver->ibf_dump(hapd->drv_priv, ibf_enable);
+}
+
+int hostapd_drv_amsdu_ctrl(struct hostapd_data *hapd)
+{
+	if (!hapd->driver || !hapd->driver->amsdu_ctrl)
+		return 0;
+	return hapd->driver->amsdu_ctrl(hapd->drv_priv, hapd->iconf->amsdu);
+}
+
+int hostapd_drv_amsdu_dump(struct hostapd_data *hapd, u8 *amsdu)
+{
+	if (!hapd->driver || !hapd->driver->amsdu_dump)
+		return 0;
+	return hapd->driver->amsdu_dump(hapd->drv_priv, amsdu);
+}
+
+int hostapd_drv_get_aval_bss_color_bmp(struct hostapd_data *hapd, u64 *aval_color_bmp)
+{
+	if (!hapd->driver || !hapd->driver->get_aval_color_bmp ||
+	    hapd->iface->conf->he_op.he_bss_color_disabled)
+		return 0;
+	return hapd->driver->get_aval_color_bmp(hapd->drv_priv, aval_color_bmp);
+}
+
+int hostapd_drv_txpower_ctrl(struct hostapd_data *hapd)
+{
+	s8 link_id = -1, sku_idx = hapd->iconf->sku_idx, ret = 0, i;
+	s8 **afc_power_table = NULL;
+	bool lpi_mode = false;
+
+	if (!hapd->driver || !hapd->driver->txpower_ctrl)
+		return 0;
+
+	if (hapd->conf->mld_ap)
+		link_id = hapd->mld_link_id;
+
+#ifdef CONFIG_AFC
+	lpi_mode = hapd->iface->afc.lpi_mode;
+	if (hapd->iface->current_mode->is_6ghz &&
+	    he_reg_is_sp(hapd->iface->conf->he_6ghz_reg_pwr_type) &&
+	    !hapd->iface->afc.lpi_mode) {
+		ret = hostapd_afc_translate_table(hapd->iface, &afc_power_table);
+		if (ret)
+			goto out;
+	}
+
+	if (hapd->iface->afc.lpi_mode == true)
+		sku_idx = hapd->iconf->lpi_sku_idx;
+#endif /* CONFIG_AFC */
+
+	ret = hapd->driver->txpower_ctrl(hapd->drv_priv, hapd->iconf->lpi_psd,
+					 sku_idx,
+					 hapd->iconf->lpi_bcn_enhance,
+					 link_id,
+					 afc_power_table,
+					 lpi_mode);
+out:
+#ifdef CONFIG_AFC
+	if (afc_power_table)
+		for (i = 0; i < MAX_CHANNEL_NUM_6G; i++)
+			os_free(afc_power_table[i]);
+	os_free(afc_power_table);
+#endif /* CONFIG_AFC */
+	return ret;
+}
+
+int hostapd_drv_ap_wireless(struct hostapd_data *hapd, u8 sub_vendor_id, int value)
+{
+	s8 link_id = -1;
+
+	if (!hapd->driver || !hapd->driver->ap_wireless)
+		return 0;
+
+	if (hapd->conf->mld_ap)
+		link_id = hapd->mld_link_id;
+
+	return hapd->driver->ap_wireless(hapd->drv_priv, sub_vendor_id, value,
+					 link_id);
+}
+
+int hostapd_drv_ap_rfeatures(struct hostapd_data *hapd, u8 sub_vendor_id, int value)
+{
+	s8 link_id = -1;
+
+	if (!hapd->driver || !hapd->driver->ap_rfeatures)
+		return 0;
+
+	if (hapd->conf->mld_ap)
+		link_id = hapd->mld_link_id;
+
+	return hapd->driver->ap_rfeatures(hapd->drv_priv, sub_vendor_id, value,
+					  link_id);
+}
+
+int hostapd_drv_ap_trig_type(struct hostapd_data *hapd, u8 enable, u8 type)
+{
+	s8 link_id = -1;
+
+	if (!hapd->driver || !hapd->driver->ap_trigtype)
+		return 0;
+
+	if (hapd->conf->mld_ap)
+		link_id = hapd->mld_link_id;
+
+	return hapd->driver->ap_trigtype(hapd->drv_priv, enable, type,
+					 link_id);
+}
+
+int hostapd_drv_amnt_set(struct hostapd_data *hapd, u8 amnt_idx, u8 *amnt_sta_mac)
+{
+	s8 link_id = -1;
+
+	if (!hapd->driver || !hapd->driver->amnt_set)
+		return 0;
+
+	if (hapd->conf->mld_ap)
+		link_id = hapd->mld_link_id;
+
+	return hapd->driver->amnt_set(hapd->drv_priv, amnt_idx, amnt_sta_mac,
+				      link_id);
+}
+
+int hostapd_drv_amnt_dump(struct hostapd_data *hapd, u8 amnt_idx, u8 *amnt_dump_buf)
+{
+	s8 link_id = -1;
+
+	if (!hapd->driver || !hapd->driver->amnt_dump)
+		return 0;
+
+	if (hapd->conf->mld_ap)
+		link_id = hapd->mld_link_id;
+
+	return hapd->driver->amnt_dump(hapd->drv_priv, amnt_idx, amnt_dump_buf,
+				       link_id);
+}
+
+int hostapd_drv_background_radar_mode(struct hostapd_data *hapd)
+{
+	if (!hapd->driver || !hapd->driver->background_radar_mode ||
+	    !(hapd->iface->drv_flags2 & WPA_DRIVER_FLAGS2_RADAR_BACKGROUND) ||
+	    !hapd->iface->conf->enable_background_radar)
+		return 0;
+	if (hapd->iconf->background_radar_mode > BACKGROUND_RADAR_CERT_MODE) {
+		wpa_printf(MSG_INFO, "Invalid value for background radar mode\n");
+		return 0;
+	}
+	return hapd->driver->background_radar_mode(hapd->drv_priv,
+						   hapd->iconf->background_radar_mode);
+}
+
+int hostapd_drv_pp_mode_set(struct hostapd_data *hapd)
+{
+	s8 link_id = -1;
+
+	if (!hapd->driver || !hapd->driver->pp_mode_set ||
+	    hapd->iconf->pp_mode > PP_USR_MODE ||
+	    hapd->iface->current_mode->mode != HOSTAPD_MODE_IEEE80211A)
+		return 0;
+
+	if (hapd->conf->mld_ap)
+		link_id = hapd->mld_link_id;
+
+	return hapd->driver->pp_mode_set(hapd->drv_priv,
+					 hapd->iconf->pp_mode,
+					 link_id,
+					 hapd->iconf->punct_bitmap);
+}
+
+int hostapd_drv_beacon_ctrl(struct hostapd_data *hapd, u8 beacon_mode)
+{
+	if (!hapd->driver || !hapd->driver->beacon_ctrl)
+		return 0;
+	return hapd->driver->beacon_ctrl(hapd->drv_priv, beacon_mode);
+}
+
+int hostapd_drv_set_eml_omn(struct hostapd_data *hapd, u8 *mac,
+			    struct eml_omn_element *omn_ie)
+{
+	u8 link_id;
+
+	if (!hapd->driver || !hapd->driver->set_eml_omn)
+		return 0;
+
+	if (!hapd->conf->mld_ap)
+		return 0;
+
+	link_id = hapd->mld_link_id;
+
+	return hapd->driver->set_eml_omn(hapd->drv_priv, link_id, mac, omn_ie);
+}
+
+int hostapd_drv_csi_set(struct hostapd_data *hapd, u8 mode, u8 cfg, u8 v1, u32 v2, u8 *mac)
+{
+	s8 link_id = -1;
+
+	if (!hapd->driver || !hapd->driver->csi_set)
+		return 0;
+
+	if (hapd->conf->mld_ap)
+		link_id = hapd->mld_link_id;
+
+	return hapd->driver->csi_set(hapd->drv_priv, link_id, mode, cfg, v1, v2, mac);
+}
+
+int hostapd_drv_csi_dump(struct hostapd_data *hapd, void *dump_buf)
+{
+	s8 link_id = -1;
+
+	if (!hapd->driver || !hapd->driver->csi_dump)
+		return 0;
+
+	if (hapd->conf->mld_ap)
+		link_id = hapd->mld_link_id;
+
+	return hapd->driver->csi_dump(hapd->drv_priv, link_id, dump_buf);
+}
+
+#ifdef CONFIG_IEEE80211BE
+int hostapd_drv_set_scs(struct hostapd_data *hapd, struct hostapd_scs_desc_info *info)
+{
+	if (!hapd->driver || !hapd->driver->set_scs)
+		return 0;
+	return hapd->driver->set_scs(hapd->drv_priv, info, hapd->mld_link_id);
+}
+#endif
diff --git a/src/ap/ap_drv_ops.h b/src/ap/ap_drv_ops.h
index 34f7fb7..d03b99b 100644
--- a/src/ap/ap_drv_ops.h
+++ b/src/ap/ap_drv_ops.h
@@ -35,6 +35,9 @@ int hostapd_set_drv_ieee8021x(struct hostapd_data *hapd, const char *ifname,
 			      int enabled);
 int hostapd_vlan_if_add(struct hostapd_data *hapd, const char *ifname);
 int hostapd_vlan_if_remove(struct hostapd_data *hapd, const char *ifname);
+
+/** @param val as per nl80211 driver implementation, 1 means add 0 means remove
+ */
 int hostapd_set_wds_sta(struct hostapd_data *hapd, char *ifname_wds,
 			const u8 *addr, int aid, int val);
 int hostapd_sta_add(struct hostapd_data *hapd,
@@ -49,7 +52,8 @@ int hostapd_sta_add(struct hostapd_data *hapd,
 		    size_t eht_capab_len,
 		    const struct ieee80211_he_6ghz_band_cap *he_6ghz_capab,
 		    u32 flags, u8 qosinfo, u8 vht_opmode, int supp_p2p_ps,
-		    int set, const u8 *link_addr, bool mld_link_sta);
+		    int set, const u8 *link_addr, bool mld_link_sta,
+		    u16 eml_capa);
 int hostapd_set_privacy(struct hostapd_data *hapd, int enabled);
 int hostapd_set_generic_elem(struct hostapd_data *hapd, const u8 *elem,
 			     size_t elem_len);
@@ -58,12 +62,13 @@ int hostapd_set_ssid(struct hostapd_data *hapd, const u8 *buf, size_t len);
 int hostapd_if_add(struct hostapd_data *hapd, enum wpa_driver_if_type type,
 		   const char *ifname, const u8 *addr, void *bss_ctx,
 		   void **drv_priv, char *force_ifname, u8 *if_addr,
-		   const char *bridge, int use_existing);
+		   const char *bridge, int use_existing, int freq, u32 radio_mask);
 int hostapd_if_remove(struct hostapd_data *hapd, enum wpa_driver_if_type type,
 		      const char *ifname);
 int hostapd_if_link_remove(struct hostapd_data *hapd,
 			   enum wpa_driver_if_type type,
 			   const char *ifname, u8 link_id);
+int hostapd_drv_set_attlm(struct hostapd_data *hapd);
 int hostapd_set_ieee8021x(struct hostapd_data *hapd,
 			  struct wpa_bss_params *params);
 int hostapd_get_seqnum(const char *ifname, struct hostapd_data *hapd,
@@ -154,6 +159,32 @@ int hostapd_drv_set_secure_ranging_ctx(struct hostapd_data *hapd,
 				       u8 ltf_keyseed_len,
 				       const u8 *ltf_keyseed, u32 action);
 
+int hostapd_drv_configure_edcca_enable(struct hostapd_data *hapd);
+int hostapd_drv_configure_edcca_threshold(struct hostapd_data *hapd,
+					  const int *threshold);
+int hostapd_drv_get_edcca(struct hostapd_data *hapd, const u8 mode, u8 *value);
+int hostapd_drv_mu_ctrl(struct hostapd_data *hapd, u8 mode);
+int hostapd_drv_mu_dump(struct hostapd_data *hapd, u8 *mu_onoff);
+int hostapd_drv_three_wire_ctrl(struct hostapd_data *hapd);
+int hostapd_drv_ibf_ctrl(struct hostapd_data *hapd);
+int hostapd_drv_ibf_dump(struct hostapd_data *hapd, u8 *ibf_enable);
+int hostapd_drv_amsdu_ctrl(struct hostapd_data *hapd);
+int hostapd_drv_amsdu_dump(struct hostapd_data *hapd, u8 *amsdu);
+int hostapd_drv_get_aval_bss_color_bmp(struct hostapd_data *hapd,
+				       u64 *aval_color_bmp);
+int hostapd_drv_txpower_ctrl(struct hostapd_data *hapd);
+int hostapd_drv_ap_wireless(struct hostapd_data *hapd, u8 sub_vendor_id, int value);
+int hostapd_drv_ap_rfeatures(struct hostapd_data *hapd, u8 sub_vendor_id, int value);
+int hostapd_drv_ap_trig_type(struct hostapd_data *hapd, u8 enable, u8 type);
+
+int hostapd_drv_amnt_set(struct hostapd_data *hapd, u8 amnt_idx, u8 *amnt_sta_mac);
+int hostapd_drv_amnt_dump(struct hostapd_data *hapd, u8 amnt_idx, u8 *amnt_dump_buf);
+int hostapd_drv_background_radar_mode(struct hostapd_data *hapd);
+int hostapd_drv_pp_mode_set(struct hostapd_data *hapd);
+int hostapd_drv_beacon_ctrl(struct hostapd_data *hapd, u8 beacon_mode);
+int hostapd_drv_set_eml_omn(struct hostapd_data *hapd, u8 *mac, struct eml_omn_element *omn_ie);
+int hostapd_drv_csi_set(struct hostapd_data *hapd, u8 mode, u8 cfg, u8 v1, u32 v2, u8 *mac);
+int hostapd_drv_csi_dump(struct hostapd_data *hapd, void *dump_buf);
 
 #include "drivers/driver.h"
 
@@ -164,6 +195,11 @@ int hostapd_drv_wnm_oper(struct hostapd_data *hapd,
 int hostapd_drv_set_qos_map(struct hostapd_data *hapd, const u8 *qos_map_set,
 			    u8 qos_map_set_len);
 
+#ifdef CONFIG_IEEE80211BE
+int hostapd_drv_set_scs(struct hostapd_data *hapd,
+			struct hostapd_scs_desc_info *info);
+#endif
+
 void hostapd_get_ext_capa(struct hostapd_iface *iface);
 void hostapd_get_mld_capa(struct hostapd_iface *iface);
 
@@ -292,11 +328,17 @@ static inline void hostapd_drv_poll_client(struct hostapd_data *hapd,
 static inline int hostapd_drv_get_survey(struct hostapd_data *hapd,
 					 unsigned int freq)
 {
+	int link_id = -1;
+
 	if (hapd->driver == NULL)
 		return -1;
 	if (!hapd->driver->get_survey)
 		return -1;
-	return hapd->driver->get_survey(hapd->drv_priv, freq);
+#ifdef CONFIG_IEEE80211BE
+	if (hapd->conf->mld_ap)
+		link_id = hapd->mld_link_id;
+#endif /* CONFIG_IEEE80211BE */
+	return hapd->driver->get_survey(hapd->drv_priv, freq, link_id);
 }
 
 static inline int hostapd_get_country(struct hostapd_data *hapd, char *alpha2)
@@ -314,6 +356,16 @@ static inline const char * hostapd_drv_get_radio_name(struct hostapd_data *hapd)
 	return hapd->driver->get_radio_name(hapd->drv_priv);
 }
 
+static inline int hostapd_drv_move_bss_to_first(struct hostapd_data *hapd,
+						const char *ifname)
+{
+	if (hapd->driver == NULL || hapd->driver->move_bss_to_first == NULL ||
+	    hapd->drv_priv == NULL)
+		return -1;
+
+	return hapd->driver->move_bss_to_first(hapd->drv_priv, ifname);
+}
+
 static inline int hostapd_drv_switch_channel(struct hostapd_data *hapd,
 					     struct csa_settings *settings)
 {
@@ -376,12 +428,12 @@ static inline int hostapd_drv_br_port_set_attr(struct hostapd_data *hapd,
 
 static inline int hostapd_drv_br_set_net_param(struct hostapd_data *hapd,
 					       enum drv_br_net_param param,
-					       unsigned int val)
+					       const char *ifname, unsigned int val)
 {
 	if (hapd->driver == NULL || hapd->drv_priv == NULL ||
 	    hapd->driver->br_set_net_param == NULL)
 		return -1;
-	return hapd->driver->br_set_net_param(hapd->drv_priv, param, val);
+	return hapd->driver->br_set_net_param(hapd->drv_priv, param, ifname, val);
 }
 
 static inline int hostapd_drv_vendor_cmd(struct hostapd_data *hapd,
@@ -409,6 +461,23 @@ static inline int hostapd_drv_stop_ap(struct hostapd_data *hapd)
 	return hapd->driver->stop_ap(hapd->drv_priv, link_id);
 }
 
+static inline int hostapd_drv_if_rename(struct hostapd_data *hapd,
+					enum wpa_driver_if_type type,
+					const char *ifname,
+					const char *new_name)
+{
+	if (!hapd->driver || !hapd->driver->if_rename || !hapd->drv_priv)
+		return -1;
+	return hapd->driver->if_rename(hapd->drv_priv, type, ifname, new_name);
+}
+
+static inline int hostapd_drv_set_first_bss(struct hostapd_data *hapd)
+{
+	if (!hapd->driver || !hapd->driver->set_first_bss || !hapd->drv_priv)
+		return 0;
+	return hapd->driver->set_first_bss(hapd->drv_priv);
+}
+
 static inline int hostapd_drv_channel_info(struct hostapd_data *hapd,
 					   struct wpa_channel_info *ci)
 {
diff --git a/src/ap/apup.c b/src/ap/apup.c
new file mode 100644
index 0000000..cb0264e
--- /dev/null
+++ b/src/ap/apup.c
@@ -0,0 +1,168 @@
+/*
+ * hostapd / APuP Access Point Micro Peering
+ *
+ * Copyright (C) 2023-2024  Gioacchino Mazzurco <gio@polymathes.cc>
+ *
+ * This software may be distributed under the terms of the BSD license.
+ * See README for more details.
+ */
+
+/* Be extremely careful altering include order, move just one in the wrong place
+ * and you will start getting a bunch of error of undefined bool, size_t etc. */
+
+#include "utils/includes.h"
+#include "utils/common.h"
+#include "utils/os.h"
+
+#include "apup.h"
+
+#include "drivers/driver.h"
+#include "wpa_auth.h"
+#include "ap_mlme.h"
+#include "ieee802_11.h"
+#include "ap_drv_ops.h"
+#include "sta_info.h"
+
+#ifdef UBUS_SUPPORT
+#	include "ubus.h"
+#endif
+
+#ifdef UCODE_SUPPORT
+#	include "ucode.h"
+#endif
+
+void apup_process_beacon(struct hostapd_data *hapd,
+              const struct ieee80211_mgmt *mgmt, size_t len,
+              const struct ieee802_11_elems *elems )
+{
+	if (!os_memcmp(hapd->own_addr, mgmt->bssid, ETH_ALEN))
+	{
+		wpa_printf(MSG_WARNING,
+		           "apup_process_beacon(...) own beacon elems.ssid %.*s",
+		           (int) elems->ssid_len, elems->ssid);
+		return;
+	}
+
+	if (elems->ssid_len != hapd->conf->ssid.ssid_len ||
+	        os_memcmp(elems->ssid, hapd->conf->ssid.ssid, elems->ssid_len))
+		return;
+
+	struct sta_info* sta_ret = ap_get_sta(hapd, mgmt->bssid);
+	if (sta_ret)
+		return;
+
+	sta_ret = ap_sta_add(hapd, mgmt->bssid);
+
+	/* TODO: this has been added just to making compiler happy after breaking
+	 * changes introduced in 11a607d121df512e010148bedcb4263a03329dc7 to support
+	 * IEEE80211BE Multi Link Operation. Look at that commit with more time and
+	 * understand what could be a proper implementation in this context too
+	 */
+	const u8 *mld_link_addr = NULL;
+	bool mld_link_sta = false;
+
+	/* First add the station without more information */
+	int aRet = hostapd_sta_add(
+	            hapd, mgmt->bssid, sta_ret->aid, 0,
+	            NULL, 0, 0, NULL, NULL, NULL, 0, NULL, 0, NULL,
+	            sta_ret->flags, 0, 0, 0,
+	            0, // 0 add, 1 set
+	            mld_link_addr, mld_link_sta, 0);
+
+	sta_ret->flags |= WLAN_STA_AUTH;
+	wpa_auth_sm_event(sta_ret->wpa_sm, WPA_AUTH);
+
+	/* TODO: Investigate if supporting WPA or other encryption method is
+	 * possible */
+	sta_ret->auth_alg = WLAN_AUTH_OPEN;
+	mlme_authenticate_indication(hapd, sta_ret);
+
+	sta_ret->capability = le_to_host16(mgmt->u.beacon.capab_info);
+
+	if (sta_ret->capability & WLAN_CAPABILITY_SHORT_PREAMBLE)
+		sta_ret->flags |= WLAN_STA_SHORT_PREAMBLE;
+	else
+		sta_ret->flags &= ~WLAN_STA_SHORT_PREAMBLE;
+
+	hostapd_copy_supp_rates(hapd, sta_ret, elems);
+
+	/* Whithout this flag copy_sta_[v]ht_capab will disable [V]HT
+	 * capabilities even if available */
+	if (elems->ht_capabilities || elems->vht_capabilities)
+		sta_ret->flags |= WLAN_STA_WMM;
+
+	copy_sta_ht_capab(hapd, sta_ret, elems->ht_capabilities);
+#ifdef CONFIG_IEEE80211AC
+	copy_sta_vht_capab(hapd, sta_ret, elems->vht_capabilities);
+	copy_sta_vht_oper(hapd, sta_ret, elems->vht_operation);
+	copy_sta_vendor_vht(hapd, sta_ret, elems->vendor_vht, elems->vendor_vht_len);
+#endif // def CONFIG_IEEE80211AC
+#ifdef CONFIG_IEEE80211AX
+	copy_sta_he_capab(hapd, sta_ret, IEEE80211_MODE_AP,
+	                  elems->he_capabilities, elems->he_capabilities_len);
+	copy_sta_he_6ghz_capab(hapd, sta_ret,  elems->he_6ghz_band_cap);
+#endif // def CONFIG_IEEE80211AX
+#ifdef CONFIG_IEEE80211BE
+	copy_sta_eht_capab(hapd, sta_ret,
+	                   IEEE80211_MODE_AP, // TODO: Make sure is the right value
+	                   elems->he_capabilities, elems->he_capabilities_len,
+	                   elems->eht_capabilities, elems->eht_capabilities_len);
+#endif //def CONFIG_IEEE80211BE
+
+	update_ht_state(hapd, sta_ret);
+
+	if (hostapd_get_aid(hapd, sta_ret) < 0)
+	{
+		wpa_printf(MSG_INFO, "apup_process_beacon(...) No room for more AIDs");
+		return;
+	}
+
+	sta_ret->flags |= WLAN_STA_ASSOC_REQ_OK;
+
+	/* Make sure that the previously registered inactivity timer will not
+	 * remove the STA immediately. */
+	sta_ret->timeout_next = STA_NULLFUNC;
+
+	sta_ret->flags |= WLAN_STA_AUTH | WLAN_STA_ASSOC;
+
+	/* Then set the paramethers */
+	int sRet = hostapd_sta_add(
+	            hapd, mgmt->bssid, sta_ret->aid,
+	            sta_ret->capability,
+	            sta_ret->supported_rates, sta_ret->supported_rates_len,
+	            0, // u16 listen_interval TODO ?
+	            sta_ret->ht_capabilities,
+	            sta_ret->vht_capabilities,
+	            sta_ret->he_capab, sta_ret->he_capab_len,
+	            sta_ret->eht_capab, sta_ret->eht_capab_len,
+	            sta_ret->he_6ghz_capab,
+	            sta_ret->flags,
+	            0, // u8 qosinfo
+	            sta_ret->vht_opmode,
+	            0, // int supp_p2p_ps
+	            1, // 0 add, 1 set
+	            mld_link_addr, mld_link_sta, 0);
+
+	ap_sta_set_authorized(hapd, sta_ret, 1);
+	hostapd_set_sta_flags(hapd, sta_ret);
+
+	char mIfname[IFNAMSIZ + 1];
+	os_memset(mIfname, 0, IFNAMSIZ + 1);
+
+	// last param 1 means add 0 means remove
+	int mRet = hostapd_set_wds_sta(
+	            hapd, mIfname, mgmt->bssid, sta_ret->aid, 1);
+
+	wpa_printf(MSG_INFO,
+	           "apup_process_beacon(...) Added APuP peer at %s with flags: %d,"
+	           " capabilities %d",
+	           mIfname, sta_ret->flags, sta_ret->capability);
+
+#ifdef UBUS_SUPPORT
+	hostapd_ubus_notify_apup_newpeer(hapd, mgmt->bssid, mIfname);
+#endif
+
+#ifdef UCODE_SUPPORT
+	hostapd_ucode_apup_newpeer(hapd, mIfname);
+#endif
+}
diff --git a/src/ap/apup.h b/src/ap/apup.h
new file mode 100644
index 0000000..a14a283
--- /dev/null
+++ b/src/ap/apup.h
@@ -0,0 +1,24 @@
+/*
+ * hostapd / APuP Access Point Micro Peering
+ *
+ * Copyright (C) 2023-2024  Gioacchino Mazzurco <gio@polymathes.cc>
+ *
+ * This software may be distributed under the terms of the BSD license.
+ * See README for more details.
+ */
+
+/* Be extremely careful altering include order, move just one in the wrong place
+ * and you will start getting a bunch of error of undefined bool, size_t etc. */
+
+#include "utils/includes.h"
+#include "utils/common.h"
+
+#include "hostapd.h"
+#include "common/ieee802_11_defs.h"
+
+/** When beacons from other Access Point are received, if the SSID is matching
+ * add them as APuP peers (aka WDS STA to our own AP) the same happens on the
+ * peer when receiving our beacons */
+void apup_process_beacon(struct hostapd_data *hapd,
+              const struct ieee80211_mgmt *mgmt, size_t len,
+              const struct ieee802_11_elems *elems );
diff --git a/src/ap/beacon.c b/src/ap/beacon.c
index 2e3d904..82ea8db 100644
--- a/src/ap/beacon.c
+++ b/src/ap/beacon.c
@@ -938,6 +938,8 @@ static u8 * hostapd_probe_resp_fill_elems(struct hostapd_data *hapd,
 
 		pos = hostapd_eid_eht_capab(hapd, pos, IEEE80211_MODE_AP);
 		pos = hostapd_eid_eht_operation(hapd, pos);
+
+		pos = hostapd_eid_eht_attlm(hapd, pos);
 	}
 #endif /* CONFIG_IEEE80211BE */
 
@@ -1418,6 +1420,12 @@ void handle_probe_req(struct hostapd_data *hapd,
 	int mld_id;
 	u16 links;
 #endif /* CONFIG_IEEE80211BE */
+	struct hostapd_ubus_request req = {
+		.type = HOSTAPD_UBUS_PROBE_REQ,
+		.mgmt_frame = mgmt,
+		.ssi_signal = ssi_signal,
+		.elems = &elems,
+	};
 
 	if (hapd->iconf->rssi_ignore_probe_request && ssi_signal &&
 	    ssi_signal < hapd->iconf->rssi_ignore_probe_request)
@@ -1471,7 +1479,7 @@ void handle_probe_req(struct hostapd_data *hapd,
 	 * is less likely to see them (Probe Request frame sent on a
 	 * neighboring, but partially overlapping, channel).
 	 */
-	if (elems.ds_params &&
+	if (elems.ds_params && 0 &&
 	    hapd->iface->current_mode &&
 	    (hapd->iface->current_mode->mode == HOSTAPD_MODE_IEEE80211G ||
 	     hapd->iface->current_mode->mode == HOSTAPD_MODE_IEEE80211B) &&
@@ -1604,6 +1612,12 @@ void handle_probe_req(struct hostapd_data *hapd,
 	}
 #endif /* CONFIG_P2P */
 
+	if (hostapd_ubus_handle_event(hapd, &req)) {
+		wpa_printf(MSG_DEBUG, "Probe request for " MACSTR " rejected by ubus handler.\n",
+		       MAC2STR(mgmt->sa));
+		return;
+	}
+
 	/* TODO: verify that supp_rates contains at least one matching rate
 	 * with AP configuration */
 
@@ -1622,7 +1636,7 @@ void handle_probe_req(struct hostapd_data *hapd,
 	if (hapd->conf->no_probe_resp_if_max_sta &&
 	    is_multicast_ether_addr(mgmt->da) &&
 	    is_multicast_ether_addr(mgmt->bssid) &&
-	    hapd->num_sta >= hapd->conf->max_num_sta &&
+	    hostapd_check_max_sta(hapd) &&
 	    !ap_get_sta(hapd, mgmt->sa)) {
 		wpa_printf(MSG_MSGDUMP, "%s: Ignore Probe Request from " MACSTR
 			   " since no room for additional STA",
@@ -2128,6 +2142,8 @@ static u8 * hostapd_fils_discovery(struct hostapd_data *hapd,
 				   struct wpa_driver_ap_params *params)
 {
 	params->fd_max_int = hapd->conf->fils_discovery_max_int;
+	params->ubpr.unsol_bcast_probe_resp_interval =
+		hapd->conf->unsol_bcast_probe_resp_interval;
 	if (is_6ghz_op_class(hapd->iconf->op_class) &&
 	    params->fd_max_int > FD_MAX_INTERVAL_6GHZ)
 		params->fd_max_int = FD_MAX_INTERVAL_6GHZ;
@@ -2136,7 +2152,8 @@ static u8 * hostapd_fils_discovery(struct hostapd_data *hapd,
 	if (params->fd_min_int > params->fd_max_int)
 		params->fd_min_int = params->fd_max_int;
 
-	if (params->fd_max_int)
+	if (params->fd_max_int || (is_6ghz_op_class(hapd->iconf->op_class) &&
+	    !params->ubpr.unsol_bcast_probe_resp_interval))
 		return hostapd_gen_fils_discovery(hapd,
 						  &params->fd_frame_tmpl_len);
 
@@ -2146,6 +2163,63 @@ static u8 * hostapd_fils_discovery(struct hostapd_data *hapd,
 #endif /* CONFIG_FILS */
 
 
+static void hostapd_fill_bcn_sta_profile(struct hostapd_data *hapd,
+					 struct mld_info *info)
+{
+	struct hostapd_data *h;
+
+	if (!info)
+		return;
+
+	os_memset(info, 0, sizeof(*info));
+
+	for_each_mld_link(h, hapd) {
+		unsigned int link_id = h->mld_link_id;
+		struct mld_link_info *link = &info->links[link_id];
+		u8 *epos, *csa_pos, buf[EHT_ML_MAX_STA_PROF_LEN];
+
+		if (!h->started || h == hapd ||
+		    h->eht_mld_bss_critical_update != BSS_CRIT_UPDATE_ALL)
+			continue;
+
+		link->valid = true;
+		os_memcpy(link->local_addr, h->own_addr, ETH_ALEN);
+
+		/* Build per-STA profile */
+		epos = buf;
+		/* Capabilities */
+		WPA_PUT_LE16(epos, hostapd_own_capab_info(h));
+		epos += 2;
+
+		/* CSA IE */
+		csa_pos = hostapd_eid_csa(h, epos);
+		if (csa_pos != epos)
+			link->sta_prof_csa_offset = csa_pos - 1 - buf;
+		epos = csa_pos;
+
+		/* eCSA IE */
+		csa_pos = hostapd_eid_ecsa(h, epos);
+		if (csa_pos != epos)
+			link->sta_prof_ecsa_offset = csa_pos - 1 - buf;
+		epos = csa_pos;
+
+		/* channel switch wrapper */
+		epos = hostapd_eid_chsw_wrapper(h, epos);
+
+		/* max channel switch time */
+		epos = hostapd_eid_max_cs_time(h, epos);
+
+		link->resp_sta_profile_len = epos - buf;
+		link->resp_sta_profile = os_memdup(buf, link->resp_sta_profile_len);
+
+		/* TODO:
+		 * 1. add other IEs
+		 * 2. handle per-STA profile inheritance
+		 * 3. handle csa offset if fragmentation is required
+		 */
+	}
+}
+
 int ieee802_11_build_ap_params(struct hostapd_data *hapd,
 			       struct wpa_driver_ap_params *params)
 {
@@ -2242,6 +2316,12 @@ int ieee802_11_build_ap_params(struct hostapd_data *hapd,
 	os_memcpy(head->bssid, hapd->own_addr, ETH_ALEN);
 	head->u.beacon.beacon_int =
 		host_to_le16(hapd->iconf->beacon_int);
+	/* if MLD AP hasn't finished setting up all links, also set beacon interval
+	 * to 0. This allows mac80211 to bypass some beacon active checks, for
+	 * example, when doing ACS
+	 */
+	if (hapd->conf->mld_ap && !hapd->mld->started)
+		head->u.beacon.beacon_int = host_to_le16(0);
 
 	/* hardware or low-level driver will setup seq_ctrl and timestamp */
 	capab_info = hostapd_own_capab_info(hapd);
@@ -2387,12 +2467,34 @@ int ieee802_11_build_ap_params(struct hostapd_data *hapd,
 
 #ifdef CONFIG_IEEE80211BE
 	if (hapd->iconf->ieee80211be && !hapd->conf->disable_11be) {
-		if (hapd->conf->mld_ap)
-			tailpos = hostapd_eid_eht_ml_beacon(hapd, NULL,
+		if (hapd->conf->mld_ap) {
+			struct hostapd_data *h;
+			struct mld_info info;
+			struct mld_link_info *link;
+			u32 base;
+			u8 link_id, *ml_pos = tailpos;
+
+			hostapd_fill_bcn_sta_profile(hapd, &info);
+			tailpos = hostapd_eid_eht_ml_beacon(hapd, &info,
 							    tailpos, false);
+
+			for_each_mld_link(h, hapd) {
+				link_id = h->mld_link_id;
+				link = &info.links[link_id];
+				base = ml_pos - tail + link->sta_prof_offset;
+				if (link->sta_prof_csa_offset)
+					hapd->cs_c_off_sta_prof[link_id] =
+							base + link->sta_prof_csa_offset;
+				if (link->sta_prof_ecsa_offset)
+					hapd->cs_c_off_ecsa_sta_prof[link_id] =
+							base + link->sta_prof_ecsa_offset;
+			}
+			ap_sta_free_sta_profile(&info);
+		}
 		tailpos = hostapd_eid_eht_capab(hapd, tailpos,
 						IEEE80211_MODE_AP);
 		tailpos = hostapd_eid_eht_operation(hapd, tailpos);
+		tailpos = hostapd_eid_eht_attlm(hapd, tailpos);
 	}
 #endif /* CONFIG_IEEE80211BE */
 
@@ -2647,6 +2749,14 @@ static int __ieee802_11_set_beacon(struct hostapd_data *hapd)
 	int res, ret = -1, i;
 	struct hostapd_hw_modes *mode;
 
+	/* skip setting beacon if other links are not started yet */
+	if (hapd->conf->mld_ap && !hapd->mld->started && hapd->beacon_set_done)
+		return 0;
+
+	/* skip setting beacon during ap link removal */
+	if (hapd->conf->mld_ap && hapd->mld->removed_links)
+		return 0;
+
 	if (!hapd->drv_priv) {
 		wpa_printf(MSG_ERROR, "Interface is disabled");
 		return -1;
@@ -2657,6 +2767,19 @@ static int __ieee802_11_set_beacon(struct hostapd_data *hapd)
 		return -1;
 	}
 
+	if (iface->cac_started) {
+		wpa_printf(MSG_DEBUG, "Ignore set beacons during CAC period");
+		return 0;
+	}
+
+#ifdef CONFIG_IEEE80211BE
+#ifdef CONFIG_TESTING_OPTIONS
+	if (hapd->conf->mld_ap && hapd->mld &&
+	    (hapd->mld->link_reconf_in_progress & BIT(hapd->mld_link_id)))
+		ieee802_11_set_bss_critical_update(hapd, BSS_CRIT_UPDATE_EVENT_ADD_LINK);
+#endif /* CONFIG_TESTING_OPTIONS */
+#endif /* CONFIG_IEEE80211BE */
+
 	hapd->beacon_set_done = 1;
 
 	if (ieee802_11_build_ap_params(hapd, &params) < 0)
@@ -2729,6 +2852,12 @@ static int __ieee802_11_set_beacon(struct hostapd_data *hapd)
 		params.freq = &freq;
 	}
 
+	params.freq->link_id = -1;
+#ifdef CONFIG_IEEE80211BE
+	if (hapd->conf->mld_ap)
+		params.freq->link_id = hapd->mld_link_id;
+#endif /* CONFIG_IEEE80211BE */
+
 	for (i = 0; i < hapd->iface->num_hw_features; i++) {
 		mode = &hapd->iface->hw_features[i];
 
@@ -2754,9 +2883,9 @@ fail:
 }
 
 
-void ieee802_11_set_beacon_per_bss_only(struct hostapd_data *hapd)
+int ieee802_11_set_beacon_per_bss_only(struct hostapd_data *hapd)
 {
-	__ieee802_11_set_beacon(hapd);
+	return __ieee802_11_set_beacon(hapd);
 }
 
 
@@ -2784,6 +2913,7 @@ static bool is_restricted_eid_in_sta_profile(u8 eid, bool tx_vap)
 	case WLAN_EID_MULTIPLE_BSSID:
 	case WLAN_EID_REDUCED_NEIGHBOR_REPORT:
 	case WLAN_EID_NEIGHBOR_REPORT:
+	case WLAN_EID_FILS_INDICATION:
 		return true;
 	case WLAN_EID_SSID:
 		/* SSID is not restricted for non-transmitted BSSID */
@@ -2798,6 +2928,7 @@ static bool is_restricted_ext_eid_in_sta_profile(u8 ext_id)
 {
 	switch (ext_id) {
 	case WLAN_EID_EXT_MULTI_LINK:
+	case WLAN_EID_EXT_TID_TO_LINK_MAPPING:
 		return true;
 	default:
 		return false;
@@ -2831,8 +2962,8 @@ static size_t hostapd_add_sta_profile(struct ieee80211_mgmt *link_fdata,
 	bool ie_found;
 	u8 non_inherit_ele_ext_list[256] = { 0 };
 	u8 non_inherit_ele_ext_list_len = 0;
-	u8 non_inherit_ele_list[256] = { 0 };
-	u8 non_inherit_ele_list_len = 0;
+	u8 non_inherit_ele_list[256] = { WLAN_EID_VHT_CAP, WLAN_EID_VHT_OPERATION };
+	u8 non_inherit_ele_list_len = 2;
 	u8 num_link_elem_vendor_ies = 0, num_own_elem_vendor_ies = 0;
 	bool add_vendor_ies = false, is_identical_vendor_ies = true;
 	/* The bitmap of parsed EIDs. There are 256 EIDs and ext EIDs, so 32
@@ -3086,7 +3217,7 @@ static u8 * hostapd_gen_sta_profile(struct ieee80211_mgmt *link_data,
 }
 
 
-static void hostapd_gen_per_sta_profiles(struct hostapd_data *hapd)
+void hostapd_gen_per_sta_profiles(struct hostapd_data *hapd)
 {
 	bool tx_vap = hapd == hostapd_mbssid_get_tx_bss(hapd);
 	size_t link_data_len, sta_profile_len;
@@ -3186,7 +3317,7 @@ static void hostapd_gen_per_sta_profiles(struct hostapd_data *hapd)
 int ieee802_11_set_beacon(struct hostapd_data *hapd)
 {
 	struct hostapd_iface *iface = hapd->iface;
-	int ret;
+	int ret, link_id;
 	size_t i, j;
 	bool is_6g, hapd_mld = false;
 #ifdef CONFIG_IEEE80211BE
@@ -3237,8 +3368,13 @@ int ieee802_11_set_beacon(struct hostapd_data *hapd)
 		return 0;
 
 	/* Generate per STA profiles for each affiliated APs */
-	for_each_mld_link(link_bss, hapd)
+	for_each_mld_link(link_bss, hapd) {
 		hostapd_gen_per_sta_profiles(link_bss);
+
+		if (link_bss->eht_mld_bss_critical_update == BSS_CRIT_UPDATE_FLAG &&
+		    (link_bss->mld->link_reconf_in_progress & BIT(link_bss->mld_link_id)))
+			link_bss->mld->link_reconf_in_progress &= ~BIT(link_bss->mld_link_id);
+	}
 #endif /* CONFIG_IEEE80211BE */
 
 	return 0;
@@ -3275,4 +3411,65 @@ int ieee802_11_update_beacons(struct hostapd_iface *iface)
 	return ret;
 }
 
+
+int ieee802_11_set_bss_critical_update(struct hostapd_data *hapd,
+				       enum bss_crit_update_event event)
+{
+	struct hostapd_data *h;
+
+	if (!hapd->conf->mld_ap)
+		return 0;
+
+	switch (event) {
+	case BSS_CRIT_UPDATE_EVENT_CSA:
+	case BSS_CRIT_UPDATE_EVENT_ECSA:
+	case BSS_CRIT_UPDATE_EVENT_QUIET:
+	case BSS_CRIT_UPDATE_EVENT_WBCS:
+	case BSS_CRIT_UPDATE_EVENT_CS_WRAP:
+	case BSS_CRIT_UPDATE_EVENT_OP_MODE_NOTIF:
+	case BSS_CRIT_UPDATE_EVENT_QUIET_CH:
+	case BSS_CRIT_UPDATE_EVENT_CCA:
+	case BSS_CRIT_UPDATE_EVENT_BCAST_TWT:
+	case BSS_CRIT_UPDATE_EVENT_BCAST_TWT_PARAM_SET:
+	case BSS_CRIT_UPDATE_EVENT_IDX_ADJUST_FACTOR:
+	case BSS_CRIT_UPDATE_EVENT_TPE:
+		hapd->eht_mld_bss_param_change += 1;
+		hapd->eht_mld_bss_critical_update = BSS_CRIT_UPDATE_ALL;
+		break;
+	case BSS_CRIT_UPDATE_EVENT_EDCA:
+	case BSS_CRIT_UPDATE_EVENT_DSSS:
+	case BSS_CRIT_UPDATE_EVENT_HT_OPERATION:
+	case BSS_CRIT_UPDATE_EVENT_VHT_OPERATION:
+	case BSS_CRIT_UPDATE_EVENT_HE_OPERATION:
+	case BSS_CRIT_UPDATE_EVENT_MU_EDCA:
+	case BSS_CRIT_UPDATE_EVENT_SR:
+	case BSS_CRIT_UPDATE_EVENT_UORA:
+	case BSS_CRIT_UPDATE_EVENT_EHT_OPERATION:
+		hapd->eht_mld_bss_param_change += 1;
+		hapd->eht_mld_bss_critical_update = BSS_CRIT_UPDATE_SINGLE;
+		break;
+	case BSS_CRIT_UPDATE_EVENT_RECONFIG:
+	case BSS_CRIT_UPDATE_EVENT_ATTLM:
+		hapd->eht_mld_bss_critical_update = BSS_CRIT_UPDATE_FLAG;
+		break;
+	case BSS_CRIT_UPDATE_EVENT_ADD_LINK:
+		/* only set the CU flag for the links in link_reconf_in_progress */
+		hapd->eht_mld_bss_critical_update = BSS_CRIT_UPDATE_FLAG;
+		return 0;
+	default:
+		hapd->eht_mld_bss_critical_update = BSS_CRIT_UPDATE_NONE;
+		return -1;
+	}
+
+	/* only set the CU flag for the non-CU links */
+	for_each_mld_link(h, hapd) {
+		if (h == hapd)
+			continue;
+
+		h->eht_mld_bss_critical_update = BSS_CRIT_UPDATE_FLAG;
+	}
+
+	return 0;
+}
+
 #endif /* CONFIG_NATIVE_WINDOWS */
diff --git a/src/ap/beacon.h b/src/ap/beacon.h
index e381542..19033b5 100644
--- a/src/ap/beacon.h
+++ b/src/ap/beacon.h
@@ -12,12 +12,49 @@
 
 struct ieee80211_mgmt;
 
+enum bss_crit_update_event {
+	BSS_CRIT_UPDATE_EVENT_CSA,
+	BSS_CRIT_UPDATE_EVENT_ECSA,
+	BSS_CRIT_UPDATE_EVENT_EDCA,
+	BSS_CRIT_UPDATE_EVENT_QUIET,
+	BSS_CRIT_UPDATE_EVENT_DSSS,
+	BSS_CRIT_UPDATE_EVENT_HT_OPERATION,
+	BSS_CRIT_UPDATE_EVENT_WBCS,
+	BSS_CRIT_UPDATE_EVENT_CS_WRAP,
+	BSS_CRIT_UPDATE_EVENT_OP_MODE_NOTIF,
+	BSS_CRIT_UPDATE_EVENT_QUIET_CH,
+	BSS_CRIT_UPDATE_EVENT_VHT_OPERATION,
+	BSS_CRIT_UPDATE_EVENT_HE_OPERATION,
+	BSS_CRIT_UPDATE_EVENT_BCAST_TWT,
+	BSS_CRIT_UPDATE_EVENT_BCAST_TWT_PARAM_SET,
+	BSS_CRIT_UPDATE_EVENT_CCA,
+	BSS_CRIT_UPDATE_EVENT_MU_EDCA,
+	BSS_CRIT_UPDATE_EVENT_SR,
+	BSS_CRIT_UPDATE_EVENT_UORA,
+	BSS_CRIT_UPDATE_EVENT_IDX_ADJUST_FACTOR,
+	BSS_CRIT_UPDATE_EVENT_EHT_OPERATION,
+	BSS_CRIT_UPDATE_EVENT_TPE,
+	BSS_CRIT_UPDATE_EVENT_CH_CHANGED,
+	BSS_CRIT_UPDATE_EVENT_RECONFIG,
+	BSS_CRIT_UPDATE_EVENT_ADD_LINK,
+	BSS_CRIT_UPDATE_EVENT_ATTLM
+};
+
+enum {
+	BSS_CRIT_UPDATE_NONE,
+	BSS_CRIT_UPDATE_SINGLE,
+	BSS_CRIT_UPDATE_ALL,
+	BSS_CRIT_UPDATE_FLAG
+};
+
 void handle_probe_req(struct hostapd_data *hapd,
 		      const struct ieee80211_mgmt *mgmt, size_t len,
 		      int ssi_signal);
-void ieee802_11_set_beacon_per_bss_only(struct hostapd_data *hapd);
+int ieee802_11_set_beacon_per_bss_only(struct hostapd_data *hapd);
 int ieee802_11_set_beacon(struct hostapd_data *hapd);
 int ieee802_11_set_beacons(struct hostapd_iface *iface);
+int ieee802_11_set_bss_critical_update(struct hostapd_data *hapd,
+				       enum bss_crit_update_event event);
 int ieee802_11_update_beacons(struct hostapd_iface *iface);
 int ieee802_11_build_ap_params(struct hostapd_data *hapd,
 			       struct wpa_driver_ap_params *params);
@@ -35,5 +72,6 @@ const u8 * hostapd_wpa_ie(struct hostapd_data *hapd, u8 eid);
 
 u8 * hostapd_unsol_bcast_probe_resp(struct hostapd_data *hapd,
 				    struct unsol_bcast_probe_resp *ubpr);
+void hostapd_gen_per_sta_profiles(struct hostapd_data *hapd);
 
 #endif /* BEACON_H */
diff --git a/src/ap/ctrl_iface_ap.c b/src/ap/ctrl_iface_ap.c
index b93a5d2..5cc8a7f 100644
--- a/src/ap/ctrl_iface_ap.c
+++ b/src/ap/ctrl_iface_ap.c
@@ -25,7 +25,28 @@
 #include "mbo_ap.h"
 #include "taxonomy.h"
 #include "wnm_ap.h"
+#include "neighbor_db.h"
 
+static const char * hw_mode_str(enum hostapd_hw_mode mode)
+{
+	switch (mode) {
+	case HOSTAPD_MODE_IEEE80211B:
+		return "b";
+	case HOSTAPD_MODE_IEEE80211G:
+		return "g";
+	case HOSTAPD_MODE_IEEE80211A:
+		return "a";
+	case HOSTAPD_MODE_IEEE80211AD:
+		return "ad";
+	case HOSTAPD_MODE_IEEE80211ANY:
+		return "any";
+	case NUM_HOSTAPD_MODES:
+		return "invalid";
+	}
+	return "unknown";
+}
+
+#ifdef CONFIG_CTRL_IFACE_MIB
 
 static size_t hostapd_write_ht_mcs_bitmask(char *buf, size_t buflen,
 					   size_t curr_len, const u8 *mcs_set)
@@ -212,26 +233,6 @@ static const char * timeout_next_str(int val)
 }
 
 
-static const char * hw_mode_str(enum hostapd_hw_mode mode)
-{
-	switch (mode) {
-	case HOSTAPD_MODE_IEEE80211B:
-		return "b";
-	case HOSTAPD_MODE_IEEE80211G:
-		return "g";
-	case HOSTAPD_MODE_IEEE80211A:
-		return "a";
-	case HOSTAPD_MODE_IEEE80211AD:
-		return "ad";
-	case HOSTAPD_MODE_IEEE80211ANY:
-		return "any";
-	case NUM_HOSTAPD_MODES:
-		return "invalid";
-	}
-	return "unknown";
-}
-
-
 static int hostapd_ctrl_iface_sta_mib(struct hostapd_data *hapd,
 				      struct sta_info *sta,
 				      char *buf, size_t buflen)
@@ -562,6 +563,7 @@ int hostapd_ctrl_iface_sta_next(struct hostapd_data *hapd, const char *txtaddr,
 	return hostapd_ctrl_iface_sta_mib(hapd, sta->next, buf, buflen);
 }
 
+#endif
 
 #ifdef CONFIG_P2P_MANAGER
 static int p2p_manager_disconnect(struct hostapd_data *hapd, u16 stype,
@@ -1016,12 +1018,12 @@ int hostapd_ctrl_iface_status(struct hostapd_data *hapd, char *buf,
 			return len;
 		len += ret;
 	}
-
+#ifdef CONFIG_CTRL_IFACE_MIB
 	if (iface->conf->ieee80211n && !hapd->conf->disable_11n && mode) {
 		len = hostapd_write_ht_mcs_bitmask(buf, buflen, len,
 						   mode->mcs_set);
 	}
-
+#endif /* CONFIG_CTRL_IFACE_MIB */
 	if (iface->current_rates && iface->num_rates) {
 		ret = os_snprintf(buf + len, buflen - len, "supported_rates=");
 		if (os_snprintf_error(buflen - len, ret))
@@ -1104,6 +1106,7 @@ int hostapd_parse_csa_settings(const char *pos,
 			       struct csa_settings *settings)
 {
 	char *end;
+	int ret;
 
 	os_memset(settings, 0, sizeof(*settings));
 	settings->cs_count = strtol(pos, &end, 10);
@@ -1113,7 +1116,9 @@ int hostapd_parse_csa_settings(const char *pos,
 	}
 
 	settings->freq_params.freq = atoi(end);
-	if (settings->freq_params.freq == 0) {
+	ret = ieee80211_freq_to_chan(settings->freq_params.freq,
+				     (u8 *)&settings->freq_params.channel);
+	if (ret == NUM_HOSTAPD_MODES) {
 		wpa_printf(MSG_ERROR, "chanswitch: invalid freq provided");
 		return -1;
 	}
@@ -1127,28 +1132,19 @@ int hostapd_parse_csa_settings(const char *pos,
 		} \
 	} while (0)
 
-#define SET_CSA_SETTING_EXT(str) \
-	do { \
-		const char *pos2 = os_strstr(pos, " " #str "="); \
-		if (pos2) { \
-			pos2 += sizeof(" " #str "=") - 1; \
-			settings->str = atoi(pos2); \
-		} \
-	} while (0)
-
 	SET_CSA_SETTING(center_freq1);
 	SET_CSA_SETTING(center_freq2);
 	SET_CSA_SETTING(bandwidth);
 	SET_CSA_SETTING(sec_channel_offset);
-	SET_CSA_SETTING_EXT(punct_bitmap);
+	SET_CSA_SETTING(punct_bitmap);
 	settings->freq_params.ht_enabled = !!os_strstr(pos, " ht");
 	settings->freq_params.vht_enabled = !!os_strstr(pos, " vht");
 	settings->freq_params.eht_enabled = !!os_strstr(pos, " eht");
 	settings->freq_params.he_enabled = !!os_strstr(pos, " he") ||
 		settings->freq_params.eht_enabled;
+	settings->freq_params.radar_background = !!os_strstr(pos, " skip_cac");
 	settings->block_tx = !!os_strstr(pos, " blocktx");
 #undef SET_CSA_SETTING
-#undef SET_CSA_SETTING_EXT
 
 	return 0;
 }
@@ -1163,7 +1159,27 @@ int hostapd_ctrl_iface_stop_ap(struct hostapd_data *hapd)
 int hostapd_ctrl_iface_pmksa_list(struct hostapd_data *hapd, char *buf,
 				  size_t len)
 {
-	return wpa_auth_pmksa_list(hapd->wpa_auth, buf, len);
+	char *pos = buf;
+	int ret, link_id;
+
+	if (!hapd->conf->mld_ap)
+		return wpa_auth_pmksa_list(hapd->wpa_auth, buf, len);
+
+	for (link_id = 0; link_id < MAX_NUM_MLD_LINKS; link_id++) {
+		struct hostapd_data *h = hostapd_mld_get_link_bss(hapd, link_id);
+
+		if (!h)
+			continue;
+
+		ret = os_snprintf(pos, len - (pos - buf), "Setup at link %u:\n", h->mld_link_id);
+		if (os_snprintf_error(len - (pos - buf), ret))
+			return pos - buf;
+		pos += ret;
+
+		pos += wpa_auth_pmksa_list(h->wpa_auth, pos, len - (pos - buf));
+	}
+
+	return pos - buf;
 }
 
 
@@ -1406,6 +1422,10 @@ int hostapd_ctrl_iface_bss_tm_req(struct hostapd_data *hapd,
 			wpa_printf(MSG_DEBUG, "Invalid bss_term data");
 			return -1;
 		}
+		if (hapd->conf->bss_termination_tsf) {
+			WPA_PUT_LE64(&bss_term_dur[2], hapd->conf->bss_termination_tsf);
+		}
+
 		end++;
 		WPA_PUT_LE16(&bss_term_dur[10], atoi(end));
 	}
@@ -1432,16 +1452,26 @@ int hostapd_ctrl_iface_bss_tm_req(struct hostapd_data *hapd,
 		req_mode |= WNM_BSS_TM_REQ_ESS_DISASSOC_IMMINENT;
 	}
 
-	if (os_strstr(cmd, " pref=1"))
+	if (os_strstr(cmd, " pref=1")) {
 		req_mode |= WNM_BSS_TM_REQ_PREF_CAND_LIST_INCLUDED;
+		if (nei_len == 0) {
+			// Add neigibor report from neighbor report db to nei_rep buffer
+			nei_len = hostapd_neighbor_insert_buffer (hapd, nei_rep, 1000);
+		}
+	}
 	if (os_strstr(cmd, " abridged=1"))
 		req_mode |= WNM_BSS_TM_REQ_ABRIDGED;
-	if (os_strstr(cmd, " disassoc_imminent=1"))
+	if (os_strstr(cmd, " disassoc_imminent=1")) {
 		req_mode |= WNM_BSS_TM_REQ_DISASSOC_IMMINENT;
+		/* Set own BSS neighbor report preference value as 0 */
+		hostapd_neighbor_set_own_report_pref(hapd, nei_rep, nei_len, 0);
+	}
 	if (os_strstr(cmd, " link_removal_imminent=1"))
 		req_mode |= WNM_BSS_TM_REQ_LINK_REMOVAL_IMMINENT;
 
 #ifdef CONFIG_MBO
+	hostapd_neighbor_set_pref_by_non_pref_chan(hapd, sta, nei_rep, nei_len);
+
 	pos = os_strstr(cmd, "mbo=");
 	if (pos) {
 		unsigned int mbo_reason, cell_pref, reassoc_delay;
diff --git a/src/ap/dfs.c b/src/ap/dfs.c
index 0cac194..96f6e7c 100644
--- a/src/ap/dfs.c
+++ b/src/ap/dfs.c
@@ -18,13 +18,7 @@
 #include "ap_drv_ops.h"
 #include "drivers/driver.h"
 #include "dfs.h"
-
-
-enum dfs_channel_type {
-	DFS_ANY_CHANNEL,
-	DFS_AVAILABLE, /* non-radar or radar-available */
-	DFS_NO_CAC_YET, /* radar-not-yet-available */
-};
+#include "crypto/crypto.h"
 
 static struct hostapd_channel_data *
 dfs_downgrade_bandwidth(struct hostapd_iface *iface, int *secondary_channel,
@@ -76,15 +70,22 @@ static int dfs_get_used_n_chans(struct hostapd_iface *iface, int *seg1)
 static int dfs_channel_available(struct hostapd_channel_data *chan,
 				 enum dfs_channel_type type)
 {
+	int dfs_status = chan->flag & HOSTAPD_CHAN_DFS_MASK;
+
+	if (chan->flag & HOSTAPD_CHAN_DISABLED)
+		return -1;
+
 	if (type == DFS_NO_CAC_YET) {
 		/* Select only radar channel where CAC has not been
 		 * performed yet
 		 */
-		if ((chan->flag & HOSTAPD_CHAN_RADAR) &&
-		    (chan->flag & HOSTAPD_CHAN_DFS_MASK) ==
-		     HOSTAPD_CHAN_DFS_USABLE)
+		if (!(chan->flag & HOSTAPD_CHAN_RADAR))
+			return 0;
+
+		if (dfs_status == HOSTAPD_CHAN_DFS_USABLE)
 			return 1;
-		return 0;
+
+		return -1;
 	}
 
 	/*
@@ -93,16 +94,14 @@ static int dfs_channel_available(struct hostapd_channel_data *chan,
 	 * channel for CSA, unless they are available for immediate use.
 	 */
 	if (type == DFS_AVAILABLE && (chan->flag & HOSTAPD_CHAN_RADAR) &&
-	    ((chan->flag & HOSTAPD_CHAN_DFS_MASK) !=
-	     HOSTAPD_CHAN_DFS_AVAILABLE))
-		return 0;
+	    (dfs_status != HOSTAPD_CHAN_DFS_AVAILABLE))
+		return -1;
 
-	if (chan->flag & HOSTAPD_CHAN_DISABLED)
-		return 0;
 	if ((chan->flag & HOSTAPD_CHAN_RADAR) &&
-	    ((chan->flag & HOSTAPD_CHAN_DFS_MASK) ==
-	     HOSTAPD_CHAN_DFS_UNAVAILABLE))
-		return 0;
+	    ((dfs_status == HOSTAPD_CHAN_DFS_UNAVAILABLE) ||
+	    (dfs_status == HOSTAPD_CHAN_DFS_UNKNOWN)))
+		return -1;
+
 	return 1;
 }
 
@@ -174,7 +173,7 @@ static int dfs_chan_range_available(struct hostapd_hw_modes *mode,
 				    enum dfs_channel_type type)
 {
 	struct hostapd_channel_data *first_chan, *chan;
-	int i;
+	int i, available = 0, ret = 0;
 	u32 bw = num_chan_to_bw(num_chans);
 
 	if (first_chan_idx + num_chans > mode->num_channels) {
@@ -210,14 +209,17 @@ static int dfs_chan_range_available(struct hostapd_hw_modes *mode,
 			return 0;
 		}
 
-		if (!dfs_channel_available(chan, type)) {
+		ret = dfs_channel_available(chan, type);
+		if (ret < 0) {
 			wpa_printf(MSG_DEBUG, "DFS: channel not available %d",
 				   first_chan->freq + i * 20);
 			return 0;
 		}
+
+		available |= ret;
 	}
 
-	return 1;
+	return available;
 }
 
 
@@ -238,16 +240,17 @@ static int is_in_chanlist(struct hostapd_iface *iface,
  *  - hapd->vht/he_oper_centr_freq_seg0_idx
  *  - hapd->vht/he_oper_centr_freq_seg1_idx
  */
-static int dfs_find_channel(struct hostapd_iface *iface,
-			    struct hostapd_channel_data **ret_chan,
-			    int idx, enum dfs_channel_type type)
+int dfs_find_channel(struct hostapd_iface *iface,
+		     struct hostapd_channel_data **ret_chan,
+		     int n_chans, int idx, enum dfs_channel_type type)
 {
 	struct hostapd_hw_modes *mode;
 	struct hostapd_channel_data *chan;
-	int i, channel_idx = 0, n_chans, n_chans1;
+	int i, channel_idx = 0, n_chans1;
 
 	mode = iface->current_mode;
-	n_chans = dfs_get_used_n_chans(iface, &n_chans1);
+	if (!n_chans)
+		n_chans = dfs_get_used_n_chans(iface, &n_chans1);
 
 	wpa_printf(MSG_DEBUG, "DFS new chan checking %d channels", n_chans);
 	for (i = 0; i < mode->num_channels; i++) {
@@ -261,8 +264,7 @@ static int dfs_find_channel(struct hostapd_iface *iface,
 		}
 
 		/* Skip HT40/VHT incompatible channels */
-		if (iface->conf->ieee80211n &&
-		    iface->conf->secondary_channel &&
+		if (iface->conf->ieee80211n && n_chans > 1 &&
 		    (!dfs_is_chan_allowed(chan, n_chans) ||
 		     !(chan->allowed_bw & HOSTAPD_CHAN_WIDTH_40P))) {
 			wpa_printf(MSG_DEBUG,
@@ -307,12 +309,12 @@ static int dfs_find_channel(struct hostapd_iface *iface,
 }
 
 
-static void dfs_adjust_center_freq(struct hostapd_iface *iface,
-				   struct hostapd_channel_data *chan,
-				   int secondary_channel,
-				   int sec_chan_idx_80p80,
-				   u8 *oper_centr_freq_seg0_idx,
-				   u8 *oper_centr_freq_seg1_idx)
+void dfs_adjust_center_freq(struct hostapd_iface *iface,
+			    struct hostapd_channel_data *chan,
+			    int secondary_channel,
+			    int sec_chan_idx_80p80,
+			    u8 *oper_centr_freq_seg0_idx,
+			    u8 *oper_centr_freq_seg1_idx)
 {
 	if (!iface->conf->ieee80211ac && !iface->conf->ieee80211ax)
 		return;
@@ -534,9 +536,14 @@ dfs_get_valid_channel(struct hostapd_iface *iface,
 	int num_available_chandefs;
 	int chan_idx, chan_idx2;
 	int sec_chan_idx_80p80 = -1;
+	bool is_mesh = false;
 	int i;
 	u32 _rand;
 
+#ifdef CONFIG_MESH
+	is_mesh = iface->mconf;
+#endif
+
 	wpa_printf(MSG_DEBUG, "DFS: Selecting random channel");
 	*secondary_channel = 0;
 	*oper_centr_freq_seg0_idx = 0;
@@ -550,18 +557,30 @@ dfs_get_valid_channel(struct hostapd_iface *iface,
 		return NULL;
 
 	/* Get the count first */
-	num_available_chandefs = dfs_find_channel(iface, NULL, 0, type);
+	num_available_chandefs = dfs_find_channel(iface, NULL, 0, 0, type);
 	wpa_printf(MSG_DEBUG, "DFS: num_available_chandefs=%d",
 		   num_available_chandefs);
 	if (num_available_chandefs == 0)
 		return NULL;
 
-	if (os_get_random((u8 *) &_rand, sizeof(_rand)) < 0)
+	/* try to use deterministic channel in mesh, so that both sides
+	 * have a chance to switch to the same channel */
+	if (is_mesh) {
+#ifdef CONFIG_MESH
+		u64 hash[4];
+		const u8 *meshid[1] = { &iface->mconf->meshid[0] };
+		const size_t meshid_len = iface->mconf->meshid_len;
+
+		sha256_vector(1, meshid, &meshid_len, (u8 *)&hash[0]);
+		_rand = hash[0] + hash[1] + hash[2] + hash[3];
+#endif
+	} else if (os_get_random((u8 *) &_rand, sizeof(_rand)) < 0)
 		return NULL;
+
 	chan_idx = _rand % num_available_chandefs;
 	wpa_printf(MSG_DEBUG, "DFS: Picked random entry from the list: %d/%d",
 		   chan_idx, num_available_chandefs);
-	dfs_find_channel(iface, &chan, chan_idx, type);
+	dfs_find_channel(iface, &chan, 0, chan_idx, type);
 	if (!chan) {
 		wpa_printf(MSG_DEBUG, "DFS: no random channel found");
 		return NULL;
@@ -591,7 +610,7 @@ dfs_get_valid_channel(struct hostapd_iface *iface,
 		for (i = 0; i < num_available_chandefs - 1; i++) {
 			/* start from chan_idx + 1, end when chan_idx - 1 */
 			chan_idx2 = (chan_idx + 1 + i) % num_available_chandefs;
-			dfs_find_channel(iface, &chan2, chan_idx2, type);
+			dfs_find_channel(iface, &chan2, 0, chan_idx2, type);
 			if (chan2 && abs(chan2->chan - chan->chan) > 12) {
 				/* two channels are not adjacent */
 				sec_chan_idx_80p80 = chan2->chan;
@@ -803,6 +822,23 @@ static int dfs_are_channels_overlapped(struct hostapd_iface *iface, int freq,
 }
 
 
+static void dfs_check_background_overlapped(struct hostapd_iface *iface)
+{
+	int width = iface->radar_background.new_chwidth;
+
+	if (!dfs_use_radar_background(iface))
+		return;
+
+	if (!width)
+		width = hostapd_get_oper_chwidth(iface->conf);
+
+	if (dfs_are_channels_overlapped(iface, iface->radar_background.freq,
+					width, iface->radar_background.centr_freq_seg0_idx,
+					iface->radar_background.centr_freq_seg1_idx))
+		iface->radar_background.channel = -1;
+}
+
+
 static unsigned int dfs_get_cac_time(struct hostapd_iface *iface,
 				     int start_chan_idx, int n_chans)
 {
@@ -835,8 +871,12 @@ static unsigned int dfs_get_cac_time(struct hostapd_iface *iface,
  */
 int hostapd_handle_dfs(struct hostapd_iface *iface)
 {
+	struct hostapd_channel_data *channel;
 	int res, n_chans, n_chans1, start_chan_idx, start_chan_idx1;
-	int skip_radar = 0;
+	int sec = 0, skip_radar = 0;
+	u8 cf1 = 0, cf2 = 0;
+	bool use_radar_background = dfs_use_radar_background(iface);
+	enum dfs_channel_type channel_type = DFS_NO_CAC_YET;
 
 	if (is_6ghz_freq(iface->freq))
 		return 1;
@@ -899,7 +939,7 @@ int hostapd_handle_dfs(struct hostapd_iface *iface)
 	/* Finally start CAC */
 	hostapd_set_state(iface, HAPD_IFACE_DFS);
 	wpa_printf(MSG_DEBUG, "DFS start CAC on %d MHz%s", iface->freq,
-		   dfs_use_radar_background(iface) ? " (background)" : "");
+		   use_radar_background ? " (background)" : "");
 	wpa_msg(iface->bss[0]->msg_ctx, MSG_INFO, DFS_EVENT_CAC_START
 		"freq=%d chan=%d sec_chan=%d, width=%d, seg0=%d, seg1=%d, cac_time=%ds",
 		iface->freq,
@@ -909,6 +949,16 @@ int hostapd_handle_dfs(struct hostapd_iface *iface)
 		hostapd_get_oper_centr_freq_seg1_idx(iface->conf),
 		iface->dfs_cac_ms / 1000);
 
+	if (use_radar_background) {
+		channel = dfs_get_valid_channel(iface, &sec, &cf1, &cf2, DFS_AVAILABLE);
+		/*
+		 * AP cannot get any random available channel.
+		 * Let AP and dedicated radar chain both perform CAC.
+		 */
+		if (!channel)
+			use_radar_background = false;
+	}
+
 	res = hostapd_start_dfs_cac(
 		iface, iface->conf->hw_mode, iface->freq, iface->conf->channel,
 		iface->conf->ieee80211n, iface->conf->ieee80211ac,
@@ -917,14 +967,14 @@ int hostapd_handle_dfs(struct hostapd_iface *iface)
 		hostapd_get_oper_chwidth(iface->conf),
 		hostapd_get_oper_centr_freq_seg0_idx(iface->conf),
 		hostapd_get_oper_centr_freq_seg1_idx(iface->conf),
-		dfs_use_radar_background(iface));
+		use_radar_background);
 
 	if (res) {
 		wpa_printf(MSG_ERROR, "DFS start_dfs_cac() failed, %d", res);
 		return -1;
 	}
 
-	if (dfs_use_radar_background(iface)) {
+	if (use_radar_background) {
 		/* Cache background radar parameters. */
 		iface->radar_background.channel = iface->conf->channel;
 		iface->radar_background.secondary_channel =
@@ -943,8 +993,68 @@ int hostapd_handle_dfs(struct hostapd_iface *iface)
 		if (res < 0)
 			return res;
 
+		if (hostapd_drv_background_radar_mode(iface->bss[0]) < 0)
+			return -1;
+
 		iface->radar_background.temp_ch = 1;
 		return 1;
+	} else if (dfs_use_radar_background(iface)) {
+		/*
+		 * AP is going to perform CAC, so reset temp_ch to 0,
+		 * when dedicated rx has already started CAC.
+		 */
+		if (iface->radar_background.cac_started) {
+			iface->radar_background.temp_ch = 0;
+			return 0;
+		}
+
+		if (iface->dfs_domain == HOSTAPD_DFS_REGION_ETSI)
+			channel_type = DFS_ANY_CHANNEL;
+
+		channel = dfs_get_valid_channel(iface, &sec, &cf1, &cf2, channel_type);
+
+		if (!channel ||
+		    (channel->chan == iface->conf->channel &&
+		    cf1 == hostapd_get_oper_centr_freq_seg0_idx(iface->conf) &&
+		    cf2 == hostapd_get_oper_centr_freq_seg1_idx(iface->conf))) {
+			wpa_printf(MSG_ERROR, "Background radar could not get valid channel\n");
+			iface->radar_background.channel = -1;
+			return 0;
+		}
+
+		hostapd_start_dfs_cac(iface, iface->conf->hw_mode,
+				      channel->freq, channel->chan,
+				      iface->conf->ieee80211n,
+				      iface->conf->ieee80211ac,
+				      iface->conf->ieee80211ax,
+				      iface->conf->ieee80211be,
+				      sec, hostapd_get_oper_chwidth(iface->conf),
+				      cf1, cf2, true);
+
+		iface->radar_background.channel = channel->chan;
+		iface->radar_background.freq = channel->freq;
+		iface->radar_background.secondary_channel = sec;
+		iface->radar_background.centr_freq_seg0_idx = cf1;
+		iface->radar_background.centr_freq_seg1_idx = cf2;
+
+		if (hostapd_drv_background_radar_mode(iface->bss[0]) < 0)
+			return -1;
+	}
+
+	/* Remove the CAC link from the active links of AP MLD temporarily to avoid
+	 * it being reported in the RNR of the affiliated APs of the same AP MLD
+	 */
+	if (iface->cac_started) {
+		int i;
+
+		for (i = 0; i < iface->num_bss; i++) {
+			struct hostapd_data *hapd = iface->bss[i];
+
+			if (!hapd->conf->mld_ap || !hapd->mld)
+				continue;
+
+			hapd->mld->active_links &= ~BIT(hapd->mld_link_id);
+		}
 	}
 
 	return 0;
@@ -1032,6 +1142,11 @@ static int hostapd_dfs_request_channel_switch(struct hostapd_iface *iface,
 		err = hostapd_switch_channel(iface->bss[i], &csa_settings);
 		if (err)
 			num_err++;
+
+#ifdef CONFIG_IEEE80211BE
+		if (iface->bss[i]->conf->mld_ap)
+			hostapd_update_aff_link_beacon(iface->bss[i], csa_settings.cs_count);
+#endif /* CONFIG_IEEE80211BE */
 	}
 
 	if (num_err == iface->num_bss) {
@@ -1057,6 +1172,8 @@ static int hostapd_dfs_request_channel_switch(struct hostapd_iface *iface,
 	 * ch_switch_notify event is received */
 	wpa_printf(MSG_DEBUG, "DFS waiting channel switch event");
 
+	hostapd_set_oper_chwidth(iface->conf, new_vht_oper_chwidth);
+
 	return 0;
 }
 
@@ -1087,6 +1204,8 @@ static void hostapd_dfs_update_background_chain(struct hostapd_iface *iface)
 						  &oper_centr_freq_seg1_idx,
 						  &channel_type);
 	if (!channel ||
+	    channel->chan == iface->conf->channel ||
+	    channel->chan == iface->radar_background.channel ||
 	    hostapd_start_dfs_cac(iface, iface->conf->hw_mode,
 				  channel->freq, channel->chan,
 				  iface->conf->ieee80211n,
@@ -1106,6 +1225,9 @@ static void hostapd_dfs_update_background_chain(struct hostapd_iface *iface)
 	iface->radar_background.secondary_channel = sec;
 	iface->radar_background.centr_freq_seg0_idx = oper_centr_freq_seg0_idx;
 	iface->radar_background.centr_freq_seg1_idx = oper_centr_freq_seg1_idx;
+	/* if main channel do not require dfs, then set temp_ch = 1 */
+	if (!hostapd_is_dfs_required(iface))
+		iface->radar_background.temp_ch = 1;
 
 	wpa_printf(MSG_DEBUG,
 		   "%s: setting background chain to chan %d (%d MHz)",
@@ -1126,6 +1248,18 @@ static int
 hostapd_dfs_start_channel_switch_background(struct hostapd_iface *iface)
 {
 	u8 current_vht_oper_chwidth = hostapd_get_oper_chwidth(iface->conf);
+	int ret;
+
+	if (iface->radar_background.new_chwidth) {
+		hostapd_set_oper_chwidth(iface->conf, iface->radar_background.new_chwidth);
+		iface->radar_background.new_chwidth = 0;
+	}
+	ret = hostapd_dfs_request_channel_switch(iface, iface->radar_background.channel,
+						 iface->radar_background.freq,
+						 iface->radar_background.secondary_channel,
+						 current_vht_oper_chwidth,
+						 iface->radar_background.centr_freq_seg0_idx,
+						 iface->radar_background.centr_freq_seg1_idx);
 
 	iface->conf->channel = iface->radar_background.channel;
 	iface->freq = iface->radar_background.freq;
@@ -1138,11 +1272,53 @@ hostapd_dfs_start_channel_switch_background(struct hostapd_iface *iface)
 
 	hostapd_dfs_update_background_chain(iface);
 
-	return hostapd_dfs_request_channel_switch(
-		iface, iface->conf->channel, iface->freq,
-		iface->conf->secondary_channel, current_vht_oper_chwidth,
-		hostapd_get_oper_centr_freq_seg0_idx(iface->conf),
-		hostapd_get_oper_centr_freq_seg1_idx(iface->conf));
+	return ret;
+}
+
+
+static void
+hostapd_dfs_background_expand(struct hostapd_iface *iface, int chan_width)
+{
+	struct hostapd_hw_modes *mode = iface->current_mode;
+	struct hostapd_channel_data *chan;
+	int i, channel, width = channel_width_to_int(chan_width);
+
+	if (iface->conf->channel - iface->radar_background.channel == width / 5)
+		channel = iface->radar_background.channel;
+	else if (iface->radar_background.channel - iface->conf->channel == width / 5)
+		channel = iface->conf->channel;
+	else
+		return;
+
+	for (i = 0; i < mode->num_channels; i++) {
+		chan = &mode->channels[i];
+		if (chan->chan == channel)
+			break;
+	}
+
+	if (i == mode->num_channels || !dfs_is_chan_allowed(chan, width / 10))
+		return;
+
+	switch (chan_width) {
+	case CHAN_WIDTH_20_NOHT:
+	case CHAN_WIDTH_20:
+		iface->radar_background.new_chwidth = CONF_OPER_CHWIDTH_USE_HT;
+		break;
+	case CHAN_WIDTH_40:
+		iface->radar_background.new_chwidth = CONF_OPER_CHWIDTH_80MHZ;
+		break;
+	case CHAN_WIDTH_80:
+		iface->radar_background.new_chwidth = CONF_OPER_CHWIDTH_160MHZ;
+		break;
+	default:
+		return;
+	}
+
+	iface->radar_background.freq = channel * 5 + 5000;
+	iface->radar_background.channel = channel;
+	iface->radar_background.centr_freq_seg0_idx = channel + width / 5 - 2;
+	iface->radar_background.secondary_channel = 1;
+	iface->radar_background.expand_ch = 0;
 }
 
 
@@ -1150,6 +1326,8 @@ int hostapd_dfs_complete_cac(struct hostapd_iface *iface, int success, int freq,
 			     int ht_enabled, int chan_offset, int chan_width,
 			     int cf1, int cf2)
 {
+	int i;
+
 	wpa_msg(iface->bss[0]->msg_ctx, MSG_INFO, DFS_EVENT_CAC_COMPLETED
 		"success=%d freq=%d ht_enabled=%d chan_offset=%d chan_width=%d cf1=%d cf2=%d radar_detected=%d",
 		success, freq, ht_enabled, chan_offset, chan_width, cf1, cf2,
@@ -1188,6 +1366,10 @@ int hostapd_dfs_complete_cac(struct hostapd_iface *iface, int success, int freq,
 					return 0;
 
 				iface->radar_background.temp_ch = 0;
+
+				if (iface->radar_background.expand_ch)
+					hostapd_dfs_background_expand(iface, chan_width);
+
 				return hostapd_dfs_start_channel_switch_background(iface);
 			}
 
@@ -1200,16 +1382,48 @@ int hostapd_dfs_complete_cac(struct hostapd_iface *iface, int success, int freq,
 			 * sure the configured channel is available because this
 			 * CAC completion event could have been propagated from
 			 * another radio.
+			 * For a AP MLD, the setup of a DFS link after bootup CAC is
+			 * considered as link adding process via link reconfiguration.
 			 */
 			if (iface->state != HAPD_IFACE_ENABLED &&
 			    hostapd_is_dfs_chan_available(iface)) {
+				for (i = 0; i < iface->num_bss; i++) {
+					struct hostapd_data *h, *hapd = iface->bss[i];
+
+					if (!hapd->conf->mld_ap || !hapd->mld)
+						continue;
+
+					hapd->mld->active_links |= BIT(hapd->mld_link_id);
+					for_each_mld_link(h, hapd)
+						h->mld->link_reconf_in_progress |=
+								BIT(h->mld_link_id);
+					hapd->mld->link_reconf_in_progress &=
+								~BIT(hapd->mld_link_id);
+				}
 				hostapd_setup_interface_complete(iface, 0);
-				iface->cac_started = 0;
 			}
+
+			iface->cac_started = 0;
+
+			/*
+			 * When background radar is enabled but the CAC completion
+			 * is not received from the background chain.
+			 * Then, reset radar background chain.
+			 */
+			if (dfs_use_radar_background(iface) &&
+			    iface->radar_background.channel == -1)
+				hostapd_dfs_update_background_chain(iface);
 		}
 	} else if (hostapd_dfs_is_background_event(iface, freq)) {
 		iface->radar_background.cac_started = 0;
+		iface->radar_background.temp_ch = 0;
+		iface->radar_background.expand_ch = 0;
 		hostapd_dfs_update_background_chain(iface);
+	} else if (iface->state == HAPD_IFACE_ENABLED) {
+		iface->cac_started = 0;
+		/* Clear all the CSA params if the switch to DFS channel fails */
+		for (i = 0; i < iface->num_bss; i++)
+			hostapd_cleanup_cs_params(iface->bss[i]);
 	}
 
 	iface->radar_detected = false;
@@ -1225,6 +1439,8 @@ int hostapd_dfs_pre_cac_expired(struct hostapd_iface *iface, int freq,
 		"freq=%d ht_enabled=%d chan_offset=%d chan_width=%d cf1=%d cf2=%d",
 		freq, ht_enabled, chan_offset, chan_width, cf1, cf2);
 
+	hostapd_ubus_notify_radar_detected(iface, freq, chan_width, cf1, cf2);
+
 	/* Proceed only if DFS is not offloaded to the driver */
 	if (iface->drv_flags & WPA_DRIVER_FLAGS_DFS_OFFLOAD)
 		return 0;
@@ -1232,6 +1448,9 @@ int hostapd_dfs_pre_cac_expired(struct hostapd_iface *iface, int freq,
 	set_dfs_state(iface, freq, ht_enabled, chan_offset, chan_width,
 		      cf1, cf2, HOSTAPD_CHAN_DFS_USABLE);
 
+	if (dfs_use_radar_background(iface) && iface->radar_background.channel == -1)
+		hostapd_dfs_update_background_chain(iface);
+
 	return 0;
 }
 
@@ -1316,6 +1535,7 @@ static int hostapd_dfs_start_channel_switch_cac(struct hostapd_iface *iface)
 	hostapd_set_oper_centr_freq_seg1_idx(iface->conf,
 					     oper_centr_freq_seg1_idx);
 	err = 0;
+	dfs_check_background_overlapped(iface);
 
 	hostapd_setup_interface_complete(iface, err);
 	return err;
@@ -1334,6 +1554,14 @@ hostapd_dfs_background_start_channel_switch(struct hostapd_iface *iface,
 		   __func__, iface->radar_background.cac_started ? "yes" : "no",
 		   hostapd_csa_in_progress(iface) ? "yes" : "no");
 
+	/* Skip channel switch when background dfs detect mode is on */
+	if (iface->conf->dfs_detect_mode == DFS_DETECT_MODE_BACKGROUND_ENABLE ||
+	    iface->conf->dfs_detect_mode == DFS_DETECT_MODE_ALL_ENABLE)
+		return 0;
+
+	iface->radar_background.temp_ch = 0;
+	iface->radar_background.expand_ch = 0;
+
 	/* Check if CSA in progress */
 	if (hostapd_csa_in_progress(iface))
 		return 0;
@@ -1382,6 +1610,11 @@ static int hostapd_dfs_start_channel_switch(struct hostapd_iface *iface)
 		   __func__, iface->cac_started ? "yes" : "no",
 		   hostapd_csa_in_progress(iface) ? "yes" : "no");
 
+	/* Skip channel switch when dfs detect mode is on */
+	if (iface->conf->dfs_detect_mode == DFS_DETECT_MODE_AP_ENABLE ||
+	    iface->conf->dfs_detect_mode == DFS_DETECT_MODE_ALL_ENABLE)
+		return 0;
+
 	/* Check if CSA in progress */
 	if (hostapd_csa_in_progress(iface))
 		return 0;
@@ -1433,6 +1666,7 @@ static int hostapd_dfs_start_channel_switch(struct hostapd_iface *iface)
 			hostapd_set_oper_centr_freq_seg1_idx(
 				iface->conf, oper_centr_freq_seg1_idx);
 
+			dfs_check_background_overlapped(iface);
 			hostapd_disable_iface(iface);
 			hostapd_enable_iface(iface);
 			return 0;
@@ -1477,6 +1711,8 @@ int hostapd_dfs_radar_detected(struct hostapd_iface *iface, int freq,
 			return 0;
 	}
 
+	iface->bss[0]->iconf->punct_bitmap = 0;
+
 	if (hostapd_dfs_background_start_channel_switch(iface, freq)) {
 		/* Radar detected while operating, switch the channel. */
 		return hostapd_dfs_start_channel_switch(iface);
@@ -1515,6 +1751,26 @@ int hostapd_dfs_nop_finished(struct hostapd_iface *iface, int freq,
 }
 
 
+int hostapd_dfs_sta_update_state(struct hostapd_iface *iface, int freq,
+				 int ht_enabled, int chan_offset, int chan_width,
+				 int cf1, int cf2, u32 state)
+{
+	wpa_msg(iface->bss[0]->msg_ctx, MSG_INFO, DFS_EVENT_STA_UPDATE
+		"freq=%d ht_enabled=%d chan_offset=%d chan_width=%d cf1=%d cf2=%d state=%s",
+		freq, ht_enabled, chan_offset, chan_width, cf1, cf2,
+		(state == HOSTAPD_CHAN_DFS_AVAILABLE) ? "available" : "usable");
+
+	/* Proceed only if DFS is not offloaded to the driver */
+	if (iface->drv_flags & WPA_DRIVER_FLAGS_DFS_OFFLOAD)
+		return 0;
+
+	set_dfs_state(iface, freq, ht_enabled, chan_offset, chan_width,
+		      cf1, cf2, state);
+
+	return 0;
+}
+
+
 int hostapd_is_dfs_required(struct hostapd_iface *iface)
 {
 	int n_chans, n_chans1, start_chan_idx, start_chan_idx1, res;
@@ -1522,6 +1778,7 @@ int hostapd_is_dfs_required(struct hostapd_iface *iface)
 	if ((!(iface->drv_flags & WPA_DRIVER_FLAGS_DFS_OFFLOAD) &&
 	     !iface->conf->ieee80211h) ||
 	    !iface->current_mode ||
+	    is_6ghz_freq(iface->freq) ||
 	    iface->current_mode->mode != HOSTAPD_MODE_IEEE80211A)
 		return 0;
 
@@ -1543,6 +1800,35 @@ int hostapd_is_dfs_required(struct hostapd_iface *iface)
 }
 
 
+int hostapd_dfs_background_chan_update(struct hostapd_iface *iface, int freq,
+				       int ht_enabled, int chan_offset, int chan_width,
+				       int cf1, int cf2, bool expand)
+{
+	switch (chan_width) {
+	case CHAN_WIDTH_80:
+		iface->radar_background.new_chwidth = CONF_OPER_CHWIDTH_80MHZ;
+		break;
+	case CHAN_WIDTH_160:
+		iface->radar_background.new_chwidth = CONF_OPER_CHWIDTH_160MHZ;
+		break;
+	default:
+		iface->radar_background.new_chwidth = CONF_OPER_CHWIDTH_USE_HT;
+		break;
+	};
+
+	iface->radar_background.freq = freq;
+	iface->radar_background.channel = (freq - 5000) / 5;
+	iface->radar_background.centr_freq_seg0_idx = (cf1 - 5000) / 5;
+	iface->radar_background.centr_freq_seg1_idx = cf2 ? (cf2 - 5000) / 5 : 0;
+	if (expand) {
+		iface->radar_background.temp_ch = 1;
+		iface->radar_background.expand_ch = 1;
+	}
+
+	return 0;
+}
+
+
 int hostapd_dfs_start_cac(struct hostapd_iface *iface, int freq,
 			  int ht_enabled, int chan_offset, int chan_width,
 			  int cf1, int cf2)
@@ -1553,7 +1839,8 @@ int hostapd_dfs_start_cac(struct hostapd_iface *iface, int freq,
 		/* This is called when the driver indicates that an offloaded
 		 * DFS has started CAC. radar_detected might be set for previous
 		 * DFS channel. Clear it for this new CAC process. */
-		hostapd_set_state(iface, HAPD_IFACE_DFS);
+		if (iface->drv_flags & WPA_DRIVER_FLAGS_DFS_OFFLOAD)
+			hostapd_set_state(iface, HAPD_IFACE_DFS);
 		iface->cac_started = 1;
 
 		/* Clear radar_detected in case it is for the previous
@@ -1566,9 +1853,11 @@ int hostapd_dfs_start_cac(struct hostapd_iface *iface, int freq,
 	/* TODO: How to check CAC time for ETSI weather channels? */
 	iface->dfs_cac_ms = 60000;
 	wpa_msg(iface->bss[0]->msg_ctx, MSG_INFO, DFS_EVENT_CAC_START
-		"freq=%d chan=%d chan_offset=%d width=%d seg0=%d "
+		"freq=%d chan=%d chan_offset=%d width=%s seg0=%d "
 		"seg1=%d cac_time=%ds%s",
-		freq, (freq - 5000) / 5, chan_offset, chan_width, cf1, cf2,
+		freq, (freq - 5000) / 5, chan_offset,
+		channel_width_to_string(chan_width),
+		(cf1 - 5000) / 5, cf2 ? (cf2 - 5000) / 5 : 0,
 		iface->dfs_cac_ms / 1000,
 		hostapd_dfs_is_background_event(iface, freq) ?
 		" (background)" : "");
@@ -1619,14 +1908,15 @@ int hostapd_handle_dfs_offload(struct hostapd_iface *iface)
 }
 
 
-int hostapd_is_dfs_overlap(struct hostapd_iface *iface, enum chan_width width,
-			   int center_freq)
+int hostapd_dfs_get_target_state(struct hostapd_iface *iface, enum chan_width width,
+				 int center_freq, int center_freq2)
 {
 	struct hostapd_channel_data *chan;
 	struct hostapd_hw_modes *mode = iface->current_mode;
-	int half_width;
-	int res = 0;
+	int half_width, chan_state, state = 0;
+	int upper, lower;
 	int i;
+	bool in_range;
 
 	if (!iface->conf->ieee80211h || !mode ||
 	    mode->mode != HOSTAPD_MODE_IEEE80211A)
@@ -1659,18 +1949,137 @@ int hostapd_is_dfs_overlap(struct hostapd_iface *iface, enum chan_width width,
 		if (!(chan->flag & HOSTAPD_CHAN_RADAR))
 			continue;
 
-		if ((chan->flag & HOSTAPD_CHAN_DFS_MASK) ==
-		    HOSTAPD_CHAN_DFS_AVAILABLE)
-			continue;
+		upper = chan->freq + half_width;
+		lower = chan->freq - half_width;
+		in_range = (lower < center_freq && center_freq < upper) ||
+			   (center_freq2 && (lower < center_freq2 && center_freq2 < upper));
+		if (in_range) {
+			chan_state = chan->flag & HOSTAPD_CHAN_DFS_MASK;
+			switch (chan_state) {
+			case HOSTAPD_CHAN_DFS_USABLE:
+				state = HOSTAPD_CHAN_DFS_USABLE;
+				break;
+			case HOSTAPD_CHAN_DFS_AVAILABLE:
+				if (state != HOSTAPD_CHAN_DFS_USABLE)
+					state = HOSTAPD_CHAN_DFS_AVAILABLE;
+				break;
+			case HOSTAPD_CHAN_DFS_UNKNOWN:
+				wpa_printf(MSG_WARNING, "chan %d DFS state: UNKNOWN",
+					   chan->freq);
+				/* fallthrough */
+			case HOSTAPD_CHAN_DFS_UNAVAILABLE:
+			default:
+				return HOSTAPD_CHAN_DFS_UNAVAILABLE;
+			}
+		}
+	}
 
-		if (center_freq - chan->freq < half_width &&
-		    chan->freq - center_freq < half_width)
-			res++;
+	wpa_printf(MSG_DEBUG, "freq range (%d, %d) has DFS state %d",
+		   center_freq - half_width, center_freq + half_width, state);
+
+	return state;
+}
+
+
+static struct hostapd_channel_data *
+dfs_get_csa_channel(struct hostapd_iface *iface,
+		    int n_chans, int cur_center,
+		    enum dfs_channel_type type)
+{
+	struct hostapd_channel_data *chan;
+	int avail_chan_num;
+	u32 _rand, idx;
+
+	if (os_get_random((u8 *)&_rand, sizeof(_rand)) < 0)
+		return NULL;
+
+	avail_chan_num = dfs_find_channel(iface, NULL, n_chans, 0, type);
+	if (!avail_chan_num)
+		return NULL;
+
+	idx = _rand % avail_chan_num;
+	dfs_find_channel(iface, &chan, n_chans, idx, type);
+	if (cur_center == chan->freq + (n_chans - 1) * 10) {
+		if (avail_chan_num == 1)
+			return NULL;
+
+		/* Get the next channel if the found channel is same as current channel */
+		idx = (idx + 1) % avail_chan_num;
+		dfs_find_channel(iface, &chan, n_chans, idx, type);
 	}
 
-	wpa_printf(MSG_DEBUG, "DFS CAC required: (%d, %d): in range: %s",
-		   center_freq - half_width, center_freq + half_width,
-		   res ? "yes" : "no");
+	return chan;
+}
 
-	return res;
+
+/*
+ * DFS handler for CSA
+ * 1  - update background radar with the filled setting
+ * 0  - background radar is not enabled / background radar remain at the same channel /
+ *	disable background radar
+ */
+int hostapd_dfs_handle_csa(struct hostapd_iface *iface,
+			   struct csa_settings *settings,
+			   struct csa_settings *background_settings,
+			   bool cac_required, bool bw_changed)
+{
+	struct hostapd_channel_data *chan;
+	struct hostapd_freq_params *freq_params = &settings->freq_params;
+	int center = settings->freq_params.center_freq1;
+	int background_center = 5000 + iface->radar_background.centr_freq_seg0_idx * 5;
+	int n_chans = settings->freq_params.bandwidth / 20;
+	bool update_background = false;
+
+	if (!dfs_use_radar_background(iface)) {
+		if (settings->cs_count < 5)
+			settings->cs_count = 5;
+		settings->block_tx = cac_required;
+		return 0;
+	}
+
+	if (!cac_required) {
+		if (!bw_changed && center != background_center)
+			return 0;
+		/* Update background radar due to bw change or channel overlapping */
+		update_background = true;
+	} else {
+		/*
+		 * Get available channel for main channel if background radar
+		 * is ready (no CAC in progress).
+		 * If no available channel exists or background radar is not ready,
+		 * then perform the CAC of the target channel on the main channel.
+		 * Also, select an usable channel for background radar if no
+		 * available channel exists.
+		 */
+		if (!iface->radar_background.cac_started) {
+			iface->radar_background.temp_ch = 1;
+			chan = dfs_get_csa_channel(iface, n_chans, 0, DFS_AVAILABLE);
+			if (!chan)
+				update_background = true;
+		} else {
+			iface->radar_background.temp_ch = 0;
+			return 0;
+		}
+	}
+
+	if (update_background) {
+		chan = dfs_get_csa_channel(iface, n_chans, center, DFS_NO_CAC_YET);
+		if (!chan)
+			goto bkg_disable;
+		freq_params = &background_settings->freq_params;
+		iface->radar_background.temp_ch = 0;
+	}
+
+	memcpy(background_settings, settings, sizeof(*settings));
+	freq_params->freq = chan->freq;
+	freq_params->channel = chan->chan;
+	freq_params->sec_channel_offset = 1;
+	freq_params->center_freq1 = chan->freq + (n_chans - 1) * 10;
+	freq_params->center_freq2 = 0;
+
+	return 1;
+
+bkg_disable:
+	iface->radar_background.channel = -1;
+	return 0;
 }
diff --git a/src/ap/dfs.h b/src/ap/dfs.h
index 606c1b3..adb09de 100644
--- a/src/ap/dfs.h
+++ b/src/ap/dfs.h
@@ -9,6 +9,12 @@
 #ifndef DFS_H
 #define DFS_H
 
+enum dfs_channel_type {
+	DFS_ANY_CHANNEL,
+	DFS_AVAILABLE, /* non-radar or radar-available */
+	DFS_NO_CAC_YET, /* radar-not-yet-available */
+};
+
 int hostapd_handle_dfs(struct hostapd_iface *iface);
 
 int hostapd_dfs_complete_cac(struct hostapd_iface *iface, int success, int freq,
@@ -24,13 +30,33 @@ int hostapd_dfs_radar_detected(struct hostapd_iface *iface, int freq,
 int hostapd_dfs_nop_finished(struct hostapd_iface *iface, int freq,
 			     int ht_enabled,
 			     int chan_offset, int chan_width, int cf1, int cf2);
+int hostapd_dfs_background_chan_update(struct hostapd_iface *iface, int freq,
+				       int ht_enabled, int chan_offset, int chan_width,
+				       int cf1, int cf2, bool expand);
+int hostapd_dfs_sta_update_state(struct hostapd_iface *iface, int freq,
+				 int ht_enabled, int chan_offset, int chan_width,
+				 int cf1, int cf2, u32 state);
 int hostapd_is_dfs_required(struct hostapd_iface *iface);
 int hostapd_is_dfs_chan_available(struct hostapd_iface *iface);
 int hostapd_dfs_start_cac(struct hostapd_iface *iface, int freq,
 			  int ht_enabled, int chan_offset, int chan_width,
 			  int cf1, int cf2);
 int hostapd_handle_dfs_offload(struct hostapd_iface *iface);
-int hostapd_is_dfs_overlap(struct hostapd_iface *iface, enum chan_width width,
-			   int center_freq);
+int hostapd_dfs_get_target_state(struct hostapd_iface *iface, enum chan_width width,
+				 int center_freq, int center_freq2);
+int dfs_find_channel(struct hostapd_iface *iface,
+		     struct hostapd_channel_data **ret_chan,
+		     int n_chans, int idx, enum dfs_channel_type type);
+void dfs_adjust_center_freq(struct hostapd_iface *iface,
+			    struct hostapd_channel_data *chan,
+			    int secondary_channel,
+			    int sec_chan_idx_80p80,
+			    u8 *oper_centr_freq_seg0_idx,
+			    u8 *oper_centr_freq_seg1_idx);
+int hostapd_dfs_handle_csa(struct hostapd_iface *iface,
+			   struct csa_settings *settings,
+			   struct csa_settings *background_settings,
+			   bool cac_required, bool bw_changed);
+
 
 #endif /* DFS_H */
diff --git a/src/ap/drv_callbacks.c b/src/ap/drv_callbacks.c
index ba54fd7..160f312 100644
--- a/src/ap/drv_callbacks.c
+++ b/src/ap/drv_callbacks.c
@@ -44,6 +44,7 @@
 #include "fils_hlp.h"
 #include "neighbor_db.h"
 #include "nan_usd_ap.h"
+#include "ap/beacon.h"
 
 
 #ifdef CONFIG_FILS
@@ -317,6 +318,10 @@ int hostapd_notif_assoc(struct hostapd_data *hapd, const u8 *addr,
 	struct hostapd_iface *iface = hapd->iface;
 #endif /* CONFIG_OWE */
 	bool updated = false;
+	struct hostapd_ubus_request req = {
+		.type = HOSTAPD_UBUS_ASSOC_REQ,
+		.addr = addr,
+	};
 
 	if (addr == NULL) {
 		/*
@@ -461,6 +466,12 @@ int hostapd_notif_assoc(struct hostapd_data *hapd, const u8 *addr,
 		goto fail;
 	}
 
+	if (hostapd_ubus_handle_event(hapd, &req)) {
+		wpa_printf(MSG_DEBUG, "Station " MACSTR " assoc rejected by ubus handler.\n",
+			   MAC2STR(req.addr));
+		goto fail;
+	}
+
 #ifdef CONFIG_P2P
 	if (elems.p2p) {
 		wpabuf_free(sta->p2p_ie);
@@ -1372,10 +1383,24 @@ void hostapd_event_ch_switch(struct hostapd_data *hapd, int freq, int ht,
 	if (hapd->csa_in_progress &&
 	    freq == hapd->cs_freq_params.freq) {
 		hostapd_cleanup_cs_params(hapd);
-		ieee802_11_set_beacon(hapd);
+
+#ifdef CONFIG_IEEE80211BE
+		if (hapd->conf->mld_ap) {
+			struct hostapd_data *link_bss;
+
+			/* Update per STA profiles for each affiliated APs */
+			for_each_mld_link(link_bss, hapd ) {
+				if (link_bss == hapd)
+					continue;
+
+				hostapd_gen_per_sta_profiles(link_bss);
+			}
+		}
+#endif /* CONFIG_IEEE80211BE */
 
 		wpa_msg(hapd->msg_ctx, MSG_INFO, AP_CSA_FINISHED
 			"freq=%d dfs=%d", freq, is_dfs);
+		hostapd_ubus_notify_csa(hapd, freq);
 	} else if (hapd->iface->drv_flags & WPA_DRIVER_FLAGS_DFS_OFFLOAD) {
 		/* Complete AP configuration for the first bring up. */
 		if (is_dfs0 > 0 &&
@@ -1426,6 +1451,104 @@ void hostapd_event_ch_switch(struct hostapd_data *hapd, int freq, int ht,
 }
 
 
+#ifdef CONFIG_IEEE80211BE
+void hostapd_event_attlm(struct hostapd_data *hapd, struct attlm_event *attlm_event)
+{
+	struct hostapd_mld *mld = hapd->mld;
+	struct hostapd_data *p_hapd;
+	bool mld_indicate_disabled = false;
+
+	if (!hapd->conf->mld_ap || !mld)
+		return;
+
+	wpa_printf(MSG_DEBUG, "A-TTLM event");
+	/*
+	 * T0: driver notifies A-TTLM has started and reports Switch Time TSF in TUs
+	 * T1: driver notifies Switch Time Expiry of a started A-TTLM
+	 * T2: driver notifies Duration Expiry of a started A-TTLM.
+	 */
+	switch (attlm_event->event) {
+		case EVENT_ATTLM_STARTED:
+			ieee802_11_set_bss_critical_update(hapd,
+						BSS_CRIT_UPDATE_EVENT_ATTLM);
+			mld->new_attlm.switch_time_tsf_tu =
+						attlm_event->switch_time_tsf_tu;
+			break;
+		case EVENT_ATTLM_SWITCH_TIME_EXPIRED:
+			mld_indicate_disabled = true;
+			mld->new_attlm.switch_time_tsf_tu = 0;
+			os_get_reltime(&mld->new_attlm.start_time);
+			break;
+		case EVENT_ATTLM_END:
+			ieee802_11_set_bss_critical_update(hapd,
+						BSS_CRIT_UPDATE_EVENT_ATTLM);
+			mld->new_attlm.valid = false;
+			break;
+		default:
+			wpa_printf(MSG_DEBUG, "Unsupported A-TTLM event");
+			return;
+	}
+
+	for_each_mld_link(p_hapd, hapd) {
+		if (mld->new_attlm.disabled_links & BIT(p_hapd->mld_link_id))
+			p_hapd->conf->mld_indicate_disabled =
+							mld_indicate_disabled;
+	}
+
+	ieee802_11_set_beacon(hapd);
+}
+
+
+static void hostapd_event_update_crit_update_flag(struct hostapd_data *hapd, u8 flag)
+{
+	const char *type;
+
+	if (!hapd->conf->mld_ap || !hapd->mld)
+		return;
+
+	switch (flag) {
+	case CRIT_UPDATE_NONE:
+		hapd->eht_mld_bss_critical_update = 0;
+		type = "UPDATE_NONE";
+		break;
+	case CRIT_UPDATE_SINGLE:
+		hapd->eht_mld_bss_critical_update = BSS_CRIT_UPDATE_SINGLE;
+		hapd->eht_mld_bss_param_change += 1;
+		type = "UPDATE_SINGLE";
+		break;
+	case CRIT_UPDATE_ALL:
+		hapd->eht_mld_bss_critical_update = BSS_CRIT_UPDATE_ALL;
+		hapd->eht_mld_bss_param_change += 1;
+		type = "UPDATE_ALL";
+		break;
+	case CRIT_UPDATE_FLAG:
+		hapd->eht_mld_bss_critical_update = BSS_CRIT_UPDATE_FLAG;
+		type = "UPDATE_FLAG";
+		break;
+	default:
+		wpa_printf(MSG_DEBUG, "Unknown critical update type");
+		return;
+	}
+
+	wpa_printf(MSG_DEBUG,
+		   "MLD: set critical update flag to %s (bpcc=%d) for %s link %d",
+		   type, hapd->eht_mld_bss_param_change, hapd->mld->name,
+		   hapd->mld_link_id);
+}
+
+void hostapd_event_tsf_offset(struct hostapd_data *hapd, s64 *tsf_offset)
+{
+	struct hostapd_mld *mld = hapd->mld;
+
+	if (!hapd->conf->mld_ap || !mld)
+		return;
+
+	os_memcpy(hapd->tsf_offset, tsf_offset, sizeof(hapd->tsf_offset));
+}
+
+#endif /* CONFIG_IEEE80211BE */
+
+
 void hostapd_event_connect_failed_reason(struct hostapd_data *hapd,
 					 const u8 *addr, int reason_code)
 {
@@ -1856,6 +1979,7 @@ switch_link_scan(struct hostapd_data *hapd, u64 scan_cookie)
 static struct hostapd_data * get_hapd_bssid(struct hostapd_iface *iface,
 					    const u8 *bssid, int link_id)
 {
+	struct hostapd_data *ret = NULL;
 	size_t i;
 
 	if (bssid == NULL)
@@ -1883,7 +2007,7 @@ static struct hostapd_data * get_hapd_bssid(struct hostapd_iface *iface,
 		if (ether_addr_equal(bssid, hapd->own_addr) ||
 		    (hapd->conf->mld_ap &&
 		     ether_addr_equal(bssid, hapd->mld->mld_addr) &&
-		     link_id == hapd->mld_link_id))
+		     (link_id == hapd->mld_link_id || link_id == -1)))
 			return hapd;
 
 		if (!hapd->conf->mld_ap)
@@ -1895,13 +2019,13 @@ static struct hostapd_data * get_hapd_bssid(struct hostapd_iface *iface,
 
 			if (ether_addr_equal(bssid, p_hapd->own_addr) ||
 			    (ether_addr_equal(bssid, p_hapd->mld->mld_addr) &&
-			     link_id == p_hapd->mld_link_id))
+			     (link_id == p_hapd->mld_link_id || link_id == -1)))
 				return p_hapd;
 		}
 #endif /* CONFIG_IEEE80211BE */
 	}
 
-	return NULL;
+	return ret;
 }
 
 
@@ -1966,6 +2090,9 @@ static int hostapd_mgmt_rx(struct hostapd_data *hapd, struct rx_mgmt *rx_mgmt)
 			return 0;
 	}
 
+	if (rx_mgmt->freq != 0 && rx_mgmt->freq != iface->freq)
+		return 0;
+
 	os_memset(&fi, 0, sizeof(fi));
 	fi.freq = rx_mgmt->freq;
 	fi.datarate = rx_mgmt->datarate;
@@ -2289,6 +2416,36 @@ static void hostapd_event_dfs_cac_started(struct hostapd_data *hapd,
 			      radar->cf1, radar->cf2);
 }
 
+
+static void hostapd_event_dfs_background_chan_update(struct hostapd_data *hapd,
+						     struct dfs_event *radar, bool expand)
+{
+	wpa_printf(MSG_DEBUG, "DFS background channel %s to %d MHz",
+		   expand ? "expand" : "update", radar->freq);
+	hostapd_dfs_background_chan_update(hapd->iface, radar->freq, radar->ht_enabled,
+					   radar->chan_offset, radar->chan_width,
+					   radar->cf1, radar->cf2, expand);
+}
+
+
+static void hostapd_event_dfs_sta_cac_skipped(struct hostapd_data *hapd,
+					      struct dfs_event *radar)
+{
+	wpa_printf(MSG_DEBUG, "DFS CAC skipped (by STA) on %d MHz", radar->freq);
+	hostapd_dfs_sta_update_state(hapd->iface, radar->freq, radar->ht_enabled,
+				     radar->chan_offset, radar->chan_width,
+				     radar->cf1, radar->cf2, HOSTAPD_CHAN_DFS_AVAILABLE);
+}
+
+static void hostapd_event_dfs_sta_cac_expired(struct hostapd_data *hapd,
+					      struct dfs_event *radar)
+{
+	wpa_printf(MSG_DEBUG, "DFS CAC expired (by STA) on %d MHz", radar->freq);
+	hostapd_dfs_sta_update_state(hapd->iface, radar->freq, radar->ht_enabled,
+				     radar->chan_offset, radar->chan_width,
+				     radar->cf1, radar->cf2, HOSTAPD_CHAN_DFS_USABLE);
+}
+
 #endif /* NEED_AP_MLME */
 
 
@@ -2524,17 +2681,89 @@ static void hostapd_mld_iface_disable(struct hostapd_data *hapd)
 		hostapd_iface_disable(link_bss);
 }
 
+
+static void hostapd_event_pp_bitmap_update(struct hostapd_data *hapd,
+					   struct ch_switch *ch_switch)
+{
+	struct hostapd_iface *iface = hapd->iface;
+	struct hostapd_hw_modes *cmode = iface->current_mode;
+	int err, freq;
+	struct csa_settings csa_settings;
+	unsigned int i;
+
+	/* Check if CSA in progress */
+	if (hostapd_csa_in_progress(iface))
+		return;
+
+	if (!hw_get_channel_chan(cmode, iface->conf->channel, &freq))
+		return;
+
+	if (iface->conf->punct_bitmap == ch_switch->punct_bitmap ||
+	    freq != ch_switch->freq)
+		return;
+
+	/* Setup CSA request */
+	os_memset(&csa_settings, 0, sizeof(csa_settings));
+	csa_settings.cs_count = 5;
+	csa_settings.block_tx = 0;
+	csa_settings.link_id = ch_switch->link_id;
+
+	err = hostapd_set_freq_params(&csa_settings.freq_params,
+				      iface->conf->hw_mode,
+				      freq,
+				      iface->conf->channel,
+				      iface->conf->enable_edmg,
+				      iface->conf->edmg_channel,
+				      iface->conf->ieee80211n,
+				      iface->conf->ieee80211ac,
+				      iface->conf->ieee80211ax,
+				      iface->conf->ieee80211be,
+				      iface->conf->secondary_channel,
+				      hostapd_get_oper_chwidth(iface->conf),
+				      hostapd_get_oper_centr_freq_seg0_idx(iface->conf),
+				      hostapd_get_oper_centr_freq_seg1_idx(iface->conf),
+				      cmode->vht_capab,
+				      &cmode->he_capab[IEEE80211_MODE_AP],
+				      &cmode->eht_capab[IEEE80211_MODE_AP],
+				      ch_switch->punct_bitmap);
+
+	if (err) {
+		wpa_printf(MSG_ERROR,
+			   "Failed to calculate CSA freq params");
+		hostapd_disable_iface(iface);
+		return;
+	}
+
+	for (i = 0; i < iface->num_bss; i++) {
+		ieee802_11_set_bss_critical_update(iface->bss[i],
+						   BSS_CRIT_UPDATE_EVENT_CSA);
+
+		err = hostapd_switch_channel(iface->bss[i], &csa_settings);
+		if (err)
+			break;
+
+#ifdef CONFIG_IEEE80211BE
+		if (iface->bss[i]->conf->mld_ap)
+			hostapd_update_aff_link_beacon(iface->bss[i],
+						       csa_settings.cs_count);
+#endif /* CONFIG_IEEE80211BE */
+	}
+}
 #endif /* CONFIG_IEEE80211BE */
 
 
-void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
-			  union wpa_event_data *data)
+void hostapd_wpa_event(void *ctx, enum wpa_event_type event,
+		       union wpa_event_data *data)
 {
 	struct hostapd_data *hapd = ctx;
 	struct sta_info *sta;
 #ifndef CONFIG_NO_STDOUT_DEBUG
 	int level = MSG_DEBUG;
 
+	/* FIXME: check why hapd might be NULL here */
+	if (!hapd)
+		return;
+
 	if (event == EVENT_RX_MGMT && data->rx_mgmt.frame &&
 	    data->rx_mgmt.frame_len >= 24) {
 		const struct ieee80211_hdr *hdr;
@@ -2564,10 +2793,12 @@ void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
 			hapd = switch_link_scan(hapd,
 						data->scan_info.scan_cookie);
 #endif /* NEED_AP_MLME */
-		if (hapd->iface->scan_cb)
+		if (hapd->iface->scan_cb) {
 			hapd->iface->scan_cb(hapd->iface);
+			break;
+		}
 #ifdef CONFIG_IEEE80211BE
-		if (!hapd->iface->scan_cb && hapd->conf->mld_ap) {
+		if (hapd->conf->mld_ap) {
 			/* Other links may be waiting for HT scan result */
 			unsigned int i;
 
@@ -2577,8 +2808,10 @@ void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
 				struct hostapd_data *h_hapd = h->bss[0];
 
 				if (hostapd_is_ml_partner(hapd, h_hapd) &&
-				    h_hapd->iface->scan_cb)
+				    h_hapd->iface->scan_cb) {
 					h_hapd->iface->scan_cb(h_hapd->iface);
+					break;
+				}
 			}
 		}
 #endif /* CONFIG_IEEE80211BE */
@@ -2744,6 +2977,19 @@ void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
 					data->ch_switch.punct_bitmap,
 					event == EVENT_CH_SWITCH);
 		break;
+	case EVENT_ATTLM:
+#ifdef CONFIG_IEEE80211BE
+		hostapd_event_attlm(hapd, &data->attlm_event);
+#endif /* CONFIG_IEEE80211BE */
+		break;
+	case EVENT_TSF_OFFSET:
+#ifdef CONFIG_IEEE80211BE
+		if (!data)
+			break;
+		hapd = switch_link_hapd(hapd, data->tsf_event.link_id);
+		hostapd_event_tsf_offset(hapd, &data->tsf_event.tsf_offset);
+#endif /* CONFIG_IEEE80211BE */
+		break;
 	case EVENT_CONNECT_FAILED_REASON:
 		if (!data)
 			break;
@@ -2752,6 +2998,7 @@ void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
 			data->connect_failed_reason.code);
 		break;
 	case EVENT_SURVEY:
+		hapd = switch_link_hapd(hapd, data->survey_results.link_id);
 		hostapd_event_get_survey(hapd->iface, &data->survey_results);
 		break;
 #ifdef NEED_AP_MLME
@@ -2788,6 +3035,28 @@ void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
 		hapd = switch_link_hapd(hapd, data->dfs_event.link_id);
 		hostapd_event_dfs_nop_finished(hapd, &data->dfs_event);
 		break;
+	case EVENT_DFS_BACKGROUND_CHAN_UPDATE:
+		if (!data)
+			break;
+		hapd = switch_link_hapd(hapd, data->dfs_event.link_id);
+		hostapd_event_dfs_background_chan_update(hapd, &data->dfs_event, false);
+		break;
+	case EVENT_DFS_BACKGROUND_CHAN_EXPAND:
+		if (!data)
+			break;
+		hapd = switch_link_hapd(hapd, data->dfs_event.link_id);
+		hostapd_event_dfs_background_chan_update(hapd, &data->dfs_event, true);
+		break;
+	case EVENT_DFS_STA_CAC_SKIPPED:
+		if (!data)
+			break;
+		hostapd_event_dfs_sta_cac_skipped(hapd, &data->dfs_event);
+		break;
+	case EVENT_DFS_STA_CAC_EXPIRED:
+		if (!data)
+			break;
+		hostapd_event_dfs_sta_cac_expired(hapd, &data->dfs_event);
+		break;
 	case EVENT_CHANNEL_LIST_CHANGED:
 		/* channel list changed (regulatory?), update channel list */
 		/* TODO: check this. hostapd_get_hw_features() initializes
@@ -2803,6 +3072,12 @@ void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
 		hostapd_event_dfs_cac_started(hapd, &data->dfs_event);
 		break;
 #endif /* NEED_AP_MLME */
+	case EVENT_PP_BITMAP_UPDATE:
+		if (!data)
+			break;
+		hapd = switch_link_hapd(hapd, data->ch_switch.link_id);
+		hostapd_event_pp_bitmap_update(hapd, &data->ch_switch);
+		break;
 	case EVENT_INTERFACE_ENABLED:
 #ifdef CONFIG_IEEE80211BE
 		if (hapd->conf->mld_ap) {
@@ -2871,6 +3146,17 @@ void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
 			   hapd->conf->iface);
 		hostapd_event_color_change(hapd, true);
 		break;
+	case EVENT_LINK_RECONFIG:
+		hostapd_link_remove_cb(hapd, data->reconfig_info.removed_links);
+		break;
+	case EVENT_CRIT_UPDATE:
+		if (!data)
+			break;
+		hapd = switch_link_hapd(hapd, data->crit_update_info.link_id);
+#ifdef CONFIG_IEEE80211BE
+		hostapd_event_update_crit_update_flag(hapd, data->crit_update_info.flag);
+#endif /* CONFIG_IEEE80211BE */
+		break;
 #endif /* CONFIG_IEEE80211AX */
 #ifdef CONFIG_IEEE80211BE
 	case EVENT_MLD_INTERFACE_FREED:
@@ -2886,7 +3172,7 @@ void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
 }
 
 
-void wpa_supplicant_event_global(void *ctx, enum wpa_event_type event,
+void hostapd_wpa_event_global(void *ctx, enum wpa_event_type event,
 				 union wpa_event_data *data)
 {
 	struct hapd_interfaces *interfaces = ctx;
diff --git a/src/ap/gas_serv.c b/src/ap/gas_serv.c
index 4642e49..cce6df4 100644
--- a/src/ap/gas_serv.c
+++ b/src/ap/gas_serv.c
@@ -19,6 +19,7 @@
 #include "dpp_hostapd.h"
 #include "sta_info.h"
 #include "gas_serv.h"
+#include "neighbor_db.h"
 
 
 #ifdef CONFIG_DPP
@@ -369,6 +370,24 @@ static void anqp_add_network_auth_type(struct hostapd_data *hapd,
 	}
 }
 
+static void anqp_add_neighbor_report(struct hostapd_data *hapd,
+				       struct wpabuf *buf)
+{
+	struct hostapd_neighbor_entry *nr;
+	u8 *len_pos = gas_anqp_add_element(buf, ANQP_NEIGHBOR_REPORT);
+	if (dl_list_empty(&hapd->nr_db)) {
+		wpabuf_put_le16(buf, 0);
+	}
+	else {
+		dl_list_for_each(nr, &hapd->nr_db, struct hostapd_neighbor_entry, list ) {
+			wpabuf_put_u8(buf, WLAN_EID_NEIGHBOR_REPORT);
+			wpabuf_put_u8(buf, wpabuf_len(nr->nr));
+			wpabuf_put_buf(buf, nr->nr);
+		}
+	}
+	gas_anqp_set_element_len(buf, len_pos);
+}
+
 
 static void anqp_add_roaming_consortium(struct hostapd_data *hapd,
 					struct wpabuf *buf)
@@ -986,6 +1005,9 @@ gas_serv_build_gas_resp_payload(struct hostapd_data *hapd,
 		len += 1000;
 	if (request & ANQP_REQ_ICON_REQUEST)
 		len += 65536;
+    if (request & ANQP_REQ_NEIGHBOR_REPORT) {
+        len += (40 * hostapd_neighbor_count(hapd));
+    }
 #ifdef CONFIG_FILS
 	if (request & ANQP_FILS_REALM_INFO)
 		len += 2 * dl_list_len(&hapd->conf->fils_realms);
@@ -1028,6 +1050,8 @@ gas_serv_build_gas_resp_payload(struct hostapd_data *hapd,
 		anqp_add_elem(hapd, buf, ANQP_TDLS_CAPABILITY);
 	if (request & ANQP_REQ_EMERGENCY_NAI)
 		anqp_add_elem(hapd, buf, ANQP_EMERGENCY_NAI);
+	if (request & ANQP_REQ_NEIGHBOR_REPORT)
+		anqp_add_neighbor_report(hapd, buf);
 
 	for (i = 0; i < num_extra_req; i++) {
 #ifdef CONFIG_FILS
@@ -1172,6 +1196,11 @@ static void rx_anqp_query_list_id(struct hostapd_data *hapd, u16 info_id,
 			     "Emergency NAI",
 			     get_anqp_elem(hapd, info_id) != NULL, qi);
 		break;
+	case ANQP_NEIGHBOR_REPORT:
+		set_anqp_req(ANQP_REQ_NEIGHBOR_REPORT,
+			     "Neighbor Report",
+			     get_anqp_elem(hapd, info_id) != NULL, qi);
+		break;
 	default:
 #ifdef CONFIG_FILS
 		if (info_id == ANQP_FILS_REALM_INFO &&
diff --git a/src/ap/gas_serv.h b/src/ap/gas_serv.h
index 7646a98..ce492b5 100644
--- a/src/ap/gas_serv.h
+++ b/src/ap/gas_serv.h
@@ -40,6 +40,8 @@
 	(1 << (ANQP_TDLS_CAPABILITY - ANQP_QUERY_LIST))
 #define ANQP_REQ_EMERGENCY_NAI \
 	(1 << (ANQP_EMERGENCY_NAI - ANQP_QUERY_LIST))
+#define ANQP_REQ_NEIGHBOR_REPORT \
+	(1 << (ANQP_NEIGHBOR_REPORT - ANQP_QUERY_LIST))
 /*
  * First 15 Hotspot 2.0 vendor specific ANQP-elements can be included in the
  * optimized bitmap.
diff --git a/src/ap/hostapd.c b/src/ap/hostapd.c
index 5ba2cab..0e0d15d 100644
--- a/src/ap/hostapd.c
+++ b/src/ap/hostapd.c
@@ -58,6 +58,7 @@
 #include "wpa_auth_kay.h"
 #include "hw_features.h"
 
+#include "common/mtk_vendor.h"
 
 static int hostapd_flush_old_stations(struct hostapd_data *hapd, u16 reason);
 #ifdef CONFIG_WEP
@@ -247,6 +248,29 @@ static int hostapd_iface_conf_changed(struct hostapd_config *newconf,
 	return 0;
 }
 
+static inline int hostapd_iface_num_sta(struct hostapd_iface *iface)
+{
+	int num_sta = 0;
+	int i;
+
+	for (i = 0; i < iface->num_bss; i++)
+		num_sta += iface->bss[i]->num_sta;
+
+	return num_sta;
+}
+
+
+int hostapd_check_max_sta(struct hostapd_data *hapd)
+{
+	if (hapd->num_sta >= hapd->conf->max_num_sta)
+		return 1;
+
+	if (hapd->iconf->max_num_sta &&
+	    hostapd_iface_num_sta(hapd->iface) >= hapd->iconf->max_num_sta)
+		return 1;
+
+	return 0;
+}
 
 int hostapd_reload_config(struct hostapd_iface *iface)
 {
@@ -255,6 +279,8 @@ int hostapd_reload_config(struct hostapd_iface *iface)
 	struct hostapd_config *newconf, *oldconf;
 	size_t j;
 
+	hostapd_ucode_reload_bss(hapd);
+
 	if (iface->config_fname == NULL) {
 		/* Only in-memory config in use - assume it has been updated */
 		hostapd_clear_old(iface);
@@ -404,26 +430,21 @@ static void hostapd_link_remove_timeout_handler(void *eloop_data,
 						void *user_ctx)
 {
 	struct hostapd_data *hapd = (struct hostapd_data *) eloop_data;
+	struct hostapd_data *link;
+	struct hostapd_mld *mld = hapd->mld;
+	u8 link_id = hapd->mld_link_id;
 
-	if (hapd->eht_mld_link_removal_count == 0)
+	if (!mld || !mld->removed_links)
 		return;
-	hapd->eht_mld_link_removal_count--;
 
-	wpa_printf(MSG_DEBUG, "MLD: Remove link_id=%u in %u beacons",
-		   hapd->mld_link_id,
-		   hapd->eht_mld_link_removal_count);
+	wpa_printf(MSG_DEBUG, "MLD: Remove link_id=%u", hapd->mld_link_id);
 
-	ieee802_11_set_beacon(hapd);
+	hostapd_free_link_stas(hapd);
+	hostapd_disable_iface(hapd->iface);
+	mld->removed_links &= ~BIT(link_id);
 
-	if (!hapd->eht_mld_link_removal_count) {
-		hostapd_free_link_stas(hapd);
-		hostapd_disable_iface(hapd->iface);
-		return;
-	}
-
-	eloop_register_timeout(0, TU_TO_USEC(hapd->iconf->beacon_int),
-			       hostapd_link_remove_timeout_handler,
-			       hapd, NULL);
+	for_each_mld_link(link, mld->fbss)
+		ieee802_11_set_beacon(link);
 }
 
 
@@ -437,18 +458,41 @@ int hostapd_link_remove(struct hostapd_data *hapd, u32 count)
 		   hapd->mld_link_id, count);
 
 	hapd->eht_mld_link_removal_count = count;
-	hapd->eht_mld_bss_param_change++;
-	if (hapd->eht_mld_bss_param_change == 255)
-		hapd->eht_mld_bss_param_change = 0;
-
-	eloop_register_timeout(0, TU_TO_USEC(hapd->iconf->beacon_int),
-			       hostapd_link_remove_timeout_handler,
-			       hapd, NULL);
+	ieee802_11_set_bss_critical_update(hapd, BSS_CRIT_UPDATE_EVENT_RECONFIG);
 
 	ieee802_11_set_beacon(hapd);
+
+	hapd->eht_mld_link_removal_count = 0;
+	hapd->mld->removed_links |= BIT(hapd->mld_link_id);
 	return 0;
 }
 
+
+void hostapd_link_remove_cb(struct hostapd_data *hapd, u16 removed_links)
+{
+	struct hostapd_data *link;
+
+	if (!hapd->conf->mld_ap)
+		return;
+
+	for_each_mld_link(link, hapd) {
+		if (!(BIT(link->mld_link_id) & removed_links))
+			continue;
+
+		eloop_register_timeout(0, 0,
+				       hostapd_link_remove_timeout_handler,
+				       link, NULL);
+	}
+}
+
+
+int hostapd_mld_set_attlm(struct hostapd_data *hapd)
+{
+	if (!hapd->drv_priv)
+		return -1;
+
+	return hostapd_drv_set_attlm(hapd);
+}
 #endif /* CONFIG_TESTING_OPTIONS */
 #endif /* CONFIG_IEEE80211BE */
 
@@ -475,6 +519,8 @@ void hostapd_free_hapd_data(struct hostapd_data *hapd)
 	hapd->beacon_set_done = 0;
 
 	wpa_printf(MSG_DEBUG, "%s(%s)", __func__, hapd->conf->iface);
+	hostapd_ucode_free_bss(hapd);
+	hostapd_ubus_free_bss(hapd);
 	accounting_deinit(hapd);
 	hostapd_deinit_wpa(hapd);
 	vlan_deinit(hapd);
@@ -485,7 +531,7 @@ void hostapd_free_hapd_data(struct hostapd_data *hapd)
 		struct hapd_interfaces *ifaces = hapd->iface->interfaces;
 		size_t i;
 
-		for (i = 0; i < ifaces->count; i++) {
+		for (i = 0; ifaces && i < ifaces->count; i++) {
 			struct hostapd_iface *iface = ifaces->iface[i];
 			size_t j;
 
@@ -546,6 +592,10 @@ void hostapd_free_hapd_data(struct hostapd_data *hapd)
 	    hapd->iface->bss[0] != hapd)
 		hostapd_if_link_remove(hapd, WPA_IF_AP_BSS, hapd->conf->iface,
 				       hapd->mld_link_id);
+	/* Clear the link reconfiguration flag when the added link failed to setup */
+	if (hapd->conf->mld_ap && hapd->mld &&
+	    !(hapd->mld->link_reconf_in_progress & BIT(hapd->mld_link_id)))
+		hapd->mld->link_reconf_in_progress = 0;
 #endif /* CONFIG_IEEE80211BE */
 
 	wpabuf_free(hapd->time_adv);
@@ -728,6 +778,8 @@ void hostapd_cleanup_iface_partial(struct hostapd_iface *iface)
 static void hostapd_cleanup_iface(struct hostapd_iface *iface)
 {
 	wpa_printf(MSG_DEBUG, "%s(%p)", __func__, iface);
+	hostapd_afc_stop(iface);
+	hostapd_ucode_free_iface(iface);
 	eloop_cancel_timeout(hostapd_interface_setup_failure_handler, iface,
 			     NULL);
 
@@ -827,7 +879,9 @@ static int hostapd_flush_old_stations(struct hostapd_data *hapd, u16 reason)
 void hostapd_bss_deinit_no_free(struct hostapd_data *hapd)
 {
 	hostapd_free_stas(hapd);
-	hostapd_flush_old_stations(hapd, WLAN_REASON_DEAUTH_LEAVING);
+	/* do not flush stations during ap link removal */
+	if (!hapd->conf->mld_ap || !hapd->mld->removed_links)
+		hostapd_flush_old_stations(hapd, WLAN_REASON_DEAUTH_LEAVING);
 #ifdef CONFIG_WEP
 	hostapd_clear_wep(hapd);
 #endif /* CONFIG_WEP */
@@ -1298,8 +1352,22 @@ static int hostapd_start_beacon(struct hostapd_data *hapd,
 	if (!conf->start_disabled && ieee802_11_set_beacon(hapd) < 0)
 		return -1;
 
+	if (hapd->conf->mld_ap && !hapd->mld->started) {
+		struct hostapd_data *p_hapd;
+		u16 valid_links = 0;
+
+		for_each_mld_link(p_hapd, hapd)
+			valid_links |= BIT(p_hapd->mld_link_id);
+
+		if (valid_links == hapd->conf->mld_allowed_links ||
+		    !hapd->conf->mld_allowed_links) {
+			hapd->mld->started = 1;
+			ieee802_11_set_beacon(hapd);
+		}
+	}
+
 	if (flush_old_stations && !conf->start_disabled &&
-	    conf->broadcast_deauth) {
+	    conf->broadcast_deauth && (hapd->conf->mld_ap && !hapd->mld->started)) {
 		u8 addr[ETH_ALEN];
 
 		/* Should any previously associated STA not have noticed that
@@ -1316,6 +1384,9 @@ static int hostapd_start_beacon(struct hostapd_data *hapd,
 	if (hapd->driver && hapd->driver->set_operstate)
 		hapd->driver->set_operstate(hapd->drv_priv, 1);
 
+	hostapd_ubus_add_bss(hapd);
+	hostapd_ucode_add_bss(hapd);
+
 	return 0;
 }
 
@@ -1348,6 +1419,7 @@ static int hostapd_bss_radius_init(struct hostapd_data *hapd)
 
 		os_memset(&das_conf, 0, sizeof(das_conf));
 		das_conf.port = conf->radius_das_port;
+		das_conf.nas_identifier = conf->nas_identifier;
 		das_conf.shared_secret = conf->radius_das_shared_secret;
 		das_conf.shared_secret_len =
 			conf->radius_das_shared_secret_len;
@@ -1390,8 +1462,7 @@ static int hostapd_bss_radius_init(struct hostapd_data *hapd)
  * initialized. Most of the modules that are initialized here will be
  * deinitialized in hostapd_cleanup().
  */
-static int hostapd_setup_bss(struct hostapd_data *hapd, int first,
-			     bool start_beacon)
+int hostapd_setup_bss(struct hostapd_data *hapd, int first, bool start_beacon)
 {
 	struct hostapd_bss_config *conf = hapd->conf;
 	u8 ssid[SSID_MAX_LEN + 1];
@@ -1399,10 +1470,20 @@ static int hostapd_setup_bss(struct hostapd_data *hapd, int first,
 	char force_ifname[IFNAMSIZ];
 	u8 if_addr[ETH_ALEN];
 	int flush_old_stations = 1;
+	u32 radio_mask = 0;
 
-	if (!hostapd_mld_is_first_bss(hapd))
+	if (!hostapd_mld_is_first_bss(hapd)) {
+		/* Only flush old stations when setting up the first BSS for the MLD. */
+		flush_old_stations = 0;
 		wpa_printf(MSG_DEBUG,
 			   "MLD: %s: Setting non-first BSS", __func__);
+	} else if (hapd->conf->mld_ap &&
+		   hapd->iface->state == HAPD_IFACE_DFS) {
+		/* Also, avoid flushing old STA when the first BSS of the MLD requires CAC. */
+		flush_old_stations = 0;
+		wpa_printf(MSG_DEBUG,
+			   "MLD: %s: Setting first BSS after CAC complete", __func__);
+	}
 
 	wpa_printf(MSG_DEBUG, "%s(hapd=%p (%s), first=%d)",
 		   __func__, hapd, conf->iface, first);
@@ -1458,6 +1539,16 @@ static int hostapd_setup_bss(struct hostapd_data *hapd, int first,
 					   hapd->mld_link_id, hapd->conf->iface);
 				goto setup_mld;
 			}
+
+			if (addr && !is_zero_ether_addr(hapd->conf->mld_addr))
+				os_memcpy(addr, hapd->conf->mld_addr, ETH_ALEN);
+		}
+
+		if (hapd->iface->current_hw_info) {
+			if (hapd->conf->mld_ap)
+				radio_mask = hapd->conf->mld_radio_mask;
+			else
+				radio_mask = 1 << hapd->iface->current_hw_info->hw_idx;
 		}
 #endif /* CONFIG_IEEE80211BE */
 
@@ -1466,7 +1557,7 @@ static int hostapd_setup_bss(struct hostapd_data *hapd, int first,
 				   conf->iface, addr, hapd,
 				   &hapd->drv_priv, force_ifname, if_addr,
 				   conf->bridge[0] ? conf->bridge : NULL,
-				   first == -1)) {
+				   first == -1, hapd->iface->freq, radio_mask)) {
 			wpa_printf(MSG_ERROR, "Failed to add BSS (BSSID="
 				   MACSTR ")", MAC2STR(hapd->own_addr));
 			hapd->interface_added = 0;
@@ -1483,6 +1574,9 @@ static int hostapd_setup_bss(struct hostapd_data *hapd, int first,
 				   hapd->mld_link_id, hapd->conf->iface);
 			os_memcpy(hapd->mld->mld_addr, hapd->own_addr,
 				  ETH_ALEN);
+
+			if (!is_zero_ether_addr(conf->bssid))
+				os_memcpy(hapd->own_addr, conf->bssid, ETH_ALEN);
 		}
 #endif /* CONFIG_IEEE80211BE */
 	}
@@ -1507,6 +1601,8 @@ setup_mld:
 	}
 #endif /* CONFIG_IEEE80211BE */
 
+	hostapd_ucode_create_bss(hapd);
+
 	if (conf->wmm_enabled < 0)
 		conf->wmm_enabled = hapd->iconf->ieee80211n |
 			hapd->iconf->ieee80211ax;
@@ -2420,7 +2516,11 @@ static int hostapd_owe_iface_iter(struct hostapd_iface *iface, void *ctx)
 		if (!bss->conf->ssid.ssid_set || !bss->conf->ssid.ssid_len ||
 		    is_zero_ether_addr(bss->own_addr))
 			continue;
-
+		if (!os_memcmp(hapd->conf->owe_transition_bssid, bss->own_addr, ETH_ALEN) &&
+		    hapd->conf->owe_transition_ssid_len == bss->conf->ssid.ssid_len &&
+		    !os_memcmp(hapd->conf->owe_transition_ssid, bss->conf->ssid.ssid,
+			       bss->conf->ssid.ssid_len))
+			return 0;
 		os_memcpy(hapd->conf->owe_transition_bssid, bss->own_addr,
 			  ETH_ALEN);
 		os_memcpy(hapd->conf->owe_transition_ssid,
@@ -2437,10 +2537,6 @@ static int hostapd_owe_iface_iter(struct hostapd_iface *iface, void *ctx)
 
 int hostapd_owe_trans_get_info(struct hostapd_data *hapd)
 {
-	if (hapd->conf->owe_transition_ssid_len > 0 &&
-	    !is_zero_ether_addr(hapd->conf->owe_transition_bssid))
-		return 0;
-
 	/* Find transition mode SSID/BSSID information from a BSS operated by
 	 * this hostapd instance. */
 	if (!hapd->iface->interfaces ||
@@ -2484,7 +2580,7 @@ static int hostapd_owe_iface_iter2(struct hostapd_iface *iface, void *ctx)
 #endif /* CONFIG_OWE */
 
 
-static void hostapd_owe_update_trans(struct hostapd_iface *iface)
+void hostapd_owe_update_trans(struct hostapd_iface *iface)
 {
 #ifdef CONFIG_OWE
 	/* Check whether the enabled BSS can complete OWE transition mode
@@ -2525,6 +2621,7 @@ static int hostapd_setup_interface_complete_sync(struct hostapd_iface *iface,
 	if (err)
 		goto fail;
 
+	hostapd_ubus_add_iface(iface);
 	wpa_printf(MSG_DEBUG, "Completing interface initialization");
 	if (iface->freq) {
 #ifdef NEED_AP_MLME
@@ -2581,6 +2678,16 @@ static int hostapd_setup_interface_complete_sync(struct hostapd_iface *iface,
 		}
 #endif /* CONFIG_MESH */
 
+#ifdef CONFIG_IEEE80211AX
+		/* check AFC for 6GHz channels. */
+		res = hostapd_afc_handle_request(iface);
+		if (res <= 0) {
+			if (res < 0)
+				goto fail;
+			return res;
+		}
+#endif /* CONFIG_IEEE80211AX */
+
 		if (!delay_apply_cfg &&
 		    hostapd_set_freq(hapd, hapd->iconf->hw_mode, iface->freq,
 				     hapd->iconf->channel,
@@ -2639,6 +2746,7 @@ static int hostapd_setup_interface_complete_sync(struct hostapd_iface *iface,
 			for (;;) {
 				hapd = iface->bss[j];
 				hostapd_bss_deinit_no_free(hapd);
+				hostapd_bss_link_deinit(hapd);
 				hostapd_free_hapd_data(hapd);
 				if (j == 0)
 					break;
@@ -2735,6 +2843,25 @@ dfs_offload:
 	}
 #endif /* CONFIG_MESH */
 
+	if (hostapd_drv_pp_mode_set(hapd) < 0)
+		goto fail;
+	if (hostapd_drv_configure_edcca_enable(hapd) < 0)
+		goto fail;
+
+	if (hostapd_drv_configure_edcca_threshold(hapd,
+						  hapd->iconf->edcca_threshold) < 0)
+		goto fail;
+	if (hostapd_drv_mu_ctrl(hapd, MU_CTRL_ONOFF) < 0)
+		goto fail;
+	if (hostapd_drv_three_wire_ctrl(hapd) < 0)
+		goto fail;
+	if (hostapd_drv_ibf_ctrl(hapd) < 0)
+		goto fail;
+	if (hostapd_drv_amsdu_ctrl(hapd) < 0)
+		goto fail;
+	if (hostapd_drv_txpower_ctrl(hapd) < 0)
+		goto fail;
+
 	wpa_printf(MSG_DEBUG, "%s: Setup of interface done.",
 		   iface->bss[0]->conf->iface);
 	if (iface->interfaces && iface->interfaces->terminate_on_error > 0)
@@ -2750,6 +2877,7 @@ dfs_offload:
 
 fail:
 	wpa_printf(MSG_ERROR, "Interface initialization failed");
+	hostapd_ubus_free_iface(iface);
 
 	if (iface->is_no_ir) {
 		hostapd_set_state(iface, HAPD_IFACE_NO_IR);
@@ -2797,6 +2925,24 @@ int hostapd_setup_interface_complete(struct hostapd_iface *iface, int err)
 	unsigned int i;
 	int not_ready_in_sync_ifaces = 0;
 
+	if (iface->state == HAPD_IFACE_ACS) {
+		int i;
+
+		for (i = 0; i < interfaces->count; i++) {
+			if (!interfaces->iface[i]->freq) {
+				/* FIXME problems remained
+				 * 1. the return value of acs_init() is
+				 *    not check
+				 * 2. if it fails the setup, next acs_init()
+				 *    will not be handled
+				 */
+				wpa_printf(MSG_DEBUG, "mtk: trigger acs_init for %s", interfaces->iface[i]->phy);
+				acs_init(interfaces->iface[i]);
+				break;
+			}
+		}
+	}
+
 	if (!iface->need_to_start_in_sync)
 		return hostapd_setup_interface_complete_sync(iface, err);
 
@@ -2949,7 +3095,7 @@ hostapd_alloc_bss_data(struct hostapd_iface *hapd_iface,
 }
 
 
-static void hostapd_bss_deinit(struct hostapd_data *hapd)
+void hostapd_bss_deinit(struct hostapd_data *hapd)
 {
 	if (!hapd)
 		return;
@@ -2979,6 +3125,7 @@ void hostapd_interface_deinit(struct hostapd_iface *iface)
 
 	hostapd_set_state(iface, HAPD_IFACE_DISABLED);
 
+	hostapd_afc_stop(iface);
 	eloop_cancel_timeout(channel_list_update_timeout, iface, NULL);
 	iface->wait_channel_update = 0;
 	iface->is_no_ir = false;
@@ -3052,6 +3199,10 @@ void hostapd_interface_free(struct hostapd_iface *iface)
 			   __func__, iface->bss[j]);
 		os_free(iface->bss[j]);
 	}
+#ifdef CONFIG_AFC
+	os_free(iface->afc.chan_info_list);
+	os_free(iface->afc.freq_range);
+#endif
 	hostapd_cleanup_iface(iface);
 }
 
@@ -3074,6 +3225,12 @@ struct hostapd_iface * hostapd_alloc_iface(void)
 static void hostapd_bss_alloc_link_id(struct hostapd_data *hapd)
 {
 	hapd->mld_link_id = hapd->mld->next_link_id++;
+
+#ifdef CONFIG_TESTING_OPTIONS
+	if (hapd->conf->mld_link_id != -1)
+		hapd->mld_link_id = hapd->conf->mld_link_id;
+#endif /* CONFIG_TESTING_OPTIONS */
+
 	wpa_printf(MSG_DEBUG, "AP MLD: %s: Link ID %d assigned.",
 		   hapd->mld->name, hapd->mld_link_id);
 }
@@ -3363,11 +3520,20 @@ hostapd_interface_init_bss(struct hapd_interfaces *interfaces, const char *phy,
 		}
 
 		ifname = conf->bss[0]->iface;
-		if (ifname[0] != '\0' && ifname_in_use(interfaces, ifname)) {
-			wpa_printf(MSG_ERROR,
-				   "Interface name %s already in use", ifname);
-			hostapd_config_free(conf);
-			return NULL;
+		if (conf->bss[0]->mld_ap) {
+			if (!iface->bss[0]->conf->mld_ap) {
+				wpa_printf(MSG_ERROR,
+					   "Cannot add a MLO BSS when the first BSS is non-MLO");
+				hostapd_config_free(conf);
+				return NULL;
+			}
+		} else {
+			if (ifname[0] != '\0' && ifname_in_use(interfaces, ifname)) {
+				wpa_printf(MSG_ERROR,
+					   "Interface name %s already in use", ifname);
+				hostapd_config_free(conf);
+				return NULL;
+			}
 		}
 
 		tmp_conf = os_realloc_array(
@@ -3399,7 +3565,6 @@ hostapd_interface_init_bss(struct hapd_interfaces *interfaces, const char *phy,
 		hapd->msg_ctx = hapd;
 		hostapd_bss_setup_multi_link(hapd, interfaces);
 
-
 		bss_idx = iface->num_bss++;
 		conf->num_bss--;
 		conf->bss[0] = NULL;
@@ -3478,6 +3643,7 @@ void hostapd_interface_deinit_free(struct hostapd_iface *iface)
 		   (unsigned int) iface->conf->num_bss);
 	driver = iface->bss[0]->driver;
 	drv_priv = iface->bss[0]->drv_priv;
+	hostapd_ubus_free_iface(iface);
 	hostapd_interface_deinit(iface);
 	wpa_printf(MSG_DEBUG, "%s: driver=%p drv_priv=%p -> hapd_deinit",
 		   __func__, driver, drv_priv);
@@ -3608,6 +3774,61 @@ int hostapd_reload_bss_only(struct hostapd_data *bss)
 }
 
 
+int hostapd_enable_bss(struct hostapd_data *hapd)
+{
+	if (hapd->beacon_set_done)
+		return 0;
+
+	if (hapd->conf->bss_load_update_period && bss_load_update_init(hapd)) {
+		wpa_printf(MSG_ERROR, "BSS Load initialization failed");
+		return -1;
+	}
+
+	return ieee802_11_set_beacon_per_bss_only(hapd);
+}
+
+
+#ifdef CONFIG_IEEE80211BE
+int hostapd_enable_mld(struct hostapd_data *hapd)
+{
+	struct hostapd_mld *mld;
+	struct hostapd_data *h;
+	int ret = 0;
+
+	if (!hapd || !hostapd_is_mld_ap(hapd)) {
+		wpa_printf(MSG_ERROR,
+			   "Trying to enable AP MLD on an interface that is not affiliated with an AP MLD");
+		return -1;
+	}
+
+	mld = hapd->mld;
+	if (!mld) {
+		wpa_printf(MSG_ERROR, "No AP MLD information found");
+		return -1;
+	}
+
+	if (mld->started) {
+		wpa_printf(MSG_DEBUG, "AP MLD is already enabled");
+		return 0;
+	}
+
+	mld->started = true;
+	for_each_mld_link(h, hapd) {
+		ret = hostapd_enable_bss(h);
+
+		if (ret) {
+			wpa_printf(MSG_ERROR, "Enabling link id %d fails",
+				   h->mld_link_id);
+			hostapd_disable_mld(hapd);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+#endif /* CONFIG_IEEE80211BE */
+
+
 int hostapd_disable_iface(struct hostapd_iface *hapd_iface)
 {
 	size_t j;
@@ -3662,6 +3883,73 @@ int hostapd_disable_iface(struct hostapd_iface *hapd_iface)
 }
 
 
+int hostapd_disable_bss(struct hostapd_data *hapd)
+{
+	struct hostapd_iface *iface = hapd->iface;
+	int i, remain_bss = 0;
+
+	if (!hapd->beacon_set_done)
+		return 0;
+
+	for (i = 0; i < iface->num_bss; i++)
+		remain_bss += iface->bss[i]->beacon_set_done ? 1 : 0;
+
+	if (remain_bss == 1) {
+		wpa_printf(MSG_ERROR, "Cannot disable last BSS");
+		return -1;
+	}
+
+	hapd->beacon_set_done = 0;
+	bss_load_update_deinit(hapd);
+	hostapd_bss_deinit_no_free(hapd);
+	return hostapd_drv_stop_ap(hapd);
+}
+
+
+#ifdef CONFIG_IEEE80211BE
+int hostapd_disable_mld(struct hostapd_data *hapd)
+{
+	struct hapd_interfaces *interfaces;
+	struct hostapd_mld *mld;
+	struct hostapd_data *h;
+	int remain_mld = 0, i;
+
+	if (!hostapd_is_mld_ap(hapd)) {
+		wpa_printf(MSG_ERROR,
+			   "Trying to disable AP MLD on an interface that is not affiliated with an AP MLD.");
+		return -1;
+	}
+
+	mld = hapd->mld;
+	if (!mld) {
+		wpa_printf(MSG_ERROR, "No AP MLD information found");
+		return -1;
+	}
+
+	if (!mld->started) {
+		wpa_printf(MSG_DEBUG, "AP MLD is already disabled");
+		return 0;
+	}
+
+	interfaces = hapd->iface->interfaces;
+	for (i = 0; i < interfaces->mld_count; i++)
+		remain_mld += interfaces->mld[i]->started ? 1 : 0;
+
+	if (remain_mld == 1) {
+		wpa_printf(MSG_ERROR, "Cannot disable last AP MLD");
+		return -1;
+	}
+
+	for_each_mld_link(h, hapd)
+		hostapd_disable_bss(h);
+
+	mld->started = false;
+
+	return 0;
+}
+#endif /* CONFIG_IEEE80211BE */
+
+
 static struct hostapd_iface *
 hostapd_iface_alloc(struct hapd_interfaces *interfaces)
 {
@@ -3823,6 +4111,7 @@ int hostapd_add_iface(struct hapd_interfaces *interfaces, char *buf)
 				goto fail;
 
 			if (hostapd_setup_interface(hapd_iface)) {
+				hostapd_bss_link_deinit(hapd_iface->bss[0]);
 				hostapd_deinit_driver(
 					hapd_iface->bss[0]->driver,
 					hapd_iface->bss[0]->drv_priv,
@@ -3963,7 +4252,35 @@ fail:
 }
 
 
-static int hostapd_remove_bss(struct hostapd_iface *iface, unsigned int idx)
+int hostapd_move_bss_to_first(struct hostapd_iface *iface, int idx)
+{
+	struct hostapd_data *target_hapd, *first_hapd;
+
+	if (idx == 0 || idx >= iface->num_bss)
+		return -1;
+
+	target_hapd = iface->bss[idx];
+	first_hapd = iface->bss[0];
+	if (hostapd_drv_move_bss_to_first(first_hapd, target_hapd->conf->iface))
+		return -1;
+
+	iface->bss[0] = target_hapd;
+	iface->bss[idx] = first_hapd;
+	iface->conf->bss[0] = iface->bss[0]->conf;
+	iface->conf->bss[idx] = iface->bss[idx]->conf;
+
+	first_hapd->interface_added = 1;
+	target_hapd->interface_added = 0;
+
+	if (idx == iface->num_bss - 1)
+		iface->conf->last_bss = iface->bss[idx]->conf;
+
+	return 0;
+}
+
+
+static int hostapd_remove_bss_by_idx(struct hostapd_iface *iface,
+				     unsigned int idx)
 {
 	size_t i;
 
@@ -4000,16 +4317,85 @@ static int hostapd_remove_bss(struct hostapd_iface *iface, unsigned int idx)
 }
 
 
-int hostapd_remove_iface(struct hapd_interfaces *interfaces, char *buf)
+int hostapd_remove_bss(struct hapd_interfaces *interfaces, char *buf)
 {
 	struct hostapd_iface *hapd_iface;
 	size_t i, j, k = 0;
+	int ret;
 
 	for (i = 0; i < interfaces->count; i++) {
 		hapd_iface = interfaces->iface[i];
 		if (hapd_iface == NULL)
 			return -1;
+
 		if (!os_strcmp(hapd_iface->conf->bss[0]->iface, buf)) {
+#ifdef CONFIG_IEEE80211BE
+			if (hostapd_is_mld_ap(hapd_iface->bss[0])) {
+				wpa_printf(MSG_ERROR, "Cannot remove MLD link\n");
+				return -1;
+			}
+#endif /* CONFIG_IEEE80211BE */
+
+			if (hapd_iface->conf->num_bss == 1) {
+				wpa_printf(MSG_INFO, "Remove interface '%s'", buf);
+				hapd_iface->driver_ap_teardown =
+					!!(hapd_iface->drv_flags &
+					   WPA_DRIVER_FLAGS_AP_TEARDOWN_SUPPORT);
+
+				hostapd_interface_deinit_free(hapd_iface);
+				k = i;
+				while (k < (interfaces->count - 1)) {
+					interfaces->iface[k] =
+						interfaces->iface[k + 1];
+					k++;
+				}
+				interfaces->count--;
+				return 0;
+			} else {
+				wpa_printf(MSG_INFO, "Switch interface to %s",
+					   hapd_iface->bss[1]->conf->iface);
+
+				ret = hostapd_move_bss_to_first(hapd_iface, 1);
+				if (ret < 0) {
+					wpa_printf(MSG_ERROR,
+						   "Interface switch failed");
+					return ret;
+				}
+			}
+		}
+
+		for (j = 0; j < hapd_iface->conf->num_bss; j++) {
+			if (!os_strcmp(hapd_iface->conf->bss[j]->iface, buf)) {
+#ifdef CONFIG_IEEE80211BE
+				if (hostapd_is_mld_ap(hapd_iface->bss[j])) {
+					wpa_printf(MSG_ERROR,
+						   "Cannot remove MLD link\n");
+					return -1;
+				}
+#endif /* CONFIG_IEEE80211BE */
+
+				hapd_iface->driver_ap_teardown =
+					!(hapd_iface->drv_flags &
+					  WPA_DRIVER_FLAGS_AP_TEARDOWN_SUPPORT);
+				return hostapd_remove_bss_by_idx(hapd_iface, j);
+			}
+		}
+	}
+	return -1;
+}
+
+
+int hostapd_remove_iface(struct hapd_interfaces *interfaces, char *buf)
+{
+	struct hostapd_iface *hapd_iface;
+	size_t i, j, k = 0;
+
+	for (i = 0; i < interfaces->count; i++) {
+		hapd_iface = interfaces->iface[i];
+		if (hapd_iface == NULL)
+			return -1;
+		if (!os_strcmp(hapd_iface->phy, buf) ||
+		    !os_strcmp(hapd_iface->conf->bss[0]->iface, buf)) {
 			wpa_printf(MSG_INFO, "Remove interface '%s'", buf);
 			hapd_iface->driver_ap_teardown =
 				!!(hapd_iface->drv_flags &
@@ -4033,7 +4419,7 @@ int hostapd_remove_iface(struct hapd_interfaces *interfaces, char *buf)
 				hapd_iface->driver_ap_teardown =
 					!(hapd_iface->drv_flags &
 					  WPA_DRIVER_FLAGS_AP_TEARDOWN_SUPPORT);
-				return hostapd_remove_bss(hapd_iface, j);
+				return hostapd_remove_bss_by_idx(hapd_iface, j);
 			}
 		}
 	}
@@ -4041,6 +4427,99 @@ int hostapd_remove_iface(struct hapd_interfaces *interfaces, char *buf)
 }
 
 
+static int hostapd_remove_mld_link_by_idx(struct hostapd_iface *iface, int idx)
+{
+	size_t j;
+	int ret;
+
+	if (iface->num_bss == 1) {
+		hostapd_remove_iface(iface->interfaces, iface->phy);
+		return 0;
+	}
+
+	if (idx == 0) {
+		for (j = 1; j < iface->num_bss; j++) {
+			if (iface->bss[j]->conf->mld_ap)
+				break;
+		}
+
+		if (j == iface->num_bss)
+			return -1;
+
+		ret = hostapd_move_bss_to_first(iface, j);
+		if (ret) {
+			wpa_printf(MSG_ERROR, "Interface switch failed");
+			return ret;
+		}
+
+		idx = j;
+	}
+
+	return hostapd_remove_bss_by_idx(iface, idx);
+}
+
+int hostapd_remove_mld(struct hapd_interfaces *interfaces, char *buf)
+{
+	struct hostapd_iface *iface;
+	struct hostapd_data *first_hapd;
+	struct hostapd_mld *mld = NULL;
+	int ret, i, j, num_mld, first_hapd_idx;
+
+	for (i = 0; i < interfaces->mld_count; i++) {
+		if (interfaces->mld[i] &&
+		    os_strcmp(interfaces->mld[i]->name, buf) == 0) {
+			mld = interfaces->mld[i];
+			break;
+		}
+	}
+
+	if (!mld) {
+		wpa_printf(MSG_ERROR, "MLD not found");
+		return -1;
+	}
+
+	for (i = 0; i < interfaces->count; i++) {
+		iface = interfaces->iface[i];
+		if (!iface)
+			continue;
+
+		num_mld = 0;
+		for (j = 0; j < iface->num_bss; j++) {
+			if (hostapd_is_mld_ap(iface->bss[j]))
+				num_mld++;
+		}
+
+		if (num_mld == 1 && iface->num_bss > 1) {
+			wpa_printf(MSG_ERROR,
+				   "Cannot remove the last AP MLD while there are remaining legacy BSSes");
+			return -1;
+		}
+	}
+
+	for (i = interfaces->count - 1; i >= 0; i--) {
+		iface = interfaces->iface[i];
+		if (!iface)
+			continue;
+
+		for (j = 0; j < iface->num_bss; j++) {
+			if (os_strcmp(iface->bss[j]->conf->iface, mld->name) == 0) {
+				if (hostapd_mld_is_first_bss(iface->bss[j])) {
+					first_hapd = iface->bss[j];
+					first_hapd_idx = j;
+					break;
+				}
+
+				hostapd_remove_mld_link_by_idx(iface, j);
+			}
+		}
+	}
+
+	hostapd_remove_mld_link_by_idx(first_hapd->iface, first_hapd_idx);
+	hostapd_cleanup_unused_mlds(interfaces);
+	return 0;
+}
+
+
 /**
  * hostapd_new_assoc_sta - Notify that a new station associated with the AP
  * @hapd: Pointer to BSS data
@@ -4055,6 +4534,8 @@ int hostapd_remove_iface(struct hapd_interfaces *interfaces, char *buf)
 void hostapd_new_assoc_sta(struct hostapd_data *hapd, struct sta_info *sta,
 			   int reassoc)
 {
+	int mld_assoc_link_id = -1;
+
 	if (hapd->tkip_countermeasures) {
 		hostapd_drv_sta_deauth(hapd, sta->addr,
 				       WLAN_REASON_MICHAEL_MIC_FAILURE);
@@ -4062,10 +4543,14 @@ void hostapd_new_assoc_sta(struct hostapd_data *hapd, struct sta_info *sta,
 	}
 
 #ifdef CONFIG_IEEE80211BE
-	if (ap_sta_is_mld(hapd, sta) &&
-	    sta->mld_assoc_link_id != hapd->mld_link_id)
-		return;
+	if (ap_sta_is_mld(hapd, sta)) {
+		if (sta->mld_assoc_link_id != hapd->mld_link_id)
+			return;
+		mld_assoc_link_id = sta->mld_assoc_link_id;
+	}
 #endif /* CONFIG_IEEE80211BE */
+        if (mld_assoc_link_id != -2)
+		hostapd_prune_associations(hapd, sta->addr, mld_assoc_link_id);
 
 	ap_sta_clear_disconnect_timeouts(hapd, sta);
 	sta->post_csa_sa_query = 0;
@@ -4310,23 +4795,26 @@ static int hostapd_change_config_freq(struct hostapd_data *hapd,
 	mode = hapd->iface->current_mode;
 
 	/* if a pointer to old_params is provided we save previous state */
-	if (old_params &&
-	    hostapd_set_freq_params(old_params, conf->hw_mode,
-				    hostapd_hw_get_freq(hapd, conf->channel),
-				    conf->channel, conf->enable_edmg,
-				    conf->edmg_channel, conf->ieee80211n,
-				    conf->ieee80211ac, conf->ieee80211ax,
-				    conf->ieee80211be, conf->secondary_channel,
-				    hostapd_get_oper_chwidth(conf),
-				    hostapd_get_oper_centr_freq_seg0_idx(conf),
-				    hostapd_get_oper_centr_freq_seg1_idx(conf),
-				    conf->vht_capab,
-				    mode ? &mode->he_capab[IEEE80211_MODE_AP] :
-				    NULL,
-				    mode ? &mode->eht_capab[IEEE80211_MODE_AP] :
-				    NULL,
-				    hostapd_get_punct_bitmap(hapd)))
-		return -1;
+	if (old_params) {
+		if (hostapd_set_freq_params(old_params, conf->hw_mode,
+					    hostapd_hw_get_freq(hapd, conf->channel),
+					    conf->channel, conf->enable_edmg,
+					    conf->edmg_channel, conf->ieee80211n,
+					    conf->ieee80211ac, conf->ieee80211ax,
+					    conf->ieee80211be, conf->secondary_channel,
+					    hostapd_get_oper_chwidth(conf),
+					    hostapd_get_oper_centr_freq_seg0_idx(conf),
+					    hostapd_get_oper_centr_freq_seg1_idx(conf),
+					    conf->vht_capab,
+					    mode ? &mode->he_capab[IEEE80211_MODE_AP] :
+					    NULL,
+					    mode ? &mode->eht_capab[IEEE80211_MODE_AP] :
+					    NULL,
+					    hostapd_get_punct_bitmap(hapd)))
+			return -1;
+
+		old_params->op_class = conf->op_class;
+	}
 
 	switch (params->bandwidth) {
 	case 0:
@@ -4371,6 +4859,7 @@ static int hostapd_change_config_freq(struct hostapd_data *hapd,
 	conf->ieee80211n = params->ht_enabled;
 	conf->ieee80211ac = params->vht_enabled;
 	conf->secondary_channel = params->sec_channel_offset;
+	conf->op_class = params->op_class;
 	if (params->center_freq1 &&
 	    ieee80211_freq_to_chan(params->center_freq1, &seg0) ==
 	    NUM_HOSTAPD_MODES)
@@ -4382,6 +4871,8 @@ static int hostapd_change_config_freq(struct hostapd_data *hapd,
 	hostapd_set_oper_centr_freq_seg0_idx(conf, seg0);
 	hostapd_set_oper_centr_freq_seg1_idx(conf, seg1);
 
+	conf->punct_bitmap = params->punct_bitmap;
+
 	/* TODO: maybe call here hostapd_config_check here? */
 
 	return 0;
@@ -4394,9 +4885,6 @@ static int hostapd_fill_csa_settings(struct hostapd_data *hapd,
 	struct hostapd_iface *iface = hapd->iface;
 	struct hostapd_freq_params old_freq;
 	int ret;
-#ifdef CONFIG_IEEE80211BE
-	u16 old_punct_bitmap;
-#endif /* CONFIG_IEEE80211BE */
 	u8 chan, bandwidth;
 
 	os_memset(&old_freq, 0, sizeof(old_freq));
@@ -4439,22 +4927,18 @@ static int hostapd_fill_csa_settings(struct hostapd_data *hapd,
 
 	settings->freq_params.channel = chan;
 
+	settings->freq_params.op_class = hapd->iface->cs_oper_class;
 	ret = hostapd_change_config_freq(iface->bss[0], iface->conf,
 					 &settings->freq_params,
 					 &old_freq);
 	if (ret)
 		return ret;
 
-#ifdef CONFIG_IEEE80211BE
-	old_punct_bitmap = iface->conf->punct_bitmap;
-	iface->conf->punct_bitmap = settings->punct_bitmap;
-#endif /* CONFIG_IEEE80211BE */
+	/* Another CU in the new channel due to OP element modification */
+	ieee802_11_set_bss_critical_update(hapd, BSS_CRIT_UPDATE_EVENT_EHT_OPERATION);
 	ret = hostapd_build_beacon_data(hapd, &settings->beacon_after);
 
 	/* change back the configuration */
-#ifdef CONFIG_IEEE80211BE
-	iface->conf->punct_bitmap = old_punct_bitmap;
-#endif /* CONFIG_IEEE80211BE */
 	hostapd_change_config_freq(iface->bss[0], iface->conf,
 				   &old_freq, NULL);
 
@@ -4466,6 +4950,12 @@ static int hostapd_fill_csa_settings(struct hostapd_data *hapd,
 	hapd->cs_count = settings->cs_count;
 	hapd->cs_block_tx = settings->block_tx;
 
+#ifdef CONFIG_IEEE80211BE
+	/* Restore BPCC to build the CSA beacon */
+	hapd->eht_mld_bss_param_change--;
+	hapd->eht_mld_bss_critical_update = BSS_CRIT_UPDATE_ALL;
+#endif /* CONFIG_IEEE80211BE */
+
 	ret = hostapd_build_beacon_data(hapd, &settings->beacon_csa);
 	if (ret) {
 		free_beacon_data(&settings->beacon_after);
@@ -4477,9 +4967,12 @@ static int hostapd_fill_csa_settings(struct hostapd_data *hapd,
 	settings->counter_offset_beacon[1] = hapd->cs_c_off_ecsa_beacon;
 	settings->counter_offset_presp[1] = hapd->cs_c_off_ecsa_proberesp;
 	settings->link_id = -1;
+	settings->freq_params.link_id = -1;
 #ifdef CONFIG_IEEE80211BE
-	if (hapd->conf->mld_ap)
+	if (hapd->conf->mld_ap) {
 		settings->link_id = hapd->mld_link_id;
+		settings->freq_params.link_id = hapd->mld_link_id;
+	}
 #endif /* CONFIG_IEEE80211BE */
 
 #ifdef CONFIG_IEEE80211AX
@@ -4534,13 +5027,25 @@ void hostapd_chan_switch_config(struct hostapd_data *hapd,
 int hostapd_switch_channel(struct hostapd_data *hapd,
 			   struct csa_settings *settings)
 {
+	struct hostapd_data *link_bss;
 	int ret;
 
+	if (!hapd->beacon_set_done)
+		return 0;
+
 	if (!(hapd->iface->drv_flags & WPA_DRIVER_FLAGS_AP_CSA)) {
 		wpa_printf(MSG_INFO, "CSA is not supported");
 		return -1;
 	}
 
+	ieee802_11_set_bss_critical_update(hapd, BSS_CRIT_UPDATE_EVENT_CSA);
+
+	if (hapd->conf->mld_ap) {
+		/* Generate per STA profiles for each affiliated APs */
+		for_each_mld_link(link_bss, hapd)
+			hostapd_gen_per_sta_profiles(link_bss);
+	}
+
 	ret = hostapd_fill_csa_settings(hapd, settings);
 	if (ret)
 		return ret;
@@ -4562,6 +5067,78 @@ int hostapd_switch_channel(struct hostapd_data *hapd,
 	return 0;
 }
 
+int hostapd_update_aff_link_beacon(struct hostapd_data *hapd, u8 cs_count)
+{
+	struct hostapd_data *h;
+	unsigned int cs_link_id = hapd->mld_link_id;
+	int cs_channel = hapd->cs_freq_params.channel;
+
+	/* TODO: add beacon offload driver flag */
+	for_each_mld_link(h, hapd) {
+		struct hostapd_config *conf = h->iconf;
+		struct hostapd_hw_modes *mode = h->iface->current_mode;
+		struct csa_settings settings = {};
+		struct hostapd_freq_params old_freq;
+		unsigned int link_id = h->mld_link_id;
+		int ret;
+
+		if (!h->started || h == hapd)
+			continue;
+
+		os_memset(&old_freq, 0, sizeof(old_freq));
+		ret = hostapd_change_config_freq(hapd, hapd->iconf,
+						 &hapd->cs_freq_params,
+						 &old_freq);
+		if (ret)
+			return ret;
+		hostapd_set_freq_params(&settings.freq_params, conf->hw_mode,
+					hostapd_hw_get_freq(h, conf->channel),
+					conf->channel, conf->enable_edmg,
+					conf->edmg_channel, conf->ieee80211n,
+					conf->ieee80211ac, conf->ieee80211ax,
+					conf->ieee80211be, conf->secondary_channel,
+					hostapd_get_oper_chwidth(conf),
+					hostapd_get_oper_centr_freq_seg0_idx(conf),
+					hostapd_get_oper_centr_freq_seg1_idx(conf),
+					conf->vht_capab,
+					mode ? &mode->he_capab[IEEE80211_MODE_AP] : NULL,
+					mode ? &mode->eht_capab[IEEE80211_MODE_AP] : NULL,
+					hostapd_get_punct_bitmap(h));
+		hapd->cs_freq_params.channel = 0;
+		ieee802_11_set_bss_critical_update(hapd, BSS_CRIT_UPDATE_EVENT_EHT_OPERATION);
+		ret = hostapd_build_beacon_data(h, &settings.beacon_after);
+		hostapd_change_config_freq(hapd, hapd->iconf,
+					   &old_freq, NULL);
+		if (ret)
+			return ret;
+
+		hapd->cs_freq_params.channel = cs_channel;
+		/* Restore BPCC to build the RNR for the CS link */
+		hapd->eht_mld_bss_param_change--;
+		hapd->eht_mld_bss_critical_update = BSS_CRIT_UPDATE_ALL;
+		ret = hostapd_build_beacon_data(h, &settings.beacon_csa);
+		if (ret) {
+			free_beacon_data(&settings.beacon_after);
+			return ret;
+		}
+
+		settings.counter_offset_sta_prof[cs_link_id][0] =
+						h->cs_c_off_sta_prof[cs_link_id];
+		settings.counter_offset_sta_prof[cs_link_id][1] =
+						h->cs_c_off_ecsa_sta_prof[cs_link_id];
+		settings.link_id = cs_link_id;
+		settings.freq_params.link_id = link_id;
+		settings.cs_count = cs_count;
+		ret = hostapd_drv_switch_channel(h, &settings);
+		free_beacon_data(&settings.beacon_csa);
+		free_beacon_data(&settings.beacon_after);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
 
 int hostapd_force_channel_switch(struct hostapd_iface *iface,
 				 struct csa_settings *settings)
@@ -4642,8 +5219,18 @@ hostapd_switch_channel_fallback(struct hostapd_iface *iface,
 		break;
 	}
 
+	if ((iface->current_mode->ht_capab & HT_CAP_INFO_SUPP_CHANNEL_WIDTH_SET) &&
+	    freq_params->bandwidth > 20)
+		iface->conf->ht_capab |= HT_CAP_INFO_SUPP_CHANNEL_WIDTH_SET;
+	if ((iface->current_mode->vht_capab & VHT_CAP_SUPP_CHAN_WIDTH_160MHZ) &&
+	    freq_params->bandwidth == 160)
+		iface->conf->vht_capab |= VHT_CAP_SUPP_CHAN_WIDTH_160MHZ;
+
 	iface->freq = freq_params->freq;
 	iface->conf->channel = freq_params->channel;
+	if (iface->conf->channel != 0) /* If channel not zero, will disable acs. */
+		iface->conf->acs = 0;
+
 	iface->conf->secondary_channel = freq_params->sec_channel_offset;
 	if (ieee80211_freq_to_channel_ext(freq_params->freq,
 					  freq_params->sec_channel_offset, bw,
@@ -4661,6 +5248,10 @@ hostapd_switch_channel_fallback(struct hostapd_iface *iface,
 	iface->conf->ieee80211ac = freq_params->vht_enabled;
 	iface->conf->ieee80211ax = freq_params->he_enabled;
 	iface->conf->ieee80211be = freq_params->eht_enabled;
+	if (ieee80211_freq_to_channel_ext(iface->freq, iface->conf->secondary_channel,
+					  hostapd_get_oper_chwidth(iface->conf),
+					  &op_class, &chan) != NUM_HOSTAPD_MODES)
+		iface->conf->op_class = op_class;
 
 	/*
 	 * cs_params must not be cleared earlier because the freq_params
@@ -4792,7 +5383,7 @@ void hostapd_switch_color(struct hostapd_data *hapd, u64 bitmap)
 {
 	struct os_reltime now;
 
-	if (hapd->cca_in_progress)
+	if (hapd->cca_in_progress || !hapd->beacon_set_done)
 		return;
 
 	if (os_get_reltime(&now))
@@ -4946,6 +5537,7 @@ int hostapd_mld_add_link(struct hostapd_data *hapd)
 
 	dl_list_add_tail(&mld->links, &hapd->link);
 	mld->num_links++;
+	mld->active_links |= BIT(hapd->mld_link_id);
 
 	wpa_printf(MSG_DEBUG, "AP MLD %s: Link ID %d added. num_links: %d",
 		   mld->name, hapd->mld_link_id, mld->num_links);
@@ -4972,8 +5564,12 @@ int hostapd_mld_remove_link(struct hostapd_data *hapd)
 	if (!mld)
 		return -1;
 
+	if (!(mld->active_links & BIT(hapd->mld_link_id)))
+		return 0;
+
 	dl_list_del(&hapd->link);
 	mld->num_links--;
+	mld->active_links &= ~BIT(hapd->mld_link_id);
 
 	wpa_printf(MSG_DEBUG, "AP MLD %s: Link ID %d removed. num_links: %d",
 		   mld->name, hapd->mld_link_id, mld->num_links);
diff --git a/src/ap/hostapd.h b/src/ap/hostapd.h
index 7e72863..d7dabb0 100644
--- a/src/ap/hostapd.h
+++ b/src/ap/hostapd.h
@@ -18,6 +18,8 @@
 #include "utils/list.h"
 #include "ap_config.h"
 #include "drivers/driver.h"
+#include "ubus.h"
+#include "ucode.h"
 
 #define OCE_STA_CFON_ENABLED(hapd) \
 	((hapd->conf->oce & OCE_STA_CFON) && \
@@ -51,6 +53,10 @@ struct hapd_interfaces {
 	struct hostapd_config * (*config_read_cb)(const char *config_fname);
 	int (*ctrl_iface_init)(struct hostapd_data *hapd);
 	void (*ctrl_iface_deinit)(struct hostapd_data *hapd);
+	int (*ctrl_iface_recv)(struct hostapd_data *hapd,
+			       char *buf, char *reply, int reply_size,
+			       struct sockaddr_storage *from,
+			       socklen_t fromlen);
 	int (*for_each_interface)(struct hapd_interfaces *interfaces,
 				  int (*cb)(struct hostapd_iface *iface,
 					    void *ctx), void *ctx);
@@ -169,6 +175,7 @@ struct hostapd_sae_commit_queue {
 	u8 msg[];
 };
 
+#define EHT_ML_MAX_STA_PROF_LEN 1024
 struct mld_link_info {
 	u8 valid:1;
 	u8 nstr_bitmap_len:2;
@@ -182,6 +189,25 @@ struct mld_link_info {
 	u16 status;
 	u16 resp_sta_profile_len;
 	u8 *resp_sta_profile;
+
+	u32 sta_prof_csa_offset;
+	u32 sta_prof_ecsa_offset;
+	u32 sta_prof_offset;
+};
+
+/**
+ * struct hostapd_openwrt_stats - OpenWrt custom STA/AP statistics
+ */
+struct hostapd_openwrt_stats {
+	struct {
+		u64 neighbor_report_tx;
+	} rrm;
+
+	struct {
+		u64 bss_transition_query_rx;
+		u64 bss_transition_request_tx;
+		u64 bss_transition_response_rx;
+	} wnm;
 };
 
 /**
@@ -191,6 +217,8 @@ struct hostapd_data {
 	struct hostapd_iface *iface;
 	struct hostapd_config *iconf;
 	struct hostapd_bss_config *conf;
+	struct hostapd_ubus_bss ubus;
+	struct hostapd_ucode_bss ucode;
 	int interface_added; /* virtual interface added for this BSS */
 	unsigned int started:1;
 	unsigned int disabled:1;
@@ -198,6 +226,9 @@ struct hostapd_data {
 
 	u8 own_addr[ETH_ALEN];
 
+	/* OpenWrt specific statistics */
+	struct hostapd_openwrt_stats openwrt_stats;
+
 	int num_sta; /* number of entries in sta_list */
 	struct sta_info *sta_list; /* STA info list head */
 #define STA_HASH_SIZE 256
@@ -331,6 +362,9 @@ struct hostapd_data {
 	unsigned int cs_c_off_ecsa_beacon;
 	unsigned int cs_c_off_ecsa_proberesp;
 
+	unsigned int cs_c_off_sta_prof[MAX_NUM_MLD_LINKS];
+	unsigned int cs_c_off_ecsa_sta_prof[MAX_NUM_MLD_LINKS];
+
 #ifdef CONFIG_IEEE80211AX
 	bool cca_in_progress;
 	u8 cca_count;
@@ -490,6 +524,7 @@ struct hostapd_data {
 
 #ifdef CONFIG_IEEE80211BE
 	u8 eht_mld_bss_param_change;
+	u8 eht_mld_bss_critical_update;
 	struct hostapd_mld *mld;
 	struct dl_list link;
 	u8 mld_link_id;
@@ -501,6 +536,8 @@ struct hostapd_data {
 	 * total, additional 7 characters required. */
 	char ctrl_sock_iface[IFNAMSIZ + 7 + 1];
 
+	s64 tsf_offset[MAX_NUM_MLD_LINKS];
+
 #ifdef CONFIG_TESTING_OPTIONS
 	u8 eht_mld_link_removal_count;
 #endif /* CONFIG_TESTING_OPTIONS */
@@ -540,7 +577,12 @@ struct hostapd_mld {
 	 * freed when num_links is 0.
 	 */
 	u8 refcount;
+	bool started;
+	u16 link_reconf_in_progress;
+	u16 active_links;
+	u16 removed_links;
 
+	struct attlm_settings new_attlm;
 	struct hostapd_data *fbss;
 	struct dl_list links; /* List head of all affiliated links */
 
@@ -557,6 +599,7 @@ struct hostapd_mld {
  */
 struct hostapd_iface {
 	struct hapd_interfaces *interfaces;
+	struct hostapd_ucode_iface ucode;
 	void *owner;
 	char *config_fname;
 	struct hostapd_config *conf;
@@ -649,6 +692,11 @@ struct hostapd_iface {
 		unsigned int temp_ch:1;
 		/* CAC started on radar offchain */
 		unsigned int cac_started:1;
+		/* Main chain should expand its width according to the
+		 * current offchain channel after CAC detection on radar offchain.
+		 */
+		unsigned int expand_ch:1;
+		int new_chwidth;
 	} radar_background;
 
 	u16 hw_flags;
@@ -744,9 +792,123 @@ struct hostapd_iface {
 	struct hostapd_multi_hw_info *multi_hw_info;
 	unsigned int num_multi_hws;
 	struct hostapd_multi_hw_info *current_hw_info;
+
+#ifdef CONFIG_AFC
+	struct {
+		int timeout;
+		unsigned int num_freq_range;
+		struct afc_freq_range_elem {
+			int low_freq;
+			int high_freq;
+			/**
+			 * max eirp power spectral density received from
+			 * the AFC coordinator for this band
+			 */
+			int max_psd;
+		} *freq_range;
+		unsigned int num_chan_info;
+		struct afc_chan_info_elem {
+			int chan;
+			/**
+			 * max eirp power received from the AFC coordinator
+			 * for this channel for each op_class
+			 */
+			int power[5];
+		} *chan_info_list;
+		bool data_valid;
+		bool lpi_mode;
+	} afc;
+#endif /* CONFIG_AFC */
 };
 
 /* hostapd.c */
+#ifdef CONFIG_AFC
+
+enum afc_state {
+	AFC_DISABLE,
+	AFC_RESTART_IFACE,
+	AFC_LPI,
+	AFC_CONTINUE,
+};
+
+#define MAX_CHANNEL_NUM_6G 59
+
+/* The power unit is 0.5 dBm */
+#define AFC_MAXIMUM_POWER 72
+#define AFC_INVALID_POWER 127
+#define PSD_TO_DBM_OFFSET 26
+#define BW20_TO_RU26_OFFSET 20
+#define DOUBLE_BW_POWER 6
+
+#define RU26_OFFSET_20MHZ 20
+#define RU52_OFFSET_20MHZ 14
+#define RU78_OFFSET_20MHZ 10
+#define RU106_OFFSET_20MHZ 8
+#define RU132_OFFSET_20MHZ 6
+
+#define RU726_OFFSET_80MHZ 2
+#define RU1480_OFFSET_160MHZ 2
+#define RU1772_OFFSET_160MHZ 1
+#define RU2476_OFFSET_320MHZ 4
+#define RU2988_OFFSET_320MHZ 2
+#define RU3472_OFFSET_320MHZ 1
+
+enum afc_table_info {
+	afc_power_bw20,
+	afc_power_bw40,
+	afc_power_bw80,
+	afc_power_bw160,
+	afc_power_bw320_1,
+	afc_power_bw320_2,
+	afc_power_ru26,
+	afc_power_ru52,
+	afc_power_ru78,
+	afc_power_ru106,
+	afc_power_ru132,
+	afc_power_ru726,
+	afc_power_ru1480,
+	afc_power_ru1772,
+	afc_power_ru2476,
+	afc_power_ru2988,
+	afc_power_ru3472,
+	afc_power_table_num,
+};
+
+int hostap_afc_get_chan_max_eirp_power(struct hostapd_iface *iface, bool psd,
+				       int *power);
+int hostapd_afc_handle_request(struct hostapd_iface *iface);
+void hostapd_afc_stop(struct hostapd_iface *iface);
+void hostap_afc_disable_channels(struct hostapd_iface *iface);
+int hostapd_afc_translate_table(struct hostapd_iface *iface,
+				s8 ***power_table);
+#else
+static inline int
+hostap_afc_get_chan_max_eirp_power(struct hostapd_iface *iface, bool psd,
+				   int *power)
+{
+	return -EINVAL;
+}
+
+static inline int hostapd_afc_handle_request(struct hostapd_iface *iface)
+{
+	return 1;
+}
+
+static inline void hostapd_afc_stop(struct hostapd_iface *iface)
+{
+}
+
+static inline void hostap_afc_disable_channels(struct hostapd_iface *iface)
+{
+}
+
+static inline int hostapd_afc_translate_table(struct hostapd_iface *iface,
+					      s8 ***power_table)
+{
+	return -EINVAL;
+}
+#endif /* CONFIG_AFC */
+
 int hostapd_for_each_interface(struct hapd_interfaces *interfaces,
 			       int (*cb)(struct hostapd_iface *iface,
 					 void *ctx), void *ctx);
@@ -758,6 +920,7 @@ hostapd_alloc_bss_data(struct hostapd_iface *hapd_iface,
 		       struct hostapd_bss_config *bss);
 int hostapd_setup_interface(struct hostapd_iface *iface);
 int hostapd_setup_interface_complete(struct hostapd_iface *iface, int err);
+void hostapd_set_own_neighbor_report(struct hostapd_data *hapd);
 void hostapd_interface_deinit(struct hostapd_iface *iface);
 void hostapd_interface_free(struct hostapd_iface *iface);
 struct hostapd_iface * hostapd_alloc_iface(void);
@@ -766,18 +929,24 @@ struct hostapd_iface * hostapd_init(struct hapd_interfaces *interfaces,
 struct hostapd_iface *
 hostapd_interface_init_bss(struct hapd_interfaces *interfaces, const char *phy,
 			   const char *config_fname, int debug);
+int hostapd_setup_bss(struct hostapd_data *hapd, int first, bool start_beacon);
+void hostapd_bss_deinit(struct hostapd_data *hapd);
 void hostapd_new_assoc_sta(struct hostapd_data *hapd, struct sta_info *sta,
 			   int reassoc);
 void hostapd_interface_deinit_free(struct hostapd_iface *iface);
 int hostapd_enable_iface(struct hostapd_iface *hapd_iface);
 int hostapd_reload_iface(struct hostapd_iface *hapd_iface);
 int hostapd_reload_bss_only(struct hostapd_data *bss);
+int hostapd_enable_bss(struct hostapd_data *hapd);
 int hostapd_disable_iface(struct hostapd_iface *hapd_iface);
+int hostapd_disable_bss(struct hostapd_data *hapd);
 void hostapd_bss_deinit_no_free(struct hostapd_data *hapd);
 void hostapd_free_hapd_data(struct hostapd_data *hapd);
 void hostapd_cleanup_iface_partial(struct hostapd_iface *iface);
 int hostapd_add_iface(struct hapd_interfaces *ifaces, char *buf);
+int hostapd_remove_bss(struct hapd_interfaces *ifaces, char *buf);
 int hostapd_remove_iface(struct hapd_interfaces *ifaces, char *buf);
+int hostapd_remove_mld(struct hapd_interfaces *ifaces, char *buf);
 void hostapd_channel_list_updated(struct hostapd_iface *iface, int initiator);
 void hostapd_set_state(struct hostapd_iface *iface, enum hostapd_iface_state s);
 const char * hostapd_state_text(enum hostapd_iface_state s);
@@ -788,13 +957,16 @@ int hostapd_switch_channel(struct hostapd_data *hapd,
 			   struct csa_settings *settings);
 int hostapd_force_channel_switch(struct hostapd_iface *iface,
 				 struct csa_settings *settings);
+int hostapd_update_aff_link_beacon(struct hostapd_data *hapd, u8 cs_count);
 void
 hostapd_switch_channel_fallback(struct hostapd_iface *iface,
 				const struct hostapd_freq_params *freq_params);
 void hostapd_cleanup_cs_params(struct hostapd_data *hapd);
 void hostapd_periodic_iface(struct hostapd_iface *iface);
 int hostapd_owe_trans_get_info(struct hostapd_data *hapd);
+void hostapd_owe_update_trans(struct hostapd_iface *iface);;
 void hostapd_ocv_check_csa_sa_query(void *eloop_ctx, void *timeout_ctx);
+int hostapd_check_max_sta(struct hostapd_data *hapd);
 
 void hostapd_switch_color(struct hostapd_data *hapd, u64 bitmap);
 void hostapd_cleanup_cca_params(struct hostapd_data *hapd);
@@ -852,6 +1024,8 @@ int hostapd_mbssid_get_bss_index(struct hostapd_data *hapd);
 struct hostapd_data * hostapd_mld_get_link_bss(struct hostapd_data *hapd,
 					       u8 link_id);
 int hostapd_link_remove(struct hostapd_data *hapd, u32 count);
+void hostapd_link_remove_cb(struct hostapd_data *hapd, u16 removed_links);
+int hostapd_mld_set_attlm(struct hostapd_data *hapd);
 bool hostapd_is_ml_partner(struct hostapd_data *hapd1,
 			   struct hostapd_data *hapd2);
 u8 hostapd_get_mld_id(struct hostapd_data *hapd);
@@ -865,8 +1039,12 @@ int hostapd_fill_cca_settings(struct hostapd_data *hapd,
 
 #ifdef CONFIG_IEEE80211BE
 
+void hostapd_event_attlm(struct hostapd_data *hapd, struct attlm_event *attlm_event);
+void hostapd_event_tsf_offset(struct hostapd_data *hapd, s64 *tsf_offset);
 bool hostapd_mld_is_first_bss(struct hostapd_data *hapd);
 void hostapd_mld_interface_freed(struct hostapd_data *hapd);
+int hostapd_enable_mld(struct hostapd_data *hapd);
+int hostapd_disable_mld(struct hostapd_data *hapd);
 
 #define for_each_mld_link(partner, self) \
 	dl_list_for_each(partner, &self->mld->links, struct hostapd_data, link)
diff --git a/src/ap/hw_features.c b/src/ap/hw_features.c
index cef3817..56eaae8 100644
--- a/src/ap/hw_features.c
+++ b/src/ap/hw_features.c
@@ -117,6 +117,8 @@ int hostapd_get_hw_features(struct hostapd_iface *iface)
 	iface->hw_features = modes;
 	iface->num_hw_features = num_modes;
 
+	hostap_afc_disable_channels(iface);
+
 	for (i = 0; i < num_modes; i++) {
 		struct hostapd_hw_modes *feature = &modes[i];
 		int dfs_enabled = hapd->iconf->ieee80211h &&
@@ -567,7 +569,8 @@ static int ieee80211n_check_40mhz(struct hostapd_iface *iface)
 	int ret;
 
 	/* Check that HT40 is used and PRI / SEC switch is allowed */
-	if (!iface->conf->secondary_channel || iface->conf->no_pri_sec_switch)
+	if (!iface->conf->secondary_channel || iface->conf->no_pri_sec_switch ||
+		iface->conf->noscan)
 		return 0;
 
 	hostapd_set_state(iface, HAPD_IFACE_HT_SCAN);
@@ -730,6 +733,32 @@ static int ieee80211ac_supported_vht_capab(struct hostapd_iface *iface)
 #ifdef CONFIG_IEEE80211AX
 static int ieee80211ax_supported_he_capab(struct hostapd_iface *iface)
 {
+	struct hostapd_hw_modes *mode = iface->current_mode;
+	struct he_capabilities *he_cap = &mode->he_capab[IEEE80211_MODE_AP];
+	struct hostapd_config *conf = iface->conf;
+
+#define HE_CAP_CHECK(hw_cap, field, phy_idx, cfg_cap)					\
+	do {									\
+		if (cfg_cap && !(hw_cap[phy_idx] & field)) {	\
+			wpa_printf(MSG_ERROR, "Driver does not support configured" \
+				     " HE capability [%s]", #field);		\
+			return 0;						\
+		}								\
+	} while (0)
+
+	HE_CAP_CHECK(he_cap->phy_cap, HE_PHYCAP_LDPC_CODING_IN_PAYLOAD,
+		     HE_PHYCAP_LDPC_CODING_IN_PAYLOAD_IDX,
+		     conf->he_phy_capab.he_ldpc);
+	HE_CAP_CHECK(he_cap->phy_cap, HE_PHYCAP_SU_BEAMFORMER_CAPAB,
+		     HE_PHYCAP_SU_BEAMFORMER_CAPAB_IDX,
+		     conf->he_phy_capab.he_su_beamformer);
+	HE_CAP_CHECK(he_cap->phy_cap, HE_PHYCAP_SU_BEAMFORMEE_CAPAB,
+		     HE_PHYCAP_SU_BEAMFORMEE_CAPAB_IDX,
+		     conf->he_phy_capab.he_su_beamformee);
+	HE_CAP_CHECK(he_cap->phy_cap, HE_PHYCAP_MU_BEAMFORMER_CAPAB,
+		     HE_PHYCAP_MU_BEAMFORMER_CAPAB_IDX,
+		     conf->he_phy_capab.he_mu_beamformer);
+
 	return 1;
 }
 #endif /* CONFIG_IEEE80211AX */
@@ -1019,28 +1048,14 @@ static bool hostapd_is_usable_punct_bitmap(struct hostapd_iface *iface)
  * 0 = not usable
  * -1 = not currently usable due to 6 GHz NO-IR
  */
-static int hostapd_is_usable_chans(struct hostapd_iface *iface)
+int hostapd_is_usable_chans(struct hostapd_iface *iface)
 {
-	int secondary_freq;
-	struct hostapd_channel_data *pri_chan;
-	int err, err2;
+	int err, central, oper_chwidth;
+	int start_chan, start_freq, chan_num, i;
 
 	if (!iface->current_mode)
 		return 0;
-	pri_chan = hw_get_channel_freq(iface->current_mode->mode,
-				       iface->freq, NULL,
-				       iface->hw_features,
-				       iface->num_hw_features);
-	if (!pri_chan) {
-		wpa_printf(MSG_ERROR, "Primary frequency not present");
-		return 0;
-	}
 
-	err = hostapd_is_usable_chan(iface, pri_chan->freq, 1);
-	if (err <= 0) {
-		wpa_printf(MSG_ERROR, "Primary frequency not allowed");
-		return err;
-	}
 	err = hostapd_is_usable_edmg(iface);
 	if (err <= 0)
 		return err;
@@ -1048,38 +1063,80 @@ static int hostapd_is_usable_chans(struct hostapd_iface *iface)
 	if (!hostapd_is_usable_punct_bitmap(iface))
 		return 0;
 
-	if (!iface->conf->secondary_channel)
-		return 1;
+	oper_chwidth = hostapd_get_oper_chwidth(iface->conf);
+	if (oper_chwidth == CONF_OPER_CHWIDTH_USE_HT) {
+		int chan = hw_get_chan(iface->current_mode->mode, iface->freq,
+				       iface->hw_features, iface->num_hw_features);
+		if (!chan) {
+			wpa_printf(MSG_ERROR, "Primary channel not present");
+			return 0;
+		}
 
-	err = hostapd_is_usable_chan(iface, iface->freq +
-				     iface->conf->secondary_channel * 20, 0);
-	if (err > 0) {
-		if (iface->conf->secondary_channel == 1 &&
-		    (pri_chan->allowed_bw & HOSTAPD_CHAN_WIDTH_40P))
-			return 1;
-		if (iface->conf->secondary_channel == -1 &&
-		    (pri_chan->allowed_bw & HOSTAPD_CHAN_WIDTH_40M))
-			return 1;
+		switch (iface->conf->secondary_channel) {
+			case 1:
+				start_chan = chan;
+				chan_num = 2;
+				break;
+			case -1:
+				start_chan = chan - 4;
+				chan_num = 2;
+				break;
+			default:
+				start_chan = chan;
+				chan_num = 1;
+		}
+	} else {
+		switch (oper_chwidth) {
+			case CONF_OPER_CHWIDTH_80MHZ:
+			case CONF_OPER_CHWIDTH_80P80MHZ:
+				chan_num = 4;
+				break;
+			case CONF_OPER_CHWIDTH_160MHZ:
+				chan_num = 8;
+				break;
+			case CONF_OPER_CHWIDTH_320MHZ:
+				chan_num = 16;
+				break;
+			default:
+				return 0;
+		}
+		central = hostapd_get_oper_centr_freq_seg0_idx(iface->conf);
+		start_chan = central - chan_num * 2 + 2;
 	}
-	if (!iface->conf->ht40_plus_minus_allowed)
-		return err;
+	start_freq = hw_get_freq(iface->current_mode, start_chan);
 
-	/* Both HT40+ and HT40- are set, pick a valid secondary channel */
-	secondary_freq = iface->freq + 20;
-	err2 = hostapd_is_usable_chan(iface, secondary_freq, 0);
-	if (err2 > 0 && (pri_chan->allowed_bw & HOSTAPD_CHAN_WIDTH_40P)) {
-		iface->conf->secondary_channel = 1;
-		return 1;
+	if (!start_freq) {
+		wpa_printf(MSG_ERROR, "frequency not present");
+		return 0;
 	}
 
-	secondary_freq = iface->freq - 20;
-	err2 = hostapd_is_usable_chan(iface, secondary_freq, 0);
-	if (err2 > 0 && (pri_chan->allowed_bw & HOSTAPD_CHAN_WIDTH_40M)) {
-		iface->conf->secondary_channel = -1;
+	for (i = 0; i < chan_num; i++) {
+		int freq = start_freq + i * 20;
+
+		err = hostapd_is_usable_chan(iface, freq, 0);
+		if (err <= 0) {
+			wpa_printf(MSG_ERROR, "frequency %d is not allowed", freq);
+			return err;
+		}
+	}
+
+	if (oper_chwidth != CONF_OPER_CHWIDTH_80P80MHZ)
 		return 1;
+
+	central = hostapd_get_oper_centr_freq_seg1_idx(iface->conf);
+	start_chan = central - chan_num * 2 + 2;
+	start_freq = hw_get_freq(iface->current_mode, start_chan);
+	for (i = 0; i < chan_num; i++) {
+		int freq = start_freq + i * 20;
+
+		err = hostapd_is_usable_chan(iface, freq, 0);
+		if (err <= 0) {
+			wpa_printf(MSG_ERROR, "frequency %d is not allowed", freq);
+			return err;
+		}
 	}
 
-	return err;
+	return 1;
 }
 
 
@@ -1140,6 +1197,8 @@ int hostapd_determine_mode(struct hostapd_iface *iface)
 static enum hostapd_chan_status
 hostapd_check_chans(struct hostapd_iface *iface)
 {
+	int i;
+
 	if (iface->freq) {
 		int err;
 
@@ -1159,6 +1218,14 @@ hostapd_check_chans(struct hostapd_iface *iface)
 	 * which is used to trigger ACS.
 	 */
 
+	/*
+	 * Only allow an ACS at one time.
+	 */
+	for (i = 0; i < iface->interfaces->count; i++) {
+		if (iface->interfaces->iface[i]->state == HAPD_IFACE_ACS)
+			return HOSTAPD_CHAN_ACS;
+	}
+
 	switch (acs_init(iface)) {
 	case HOSTAPD_CHAN_ACS:
 		return HOSTAPD_CHAN_ACS;
diff --git a/src/ap/hw_features.h b/src/ap/hw_features.h
index 73663d0..d4953e8 100644
--- a/src/ap/hw_features.h
+++ b/src/ap/hw_features.h
@@ -32,6 +32,7 @@ int hostapd_hw_skip_mode(struct hostapd_iface *iface,
 int hostapd_determine_mode(struct hostapd_iface *iface);
 void hostapd_free_multi_hw_info(struct hostapd_multi_hw_info *multi_hw_info);
 int hostapd_set_current_hw_info(struct hostapd_iface *iface, int oper_freq);
+int hostapd_is_usable_chans(struct hostapd_iface *iface);
 #else /* NEED_AP_MLME */
 static inline void
 hostapd_free_hw_features(struct hostapd_hw_modes *hw_features,
@@ -115,6 +116,12 @@ static inline int hostapd_set_current_hw_info(struct hostapd_iface *iface,
 {
 	return 0;
 }
+
+static inline int hostapd_is_usable_chans(struct hostapd_iface *iface)
+{
+	return 1;
+}
+
 #endif /* NEED_AP_MLME */
 
 #endif /* HW_FEATURES_H */
diff --git a/src/ap/ieee802_11.c b/src/ap/ieee802_11.c
index 8206932..503dc66 100644
--- a/src/ap/ieee802_11.c
+++ b/src/ap/ieee802_11.c
@@ -60,6 +60,12 @@
 #include "nan_usd_ap.h"
 #include "pasn/pasn_common.h"
 
+#ifdef CONFIG_APUP
+#	include "apup.h"
+#endif // def CONFIG_APUP
+#ifdef CONFIG_IEEE80211BE
+#include "scs.h"
+#endif
 
 #ifdef CONFIG_FILS
 static struct wpabuf *
@@ -87,6 +93,10 @@ static void handle_auth(struct hostapd_data *hapd,
 			int rssi, int from_queue);
 static int add_associated_sta(struct hostapd_data *hapd,
 			      struct sta_info *sta, int reassoc);
+static bool hostapd_ml_handle_disconnect(struct hostapd_data *hapd,
+					 struct sta_info *sta,
+					 const struct ieee80211_mgmt *mgmt,
+					 bool disassoc);
 
 
 static u8 * hostapd_eid_multi_ap(struct hostapd_data *hapd, u8 *eid, size_t len)
@@ -280,6 +290,7 @@ u8 * hostapd_eid_rm_enabled_capab(struct hostapd_data *hapd, u8 *eid,
 
 u16 hostapd_own_capab_info(struct hostapd_data *hapd)
 {
+	struct hostapd_data *h;
 	int capab = WLAN_CAPABILITY_ESS;
 	int privacy = 0;
 	int dfs;
@@ -340,6 +351,12 @@ u16 hostapd_own_capab_info(struct hostapd_data *hapd)
 		}
 	}
 
+#ifdef CONFIG_IEEE80211BE
+	if (hapd->conf->mld_ap && hapd->eht_mld_bss_critical_update)
+		capab |= WLAN_CAPABILITY_PBCC;
+#endif /* CONFIG_IEEE80211BE */
+
+
 	return capab;
 }
 
@@ -930,6 +947,7 @@ static void sae_sme_send_external_auth_status(struct hostapd_data *hapd,
 
 void sae_accept_sta(struct hostapd_data *hapd, struct sta_info *sta)
 {
+	struct hostapd_data *link;
 #ifndef CONFIG_NO_VLAN
 	struct vlan_description vlan_desc;
 
@@ -971,9 +989,19 @@ void sae_accept_sta(struct hostapd_data *hapd, struct sta_info *sta)
 	crypto_bignum_deinit(sta->sae->peer_commit_scalar_accepted, 0);
 	sta->sae->peer_commit_scalar_accepted = sta->sae->peer_commit_scalar;
 	sta->sae->peer_commit_scalar = NULL;
-	wpa_auth_pmksa_add_sae(hapd->wpa_auth, sta->addr,
-			       sta->sae->pmk, sta->sae->pmk_len,
-			       sta->sae->pmkid, sta->sae->akmp);
+	if (hostapd_is_mld_ap(hapd)) {
+		for_each_mld_link(link, hapd) {
+			if (!(hapd->mld->active_links & BIT(link->mld_link_id)))
+				continue;
+			wpa_auth_pmksa_add_sae(link->wpa_auth, sta->addr,
+					sta->sae->pmk, sta->sae->pmk_len,
+					sta->sae->pmkid, sta->sae->akmp);
+		}
+	} else {
+		wpa_auth_pmksa_add_sae(hapd->wpa_auth, sta->addr,
+				sta->sae->pmk, sta->sae->pmk_len,
+				sta->sae->pmkid, sta->sae->akmp);
+	}
 	sae_sme_send_external_auth_status(hapd, sta, WLAN_STATUS_SUCCESS);
 }
 
@@ -2904,7 +2932,7 @@ static void handle_auth(struct hostapd_data *hapd,
 	u16 auth_alg, auth_transaction, status_code;
 	u16 resp = WLAN_STATUS_SUCCESS;
 	struct sta_info *sta = NULL;
-	int res, reply_res;
+	int res, reply_res, ubus_resp;
 	u16 fc;
 	const u8 *challenge = NULL;
 	u8 resp_ies[2 + WLAN_AUTH_CHALLENGE_LEN];
@@ -2915,6 +2943,11 @@ static void handle_auth(struct hostapd_data *hapd,
 #ifdef CONFIG_IEEE80211BE
 	bool mld_sta = false;
 #endif /* CONFIG_IEEE80211BE */
+	struct hostapd_ubus_request req = {
+		.type = HOSTAPD_UBUS_AUTH_REQ,
+		.mgmt_frame = mgmt,
+		.ssi_signal = rssi,
+	};
 
 	if (len < IEEE80211_HDRLEN + sizeof(mgmt->u.auth)) {
 		wpa_printf(MSG_INFO, "handle_auth - too short payload (len=%lu)",
@@ -3111,6 +3144,13 @@ static void handle_auth(struct hostapd_data *hapd,
 		resp = WLAN_STATUS_UNSPECIFIED_FAILURE;
 		goto fail;
 	}
+	ubus_resp = hostapd_ubus_handle_event(hapd, &req);
+	if (ubus_resp) {
+		wpa_printf(MSG_DEBUG, "Station " MACSTR " rejected by ubus handler.\n",
+			MAC2STR(mgmt->sa));
+		resp = ubus_resp > 0 ? (u16) ubus_resp : WLAN_STATUS_UNSPECIFIED_FAILURE;
+		goto fail;
+	}
 	if (res == HOSTAPD_ACL_PENDING)
 		return;
 
@@ -3154,6 +3194,18 @@ static void handle_auth(struct hostapd_data *hapd,
 			return;
 		}
 #endif /* CONFIG_PASN */
+#ifdef CONFIG_IEEE80211BE
+		if (mld_sta && auth_transaction == 1 && !sta->added_unassoc) {
+			wpa_printf(MSG_INFO,
+				   "recveive AUTH from associated STA "MACSTR
+				   ", do deauthentication\n",
+				   MAC2STR(sa));
+			hostapd_ml_handle_disconnect(hapd, sta, mgmt, false);
+			hostapd_drv_sta_remove(hapd, sa);
+			resp = WLAN_STATUS_UNSPECIFIED_FAILURE;
+			goto fail;
+		}
+#endif /* CONFIG_IEEE80211BE */
 	} else {
 #ifdef CONFIG_MESH
 		if (hapd->conf->mesh & MESH_ENABLED) {
@@ -3196,6 +3248,7 @@ static void handle_auth(struct hostapd_data *hapd,
 
 			ap_sta_set_mld(sta, true);
 			sta->mld_assoc_link_id = link_id;
+			sta->mld_assoc_sta = sta;
 
 			/*
 			 * Set the MLD address as the station address and the
@@ -3207,6 +3260,7 @@ static void handle_auth(struct hostapd_data *hapd,
 				  mgmt->sa, ETH_ALEN);
 			os_memcpy(sta->mld_info.links[link_id].local_addr,
 				  hapd->own_addr, ETH_ALEN);
+			os_memcpy(sta->setup_link_addr, mgmt->sa, ETH_ALEN);
 		}
 	}
 #endif /* CONFIG_IEEE80211BE */
@@ -3583,8 +3637,8 @@ static u16 check_multi_ap(struct hostapd_data *hapd, struct sta_info *sta,
 }
 
 
-static u16 copy_supp_rates(struct hostapd_data *hapd, struct sta_info *sta,
-			   struct ieee802_11_elems *elems)
+u16 hostapd_copy_supp_rates(struct hostapd_data *hapd, struct sta_info *sta,
+			   const struct ieee802_11_elems *elems)
 {
 	/* Supported rates not used in IEEE 802.11ad/DMG */
 	if (hapd->iface->current_mode &&
@@ -3971,7 +4025,7 @@ static int __check_assoc_ies(struct hostapd_data *hapd, struct sta_info *sta,
 			       elems->ext_capab_len);
 	if (resp != WLAN_STATUS_SUCCESS)
 		return resp;
-	resp = copy_supp_rates(hapd, sta, elems);
+	resp = hostapd_copy_supp_rates(hapd, sta, elems);
 	if (resp != WLAN_STATUS_SUCCESS)
 		return resp;
 
@@ -4518,6 +4572,8 @@ static void ieee80211_ml_build_assoc_resp(struct hostapd_data *hapd,
 	p = hostapd_eid_mbo(hapd, p, buf + buflen - p);
 	p = hostapd_eid_wmm(hapd, p);
 
+	p = hostapd_eid_non_inheritance(hapd, p);
+
 	if (hapd->conf->assocresp_elements &&
 	    (size_t) (buf + buflen - p) >=
 	    wpabuf_len(hapd->conf->assocresp_elements)) {
@@ -4583,6 +4639,7 @@ static int ieee80211_ml_process_link(struct hostapd_data *hapd,
 
 	sta->flags |= origin_sta->flags | WLAN_STA_ASSOC_REQ_OK;
 	sta->mld_assoc_link_id = origin_sta->mld_assoc_link_id;
+	sta->mld_assoc_sta = origin_sta;
 
 	status = __check_assoc_ies(hapd, sta, NULL, 0, &elems, reassoc, true);
 	if (status != WLAN_STATUS_SUCCESS) {
@@ -4613,7 +4670,8 @@ static int ieee80211_ml_process_link(struct hostapd_data *hapd,
 		}
 		hapd->sta_aid[(sta->aid - 1) / 32] |= BIT((sta->aid - 1) % 32);
 		sta->listen_interval = origin_sta->listen_interval;
-		if (update_ht_state(hapd, sta) > 0)
+		if (!is_6ghz_op_class(hapd->iconf->op_class) &&
+		    update_ht_state(hapd, sta) > 0)
 			ieee802_11_update_beacons(hapd->iface);
 	}
 
@@ -4759,6 +4817,7 @@ static int add_associated_sta(struct hostapd_data *hapd,
 	int set = 1;
 	const u8 *mld_link_addr = NULL;
 	bool mld_link_sta = false;
+	u16 eml_capa = 0;
 
 #ifdef CONFIG_IEEE80211BE
 	if (ap_sta_is_mld(hapd, sta)) {
@@ -4769,6 +4828,8 @@ static int add_associated_sta(struct hostapd_data *hapd,
 
 		if (hapd->mld_link_id != sta->mld_assoc_link_id)
 			set = 0;
+
+		eml_capa = sta->mld_info.common_info.eml_capa;
 	}
 #endif /* CONFIG_IEEE80211BE */
 
@@ -4790,6 +4851,13 @@ static int add_associated_sta(struct hostapd_data *hapd,
 	 * drivers to accept the STA parameter configuration. Since this is
 	 * after a new FT-over-DS exchange, a new TK has been derived, so key
 	 * reinstallation is not a concern for this case.
+	 *
+	 * If the STA was associated and authorized earlier, but came for a new
+	 * connection (!added_unassoc + !reassoc), remove the existing STA entry
+	 * so that it can be re-added. This case is rarely seen when the AP could
+	 * not receive the deauth/disassoc frame from the STA. And the STA comes
+	 * back with new connection within a short period or before the inactive
+	 * STA entry is removed from the list.
 	 */
 	wpa_printf(MSG_DEBUG, "Add associated STA " MACSTR
 		   " (added_unassoc=%d auth_alg=%u ft_over_ds=%u reassoc=%d authorized=%d ft_tk=%d fils_tk=%d)",
@@ -4803,9 +4871,11 @@ static int add_associated_sta(struct hostapd_data *hapd,
 	    (!(sta->flags & WLAN_STA_AUTHORIZED) ||
 	     (reassoc && sta->ft_over_ds && sta->auth_alg == WLAN_AUTH_FT) ||
 	     (!wpa_auth_sta_ft_tk_already_set(sta->wpa_sm) &&
-	      !wpa_auth_sta_fils_tk_already_set(sta->wpa_sm)))) {
+	      !wpa_auth_sta_fils_tk_already_set(sta->wpa_sm)) ||
+	     (!reassoc && (sta->flags & WLAN_STA_AUTHORIZED)))) {
 		hostapd_drv_sta_remove(hapd, sta->addr);
 		wpa_auth_sm_event(sta->wpa_sm, WPA_DRV_STA_REMOVED);
+		ap_sta_set_authorized_flag(hapd, sta, 0);
 		set = 0;
 
 		 /* Do not allow the FT-over-DS exception to be used more than
@@ -4849,7 +4919,7 @@ static int add_associated_sta(struct hostapd_data *hapd,
 			    sta->he_6ghz_capab,
 			    sta->flags | WLAN_STA_ASSOC, sta->qosinfo,
 			    sta->vht_opmode, sta->p2p_ie ? 1 : 0,
-			    set, mld_link_addr, mld_link_sta)) {
+			    set, mld_link_addr, mld_link_sta, eml_capa)) {
 		hostapd_logger(hapd, sta->addr,
 			       HOSTAPD_MODULE_IEEE80211, HOSTAPD_LEVEL_NOTICE,
 			       "Could not %s STA to kernel driver",
@@ -5011,7 +5081,8 @@ static u16 send_assoc_resp(struct hostapd_data *hapd, struct sta_info *sta,
 #endif /* CONFIG_IEEE80211AC */
 
 #ifdef CONFIG_IEEE80211AX
-	if (hapd->iconf->ieee80211ax && !hapd->conf->disable_11ax) {
+	if (hapd->iconf->ieee80211ax && !hapd->conf->disable_11ax && sta &&
+			sta->flags & WLAN_STA_HE) {
 		p = hostapd_eid_he_capab(hapd, p, IEEE80211_MODE_AP);
 		p = hostapd_eid_he_operation(hapd, p);
 		p = hostapd_eid_cca(hapd, p);
@@ -5059,6 +5130,7 @@ rsnxe_done:
 			p = hostapd_eid_eht_ml_assoc(hapd, sta, p);
 		p = hostapd_eid_eht_capab(hapd, p, IEEE80211_MODE_AP);
 		p = hostapd_eid_eht_operation(hapd, p);
+		p = hostapd_eid_eht_attlm(hapd, p);
 	}
 #endif /* CONFIG_IEEE80211BE */
 
@@ -5365,7 +5437,7 @@ static void handle_assoc(struct hostapd_data *hapd,
 	int resp = WLAN_STATUS_SUCCESS;
 	u16 reply_res = WLAN_STATUS_UNSPECIFIED_FAILURE;
 	const u8 *pos;
-	int left, i;
+	int left, i, ubus_resp;
 	struct sta_info *sta;
 	u8 *tmp = NULL;
 #ifdef CONFIG_FILS
@@ -5374,6 +5446,7 @@ static void handle_assoc(struct hostapd_data *hapd,
 	int omit_rsnxe = 0;
 	bool set_beacon = false;
 	bool mld_addrs_not_translated = false;
+	bool sae_pk = false;
 
 	if (len < IEEE80211_HDRLEN + (reassoc ? sizeof(mgmt->u.reassoc_req) :
 				      sizeof(mgmt->u.assoc_req))) {
@@ -5607,12 +5680,18 @@ static void handle_assoc(struct hostapd_data *hapd,
 		left = res;
 	}
 #endif /* CONFIG_FILS */
+	struct hostapd_ubus_request req = {
+		.type = HOSTAPD_UBUS_ASSOC_REQ,
+		.mgmt_frame = mgmt,
+		.ssi_signal = rssi,
+	};
 
 	/* followed by SSID and Supported rates; and HT capabilities if 802.11n
 	 * is used */
 	resp = check_assoc_ies(hapd, sta, pos, left, reassoc);
 	if (resp != WLAN_STATUS_SUCCESS)
 		goto fail;
+
 #ifdef CONFIG_IEEE80211R_AP
 	if (reassoc && sta->auth_alg == WLAN_AUTH_FT)
 		omit_rsnxe = !get_ie(pos, left, WLAN_EID_RSNX);
@@ -5620,6 +5699,20 @@ static void handle_assoc(struct hostapd_data *hapd,
 	if (hapd->conf->rsn_override_omit_rsnxe)
 		omit_rsnxe = 1;
 
+	/* TODO: check if this section is needed */
+	omit_rsnxe = !get_ie(pos, left, WLAN_EID_RSNX);
+#ifdef CONFIG_SAE_PK
+	sae_pk = hostapd_sae_pk_in_use(hapd->conf);
+#endif /* CONFIG_SAE_PK */
+	if (omit_rsnxe) {
+		if (!reassoc && wpa_key_mgmt_sae(hapd->conf->wpa_key_mgmt) &&
+				(hapd->conf->sae_pwe == SAE_PWE_HASH_TO_ELEMENT ||
+				 hapd->conf->sae_pwe == SAE_PWE_BOTH || sae_pk ||
+				 wpa_key_mgmt_sae_ext_key(hapd->conf->wpa_key_mgmt))) {
+			omit_rsnxe = 0;
+		}
+	}
+
 	if (hostapd_get_aid(hapd, sta) < 0) {
 		hostapd_logger(hapd, mgmt->sa, HOSTAPD_MODULE_IEEE80211,
 			       HOSTAPD_LEVEL_INFO, "No room for more AIDs");
@@ -5671,7 +5764,7 @@ static void handle_assoc(struct hostapd_data *hapd,
 			set_beacon = true;
 	}
 
-	if (update_ht_state(hapd, sta) > 0)
+	if (!is_6ghz_op_class(hapd->iconf->op_class) && update_ht_state(hapd, sta) > 0)
 		set_beacon = true;
 
 	hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
@@ -5714,6 +5807,13 @@ static void handle_assoc(struct hostapd_data *hapd,
 	if (set_beacon)
 		ieee802_11_update_beacons(hapd->iface);
 
+	ubus_resp = hostapd_ubus_handle_event(hapd, &req);
+	if (ubus_resp) {
+		wpa_printf(MSG_DEBUG, "Station " MACSTR " assoc rejected by ubus handler.\n",
+		       MAC2STR(mgmt->sa));
+		resp = ubus_resp > 0 ? (u16) ubus_resp : WLAN_STATUS_UNSPECIFIED_FAILURE;
+		goto fail;
+	}
  fail:
 
 	/*
@@ -5805,9 +5905,17 @@ static void hostapd_deauth_sta(struct hostapd_data *hapd,
 			       struct sta_info *sta,
 			       const struct ieee80211_mgmt *mgmt)
 {
+
+	u16 fc, reason;
+
+	fc = le_to_host16(mgmt->frame_control);
+	reason = WLAN_FC_GET_STYPE(fc) == WLAN_FC_STYPE_DEAUTH ?
+		 le_to_host16(mgmt->u.deauth.reason_code) :
+		 WLAN_REASON_PREV_AUTH_NOT_VALID;
+
 	wpa_msg(hapd->msg_ctx, MSG_DEBUG,
 		"deauthentication: STA=" MACSTR " reason_code=%d",
-		MAC2STR(mgmt->sa), le_to_host16(mgmt->u.deauth.reason_code));
+		MAC2STR(mgmt->sa), reason);
 
 	ap_sta_set_authorized(hapd, sta, 0);
 	sta->last_seq_ctrl = WLAN_INVALID_MGMT_SEQ;
@@ -5818,7 +5926,7 @@ static void hostapd_deauth_sta(struct hostapd_data *hapd,
 	hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
 		       HOSTAPD_LEVEL_DEBUG, "deauthenticated");
 	mlme_deauthenticate_indication(
-		hapd, sta, le_to_host16(mgmt->u.deauth.reason_code));
+		hapd, sta, reason);
 	sta->acct_terminate_cause = RADIUS_ACCT_TERMINATE_CAUSE_USER_REQUEST;
 	ieee802_1x_notify_port_enabled(sta->eapol_sm, 0);
 	ap_free_sta(hapd, sta);
@@ -5943,6 +6051,7 @@ static void handle_disassoc(struct hostapd_data *hapd,
 			   (unsigned long) len);
 		return;
 	}
+	hostapd_ubus_notify(hapd, "disassoc", mgmt->sa);
 
 	sta = ap_get_sta(hapd, mgmt->sa);
 	if (!sta) {
@@ -5974,6 +6083,8 @@ static void handle_deauth(struct hostapd_data *hapd,
 	/* Clear the PTKSA cache entries for PASN */
 	ptksa_cache_flush(hapd->ptksa, mgmt->sa, WPA_CIPHER_NONE);
 
+	hostapd_ubus_notify(hapd, "deauth", mgmt->sa);
+
 	sta = ap_get_sta(hapd, mgmt->sa);
 	if (!sta) {
 		wpa_msg(hapd->msg_ctx, MSG_DEBUG, "Station " MACSTR
@@ -6007,6 +6118,11 @@ static void handle_beacon(struct hostapd_data *hapd,
 				      0);
 
 	ap_list_process_beacon(hapd->iface, mgmt, &elems, fi);
+
+#ifdef CONFIG_APUP
+	if (hapd->conf->apup)
+		apup_process_beacon(hapd, mgmt, len, &elems);
+#endif // def CONFIG_APUP
 }
 
 
@@ -6176,6 +6292,9 @@ static int handle_action(struct hostapd_data *hapd,
 		if (hapd->public_action_cb || hapd->public_action_cb2)
 			return 1;
 		break;
+	case WLAN_ACTION_PROTECTED_EHT:
+		ieee802_11_rx_prot_eht(hapd, mgmt, len);
+		return 1;
 	case WLAN_ACTION_VENDOR_SPECIFIC:
 		if (hapd->vendor_action_cb) {
 			if (hapd->vendor_action_cb(hapd->vendor_action_cb_ctx,
@@ -6188,6 +6307,9 @@ static int handle_action(struct hostapd_data *hapd,
 		hostapd_handle_radio_measurement(hapd, (const u8 *) mgmt, len);
 		return 1;
 #endif /* CONFIG_NO_RRM */
+	case WLAN_ACTION_ROBUST_AV_STREAMING:
+		hostapd_handle_scs(hapd, (const u8 *) mgmt, len);
+		return 1;
 	}
 
 	hostapd_logger(hapd, mgmt->sa, HOSTAPD_MODULE_IEEE80211,
@@ -6280,6 +6402,20 @@ int ieee802_11_mgmt(struct hostapd_data *hapd, const u8 *buf, size_t len,
 	if (len < 24)
 		return 0;
 
+#ifdef CONFIG_IEEE80211BE
+	if (hapd->conf->mld_ap && !hapd->mld->started) {
+		wpa_printf(MSG_DEBUG, "MGMT: Drop the frame - MLD not ready");
+		return 1;
+	}
+
+	if (hapd->conf->mld_ap && hapd->mld->new_attlm.valid &&
+	    !hapd->mld->new_attlm.switch_time_tsf_tu &&
+	    (hapd->mld->new_attlm.disabled_links & BIT(hapd->mld_link_id))) {
+		wpa_printf(MSG_DEBUG, "MGMT: Drop the frame - Disabled link");
+		return 1;
+	}
+#endif /* CONFIG_IEEE80211BE */
+
 	if (fi && fi->freq)
 		freq = fi->freq;
 	else
@@ -6334,6 +6470,11 @@ int ieee802_11_mgmt(struct hostapd_data *hapd, const u8 *buf, size_t len,
 		return 1;
 	}
 
+	if (hapd->iface->cac_started) {
+		wpa_printf(MSG_DEBUG, "MGMT: Ignore management frame during CAC");
+		return 1;
+	}
+
 	if (stype == WLAN_FC_STYPE_PROBE_REQ) {
 		handle_probe_req(hapd, mgmt, len, ssi_signal);
 		return 1;
@@ -6592,11 +6733,20 @@ static void handle_assoc_cb(struct hostapd_data *hapd,
 #ifdef CONFIG_IEEE80211BE
 	if (ap_sta_is_mld(hapd, sta) &&
 	    hapd->mld_link_id != sta->mld_assoc_link_id) {
+		struct hostapd_data *temp_hapd = hapd;
+
 		/* See ieee80211_ml_link_sta_assoc_cb() for the MLD case */
 		wpa_printf(MSG_DEBUG,
 			   "%s: MLD: ignore on link station (%d != %d)",
 			   __func__, hapd->mld_link_id, sta->mld_assoc_link_id);
-		return;
+
+		if (temp_hapd->conf->mld_ap && sta->mld_assoc_link_id >= 0) {
+			struct hostapd_data *link_bss;
+
+			link_bss = hostapd_mld_get_link_bss(temp_hapd, sta->mld_assoc_link_id);
+			if (link_bss)
+				hapd = link_bss;
+		}
 	}
 #endif /* CONFIG_IEEE80211BE */
 
@@ -7017,6 +7167,27 @@ void ieee802_11_rx_from_unknown(struct hostapd_data *hapd, const u8 *src,
 	struct sta_info *sta;
 
 	sta = ap_get_sta(hapd, src);
+
+#ifdef CONFIG_IEEE80211BE
+	if (!sta && hapd->conf->mld_ap) {
+		struct hostapd_data *h;
+
+		/* The data frame might be sent by a non-MLD STA via non-first
+		 * link, so we must also check other links.
+		 */
+		for_each_mld_link(h, hapd) {
+			if (h == hapd)
+				continue;
+
+			if (sta = ap_get_sta(h, src))
+				break;
+		}
+	}
+
+	if (sta && sta->mld_info.mld_sta)
+		sta = sta->mld_assoc_sta;
+#endif
+
 	if (sta &&
 	    ((sta->flags & WLAN_STA_ASSOC) ||
 	     ((sta->flags & WLAN_STA_ASSOC_REQ_OK) && wds))) {
@@ -7146,42 +7317,53 @@ u8 * hostapd_eid_txpower_envelope(struct hostapd_data *hapd, u8 *eid)
 	 */
 	if (is_6ghz_op_class(iconf->op_class)) {
 		enum max_tx_pwr_interpretation tx_pwr_intrpn;
+		int err, max_eirp_psd, max_eirp_power;
 
 		/* Same Maximum Transmit Power for all 20 MHz bands */
 		tx_pwr_count = 0;
 		tx_pwr_intrpn = REGULATORY_CLIENT_EIRP_PSD;
 
 		/* Default Transmit Power Envelope for Global Operating Class */
-		if (hapd->iconf->reg_def_cli_eirp_psd != -1)
-			tx_pwr = hapd->iconf->reg_def_cli_eirp_psd;
-		else
-			tx_pwr = REG_PSD_MAX_TXPOWER_FOR_DEFAULT_CLIENT * 2;
+		err = hostap_afc_get_chan_max_eirp_power(iface, true,
+							 &max_eirp_psd);
+		if (err < 0) {
+			if (hapd->iconf->reg_def_cli_eirp_psd != -1)
+				max_eirp_psd = hapd->iconf->reg_def_cli_eirp_psd;
+			else
+				max_eirp_psd = REG_PSD_MAX_TXPOWER_FOR_DEFAULT_CLIENT * 2;
+		}
 
 		eid = hostapd_add_tpe_info(eid, tx_pwr_count, tx_pwr_intrpn,
-					   REG_DEFAULT_CLIENT, tx_pwr);
+					   REG_DEFAULT_CLIENT, max_eirp_psd);
 
 		/* Indoor Access Point must include an additional TPE for
 		 * subordinate devices */
 		if (he_reg_is_indoor(iconf->he_6ghz_reg_pwr_type)) {
-			/* TODO: Extract PSD limits from channel data */
-			if (hapd->iconf->reg_sub_cli_eirp_psd != -1)
-				tx_pwr = hapd->iconf->reg_sub_cli_eirp_psd;
-			else
-				tx_pwr = REG_PSD_MAX_TXPOWER_FOR_SUBORDINATE_CLIENT * 2;
+			if (err < 0) {
+				/* non-AFC connection */
+				if (hapd->iconf->reg_sub_cli_eirp_psd != -1)
+					max_eirp_psd = hapd->iconf->reg_sub_cli_eirp_psd;
+				else
+					max_eirp_psd = REG_PSD_MAX_TXPOWER_FOR_SUBORDINATE_CLIENT * 2;
+			}
 			eid = hostapd_add_tpe_info(eid, tx_pwr_count,
 						   tx_pwr_intrpn,
 						   REG_SUBORDINATE_CLIENT,
-						   tx_pwr);
+						   max_eirp_psd);
 		}
 
-		if (iconf->reg_def_cli_eirp != -1 &&
-		    he_reg_is_sp(iconf->he_6ghz_reg_pwr_type))
-			eid = hostapd_add_tpe_info(
-				eid, tx_pwr_count, REGULATORY_CLIENT_EIRP,
-				REG_DEFAULT_CLIENT,
-				hapd->iconf->reg_def_cli_eirp);
+		if (hostap_afc_get_chan_max_eirp_power(iface, false,
+						       &max_eirp_power)) {
+			max_eirp_power = iconf->reg_def_cli_eirp;
+			if (max_eirp_power == -1 ||
+			    !he_reg_is_sp(iconf->he_6ghz_reg_pwr_type))
+				return eid;
+		}
 
-		return eid;
+		return hostapd_add_tpe_info(eid, tx_pwr_count,
+					    REGULATORY_CLIENT_EIRP,
+					    REG_DEFAULT_CLIENT,
+					    max_eirp_power);
 	}
 #endif /* CONFIG_IEEE80211AX */
 
@@ -7262,37 +7444,67 @@ u8 * hostapd_eid_txpower_envelope(struct hostapd_data *hapd, u8 *eid)
 				    tx_pwr);
 }
 
-
 /* Wide Bandwidth Channel Switch subelement */
 static u8 * hostapd_eid_wb_channel_switch(struct hostapd_data *hapd, u8 *eid,
 					  u8 chan1, u8 chan2)
 {
 	u8 bw;
+	enum oper_chan_width oper_chwidth;
+#ifdef CONFIG_IEEE80211BE
+	u16 punct_bitmap = hapd->cs_freq_params.punct_bitmap;
+#endif /* CONFIG_IEEE80211BE */
 
 	/* bandwidth: 0: 40, 1: 80, 160, 80+80, 4: 320 as per
 	 * IEEE P802.11-REVme/D4.0, 9.4.2.159 and Table 9-314. */
 	switch (hapd->cs_freq_params.bandwidth) {
 	case 40:
-		bw = 0;
+		oper_chwidth = CONF_OPER_CHWIDTH_USE_HT;
 		break;
 	case 80:
-		bw = 1;
+		oper_chwidth = CONF_OPER_CHWIDTH_80MHZ;
 		break;
 	case 160:
-		bw = 1;
+		oper_chwidth = CONF_OPER_CHWIDTH_160MHZ;
 		break;
 	case 320:
-		bw = 4;
+		oper_chwidth = CONF_OPER_CHWIDTH_320MHZ;
 		break;
 	default:
 		/* not valid VHT bandwidth or not in CSA */
 		return eid;
 	}
 
+#ifdef CONFIG_IEEE80211BE
+	if (punct_bitmap) {
+		punct_update_legacy_bw(punct_bitmap,
+				       hapd->cs_freq_params.channel,
+				       &oper_chwidth, &chan1, &chan2);
+	}
+#endif /* CONFIG_IEEE80211BE */
+
+	bw = oper_chwidth == CONF_OPER_CHWIDTH_USE_HT ? 0 : 1;
 	*eid++ = WLAN_EID_WIDE_BW_CHSWITCH;
 	*eid++ = 3; /* Length of Wide Bandwidth Channel Switch element */
 	*eid++ = bw; /* New Channel Width */
-	if (hapd->cs_freq_params.bandwidth == 160) {
+
+	if (oper_chwidth == CONF_OPER_CHWIDTH_320MHZ) {
+		/* Based on IEEE P802.11be/D5.0 35.15.3 Channel switch methods
+		 * for an EHT BSS, when the Bandwidth Indication (BI) element
+		 * is present along with the Wide Bandwidth Channel Switch
+		 * (WBCS) element, the bandwidth in the WBCS element is less
+		 * than the bandwidth in the BI element.
+		 *
+		 * In other word, if the bandwidth is 320 MHz in the BI element,
+		 * the bandwidth in the WBCS element should be 160.
+		 */
+		oper_chwidth = CONF_OPER_CHWIDTH_160MHZ;
+		if (hapd->cs_freq_params.channel < chan1)
+			chan1 -= 16;
+		else
+			chan1 += 16;
+	}
+
+	if (oper_chwidth == CONF_OPER_CHWIDTH_160MHZ) {
 		/* Update the CCFS0 and CCFS1 values in the element based on
 		 * IEEE P802.11-REVme/D4.0, Table 9-314 */
 
@@ -7313,16 +7525,15 @@ static u8 * hostapd_eid_wb_channel_switch(struct hostapd_data *hapd, u8 *eid,
 	return eid;
 }
 
-
 #ifdef CONFIG_IEEE80211BE
 /* Bandwidth Indication element that is also used as the Bandwidth Indication
  * For Channel Switch subelement within a Channel Switch Wrapper element. */
 static u8 * hostapd_eid_bw_indication(struct hostapd_data *hapd, u8 *eid,
 				      u8 chan1, u8 chan2)
 {
-	u16 punct_bitmap = hostapd_get_punct_bitmap(hapd);
+	u16 punct_bitmap = hapd->cs_freq_params.punct_bitmap;
 	struct ieee80211_bw_ind_element *bw_ind_elem;
-	size_t elen = 3;
+	size_t elen = 4;
 
 	if (hapd->cs_freq_params.bandwidth <= 160 && !punct_bitmap)
 		return eid;
@@ -7528,16 +7739,21 @@ repeat_rnr_len:
 		for (i = start; i < hapd->iface->num_bss; i++) {
 			struct hostapd_data *bss = hapd->iface->bss[i];
 			bool ap_mld = false;
+			bool ignore_broadcast_ssid;
 
 			if (!bss || !bss->conf || !bss->started)
 				continue;
 
+			ignore_broadcast_ssid = bss->conf->ignore_broadcast_ssid;
 #ifdef CONFIG_IEEE80211BE
 			ap_mld = bss->conf->mld_ap;
+			/* FIXME How to exclude the hidden link in beacon? */
+			ignore_broadcast_ssid &=
+				!hostapd_is_ml_partner(bss, reporting_hapd);
 #endif /* CONFIG_IEEE80211BE */
 
 			if (bss == reporting_hapd ||
-			    bss->conf->ignore_broadcast_ssid)
+			    ignore_broadcast_ssid)
 				continue;
 
 			if (hostapd_skip_rnr(i, skip_profiles, ap_mld,
@@ -7796,13 +8012,19 @@ static bool hostapd_eid_rnr_bss(struct hostapd_data *hapd,
 	u8 bss_param = 0;
 	bool ap_mld = false;
 	u8 *eid = *pos;
+	bool ignore_broadcast_ssid;
 
+	if (!bss || !bss->conf || !bss->started)
+		return false;
+
+	ignore_broadcast_ssid = bss->conf->ignore_broadcast_ssid;
 #ifdef CONFIG_IEEE80211BE
 	ap_mld = !!hapd->conf->mld_ap;
+	/* FIXME How to exclude the hidden link in beacon? */
+	ignore_broadcast_ssid &= !hostapd_is_ml_partner(bss, reporting_hapd);
 #endif /* CONFIG_IEEE80211BE */
 
-	if (!bss || !bss->conf || !bss->started ||
-	    bss == reporting_hapd || bss->conf->ignore_broadcast_ssid)
+	if (bss == reporting_hapd || ignore_broadcast_ssid)
 		return false;
 
 	if (hostapd_skip_rnr(i, skip_profiles, ap_mld, tbtt_info_len,
@@ -7818,7 +8040,7 @@ static bool hostapd_eid_rnr_bss(struct hostapd_data *hapd,
 		 * one TBTT info available. */
 		*tbtt_count_pos = eid++;
 		*eid++ = tbtt_info_len;
-		*eid++ = op_class;
+		*eid++ = (op_class == 137 ? 134 : op_class);
 		*eid++ = bss->iconf->channel;
 		*len += RNR_TBTT_HEADER_LEN;
 	}
@@ -7865,6 +8087,8 @@ static bool hostapd_eid_rnr_bss(struct hostapd_data *hapd,
 			(MAX_NUM_MLD_LINKS | 0xF0);
 		/* BPCC (Bit 3 to Bit 0) */
 		*eid = is_partner ? ((param_ch & 0xF0) >> 4) : 0x0F;
+		if (bss->eht_mld_bss_critical_update == BSS_CRIT_UPDATE_ALL)
+			*eid |= RNR_TBTT_INFO_MLD_PARAM2_ALL_UPDATE_INC;
 #ifdef CONFIG_TESTING_OPTIONS
 		if (bss->conf->mld_indicate_disabled)
 			*eid |= RNR_TBTT_INFO_MLD_PARAM2_LINK_DISABLED;
@@ -7972,6 +8196,9 @@ u8 * hostapd_eid_rnr_colocation(struct hostapd_data *hapd, u8 *eid,
 		    !is_6ghz_op_class(iface->conf->op_class))
 			continue;
 
+		if (!iface->bss[0]->started)
+			continue;
+
 		eid = hostapd_eid_rnr_iface(iface->bss[0], hapd, eid,
 					    current_len, NULL, false);
 	}
@@ -7987,7 +8214,7 @@ u8 * hostapd_eid_rnr_mlo(struct hostapd_data *hapd, u32 type,
 	struct hostapd_iface *iface;
 	size_t i;
 
-	if (!hapd->iface || !hapd->iface->interfaces || !hapd->conf->mld_ap)
+	if (!hapd->iface || !hapd->iface->interfaces || !hapd->conf->mld_ap || !hapd->mld)
 		return eid;
 
 	/* TODO: Allow for FILS/Action as well */
@@ -7998,7 +8225,8 @@ u8 * hostapd_eid_rnr_mlo(struct hostapd_data *hapd, u32 type,
 		iface = hapd->iface->interfaces->iface[i];
 
 		if (!iface || iface == hapd->iface ||
-		    hapd->iface->freq == iface->freq)
+		    hapd->iface->freq == iface->freq ||
+		    !(hapd->mld->active_links & BIT(hapd->mld_link_id)))
 			continue;
 
 		eid = hostapd_eid_rnr_iface(iface->bss[0], hapd, eid,
@@ -8152,7 +8380,7 @@ static size_t hostapd_eid_mbssid_elem_len(struct hostapd_data *hapd,
 		else if (hapd->conf->xrates_supported)
 			ie_count++;
 		if (ie_count)
-			nontx_profile_len += 4 + ie_count;
+			nontx_profile_len += 5 + ie_count;
 
 		if (len + nontx_profile_len > 255)
 			break;
diff --git a/src/ap/ieee802_11.h b/src/ap/ieee802_11.h
index abf48ab..1dd5881 100644
--- a/src/ap/ieee802_11.h
+++ b/src/ap/ieee802_11.h
@@ -108,6 +108,8 @@ int hostapd_process_ml_assoc_req_addr(struct hostapd_data *hapd,
 				      const u8 *basic_mle, size_t basic_mle_len,
 				      u8 *mld_addr);
 int hostapd_get_aid(struct hostapd_data *hapd, struct sta_info *sta);
+u16 hostapd_copy_supp_rates(struct hostapd_data *hapd, struct sta_info *sta,
+		      const struct ieee802_11_elems *elems);
 u16 copy_sta_ht_capab(struct hostapd_data *hapd, struct sta_info *sta,
 		      const u8 *ht_capab);
 u16 copy_sta_vendor_vht(struct hostapd_data *hapd, struct sta_info *sta,
@@ -237,7 +239,9 @@ size_t hostapd_eid_eht_capab_len(struct hostapd_data *hapd,
 				 enum ieee80211_op_mode opmode);
 u8 * hostapd_eid_eht_capab(struct hostapd_data *hapd, u8 *eid,
 			   enum ieee80211_op_mode opmode);
+u8 * hostapd_eid_non_inheritance(struct hostapd_data *hapd, u8 *eid);
 u8 * hostapd_eid_eht_operation(struct hostapd_data *hapd, u8 *eid);
+u8 * hostapd_eid_eht_attlm(struct hostapd_data *hapd, u8 *eid);
 u16 copy_sta_eht_capab(struct hostapd_data *hapd, struct sta_info *sta,
 		       enum ieee80211_op_mode opmode,
 		       const u8 *he_capab, size_t he_capab_len,
@@ -250,6 +254,7 @@ u8 * hostapd_eid_mbssid(struct hostapd_data *hapd, u8 *eid, u8 *end,
 			u8 **elem_offset,
 			const u8 *known_bss, size_t known_bss_len, u8 *rnr_eid,
 			u8 *rnr_count, u8 **rnr_offset, size_t rnr_len);
+size_t hostapd_eid_non_inheritance_len(struct hostapd_data *hapd);
 bool hostapd_is_mld_ap(struct hostapd_data *hapd);
 const char * sae_get_password(struct hostapd_data *hapd,
 			      struct sta_info *sta, const char *rx_id,
@@ -263,5 +268,7 @@ int hostapd_process_assoc_ml_info(struct hostapd_data *hapd,
 				  const u8 *ies, size_t ies_len,
 				  bool reassoc, int tx_link_status,
 				  bool offload);
-
+void ieee802_11_rx_prot_eht(struct hostapd_data *hapd,
+			    const struct ieee80211_mgmt *mgmt,
+			    size_t len);
 #endif /* IEEE802_11_H */
diff --git a/src/ap/ieee802_11_eht.c b/src/ap/ieee802_11_eht.c
index 89f8ffd..b131c40 100644
--- a/src/ap/ieee802_11_eht.c
+++ b/src/ap/ieee802_11_eht.c
@@ -131,7 +131,6 @@ size_t hostapd_eid_eht_capab_len(struct hostapd_data *hapd,
 	return len;
 }
 
-
 u8 * hostapd_eid_eht_capab(struct hostapd_data *hapd, u8 *eid,
 			   enum ieee80211_op_mode opmode)
 {
@@ -237,9 +236,6 @@ u8 * hostapd_eid_eht_operation(struct hostapd_data *hapd, u8 *eid)
 
 	/* TODO: Fill in appropriate EHT-MCS max Nss information */
 	oper->basic_eht_mcs_nss_set[0] = 0x11;
-	oper->basic_eht_mcs_nss_set[1] = 0x00;
-	oper->basic_eht_mcs_nss_set[2] = 0x00;
-	oper->basic_eht_mcs_nss_set[3] = 0x00;
 
 	if (!eht_oper_info_present)
 		return pos + elen;
@@ -287,7 +283,74 @@ u8 * hostapd_eid_eht_operation(struct hostapd_data *hapd, u8 *eid)
 	return pos + elen;
 }
 
+u8 mlo_non_inherit_list_6ghz[] = {
+	WLAN_EID_AP_CHANNEL_REPORT,
+	WLAN_EID_HT_CAP,
+	WLAN_EID_HT_OPERATION,
+	WLAN_EID_VHT_CAP,
+	WLAN_EID_VHT_OPERATION,
+};
+
+u8 mlo_non_inherit_list_6ghz_ext[] = {
+};
+
+u8 mlo_non_inherit_list_2_5ghz[] = {
+	WLAN_EID_VHT_CAP,
+	WLAN_EID_VHT_OPERATION,
+	WLAN_EID_TRANSMIT_POWER_ENVELOPE,
+};
+
+u8 mlo_non_inherit_list_2_5ghz_ext[] = {
+	WLAN_EID_EXT_HE_6GHZ_BAND_CAP,
+};
 
+size_t hostapd_eid_non_inheritance_len(struct hostapd_data *hapd)
+{
+	size_t len = 4;
+
+	if (is_6ghz_op_class(hapd->iconf->op_class)) {
+		len += sizeof(mlo_non_inherit_list_6ghz);
+		len += sizeof(mlo_non_inherit_list_6ghz_ext);
+	} else {
+		len += sizeof(mlo_non_inherit_list_2_5ghz);
+		len += sizeof(mlo_non_inherit_list_2_5ghz_ext);
+	}
+
+	return len;
+}
+
+u8 * hostapd_eid_non_inheritance(struct hostapd_data *hapd, u8 *eid)
+{
+	u8 *pos = eid, *len_pos;
+	int i;
+
+	*pos++ = WLAN_EID_EXTENSION;
+	len_pos = pos++;
+	*pos++ = WLAN_EID_EXT_NON_INHERITANCE;
+	if (is_6ghz_op_class(hapd->iconf->op_class)) {
+		/* Element ID list */
+		*pos++ = sizeof(mlo_non_inherit_list_6ghz);
+		for (i = 0; i < sizeof(mlo_non_inherit_list_6ghz); i++)
+			*pos++ = mlo_non_inherit_list_6ghz[i];
+
+		/* Element ID Extension list */
+		*pos++ = sizeof(mlo_non_inherit_list_6ghz_ext);
+		for (i = 0; i < sizeof(mlo_non_inherit_list_6ghz_ext); i++)
+			*pos++ = mlo_non_inherit_list_6ghz_ext[i];
+	} else {
+		/* Element ID list */
+		*pos++ = sizeof(mlo_non_inherit_list_2_5ghz);
+		for (i = 0; i < sizeof(mlo_non_inherit_list_2_5ghz); i++)
+			*pos++ = mlo_non_inherit_list_2_5ghz[i];
+
+		/* Element ID Extension list */
+		*pos++ = sizeof(mlo_non_inherit_list_2_5ghz_ext);
+		for (i = 0; i < sizeof(mlo_non_inherit_list_2_5ghz_ext); i++)
+			*pos++ = mlo_non_inherit_list_2_5ghz_ext[i];
+	}
+	*len_pos = pos - (eid + 2);
+	return pos;
+}
 static bool check_valid_eht_mcs_nss(struct hostapd_data *hapd, const u8 *ap_mcs,
 				    const u8 *sta_mcs, u8 mcs_count, u8 map_len)
 {
@@ -451,7 +514,13 @@ static u8 * hostapd_eid_eht_basic_ml_common(struct hostapd_data *hapd,
 	u8 link_id;
 	u8 common_info_len;
 	u16 mld_cap;
-	u8 max_simul_links, active_links;
+	u8 max_simul_links, active_links = 0;
+
+	if (hapd->mld && !(hapd->mld->active_links & BIT(hapd->mld_link_id))) {
+		wpa_printf(MSG_ERROR, "MLD: Current link %d is not active for %s",
+			   hapd->mld_link_id, hapd->mld->name);
+		return pos;
+	}
 
 	/*
 	 * As the Multi-Link element can exceed the size of 255 bytes need to
@@ -465,9 +534,11 @@ static u8 * hostapd_eid_eht_basic_ml_common(struct hostapd_data *hapd,
 	control = MULTI_LINK_CONTROL_TYPE_BASIC |
 		BASIC_MULTI_LINK_CTRL_PRES_LINK_ID |
 		BASIC_MULTI_LINK_CTRL_PRES_BSS_PARAM_CH_COUNT |
-		BASIC_MULTI_LINK_CTRL_PRES_EML_CAPA |
 		BASIC_MULTI_LINK_CTRL_PRES_MLD_CAPA;
 
+	if (!hapd->iconf->eml_disable)
+		control |= BASIC_MULTI_LINK_CTRL_PRES_EML_CAPA;
+
 	/*
 	 * Set the basic Multi-Link common information. Hard code the common
 	 * info length to 13 based on the length of the present fields:
@@ -478,7 +549,10 @@ static u8 * hostapd_eid_eht_basic_ml_common(struct hostapd_data *hapd,
 #define EHT_ML_COMMON_INFO_LEN 13
 	common_info_len = EHT_ML_COMMON_INFO_LEN;
 
-	if (include_mld_id) {
+	if (hapd->iconf->eml_disable)
+		common_info_len -= 2; /* EML Capabilities (2) */
+
+	if (include_mld_id && hostapd_get_mld_id(hapd)) {
 		/* AP MLD ID */
 		control |= BASIC_MULTI_LINK_CTRL_PRES_AP_MLD_ID;
 		common_info_len++;
@@ -495,15 +569,20 @@ static u8 * hostapd_eid_eht_basic_ml_common(struct hostapd_data *hapd,
 	wpabuf_put_u8(buf, hapd->mld_link_id);
 
 	/* Currently hard code the BSS Parameters Change Count to 0x1 */
-	wpabuf_put_u8(buf, 0x1);
+	wpabuf_put_u8(buf, hapd->eht_mld_bss_param_change);
 
-	wpa_printf(MSG_DEBUG, "MLD: EML Capabilities=0x%x",
-		   hapd->iface->mld_eml_capa);
-	wpabuf_put_le16(buf, hapd->iface->mld_eml_capa);
+	if (!hapd->iconf->eml_disable) {
+		wpa_printf(MSG_DEBUG, "MLD: EML Capabilities=0x%x",
+			   hapd->iface->mld_eml_capa);
+		wpabuf_put_le16(buf, hapd->iface->mld_eml_capa);
+	}
 
 	mld_cap = hapd->iface->mld_mld_capa;
 	max_simul_links = mld_cap & EHT_ML_MLD_CAPA_MAX_NUM_SIM_LINKS_MASK;
-	active_links = hapd->mld->num_links - 1;
+	for (link_id = 0; link_id < MAX_NUM_MLD_LINKS; link_id++)
+		if (hapd->mld_link_id != link_id &&
+		    (hapd->mld->active_links & BIT(link_id)))
+			active_links++;
 
 	if (active_links > max_simul_links) {
 		wpa_printf(MSG_ERROR,
@@ -516,13 +595,13 @@ static u8 * hostapd_eid_eht_basic_ml_common(struct hostapd_data *hapd,
 	mld_cap |= active_links & EHT_ML_MLD_CAPA_MAX_NUM_SIM_LINKS_MASK;
 
 	/* TODO: Advertise T2LM based on driver support as well */
-	mld_cap &= ~EHT_ML_MLD_CAPA_TID_TO_LINK_MAP_NEG_SUPP_MSK;
+	mld_cap |= EHT_ML_MLD_CAPA_TID_TO_LINK_MAP_ALL_TO_ALL;
 
 	wpa_printf(MSG_DEBUG, "MLD: MLD Capabilities and Operations=0x%x",
 		   mld_cap);
 	wpabuf_put_le16(buf, mld_cap);
 
-	if (include_mld_id) {
+	if (include_mld_id && hostapd_get_mld_id(hapd)) {
 		wpa_printf(MSG_DEBUG, "MLD: AP MLD ID=0x%x",
 			   hostapd_get_mld_id(hapd));
 		wpabuf_put_u8(buf, hostapd_get_mld_id(hapd));
@@ -541,8 +620,8 @@ static u8 * hostapd_eid_eht_basic_ml_common(struct hostapd_data *hapd,
 		 * beacon interval (2) + TSF offset (8) + DTIM info (2) + BSS
 		 * parameters change counter (1) + station profile length.
 		 */
-#define EHT_ML_STA_INFO_LEN 22
-		size_t total_len = EHT_ML_STA_INFO_LEN +
+		size_t sta_info_len = include_mld_id ? 21 : 22;
+		size_t total_len = sta_info_len +
 			link->resp_sta_profile_len;
 
 		/* Skip the local one */
@@ -570,14 +649,16 @@ static u8 * hostapd_eid_eht_basic_ml_common(struct hostapd_data *hapd,
 			EHT_PER_STA_CTRL_COMPLETE_PROFILE_MSK |
 			EHT_PER_STA_CTRL_TSF_OFFSET_PRESENT_MSK |
 			EHT_PER_STA_CTRL_BEACON_INTERVAL_PRESENT_MSK |
-			EHT_PER_STA_CTRL_DTIM_INFO_PRESENT_MSK |
-			EHT_PER_STA_CTRL_BSS_PARAM_CNT_PRESENT_MSK;
+			EHT_PER_STA_CTRL_DTIM_INFO_PRESENT_MSK;
+
+		if (!include_mld_id)
+			control |= EHT_PER_STA_CTRL_BSS_PARAM_CNT_PRESENT_MSK;
 		wpabuf_put_le16(buf, control);
 
 		/* STA Info */
 
 		/* STA Info Length */
-		wpabuf_put_u8(buf, EHT_ML_STA_INFO_LEN - 2);
+		wpabuf_put_u8(buf, sta_info_len - 2);
 		wpabuf_put_data(buf, link->local_addr, ETH_ALEN);
 		wpabuf_put_le16(buf, link_bss->iconf->beacon_int);
 
@@ -586,18 +667,22 @@ static u8 * hostapd_eid_eht_basic_ml_common(struct hostapd_data *hapd,
 		 * TODO: Currently setting TSF offset to zero. However, this
 		 * information needs to come from the driver.
 		 */
-		wpabuf_put_le64(buf, 0);
+		wpabuf_put_le64(buf, link_bss->tsf_offset[hapd->mld_link_id]);
 
 		/* DTIM Info */
 		wpabuf_put_u8(buf, 0); /* DTIM Count */
 		wpabuf_put_u8(buf, link_bss->conf->dtim_period);
 
 		/* BSS Parameters Change Count */
-		wpabuf_put_u8(buf, hapd->eht_mld_bss_param_change);
+		if (!include_mld_id)
+			wpabuf_put_u8(buf, link_bss->eht_mld_bss_param_change);
 
 		if (!link->resp_sta_profile)
 			continue;
 
+#define EXT_EID_TAG_LEN 3
+		link->sta_prof_offset = wpabuf_len(buf) + EXT_EID_TAG_LEN;
+
 		/* Fragment the sub element if needed */
 		if (total_len <= 255) {
 			wpabuf_put_data(buf, link->resp_sta_profile,
@@ -606,8 +691,7 @@ static u8 * hostapd_eid_eht_basic_ml_common(struct hostapd_data *hapd,
 			ptr = link->resp_sta_profile;
 			len = link->resp_sta_profile_len;
 
-			slice_len = 255 - EHT_ML_STA_INFO_LEN;
-
+			slice_len = 255 - sta_info_len;
 			wpabuf_put_data(buf, ptr, slice_len);
 			len -= slice_len;
 			ptr += slice_len;
@@ -740,20 +824,90 @@ static u8 * hostapd_eid_eht_reconf_ml(struct hostapd_data *hapd, u8 *eid)
 }
 
 
+u8 * hostapd_eid_eht_attlm(struct hostapd_data *hapd, u8 *eid)
+{
+	struct attlm_settings *attlm;
+	struct os_reltime now, res;
+	int i;
+	u16 control = 0;
+	u8 *pos = eid;
+	u16 enabled_links;
+
+	if (!hapd->conf->mld_ap)
+		return eid;
+
+	attlm = &hapd->mld->new_attlm;
+	if (!attlm || !attlm->valid)
+		return eid;
+
+	/* The length will be set at the end */
+	*pos++ = WLAN_EID_EXTENSION;
+	*pos++ = 0;
+	*pos++ = WLAN_EID_EXT_TID_TO_LINK_MAPPING;
+
+	/* Set the A-TTLM Control field */
+	control = (IEEE80211_TTLM_CONTROL_DIRECTION & attlm->direction) |
+		  IEEE80211_TTLM_CONTROL_EXPECTED_DUR_PRESENT |
+		  IEEE80211_TTLM_CONTROL_INDICATOR;
+
+	if (attlm->switch_time_tsf_tu != 0)
+		control |= IEEE80211_TTLM_CONTROL_SWITCH_TIME_PRESENT;
+
+	WPA_PUT_LE16(pos, control);
+	pos += 2;
+
+	/* switch time & expected duration */
+	if (attlm->switch_time_tsf_tu != 0) {
+		WPA_PUT_LE16(pos, attlm->switch_time_tsf_tu);
+		pos += 2;
+
+		WPA_PUT_LE24(pos, (attlm->duration * 1000) >> 10);
+		pos += 3;
+	} else {
+		u32 diff;
+
+		os_get_reltime(&now);
+		os_reltime_sub(&now, &attlm->start_time, &res);
+		diff = (u32)os_reltime_in_ms(&res);
+
+		if (attlm->duration <= diff)
+			return eid;
+
+		WPA_PUT_LE24(pos, ((attlm->duration - diff) * 1000) >> 10);
+		pos += 3;
+	}
+
+	/* Link Mapping of each TID (0 - 7) */
+	enabled_links = hapd->conf->mld_allowed_links & ~attlm->disabled_links;
+	for (i = 0; i < 8; i++) {
+		WPA_PUT_LE16(pos, enabled_links);
+		pos += 2;
+	}
+
+	eid[1] = pos - eid - 2;
+
+	return pos;
+}
+
+
 static size_t hostapd_eid_eht_ml_len(struct mld_info *info,
-				     bool include_mld_id)
+				     bool include_mld_id,
+				     u8 eml_disable)
 {
 	size_t len = 0;
 	size_t eht_ml_len = 2 + EHT_ML_COMMON_INFO_LEN;
 	u8 link_id;
 
+	if (eml_disable)
+		eht_ml_len -= 2; /* EML Capabilities (2) */
+
 	if (include_mld_id)
 		eht_ml_len++;
 
 	for (link_id = 0; info && link_id < ARRAY_SIZE(info->links);
 	     link_id++) {
 		struct mld_link_info *link;
-		size_t sta_len = EHT_ML_STA_INFO_LEN;
+		size_t sta_len = include_mld_id ? 21 : 22;
 
 		link = &info->links[link_id];
 		if (!link->valid)
@@ -778,7 +932,6 @@ static size_t hostapd_eid_eht_ml_len(struct mld_info *info,
 	return len;
 }
 #undef EHT_ML_COMMON_INFO_LEN
-#undef EHT_ML_STA_INFO_LEN
 
 
 u8 * hostapd_eid_eht_ml_beacon(struct hostapd_data *hapd,
@@ -808,7 +961,9 @@ size_t hostapd_eid_eht_ml_beacon_len(struct hostapd_data *hapd,
 				     struct mld_info *info,
 				     bool include_mld_id)
 {
-	return hostapd_eid_eht_ml_len(info, include_mld_id);
+	return hostapd_eid_eht_ml_len(info,
+				      include_mld_id && hostapd_get_mld_id(hapd),
+				      hapd->iconf->eml_disable);
 }
 
 
@@ -1431,3 +1586,120 @@ out:
 
 	return WLAN_STATUS_SUCCESS;
 }
+
+static void ieee802_11_send_eml_omn(struct hostapd_data *hapd,
+				    const u8 *addr,
+				    struct eml_omn_element *omn_ie,
+				    size_t len)
+{
+	struct wpabuf *buf;
+
+	buf = wpabuf_alloc(2 + len);
+	if (!buf)
+		return;
+
+	wpabuf_put_u8(buf, WLAN_ACTION_PROTECTED_EHT);
+	wpabuf_put_u8(buf, WLAN_PROTECTED_EHT_ACTION_EML_OMN);
+	wpabuf_put_data(buf, omn_ie, len);
+
+	hostapd_drv_send_action(hapd, hapd->iface->freq, 0, addr,
+				wpabuf_head(buf), wpabuf_len(buf));
+
+	wpabuf_free(buf);
+}
+
+static void ieee802_11_rx_eml_omn(struct hostapd_data *hapd,
+				  const u8 *addr, const u8 *frm,
+				  size_t len)
+{
+	struct eml_omn_element *omn_ie;
+
+	if (hapd->iconf->eml_disable) {
+		wpa_printf(MSG_ERROR,
+			   "Ignore EML Operating Mode Notification from "
+			   MACSTR
+			   " since EML Capabilities is disabled",
+			   MAC2STR(addr));
+		return;
+	}
+
+	/* EML Operating Mode Notification IE */
+	omn_ie = os_zalloc(sizeof(struct eml_omn_element));
+	if (omn_ie == NULL)
+		return;
+
+	os_memcpy(omn_ie, frm, len);
+
+	if (omn_ie->control & EHT_EML_OMN_CONTROL_EMLMR_MODE) {
+		wpa_printf(MSG_ERROR,
+			   "EML: Ignore EML Operating Mode Fotification from "
+			   MACSTR
+			   " since doesn't support EMLMR",
+			   MAC2STR(addr));
+		goto out;
+	}
+
+	hostapd_drv_set_eml_omn(hapd, addr, omn_ie);
+
+	omn_ie->control &= ~(EHT_EML_OMN_CONTROL_EMLSR_PARA_UPDATE_COUNT |
+			     EHT_EML_OMN_CONTROL_INDEV_COEX_ACTIVITIES);
+
+	if (hapd->iconf->eml_resp) {
+		ieee802_11_send_eml_omn(hapd, addr, omn_ie, len);
+		wpa_printf(MSG_ERROR, "EML: AP send EML Operating Mode Fotification to "
+				       MACSTR,
+				       MAC2STR(addr));
+	}
+out:
+	os_free(omn_ie);
+	return;
+}
+
+void ieee802_11_rx_prot_eht(struct hostapd_data *hapd,
+			    const struct ieee80211_mgmt *mgmt,
+			    size_t len)
+{
+	struct sta_info *sta;
+	struct mld_info *info;
+	u8 action;
+	const u8 *payload;
+	size_t plen;
+
+	if (!hapd->conf->mld_ap)
+		return;
+
+	if (len < IEEE80211_HDRLEN + 2)
+		return;
+
+	sta = ap_get_sta(hapd, mgmt->sa);
+	if (!sta) {
+		wpa_printf(MSG_DEBUG, "EHT: Station " MACSTR,
+			   " not found for received Protected EHT Action",
+			   MAC2STR(mgmt->sa));
+		return;
+	}
+
+	info = &sta->mld_info;
+
+	payload = mgmt->u.action.u.eht_prot.variable;
+	action = mgmt->u.action.u.eht_prot.action;
+	plen = len - IEEE80211_HDRLEN - 2;
+
+	switch (action) {
+	case WLAN_PROTECTED_EHT_ACTION_EML_OMN:
+		if (!info->common_info.eml_capa & EHT_ML_EML_CAPA_EMLSR_SUPP) {
+			wpa_printf(MSG_ERROR, "EHT: Fail, Station does not support EMLSR!");
+			return;
+		}
+
+		ieee802_11_rx_eml_omn(hapd, mgmt->sa, payload, plen);
+		return;
+	}
+
+	wpa_printf(MSG_ERROR, "EHT: Unsupported Protected EHT Action %u from " MACSTR,
+		   action, MAC2STR(mgmt->sa));
+
+	return;
+
+}
+
diff --git a/src/ap/ieee802_11_he.c b/src/ap/ieee802_11_he.c
index a2deda6..f3a5679 100644
--- a/src/ap/ieee802_11_he.c
+++ b/src/ap/ieee802_11_he.c
@@ -139,6 +139,13 @@ u8 * hostapd_eid_he_capab(struct hostapd_data *hapd, u8 *eid,
 		os_memcpy(&cap->optional[mcs_nss_size],
 			  mode->he_capab[opmode].ppet,  ppet_size);
 
+	if (hapd->iface->conf->he_phy_capab.he_ldpc)
+		cap->he_phy_capab_info[HE_PHYCAP_LDPC_CODING_IN_PAYLOAD_IDX] |=
+			HE_PHYCAP_LDPC_CODING_IN_PAYLOAD;
+	else
+		cap->he_phy_capab_info[HE_PHYCAP_LDPC_CODING_IN_PAYLOAD_IDX] &=
+			~HE_PHYCAP_LDPC_CODING_IN_PAYLOAD;
+
 	if (hapd->iface->conf->he_phy_capab.he_su_beamformer)
 		cap->he_phy_capab_info[HE_PHYCAP_SU_BEAMFORMER_CAPAB_IDX] |=
 			HE_PHYCAP_SU_BEAMFORMER_CAPAB;
@@ -257,6 +264,9 @@ u8 * hostapd_eid_he_operation(struct hostapd_data *hapd, u8 *eid)
 		else
 			control = center_idx_to_bw_6ghz(seg0);
 
+		if (hapd->iconf->lpi_bcn_enhance)
+			control |= HE_6GHZ_OPER_INFO_CTRL_DUP_BEACON;
+
 		control |= hapd->iconf->he_6ghz_reg_pwr_type <<
 			HE_6GHZ_OPER_INFO_CTRL_REG_INFO_SHIFT;
 
@@ -310,6 +320,9 @@ u8 * hostapd_eid_he_mu_edca_parameter_set(struct hostapd_data *hapd, u8 *eid)
 	edca = (struct ieee80211_he_mu_edca_parameter_set *) pos;
 	os_memcpy(edca, &hapd->iface->conf->he_mu_edca, sizeof(*edca));
 
+	if (hapd->conf->wmm_enabled)
+		edca->he_qos_info = hapd->parameter_set_count % 0xf;
+
 	wpa_hexdump(MSG_DEBUG, "HE: MU EDCA Parameter Set element",
 		    pos, sizeof(*edca));
 
diff --git a/src/ap/ieee802_11_ht.c b/src/ap/ieee802_11_ht.c
index 4c39e40..3b0af99 100644
--- a/src/ap/ieee802_11_ht.c
+++ b/src/ap/ieee802_11_ht.c
@@ -127,7 +127,9 @@ no_update:
 u8 * hostapd_eid_ht_operation(struct hostapd_data *hapd, u8 *eid)
 {
 	struct ieee80211_ht_operation *oper;
+	le32 vht_capabilities_info;
 	u8 *pos = eid;
+	u8 chwidth;
 
 	if (!hapd->iconf->ieee80211n || hapd->conf->disable_11n ||
 	    is_6ghz_op_class(hapd->iconf->op_class))
@@ -143,6 +145,13 @@ u8 * hostapd_eid_ht_operation(struct hostapd_data *hapd, u8 *eid)
 	oper->operation_mode = host_to_le16(hapd->iface->ht_op_mode);
 	set_ht_param(hapd, oper);
 
+	vht_capabilities_info = host_to_le32(hapd->iface->current_mode->vht_capab);
+	chwidth = hostapd_get_oper_chwidth(hapd->iconf);
+	if (vht_capabilities_info & VHT_CAP_EXTENDED_NSS_BW_SUPPORT
+		&& ((chwidth == CHANWIDTH_160MHZ) || (chwidth == CHANWIDTH_80P80MHZ))) {
+		oper->operation_mode = host_to_le16(hapd->iconf->vht_oper_centr_freq_seg0_idx << 5);
+	}
+
 	pos += sizeof(*oper);
 
 	return pos;
@@ -270,6 +279,9 @@ void hostapd_2040_coex_action(struct hostapd_data *hapd,
 		return;
 	}
 
+	if (iface->conf->noscan || iface->conf->no_ht_coex)
+		return;
+
 	if (len < IEEE80211_HDRLEN + 2 + sizeof(*bc_ie)) {
 		wpa_printf(MSG_DEBUG,
 			   "Ignore too short 20/40 BSS Coexistence Management frame");
@@ -430,6 +442,9 @@ void ht40_intolerant_add(struct hostapd_iface *iface, struct sta_info *sta)
 	if (iface->current_mode->mode != HOSTAPD_MODE_IEEE80211G)
 		return;
 
+	if (iface->conf->noscan || iface->conf->no_ht_coex)
+		return;
+
 	wpa_printf(MSG_INFO, "HT: Forty MHz Intolerant is set by STA " MACSTR
 		   " in Association Request", MAC2STR(sta->addr));
 
diff --git a/src/ap/ieee802_11_shared.c b/src/ap/ieee802_11_shared.c
index 3dd3a6a..58283ea 100644
--- a/src/ap/ieee802_11_shared.c
+++ b/src/ap/ieee802_11_shared.c
@@ -510,6 +510,11 @@ u8 * hostapd_eid_ext_capab(struct hostapd_data *hapd, u8 *eid,
 			*pos &= ~0x08;
 		if (i == 2 && !hapd->iconf->mbssid)
 			*pos &= ~0x40;
+
+		/* Clear bits 62 (Operating Mode Notification)
+		 * if ieee80211ac is not enabled (mainly 2.4G and 6G) */
+		if (i == 7 && !hapd->iconf->ieee80211ac)
+			*pos &= ~0x40;
 	}
 
 	while (len > 0 && eid[1 + len] == 0) {
diff --git a/src/ap/ieee802_11_vht.c b/src/ap/ieee802_11_vht.c
index 4dc325c..68880ab 100644
--- a/src/ap/ieee802_11_vht.c
+++ b/src/ap/ieee802_11_vht.c
@@ -26,6 +26,7 @@ u8 * hostapd_eid_vht_capabilities(struct hostapd_data *hapd, u8 *eid, u32 nsts)
 	struct ieee80211_vht_capabilities *cap;
 	struct hostapd_hw_modes *mode = hapd->iface->current_mode;
 	u8 *pos = eid;
+	u8 chwidth;
 
 	if (!mode || is_6ghz_op_class(hapd->iconf->op_class))
 		return eid;
@@ -63,6 +64,17 @@ u8 * hostapd_eid_vht_capabilities(struct hostapd_data *hapd, u8 *eid, u32 nsts)
 			host_to_le32(nsts << VHT_CAP_BEAMFORMEE_STS_OFFSET);
 	}
 
+	chwidth = hostapd_get_oper_chwidth(hapd->iconf);
+	if (((host_to_le32(mode->vht_capab)) & VHT_CAP_EXTENDED_NSS_BW_SUPPORT)
+		&& ((chwidth == CHANWIDTH_160MHZ) || (chwidth == CHANWIDTH_80P80MHZ))) {
+		cap->vht_capabilities_info |= VHT_CAP_EXTENDED_NSS_BW_SUPPORT;
+		cap->vht_capabilities_info &= ~(host_to_le32(VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ));
+		cap->vht_capabilities_info &= ~(host_to_le32(VHT_CAP_SUPP_CHAN_WIDTH_160MHZ));
+		cap->vht_capabilities_info &= ~(host_to_le32(VHT_CAP_SUPP_CHAN_WIDTH_MASK));
+	} else {
+		cap->vht_capabilities_info &= ~VHT_CAP_EXTENDED_NSS_BW_SUPPORT_MASK;
+	}
+
 	/* Supported MCS set comes from hw */
 	os_memcpy(&cap->vht_supported_mcs_set, mode->vht_mcs_set, 8);
 
@@ -75,6 +87,7 @@ u8 * hostapd_eid_vht_capabilities(struct hostapd_data *hapd, u8 *eid, u32 nsts)
 u8 * hostapd_eid_vht_operation(struct hostapd_data *hapd, u8 *eid)
 {
 	struct ieee80211_vht_operation *oper;
+	le32 vht_capabilities_info;
 	u8 *pos = eid;
 	enum oper_chan_width oper_chwidth =
 		hostapd_get_oper_chwidth(hapd->iconf);
@@ -110,6 +123,7 @@ u8 * hostapd_eid_vht_operation(struct hostapd_data *hapd, u8 *eid)
 	oper->vht_op_info_chan_center_freq_seg1_idx = seg1;
 
 	oper->vht_op_info_chwidth = oper_chwidth;
+	vht_capabilities_info = host_to_le32(hapd->iface->current_mode->vht_capab);
 	if (oper_chwidth == CONF_OPER_CHWIDTH_160MHZ) {
 		/*
 		 * Convert 160 MHz channel width to new style as interop
@@ -123,6 +137,9 @@ u8 * hostapd_eid_vht_operation(struct hostapd_data *hapd, u8 *eid)
 			oper->vht_op_info_chan_center_freq_seg0_idx -= 8;
 		else
 			oper->vht_op_info_chan_center_freq_seg0_idx += 8;
+
+		if (vht_capabilities_info & VHT_CAP_EXTENDED_NSS_BW_SUPPORT)
+			oper->vht_op_info_chan_center_freq_seg1_idx = 0;
 	} else if (oper_chwidth == CONF_OPER_CHWIDTH_80P80MHZ) {
 		/*
 		 * Convert 80+80 MHz channel width to new style as interop
diff --git a/src/ap/ieee802_1x.c b/src/ap/ieee802_1x.c
index 34de54a..4e79fe1 100644
--- a/src/ap/ieee802_1x.c
+++ b/src/ap/ieee802_1x.c
@@ -600,6 +600,10 @@ int add_common_radius_attr(struct hostapd_data *hapd,
 	struct hostapd_radius_attr *attr;
 	int len;
 
+	if (hapd->conf->dynamic_own_ip_addr)
+		radius_client_get_local_addr(hapd->radius,
+					     &hapd->conf->own_ip_addr);
+
 	if (!hostapd_config_get_radius_attr(req_attr,
 					    RADIUS_ATTR_NAS_IP_ADDRESS) &&
 	    hapd->conf->own_ip_addr.af == AF_INET &&
@@ -2869,6 +2873,7 @@ static const char * bool_txt(bool val)
 	return val ? "TRUE" : "FALSE";
 }
 
+#ifdef CONFIG_CTRL_IFACE_MIB
 
 int ieee802_1x_get_mib(struct hostapd_data *hapd, char *buf, size_t buflen)
 {
@@ -3055,6 +3060,7 @@ int ieee802_1x_get_mib_sta(struct hostapd_data *hapd, struct sta_info *sta,
 	return len;
 }
 
+#endif
 
 #ifdef CONFIG_HS20
 static void ieee802_1x_wnm_notif_send(void *eloop_ctx, void *timeout_ctx)
diff --git a/src/ap/neighbor_db.c b/src/ap/neighbor_db.c
index f7a7d83..3e958f4 100644
--- a/src/ap/neighbor_db.c
+++ b/src/ap/neighbor_db.c
@@ -11,7 +11,7 @@
 
 #include "utils/common.h"
 #include "utils/crc32.h"
-#include "hostapd.h"
+#include "sta_info.h"
 #include "ieee802_11.h"
 #include "neighbor_db.h"
 
@@ -89,6 +89,38 @@ int hostapd_neighbor_show(struct hostapd_data *hapd, char *buf, size_t buflen)
 }
 
 
+int hostapd_neighbor_count(struct hostapd_data *hapd)
+{
+	struct hostapd_neighbor_entry *nr;
+	int count = 0;
+
+	dl_list_for_each(nr, &hapd->nr_db, struct hostapd_neighbor_entry,
+			 list) {
+		count++;
+	}
+	return count;
+}
+
+
+int hostapd_neighbor_insert_buffer(struct hostapd_data *hapd, char *buf,
+        size_t buflen)
+{
+	struct hostapd_neighbor_entry *nr;
+	char *pos = buf;
+
+	dl_list_for_each(nr, &hapd->nr_db, struct hostapd_neighbor_entry,
+			 list) {
+		/* For neighbor report IE, we only need bssid and nr*/
+		*pos++ = WLAN_EID_NEIGHBOR_REPORT;
+		*pos++ = wpabuf_len(nr->nr);
+		os_memcpy(pos, wpabuf_head(nr->nr), wpabuf_len(nr->nr));
+		pos += wpabuf_len(nr->nr);
+	}
+
+	return pos - buf;
+}
+
+
 static void hostapd_neighbor_clear_entry(struct hostapd_neighbor_entry *nr)
 {
 	wpabuf_free(nr->nr);
@@ -364,3 +396,89 @@ int hostapd_neighbor_sync_own_report(struct hostapd_data *hapd)
 
 	return 0;
 }
+
+void hostapd_neighbor_set_own_report_pref(struct hostapd_data *hapd, char *nei_buf,
+			 size_t buflen, const int pref)
+{
+	struct hostapd_neighbor_entry *nr;
+	char *pos, *next_nr;
+
+	pos = nei_buf;
+	next_nr = nei_buf;
+
+	dl_list_for_each(nr, &hapd->nr_db, struct hostapd_neighbor_entry,
+			 list) {
+		pos = next_nr;
+		next_nr = pos + 2 + wpabuf_len(nr->nr);
+		/* Shift 2 bytes for Element ID and Neighbor report length */
+		pos = pos + 2;
+		if(os_memcmp(pos, hapd->own_addr, ETH_ALEN) == 0) {
+			/* Shift for BSSID + BSSID info + Op_class + channel num + PHY type */
+			pos = pos + 6 + 4 + 1 + 1 + 1;
+
+			/* Iterate Subelement */
+			while (next_nr - pos > 0) {
+				if (*pos == 3) {
+					pos = pos + 2;
+					*pos = pref;
+					return;
+				} else {
+					pos++;
+					int shift_len = *pos++;
+					pos = pos + shift_len;
+				}
+			}
+		}
+	}
+}
+
+#ifdef CONFIG_MBO
+void hostapd_neighbor_set_pref_by_non_pref_chan(struct hostapd_data *hapd,
+			 struct sta_info* sta, char *nei_buf, size_t buflen)
+{
+	struct hostapd_neighbor_entry *nr;
+	struct mbo_non_pref_chan_info *info;
+	u8 i;
+
+	for(info = sta->non_pref_chan; info; info = info->next) {
+		/* Check OP_Class and Channel num */
+		for(i = 0; i < info->num_channels; i++) {
+			char *pos, *next_nr;
+
+			pos = nei_buf;
+			next_nr = nei_buf;
+
+			/* Iterate Neighbor report database */
+			dl_list_for_each(nr, &hapd->nr_db, struct hostapd_neighbor_entry,
+					 list) {
+				pos = next_nr;
+				next_nr = pos + 2 + wpabuf_len(nr->nr);
+				/**
+				 * Shift 12 bytes for Element ID, Neighbor report length,
+				 * BSSID and BSSID info.
+				 */
+				pos = pos + 12;
+				int nr_op_class = *pos++;
+				int nr_channel = *pos;
+				if(info->op_class == nr_op_class && info->channels[i] == nr_channel) {
+					/* Shift for Channel Num + PHY type */
+					pos = pos + 1 + 1;
+
+					// Iterate Subelement
+					while(next_nr - pos > 0) {
+						if(*pos == 3) {
+							pos = pos + 2;
+							*pos = info->pref;
+							break;
+						}else {
+							pos++;
+							int shift_len = *pos++;
+							pos = pos + shift_len;
+						}
+					}
+				}
+			}
+		}
+	}
+}
+#endif
diff --git a/src/ap/neighbor_db.h b/src/ap/neighbor_db.h
index 53f7142..cf14002 100644
--- a/src/ap/neighbor_db.h
+++ b/src/ap/neighbor_db.h
@@ -25,4 +25,13 @@ int hostapd_neighbor_remove(struct hostapd_data *hapd, const u8 *bssid,
 			    const struct wpa_ssid_value *ssid);
 void hostapd_free_neighbor_db(struct hostapd_data *hapd);
 
+int hostapd_neighbor_count(struct hostapd_data *hapd);
+int hostapd_neighbor_insert_buffer(struct hostapd_data *hapd, char *buf,
+        size_t buflen);
+void hostapd_neighbor_set_own_report_pref(struct hostapd_data *hapd, char *nei_buf,
+			 size_t buflen, const int pref);
+#ifdef CONFIG_MBO
+void hostapd_neighbor_set_pref_by_non_pref_chan(struct hostapd_data *hapd,
+			 struct sta_info* sta, char *nei_buf, size_t buflen);
+#endif
 #endif /* NEIGHBOR_DB_H */
diff --git a/src/ap/pmksa_cache_auth.c b/src/ap/pmksa_cache_auth.c
index 2fce838..8a63cb6 100644
--- a/src/ap/pmksa_cache_auth.c
+++ b/src/ap/pmksa_cache_auth.c
@@ -658,7 +658,7 @@ int pmksa_cache_auth_list(struct rsn_pmksa_cache *pmksa, char *buf, size_t len)
 
 	os_get_reltime(&now);
 	ret = os_snprintf(pos, buf + len - pos,
-			  "Index / SPA / PMKID / expiration (in seconds) / opportunistic\n");
+			  "Index / SPA / PMKID / PMK / expiration (in seconds) / opportunistic\n");
 	if (os_snprintf_error(buf + len - pos, ret))
 		return pos - buf;
 	pos += ret;
@@ -672,6 +672,9 @@ int pmksa_cache_auth_list(struct rsn_pmksa_cache *pmksa, char *buf, size_t len)
 		pos += ret;
 		pos += wpa_snprintf_hex(pos, buf + len - pos, entry->pmkid,
 					PMKID_LEN);
+		*pos++ = ' ';
+		pos += wpa_snprintf_hex(pos, buf + len - pos, entry->pmk,
+					entry->pmk_len);
 		ret = os_snprintf(pos, buf + len - pos, " %d %d\n",
 				  (int) (entry->expiration - now.sec),
 				  entry->opportunistic);
diff --git a/src/ap/rrm.c b/src/ap/rrm.c
index fbcddf3..3b045dd 100644
--- a/src/ap/rrm.c
+++ b/src/ap/rrm.c
@@ -89,6 +89,9 @@ static void hostapd_handle_beacon_report(struct hostapd_data *hapd,
 		return;
 	wpa_msg(hapd->msg_ctx, MSG_INFO, BEACON_RESP_RX MACSTR " %u %02x %s",
 		MAC2STR(addr), token, rep_mode, report);
+	if (len < sizeof(struct rrm_measurement_beacon_report))
+		return;
+	hostapd_ubus_notify_beacon_report(hapd, addr, token, rep_mode, (struct rrm_measurement_beacon_report*) pos, len);
 }
 
 
@@ -269,6 +272,8 @@ static void hostapd_send_nei_report_resp(struct hostapd_data *hapd,
 		}
 	}
 
+	hapd->openwrt_stats.rrm.neighbor_report_tx++;
+
 	hostapd_drv_send_action(hapd, hapd->iface->freq, 0, addr,
 				wpabuf_head(buf), wpabuf_len(buf));
 	wpabuf_free(buf);
@@ -404,7 +409,7 @@ void hostapd_handle_radio_measurement(struct hostapd_data *hapd,
 		hostapd_handle_nei_report_req(hapd, buf, len);
 		break;
 	case WLAN_RRM_LINK_MEASUREMENT_REPORT:
-		hostapd_handle_link_mesr_report(hapd, buf, len);
+		hostapd_ubus_handle_link_measurement(hapd, buf, len);
 		break;
 	default:
 		wpa_printf(MSG_DEBUG, "RRM action %u is not supported",
diff --git a/src/ap/scs.c b/src/ap/scs.c
new file mode 100644
index 0000000..6f3c044
--- /dev/null
+++ b/src/ap/scs.c
@@ -0,0 +1,247 @@
+#include "utils/includes.h"
+
+#include "utils/common.h"
+#include "common/ieee802_11_defs.h"
+#include "common/ieee802_11_common.h"
+#include "hostapd.h"
+#include "ieee802_11.h"
+#include "sta_info.h"
+#include "ap_config.h"
+#include "ap_drv_ops.h"
+#include "scs.h"
+
+static bool hostapd_find_scs_session(struct sta_info *sta, u8 scsid,
+				     u8 *session_idx)
+{
+	u8 idx;
+
+	for (idx = 0; idx < SCS_MAX_CFG_CNT; idx++) {
+		if (sta->scs_session[idx].scs_id == scsid) {
+			*session_idx = idx;
+			return sta->scs_session[idx].alive;
+		}
+	}
+
+	return false;
+}
+
+static int hostapd_find_available_scs_session(struct sta_info *sta)
+{
+	u8 idx;
+
+	for (idx = 0; idx < SCS_MAX_CFG_CNT; idx++) {
+		if (!sta->scs_session[idx].alive)
+			return idx;
+	}
+
+	return -1;
+}
+
+static bool hostapd_parse_qos_char_element(const struct element *elem,
+					   struct hostapd_scs_desc_info *info)
+{
+#define SCS_DIRECTION_UPLINK 0
+	u8 id_extension = elem->data[0];
+	u32 control_info;
+
+	info->qos_ie_len = elem->datalen + 2;
+
+	if (id_extension != WLAN_EID_EXT_QOS_CHARACTERISTICS ||
+	    info->qos_ie_len > sizeof(info->qos_ie))
+		return false;
+
+	control_info = WPA_GET_LE32(&elem->data[1]);
+	info->dir = control_info & 0x3;
+
+	/* Only support Uplink direction SCS request now. */
+	if (info->dir != SCS_DIRECTION_UPLINK)
+		return false;
+
+	os_memcpy(info->qos_ie, elem, info->qos_ie_len);
+
+	return true;
+}
+
+static u16 hostapd_process_scs_descriptor(struct hostapd_data *hapd,
+					  struct sta_info *sta, const u8 *payload,
+					  u8 scs_desc_len,
+					  struct hostapd_scs_desc_info *info)
+{
+	bool scs_avail, qos_char_elem_avail = false;
+	const struct element *elem;
+	u8 session_idx;
+	int ret;
+
+	scs_avail = hostapd_find_scs_session(sta, info->id, &session_idx);
+
+	switch (info->req_type) {
+	case SCS_REQ_TYPE_ADD:
+	case SCS_REQ_TYPE_CHANGE:
+		if ((info->req_type == SCS_REQ_TYPE_ADD && scs_avail) ||
+		    (info->req_type == SCS_REQ_TYPE_CHANGE && !scs_avail))
+			goto decline;
+
+		if (info->req_type == SCS_REQ_TYPE_ADD) {
+			session_idx = hostapd_find_available_scs_session(sta);
+			if (session_idx == -1) {
+				wpa_printf(MSG_ERROR, "%s: Out of SCS resource.\n",
+					   __func__);
+				goto decline;
+			}
+		}
+
+		for_each_element(elem, payload + 2, scs_desc_len - 2) {
+			switch (elem->id) {
+			case WLAN_EID_EXTENSION:
+				qos_char_elem_avail =
+					hostapd_parse_qos_char_element(elem, info);
+				break;
+			default:
+				/* The rest elements would be ignored now. */
+				break;
+			}
+		}
+
+		if (!qos_char_elem_avail) {
+			wpa_printf(MSG_ERROR, "%s: The content of QoS Charactristics"
+				   " element is empty or not supported yet!\n",
+				   __func__);
+			goto decline;
+		}
+
+		break;
+	case SCS_REQ_TYPE_REMOVE:
+		if (!scs_avail)
+			goto decline;
+
+		break;
+	default:
+		goto decline;
+	}
+
+	ret = hostapd_drv_set_scs(hapd, info);
+	if (ret)
+		goto decline;
+
+	sta->scs_session[session_idx].scs_id = info->id;
+	sta->scs_session[session_idx].alive =
+		info->req_type == SCS_REQ_TYPE_REMOVE ? false : true;
+
+	return (info->req_type == SCS_REQ_TYPE_REMOVE) ?
+		SCS_REQ_TCLAS_PROCESSING_TERMINATED : SCS_REQ_SUCCESS;
+
+decline:
+	wpa_printf(MSG_ERROR, "%s: Decline Request Type %d\n",
+		   __func__, info->req_type);
+
+	return SCS_REQ_DECLINED;
+}
+
+static void send_scs_response(struct hostapd_data *hapd,
+			      struct scs_status_duple *scs_status, const u8 *da,
+			      u8 dialog_token, u8 count)
+{
+	struct wpabuf *buf;
+	size_t len;
+	u8 i;
+
+	if (count == 0)
+		return;
+
+	/* Reference to 802_11be_D5.0 Figure 9-1183  */
+	len = 4 + count * sizeof(struct scs_status_duple);
+	buf = wpabuf_alloc(len);
+	if (buf == NULL)
+		return;
+
+	wpabuf_put_u8(buf, WLAN_ACTION_ROBUST_AV_STREAMING);
+	wpabuf_put_u8(buf, ROBUST_AV_SCS_RESP);
+	wpabuf_put_u8(buf, dialog_token);
+	wpabuf_put_u8(buf, count);
+
+	for (i = 0; i < count && i < SCS_MAX_CFG_CNT; i++) {
+		wpabuf_put_u8(buf, scs_status[i].scs_id);
+		wpabuf_put_le16(buf, scs_status[i].status);
+	}
+
+	len = wpabuf_len(buf);
+	hostapd_drv_send_action(hapd, hapd->iface->freq, 0, da,
+				wpabuf_head(buf), len);
+	wpabuf_free(buf);
+}
+
+static void hostapd_handle_scs_req(struct hostapd_data *hapd,
+				   const u8 *buf, size_t len)
+{
+	const struct ieee80211_mgmt *mgmt = (const struct ieee80211_mgmt *) buf;
+	struct hostapd_scs_desc_info info;
+	struct sta_info *sta;
+	struct scs_status_duple scs_status_list[SCS_MAX_CFG_CNT];
+	const u8 *pos, *end;
+	u8 token, index = 0;
+	const struct element *elem;
+
+	sta = ap_get_sta(hapd, mgmt->sa);
+
+	if (!sta) {
+		wpa_printf(MSG_ERROR, "Station " MACSTR " not found "
+			   "for SCS Request frame\n", MAC2STR(mgmt->sa));
+		return;
+	}
+
+	token = mgmt->u.action.u.scs.dialog_token;
+	pos = mgmt->u.action.u.scs.variable;
+
+	end = buf + len;
+	len = end - pos;
+
+	for_each_element(elem, pos, len) {
+		if (elem->id != WLAN_EID_SCS_DESCRIPTOR) {
+			wpa_printf(MSG_ERROR, "%s: no scs elem %d in scs req frame!\n",
+				   __func__, WLAN_EID_SCS_DESCRIPTOR);
+			break;
+		}
+
+		info.id = elem->data[0];
+		if (!info.id) {
+			wpa_printf(MSG_ERROR, "%s: SCSID = 0 is invalid\n", __func__);
+			break;
+		}
+
+		info.req_type = elem->data[1];
+		os_memcpy(info.peer_addr, mgmt->sa, ETH_ALEN);
+		scs_status_list[index].scs_id = info.id;
+		scs_status_list[index].status =
+			hostapd_process_scs_descriptor(hapd, sta, elem->data,
+						       elem->datalen, &info);
+		index++;
+	}
+
+	send_scs_response(hapd, scs_status_list, mgmt->sa, token, index);
+}
+
+void hostapd_handle_scs(struct hostapd_data *hapd, const u8 *buf, size_t len)
+{
+	const struct ieee80211_mgmt *mgmt = (const struct ieee80211_mgmt *) buf;
+
+	/*
+	 * Check for enough bytes: header + (1B)Category + (1B)Action +
+	 * (1B)Dialog Token.
+	 */
+	if (len < IEEE80211_HDRLEN + 3) {
+		wpa_printf(MSG_ERROR, "%s SCS frame len %lu is not enough!",
+			   __func__, len);
+		return;
+	}
+
+	switch (mgmt->u.action.u.scs.action) {
+	case ROBUST_AV_SCS_REQ:
+		hostapd_handle_scs_req(hapd, buf, len);
+		break;
+	case ROBUST_AV_SCS_RESP:
+		/* Not supported yet. */
+		break;
+	default:
+		break;
+	}
+}
diff --git a/src/ap/scs.h b/src/ap/scs.h
new file mode 100644
index 0000000..b69190b
--- /dev/null
+++ b/src/ap/scs.h
@@ -0,0 +1,30 @@
+#ifndef SCS_H
+#define SCS_H
+
+struct hostapd_data;
+
+/* Only support TUAO certification */
+#define SCS_MAX_CFG_CNT 2
+
+struct scs_status_duple {
+	u8 scs_id;
+	u16 status;
+};
+
+struct scs_session_status {
+	u8 scs_id;
+	bool alive;
+};
+
+enum scs_req_type {
+	SCS_REQ_TYPE_ADD,
+	SCS_REQ_TYPE_REMOVE,
+	SCS_REQ_TYPE_CHANGE,
+};
+
+#define SCS_REQ_SUCCESS		0
+#define SCS_REQ_DECLINED	37
+#define SCS_REQ_TCLAS_PROCESSING_TERMINATED	97
+
+void hostapd_handle_scs(struct hostapd_data *hapd, const u8 *buf, size_t len);
+#endif
diff --git a/src/ap/sta_info.c b/src/ap/sta_info.c
index 98c1413..2acd497 100644
--- a/src/ap/sta_info.c
+++ b/src/ap/sta_info.c
@@ -49,6 +49,7 @@ static void ap_sta_disassoc_cb_timeout(void *eloop_ctx, void *timeout_ctx);
 static void ap_sa_query_timer(void *eloop_ctx, void *timeout_ctx);
 static int ap_sta_remove(struct hostapd_data *hapd, struct sta_info *sta);
 static void ap_sta_delayed_1x_auth_fail_cb(void *eloop_ctx, void *timeout_ctx);
+static void ap_sta_remove_link_sta(struct hostapd_data *hapd, struct sta_info *sta);
 
 int ap_for_each_sta(struct hostapd_data *hapd,
 		    int (*cb)(struct hostapd_data *hapd, struct sta_info *sta,
@@ -73,6 +74,27 @@ struct sta_info * ap_get_sta(struct hostapd_data *hapd, const u8 *sta)
 	s = hapd->sta_hash[STA_HASH(sta)];
 	while (s != NULL && os_memcmp(s->addr, sta, 6) != 0)
 		s = s->hnext;
+
+#ifdef CONFIG_IEEE80211BE
+	if (hapd->conf->mld_ap && !s) {
+		u8 link_id;
+
+		for (link_id = 0; link_id < MAX_NUM_MLD_LINKS; link_id++) {
+			struct hostapd_data *h = hostapd_mld_get_link_bss(hapd, link_id);
+
+			if (!h)
+				continue;
+
+			for (s = h->sta_list; s; s = s->next)
+				if ((!os_memcmp(s->setup_link_addr, sta, 6) ||
+				     !os_memcmp(s->addr, sta, 6)) &&
+				     s->flags & WLAN_STA_ASSOC &&
+				     s->mld_info.mld_sta)
+					return s;
+		}
+	}
+#endif
+
 	return s;
 }
 
@@ -542,6 +564,9 @@ void ap_handle_timer(void *eloop_ctx, void *timeout_ctx)
 		hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
 			       HOSTAPD_LEVEL_INFO, "deauthenticated due to "
 			       "local deauth request");
+		hostapd_ubus_notify(hapd, "local-deauth", sta->addr);
+		if (ap_sta_is_mld(hapd, sta))
+			ap_sta_remove_link_sta(hapd, sta);
 		ap_free_sta(hapd, sta);
 		return;
 	}
@@ -699,6 +724,9 @@ skip_poll:
 		mlme_deauthenticate_indication(
 			hapd, sta,
 			WLAN_REASON_PREV_AUTH_NOT_VALID);
+		hostapd_ubus_notify(hapd, "inactive-deauth", sta->addr);
+		if (ap_sta_is_mld(hapd, sta))
+			ap_sta_remove_link_sta(hapd, sta);
 		ap_free_sta(hapd, sta);
 		break;
 	}
@@ -796,6 +824,7 @@ struct sta_info * ap_sta_add(struct hostapd_data *hapd, const u8 *addr)
 	struct sta_info *sta;
 	int i;
 	int max_inactivity = hapd->conf->ap_max_inactivity;
+	bool registered = false;
 
 	sta = ap_get_sta(hapd, addr);
 	if (sta)
@@ -832,7 +861,22 @@ struct sta_info * ap_sta_add(struct hostapd_data *hapd, const u8 *addr)
 	if (sta->max_idle_period)
 		max_inactivity = (sta->max_idle_period * 1024 + 999) / 1000;
 
-	if (!(hapd->iface->drv_flags & WPA_DRIVER_FLAGS_INACTIVITY_TIMER)) {
+#ifdef CONFIG_IEEE80211BE
+	if (hapd->conf->mld_ap) {
+		struct hostapd_data *h;
+		struct sta_info *s;
+
+		for_each_mld_link(h, hapd) {
+			s = ap_get_sta(h, addr);
+			if (s && eloop_is_timeout_registered(ap_handle_timer, h, s)) {
+				registered = true;
+				break;
+			}
+		}
+	}
+#endif /* CONFIG_IEEE80211BE */
+
+	if (!(hapd->iface->drv_flags & WPA_DRIVER_FLAGS_INACTIVITY_TIMER) && !registered) {
 		wpa_printf(MSG_DEBUG, "%s: register ap_handle_timer timeout "
 			   "for " MACSTR " (%d seconds - ap_max_inactivity)",
 			   __func__, MAC2STR(addr),
@@ -1497,9 +1541,6 @@ bool ap_sta_set_authorized_flag(struct hostapd_data *hapd, struct sta_info *sta,
 				mld_assoc_link_id = -2;
 		}
 #endif /* CONFIG_IEEE80211BE */
-		if (mld_assoc_link_id != -2)
-			hostapd_prune_associations(hapd, sta->addr,
-						   mld_assoc_link_id);
 		sta->flags |= WLAN_STA_AUTHORIZED;
 	} else {
 		sta->flags &= ~WLAN_STA_AUTHORIZED;
@@ -1536,15 +1577,28 @@ void ap_sta_set_authorized_event(struct hostapd_data *hapd,
 		os_snprintf(buf, sizeof(buf), MACSTR, MAC2STR(sta->addr));
 
 	if (authorized) {
+		static const char * const auth_algs[] = {
+			[WLAN_AUTH_OPEN] = "open",
+			[WLAN_AUTH_SHARED_KEY] = "shared",
+			[WLAN_AUTH_FT] = "ft",
+			[WLAN_AUTH_SAE] = "sae",
+			[WLAN_AUTH_FILS_SK] = "fils-sk",
+			[WLAN_AUTH_FILS_SK_PFS] = "fils-sk-pfs",
+			[WLAN_AUTH_FILS_PK] = "fils-pk",
+			[WLAN_AUTH_PASN] = "pasn",
+		};
+		const char *auth_alg = NULL;
 		const u8 *dpp_pkhash;
 		const char *keyid;
 		char dpp_pkhash_buf[100];
 		char keyid_buf[100];
 		char ip_addr[100];
+		char alg_buf[100];
 
 		dpp_pkhash_buf[0] = '\0';
 		keyid_buf[0] = '\0';
 		ip_addr[0] = '\0';
+		alg_buf[0] = '\0';
 #ifdef CONFIG_P2P
 		if (wpa_auth_get_ip_addr(sta->wpa_sm, ip_addr_buf) == 0) {
 			os_snprintf(ip_addr, sizeof(ip_addr),
@@ -1555,6 +1609,13 @@ void ap_sta_set_authorized_event(struct hostapd_data *hapd,
 		}
 #endif /* CONFIG_P2P */
 
+		if (sta->auth_alg < ARRAY_SIZE(auth_algs))
+			auth_alg = auth_algs[sta->auth_alg];
+
+		if (auth_alg)
+			os_snprintf(alg_buf, sizeof(alg_buf),
+				" auth_alg=%s", auth_alg);
+
 		keyid = ap_sta_wpa_get_keyid(hapd, sta);
 		if (keyid) {
 			os_snprintf(keyid_buf, sizeof(keyid_buf),
@@ -1573,17 +1634,19 @@ void ap_sta_set_authorized_event(struct hostapd_data *hapd,
 					 dpp_pkhash, SHA256_MAC_LEN);
 		}
 
-		wpa_msg(hapd->msg_ctx, MSG_INFO, AP_STA_CONNECTED "%s%s%s%s",
-			buf, ip_addr, keyid_buf, dpp_pkhash_buf);
+		hostapd_ubus_notify_authorized(hapd, sta, auth_alg);
+		wpa_msg(hapd->msg_ctx, MSG_INFO, AP_STA_CONNECTED "%s%s%s%s%s",
+			buf, ip_addr, keyid_buf, dpp_pkhash_buf, alg_buf);
 
 		if (hapd->msg_ctx_parent &&
 		    hapd->msg_ctx_parent != hapd->msg_ctx)
 			wpa_msg_no_global(hapd->msg_ctx_parent, MSG_INFO,
-					  AP_STA_CONNECTED "%s%s%s%s",
+					  AP_STA_CONNECTED "%s%s%s%s%s",
 					  buf, ip_addr, keyid_buf,
-					  dpp_pkhash_buf);
+					  dpp_pkhash_buf, alg_buf);
 	} else {
 		wpa_msg(hapd->msg_ctx, MSG_INFO, AP_STA_DISCONNECTED "%s", buf);
+		hostapd_ubus_notify(hapd, "disassoc", sta->addr);
 
 		if (hapd->msg_ctx_parent &&
 		    hapd->msg_ctx_parent != hapd->msg_ctx)
@@ -1860,7 +1923,7 @@ int ap_sta_re_add(struct hostapd_data *hapd, struct sta_info *sta)
 			    sta->supported_rates_len,
 			    0, NULL, NULL, NULL, 0, NULL, 0, NULL,
 			    sta->flags, 0, 0, 0, 0,
-			    mld_link_addr, mld_link_sta)) {
+			    mld_link_addr, mld_link_sta, 0)) {
 		hostapd_logger(hapd, sta->addr,
 			       HOSTAPD_MODULE_IEEE80211,
 			       HOSTAPD_LEVEL_NOTICE,
@@ -1887,3 +1950,22 @@ void ap_sta_free_sta_profile(struct mld_info *info)
 	}
 }
 #endif /* CONFIG_IEEE80211BE */
+
+bool ap_sta_is_mld(struct hostapd_data *hapd,
+		   struct sta_info *sta)
+{
+#ifdef CONFIG_IEEE80211BE
+	return hapd->conf->mld_ap && sta && sta->mld_info.mld_sta;
+#else /* CONFIG_IEEE80211BE */
+	return false;
+#endif /* CONFIG_IEEE80211BE */
+}
+
+void ap_sta_set_mld(struct sta_info *sta, bool mld)
+{
+#ifdef CONFIG_IEEE80211BE
+	if (sta)
+		sta->mld_info.mld_sta = mld;
+#endif /* CONFIG_IEEE80211BE */
+}
+
diff --git a/src/ap/sta_info.h b/src/ap/sta_info.h
index 5b01c1e..85763ce 100644
--- a/src/ap/sta_info.h
+++ b/src/ap/sta_info.h
@@ -19,6 +19,10 @@
 #include "pasn/pasn_common.h"
 #include "hostapd.h"
 
+#ifdef CONFIG_IEEE80211BE
+#include "scs.h"
+#endif
+
 /* STA flags */
 #define WLAN_STA_AUTH BIT(0)
 #define WLAN_STA_ASSOC BIT(1)
@@ -49,10 +53,6 @@
 #define WLAN_STA_PENDING_DEAUTH_CB BIT(30)
 #define WLAN_STA_NONERP BIT(31)
 
-/* Maximum number of supported rates (from both Supported Rates and Extended
- * Supported Rates IEs). */
-#define WLAN_SUPP_RATES_MAX 32
-
 struct hostapd_data;
 
 struct mbo_non_pref_chan_info {
@@ -70,7 +70,6 @@ struct pending_eapol_rx {
 	enum frame_encryption encrypted;
 };
 
-#define EHT_ML_MAX_STA_PROF_LEN 1024
 struct mld_info {
 	bool mld_sta;
 
@@ -88,6 +87,7 @@ struct sta_info {
 	struct sta_info *next; /* next entry in sta list */
 	struct sta_info *hnext; /* next entry in hash table list */
 	u8 addr[6];
+	u8 setup_link_addr[6];
 	be32 ipaddr;
 	struct dl_list ip6addr; /* list head for struct ip6addr */
 	u16 aid; /* STA's unique AID (1 .. 2007) or 0 if not yet assigned */
@@ -308,6 +308,7 @@ struct sta_info {
 #endif /* CONFIG_TESTING_OPTIONS */
 #ifdef CONFIG_AIRTIME_POLICY
 	unsigned int airtime_weight;
+	unsigned int dyn_airtime_weight;
 	struct os_reltime backlogged_until;
 #endif /* CONFIG_AIRTIME_POLICY */
 
@@ -318,6 +319,8 @@ struct sta_info {
 #ifdef CONFIG_IEEE80211BE
 	struct mld_info mld_info;
 	u8 mld_assoc_link_id;
+	struct sta_info *mld_assoc_sta;
+	struct scs_session_status scs_session[SCS_MAX_CFG_CNT];
 #endif /* CONFIG_IEEE80211BE */
 
 	u16 max_idle_period; /* if nonzero, the granted BSS max idle period in
@@ -408,23 +411,8 @@ int ap_sta_re_add(struct hostapd_data *hapd, struct sta_info *sta);
 
 void ap_free_sta_pasn(struct hostapd_data *hapd, struct sta_info *sta);
 
-static inline bool ap_sta_is_mld(struct hostapd_data *hapd,
-				 struct sta_info *sta)
-{
-#ifdef CONFIG_IEEE80211BE
-	return hapd->conf->mld_ap && sta && sta->mld_info.mld_sta;
-#else /* CONFIG_IEEE80211BE */
-	return false;
-#endif /* CONFIG_IEEE80211BE */
-}
-
-static inline void ap_sta_set_mld(struct sta_info *sta, bool mld)
-{
-#ifdef CONFIG_IEEE80211BE
-	if (sta)
-		sta->mld_info.mld_sta = mld;
-#endif /* CONFIG_IEEE80211BE */
-}
+bool ap_sta_is_mld(struct hostapd_data *hapd, struct sta_info *sta);
+void ap_sta_set_mld(struct sta_info *sta, bool mld);
 
 void ap_sta_free_sta_profile(struct mld_info *info);
 
diff --git a/src/ap/ubus.c b/src/ap/ubus.c
new file mode 100644
index 0000000..2256720
--- /dev/null
+++ b/src/ap/ubus.c
@@ -0,0 +1,2039 @@
+/*
+ * hostapd / ubus support
+ * Copyright (c) 2013, Felix Fietkau <nbd@nbd.name>
+ *
+ * This software may be distributed under the terms of the BSD license.
+ * See README for more details.
+ */
+
+#include "utils/includes.h"
+#include "utils/common.h"
+#include "utils/eloop.h"
+#include "utils/wpabuf.h"
+#include "common/ieee802_11_defs.h"
+#include "common/hw_features_common.h"
+#include "hostapd.h"
+#include "neighbor_db.h"
+#include "wps_hostapd.h"
+#include "sta_info.h"
+#include "ubus.h"
+#include "ap_drv_ops.h"
+#include "beacon.h"
+#include "rrm.h"
+#include "wnm_ap.h"
+#include "taxonomy.h"
+#include "airtime_policy.h"
+#include "hw_features.h"
+
+static struct ubus_context *ctx;
+static struct blob_buf b;
+static int ctx_ref;
+
+static inline struct hostapd_data *get_hapd_from_object(struct ubus_object *obj)
+{
+	return container_of(obj, struct hostapd_data, ubus.obj);
+}
+
+struct ubus_banned_client {
+	struct avl_node avl;
+	u8 addr[ETH_ALEN];
+};
+
+static void ubus_reconnect_timeout(void *eloop_data, void *user_ctx)
+{
+	if (ubus_reconnect(ctx, NULL)) {
+		eloop_register_timeout(1, 0, ubus_reconnect_timeout, ctx, NULL);
+		return;
+	}
+
+	ubus_add_uloop(ctx);
+}
+
+static void hostapd_ubus_connection_lost(struct ubus_context *ctx)
+{
+	uloop_fd_delete(&ctx->sock);
+	eloop_register_timeout(1, 0, ubus_reconnect_timeout, ctx, NULL);
+}
+
+static bool hostapd_ubus_init(void)
+{
+	if (ctx)
+		return true;
+
+	eloop_add_uloop();
+	ctx = ubus_connect(NULL);
+	if (!ctx)
+		return false;
+
+	ctx->connection_lost = hostapd_ubus_connection_lost;
+	ubus_add_uloop(ctx);
+
+	return true;
+}
+
+static void hostapd_ubus_ref_inc(void)
+{
+	ctx_ref++;
+}
+
+static void hostapd_ubus_ref_dec(void)
+{
+	ctx_ref--;
+	if (!ctx)
+		return;
+
+	if (ctx_ref)
+		return;
+
+	uloop_fd_delete(&ctx->sock);
+	ubus_free(ctx);
+	ctx = NULL;
+}
+
+void hostapd_ubus_add_iface(struct hostapd_iface *iface)
+{
+	if (!hostapd_ubus_init())
+		return;
+}
+
+void hostapd_ubus_free_iface(struct hostapd_iface *iface)
+{
+	if (!ctx)
+		return;
+}
+
+static void hostapd_notify_ubus(struct ubus_object *obj, char *bssname, char *event)
+{
+	char *event_type;
+
+	if (!ctx || !obj)
+		return;
+
+	if (asprintf(&event_type, "bss.%s", event) < 0)
+		return;
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_string(&b, "name", bssname);
+	ubus_notify(ctx, obj, event_type, b.head, -1);
+	free(event_type);
+}
+
+static void
+hostapd_bss_del_ban(void *eloop_data, void *user_ctx)
+{
+	struct ubus_banned_client *ban = eloop_data;
+	struct hostapd_data *hapd = user_ctx;
+
+	avl_delete(&hapd->ubus.banned, &ban->avl);
+	free(ban);
+}
+
+static void
+hostapd_bss_ban_client(struct hostapd_data *hapd, u8 *addr, int time)
+{
+	struct ubus_banned_client *ban;
+
+	if (time < 0)
+		time = 0;
+
+	ban = avl_find_element(&hapd->ubus.banned, addr, ban, avl);
+	if (!ban) {
+		if (!time)
+			return;
+
+		ban = os_zalloc(sizeof(*ban));
+		memcpy(ban->addr, addr, sizeof(ban->addr));
+		ban->avl.key = ban->addr;
+		avl_insert(&hapd->ubus.banned, &ban->avl);
+	} else {
+		eloop_cancel_timeout(hostapd_bss_del_ban, ban, hapd);
+		if (!time) {
+			hostapd_bss_del_ban(ban, hapd);
+			return;
+		}
+	}
+
+	eloop_register_timeout(0, time * 1000, hostapd_bss_del_ban, ban, hapd);
+}
+
+static int
+hostapd_bss_reload(struct ubus_context *ctx, struct ubus_object *obj,
+		   struct ubus_request_data *req, const char *method,
+		   struct blob_attr *msg)
+{
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+
+	return hostapd_reload_config(hapd->iface);
+}
+
+
+static void
+hostapd_parse_vht_map_blobmsg(uint16_t map)
+{
+	char label[4];
+	int16_t val;
+	int i;
+
+	for (i = 0; i < 8; i++) {
+		snprintf(label, 4, "%dss", i + 1);
+
+		val = (map & (BIT(1) | BIT(0))) + 7;
+		blobmsg_add_u16(&b, label, val == 10 ? -1 : val);
+		map = map >> 2;
+	}
+}
+
+static void
+hostapd_parse_vht_capab_blobmsg(struct ieee80211_vht_capabilities *vhtc)
+{
+	void *supported_mcs;
+	void *map;
+	int i;
+
+	static const struct {
+		const char *name;
+		uint32_t flag;
+	} vht_capas[] = {
+		{ "su_beamformee", VHT_CAP_SU_BEAMFORMEE_CAPABLE },
+		{ "mu_beamformee", VHT_CAP_MU_BEAMFORMEE_CAPABLE },
+	};
+
+	for (i = 0; i < ARRAY_SIZE(vht_capas); i++)
+		blobmsg_add_u8(&b, vht_capas[i].name,
+				!!(vhtc->vht_capabilities_info & vht_capas[i].flag));
+
+	supported_mcs = blobmsg_open_table(&b, "mcs_map");
+
+	/* RX map */
+	map = blobmsg_open_table(&b, "rx");
+	hostapd_parse_vht_map_blobmsg(le_to_host16(vhtc->vht_supported_mcs_set.rx_map));
+	blobmsg_close_table(&b, map);
+
+	/* TX map */
+	map = blobmsg_open_table(&b, "tx");
+	hostapd_parse_vht_map_blobmsg(le_to_host16(vhtc->vht_supported_mcs_set.tx_map));
+	blobmsg_close_table(&b, map);
+
+	blobmsg_close_table(&b, supported_mcs);
+}
+
+static void
+hostapd_parse_capab_blobmsg(struct sta_info *sta)
+{
+	void *r, *v;
+
+	v = blobmsg_open_table(&b, "capabilities");
+
+	if (sta->vht_capabilities) {
+		r = blobmsg_open_table(&b, "vht");
+		hostapd_parse_vht_capab_blobmsg(sta->vht_capabilities);
+		blobmsg_close_table(&b, r);
+	}
+
+	/* ToDo: Add HT / HE capability parsing */
+
+	blobmsg_close_table(&b, v);
+}
+
+static int
+hostapd_bss_get_clients(struct ubus_context *ctx, struct ubus_object *obj,
+			struct ubus_request_data *req, const char *method,
+			struct blob_attr *msg)
+{
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+	struct hostap_sta_driver_data sta_driver_data;
+	struct sta_info *sta;
+	void *list, *c;
+	char mac_buf[20];
+	static const struct {
+		const char *name;
+		uint32_t flag;
+	} sta_flags[] = {
+		{ "auth", WLAN_STA_AUTH },
+		{ "assoc", WLAN_STA_ASSOC },
+		{ "authorized", WLAN_STA_AUTHORIZED },
+		{ "preauth", WLAN_STA_PREAUTH },
+		{ "wds", WLAN_STA_WDS },
+		{ "wmm", WLAN_STA_WMM },
+		{ "ht", WLAN_STA_HT },
+		{ "vht", WLAN_STA_VHT },
+		{ "he", WLAN_STA_HE },
+		{ "wps", WLAN_STA_WPS },
+		{ "mfp", WLAN_STA_MFP },
+	};
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_u32(&b, "freq", hapd->iface->freq);
+	list = blobmsg_open_table(&b, "clients");
+	for (sta = hapd->sta_list; sta; sta = sta->next) {
+		void *r;
+		int i;
+
+		sprintf(mac_buf, MACSTR, MAC2STR(sta->addr));
+		c = blobmsg_open_table(&b, mac_buf);
+		for (i = 0; i < ARRAY_SIZE(sta_flags); i++)
+			blobmsg_add_u8(&b, sta_flags[i].name,
+				       !!(sta->flags & sta_flags[i].flag));
+
+#ifdef CONFIG_MBO
+		blobmsg_add_u8(&b, "mbo", !!(sta->cell_capa));
+#endif
+
+		r = blobmsg_open_array(&b, "rrm");
+		for (i = 0; i < ARRAY_SIZE(sta->rrm_enabled_capa); i++)
+			blobmsg_add_u32(&b, "", sta->rrm_enabled_capa[i]);
+		blobmsg_close_array(&b, r);
+
+		r = blobmsg_open_array(&b, "extended_capabilities");
+		/* Check if client advertises extended capabilities */
+		if (sta->ext_capability && sta->ext_capability[0] > 0) {
+			for (i = 0; i < sta->ext_capability[0]; i++) {
+				blobmsg_add_u32(&b, "", sta->ext_capability[1 + i]);
+			}
+		}
+		blobmsg_close_array(&b, r);
+
+		blobmsg_add_u32(&b, "aid", sta->aid);
+#ifdef CONFIG_TAXONOMY
+		r = blobmsg_alloc_string_buffer(&b, "signature", 1024);
+		if (retrieve_sta_taxonomy(hapd, sta, r, 1024) > 0)
+			blobmsg_add_string_buffer(&b);
+#endif
+
+		/* Driver information */
+		if (hostapd_drv_read_sta_data(hapd, &sta_driver_data, sta->addr) >= 0) {
+			r = blobmsg_open_table(&b, "bytes");
+			blobmsg_add_u64(&b, "rx", sta_driver_data.rx_bytes);
+			blobmsg_add_u64(&b, "tx", sta_driver_data.tx_bytes);
+			blobmsg_close_table(&b, r);
+			r = blobmsg_open_table(&b, "airtime");
+			blobmsg_add_u64(&b, "rx", sta_driver_data.rx_airtime);
+			blobmsg_add_u64(&b, "tx", sta_driver_data.tx_airtime);
+			blobmsg_close_table(&b, r);
+			r = blobmsg_open_table(&b, "packets");
+			blobmsg_add_u32(&b, "rx", sta_driver_data.rx_packets);
+			blobmsg_add_u32(&b, "tx", sta_driver_data.tx_packets);
+			blobmsg_close_table(&b, r);
+			r = blobmsg_open_table(&b, "rate");
+			/* Rate in kbits */
+			blobmsg_add_u32(&b, "rx", sta_driver_data.current_rx_rate * 100);
+			blobmsg_add_u32(&b, "tx", sta_driver_data.current_tx_rate * 100);
+			blobmsg_close_table(&b, r);
+			blobmsg_add_u32(&b, "signal", sta_driver_data.signal);
+		}
+
+		hostapd_parse_capab_blobmsg(sta);
+
+		blobmsg_close_table(&b, c);
+	}
+	blobmsg_close_array(&b, list);
+	ubus_send_reply(ctx, req, b.head);
+
+	return 0;
+}
+
+static int
+hostapd_bss_get_features(struct ubus_context *ctx, struct ubus_object *obj,
+			struct ubus_request_data *req, const char *method,
+			struct blob_attr *msg)
+{
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_u8(&b, "ht_supported", ht_supported(hapd->iface->hw_features));
+	blobmsg_add_u8(&b, "vht_supported", vht_supported(hapd->iface->hw_features));
+	ubus_send_reply(ctx, req, b.head);
+
+	return 0;
+}
+
+static int
+hostapd_bss_get_status(struct ubus_context *ctx, struct ubus_object *obj,
+		       struct ubus_request_data *req, const char *method,
+		       struct blob_attr *msg)
+{
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+	void *airtime_table, *dfs_table, *rrm_table, *wnm_table;
+	struct os_reltime now;
+	char ssid[SSID_MAX_LEN + 1];
+	char phy_name[17];
+	size_t ssid_len = SSID_MAX_LEN;
+	u8 channel = 0, op_class = 0;
+
+	if (hapd->conf->ssid.ssid_len < SSID_MAX_LEN)
+		ssid_len = hapd->conf->ssid.ssid_len;
+	
+	ieee80211_freq_to_channel_ext(hapd->iface->freq,
+				      hapd->iconf->secondary_channel,
+				      hostapd_get_oper_chwidth(hapd->iconf),
+				      &op_class, &channel);
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_string(&b, "status", hostapd_state_text(hapd->iface->state));
+	blobmsg_printf(&b, "bssid", MACSTR, MAC2STR(hapd->conf->bssid));
+
+	memset(ssid, 0, SSID_MAX_LEN + 1);
+	memcpy(ssid, hapd->conf->ssid.ssid, ssid_len);
+	blobmsg_add_string(&b, "ssid", ssid);
+
+	blobmsg_add_u32(&b, "freq", hapd->iface->freq);
+	blobmsg_add_u32(&b, "channel", channel);
+	blobmsg_add_u32(&b, "op_class", op_class);
+	blobmsg_add_u32(&b, "beacon_interval", hapd->iconf->beacon_int);
+#ifdef CONFIG_IEEE80211AX
+	blobmsg_add_u32(&b, "bss_color", hapd->iface->conf->he_op.he_bss_color_disabled ? -1 :
+					 hapd->iface->conf->he_op.he_bss_color);
+#else
+	blobmsg_add_u32(&b, "bss_color", -1);
+#endif
+
+	snprintf(phy_name, 17, "%s", hapd->iface->phy);
+	blobmsg_add_string(&b, "phy", phy_name);
+
+	/* RRM */
+	rrm_table = blobmsg_open_table(&b, "rrm");
+	blobmsg_add_u64(&b, "neighbor_report_tx", hapd->openwrt_stats.rrm.neighbor_report_tx);
+	blobmsg_close_table(&b, rrm_table);
+
+	/* WNM */
+	wnm_table = blobmsg_open_table(&b, "wnm");
+	blobmsg_add_u64(&b, "bss_transition_query_rx", hapd->openwrt_stats.wnm.bss_transition_query_rx);
+	blobmsg_add_u64(&b, "bss_transition_request_tx", hapd->openwrt_stats.wnm.bss_transition_request_tx);
+	blobmsg_add_u64(&b, "bss_transition_response_rx", hapd->openwrt_stats.wnm.bss_transition_response_rx);
+	blobmsg_close_table(&b, wnm_table);
+
+	/* Airtime */
+	airtime_table = blobmsg_open_table(&b, "airtime");
+	blobmsg_add_u64(&b, "time", hapd->iface->last_channel_time);
+	blobmsg_add_u64(&b, "time_busy", hapd->iface->last_channel_time_busy);
+	blobmsg_add_u16(&b, "utilization", hapd->iface->channel_utilization);
+	blobmsg_close_table(&b, airtime_table);
+
+	/* DFS */
+	dfs_table = blobmsg_open_table(&b, "dfs");
+	blobmsg_add_u32(&b, "cac_seconds", hapd->iface->dfs_cac_ms / 1000);
+	blobmsg_add_u8(&b, "cac_active", !!(hapd->iface->cac_started));
+	os_reltime_age(&hapd->iface->dfs_cac_start, &now);
+	blobmsg_add_u32(&b, "cac_seconds_left",
+			hapd->iface->cac_started ? hapd->iface->dfs_cac_ms / 1000 - now.sec : 0);
+	blobmsg_close_table(&b, dfs_table);
+
+	ubus_send_reply(ctx, req, b.head);
+
+	return 0;
+}
+
+enum {
+	NOTIFY_RESPONSE,
+	__NOTIFY_MAX
+};
+
+static const struct blobmsg_policy notify_policy[__NOTIFY_MAX] = {
+	[NOTIFY_RESPONSE] = { "notify_response", BLOBMSG_TYPE_INT32 },
+};
+
+static int
+hostapd_notify_response(struct ubus_context *ctx, struct ubus_object *obj,
+			struct ubus_request_data *req, const char *method,
+			struct blob_attr *msg)
+{
+	struct blob_attr *tb[__NOTIFY_MAX];
+	struct hostapd_data *hapd = get_hapd_from_object(obj);
+	struct wpabuf *elems;
+	const char *pos;
+	size_t len;
+
+	blobmsg_parse(notify_policy, __NOTIFY_MAX, tb,
+		      blob_data(msg), blob_len(msg));
+
+	if (!tb[NOTIFY_RESPONSE])
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	hapd->ubus.notify_response = blobmsg_get_u32(tb[NOTIFY_RESPONSE]);
+
+	return UBUS_STATUS_OK;
+}
+
+enum {
+	DEL_CLIENT_ADDR,
+	DEL_CLIENT_REASON,
+	DEL_CLIENT_DEAUTH,
+	DEL_CLIENT_BAN_TIME,
+	__DEL_CLIENT_MAX
+};
+
+static const struct blobmsg_policy del_policy[__DEL_CLIENT_MAX] = {
+	[DEL_CLIENT_ADDR] = { "addr", BLOBMSG_TYPE_STRING },
+	[DEL_CLIENT_REASON] = { "reason", BLOBMSG_TYPE_INT32 },
+	[DEL_CLIENT_DEAUTH] = { "deauth", BLOBMSG_TYPE_INT8 },
+	[DEL_CLIENT_BAN_TIME] = { "ban_time", BLOBMSG_TYPE_INT32 },
+};
+
+static int
+hostapd_bss_del_client(struct ubus_context *ctx, struct ubus_object *obj,
+			struct ubus_request_data *req, const char *method,
+			struct blob_attr *msg)
+{
+	struct blob_attr *tb[__DEL_CLIENT_MAX];
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+	struct sta_info *sta;
+	bool deauth = false;
+	int reason;
+	u8 addr[ETH_ALEN];
+
+	blobmsg_parse(del_policy, __DEL_CLIENT_MAX, tb, blob_data(msg), blob_len(msg));
+
+	if (!tb[DEL_CLIENT_ADDR])
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	if (hwaddr_aton(blobmsg_data(tb[DEL_CLIENT_ADDR]), addr))
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	if (tb[DEL_CLIENT_REASON])
+		reason = blobmsg_get_u32(tb[DEL_CLIENT_REASON]);
+
+	if (tb[DEL_CLIENT_DEAUTH])
+		deauth = blobmsg_get_bool(tb[DEL_CLIENT_DEAUTH]);
+
+	sta = ap_get_sta(hapd, addr);
+	if (sta) {
+		if (deauth) {
+			hostapd_drv_sta_deauth(hapd, addr, reason);
+			ap_sta_deauthenticate(hapd, sta, reason);
+		} else {
+			hostapd_drv_sta_disassoc(hapd, addr, reason);
+			ap_sta_disassociate(hapd, sta, reason);
+		}
+	}
+
+	if (tb[DEL_CLIENT_BAN_TIME])
+		hostapd_bss_ban_client(hapd, addr, blobmsg_get_u32(tb[DEL_CLIENT_BAN_TIME]));
+
+	return 0;
+}
+
+static void
+blobmsg_add_macaddr(struct blob_buf *buf, const char *name, const u8 *addr)
+{
+	char *s;
+
+	s = blobmsg_alloc_string_buffer(buf, name, 20);
+	sprintf(s, MACSTR, MAC2STR(addr));
+	blobmsg_add_string_buffer(buf);
+}
+
+static int
+hostapd_bss_list_bans(struct ubus_context *ctx, struct ubus_object *obj,
+		      struct ubus_request_data *req, const char *method,
+		      struct blob_attr *msg)
+{
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+	struct ubus_banned_client *ban;
+	void *c;
+
+	blob_buf_init(&b, 0);
+	c = blobmsg_open_array(&b, "clients");
+	avl_for_each_element(&hapd->ubus.banned, ban, avl)
+		blobmsg_add_macaddr(&b, NULL, ban->addr);
+	blobmsg_close_array(&b, c);
+	ubus_send_reply(ctx, req, b.head);
+
+	return 0;
+}
+
+#ifdef CONFIG_WPS
+static int
+hostapd_bss_wps_start(struct ubus_context *ctx, struct ubus_object *obj,
+			struct ubus_request_data *req, const char *method,
+			struct blob_attr *msg)
+{
+	int rc;
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+
+	rc = hostapd_wps_button_pushed(hapd, NULL);
+
+	if (rc != 0)
+		return UBUS_STATUS_NOT_SUPPORTED;
+
+	return 0;
+}
+
+
+static const char * pbc_status_enum_str(enum pbc_status status)
+{
+	switch (status) {
+	case WPS_PBC_STATUS_DISABLE:
+		return "Disabled";
+	case WPS_PBC_STATUS_ACTIVE:
+		return "Active";
+	case WPS_PBC_STATUS_TIMEOUT:
+		return "Timed-out";
+	case WPS_PBC_STATUS_OVERLAP:
+		return "Overlap";
+	default:
+		return "Unknown";
+	}
+}
+
+static int
+hostapd_bss_wps_status(struct ubus_context *ctx, struct ubus_object *obj,
+			struct ubus_request_data *req, const char *method,
+			struct blob_attr *msg)
+{
+	int rc;
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+
+	blob_buf_init(&b, 0);
+
+	blobmsg_add_string(&b, "pbc_status", pbc_status_enum_str(hapd->wps_stats.pbc_status));
+	blobmsg_add_string(&b, "last_wps_result",
+			   (hapd->wps_stats.status == WPS_STATUS_SUCCESS ?
+			    "Success":
+			    (hapd->wps_stats.status == WPS_STATUS_FAILURE ?
+			     "Failed" : "None")));
+
+	/* If status == Failure - Add possible Reasons */
+	if(hapd->wps_stats.status == WPS_STATUS_FAILURE &&
+	   hapd->wps_stats.failure_reason > 0)
+		blobmsg_add_string(&b, "reason", wps_ei_str(hapd->wps_stats.failure_reason));
+
+	if (hapd->wps_stats.status)
+		blobmsg_printf(&b, "peer_address", MACSTR, MAC2STR(hapd->wps_stats.peer_addr));
+
+	ubus_send_reply(ctx, req, b.head);
+
+	return 0;
+}
+
+static int
+hostapd_bss_wps_cancel(struct ubus_context *ctx, struct ubus_object *obj,
+			struct ubus_request_data *req, const char *method,
+			struct blob_attr *msg)
+{
+	int rc;
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+
+	rc = hostapd_wps_cancel(hapd);
+
+	if (rc != 0)
+		return UBUS_STATUS_NOT_SUPPORTED;
+
+	return 0;
+}
+#endif /* CONFIG_WPS */
+
+static int
+hostapd_bss_update_beacon(struct ubus_context *ctx, struct ubus_object *obj,
+			struct ubus_request_data *req, const char *method,
+			struct blob_attr *msg)
+{
+	int rc;
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+
+	rc = ieee802_11_set_beacon(hapd);
+
+	if (rc != 0)
+		return UBUS_STATUS_NOT_SUPPORTED;
+
+	return 0;
+}
+
+enum {
+	CONFIG_IFACE,
+	CONFIG_FILE,
+	__CONFIG_MAX
+};
+
+enum {
+	CSA_FREQ,
+	CSA_BCN_COUNT,
+	CSA_CENTER_FREQ1,
+	CSA_CENTER_FREQ2,
+	CSA_BANDWIDTH,
+	CSA_SEC_CHANNEL_OFFSET,
+	CSA_HT,
+	CSA_VHT,
+	CSA_HE,
+	CSA_BLOCK_TX,
+	CSA_FORCE,
+	__CSA_MAX
+};
+
+static const struct blobmsg_policy csa_policy[__CSA_MAX] = {
+	[CSA_FREQ] = { "freq", BLOBMSG_TYPE_INT32 },
+	[CSA_BCN_COUNT] = { "bcn_count", BLOBMSG_TYPE_INT32 },
+	[CSA_CENTER_FREQ1] = { "center_freq1", BLOBMSG_TYPE_INT32 },
+	[CSA_CENTER_FREQ2] = { "center_freq2", BLOBMSG_TYPE_INT32 },
+	[CSA_BANDWIDTH] = { "bandwidth", BLOBMSG_TYPE_INT32 },
+	[CSA_SEC_CHANNEL_OFFSET] = { "sec_channel_offset", BLOBMSG_TYPE_INT32 },
+	[CSA_HT] = { "ht", BLOBMSG_TYPE_BOOL },
+	[CSA_VHT] = { "vht", BLOBMSG_TYPE_BOOL },
+	[CSA_HE] = { "he", BLOBMSG_TYPE_BOOL },
+	[CSA_BLOCK_TX] = { "block_tx", BLOBMSG_TYPE_BOOL },
+	[CSA_FORCE] = { "force", BLOBMSG_TYPE_BOOL },
+};
+
+
+static void switch_chan_fallback_cb(void *eloop_data, void *user_ctx)
+{
+	struct hostapd_iface *iface = eloop_data;
+	struct hostapd_freq_params *freq_params = user_ctx;
+
+	hostapd_switch_channel_fallback(iface, freq_params);
+}
+
+#ifdef NEED_AP_MLME
+static int
+hostapd_switch_chan(struct ubus_context *ctx, struct ubus_object *obj,
+		    struct ubus_request_data *req, const char *method,
+		    struct blob_attr *msg)
+{
+	struct blob_attr *tb[__CSA_MAX];
+	struct hostapd_data *hapd = get_hapd_from_object(obj);
+	struct hostapd_config *iconf = hapd->iface->conf;
+	struct hostapd_freq_params *freq_params;
+	struct hostapd_hw_modes *mode = hapd->iface->current_mode;
+	struct csa_settings css = {
+		.freq_params = {
+			.ht_enabled = iconf->ieee80211n,
+			.vht_enabled = iconf->ieee80211ac,
+			.he_enabled = iconf->ieee80211ax,
+			.sec_channel_offset = iconf->secondary_channel,
+		}
+	};
+	u8 chwidth = hostapd_get_oper_chwidth(iconf);
+	u8 seg0 = 0, seg1 = 0;
+	int ret = UBUS_STATUS_OK;
+	int i;
+
+	blobmsg_parse(csa_policy, __CSA_MAX, tb, blob_data(msg), blob_len(msg));
+
+	if (!tb[CSA_FREQ])
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	switch (iconf->vht_oper_chwidth) {
+	case CHANWIDTH_USE_HT:
+		if (iconf->secondary_channel)
+			css.freq_params.bandwidth = 40;
+		else
+			css.freq_params.bandwidth = 20;
+		break;
+	case CHANWIDTH_160MHZ:
+		css.freq_params.bandwidth = 160;
+		break;
+	default:
+		css.freq_params.bandwidth = 80;
+		break;
+	}
+
+	css.freq_params.freq = blobmsg_get_u32(tb[CSA_FREQ]);
+
+#define SET_CSA_SETTING(name, field, type) \
+	do { \
+		if (tb[name]) \
+			css.field = blobmsg_get_ ## type(tb[name]); \
+	} while(0)
+
+	SET_CSA_SETTING(CSA_BCN_COUNT, cs_count, u32);
+	SET_CSA_SETTING(CSA_CENTER_FREQ1, freq_params.center_freq1, u32);
+	SET_CSA_SETTING(CSA_CENTER_FREQ2, freq_params.center_freq2, u32);
+	SET_CSA_SETTING(CSA_BANDWIDTH, freq_params.bandwidth, u32);
+	SET_CSA_SETTING(CSA_SEC_CHANNEL_OFFSET, freq_params.sec_channel_offset, u32);
+	SET_CSA_SETTING(CSA_HT, freq_params.ht_enabled, bool);
+	SET_CSA_SETTING(CSA_VHT, freq_params.vht_enabled, bool);
+	SET_CSA_SETTING(CSA_HE, freq_params.he_enabled, bool);
+	SET_CSA_SETTING(CSA_BLOCK_TX, block_tx, bool);
+
+	css.freq_params.channel = hostapd_hw_get_channel(hapd, css.freq_params.freq);
+	if (!css.freq_params.channel)
+		return UBUS_STATUS_NOT_SUPPORTED;
+
+	switch (css.freq_params.bandwidth) {
+	case 160:
+		chwidth = CHANWIDTH_160MHZ;
+		break;
+	case 80:
+		chwidth = css.freq_params.center_freq2 ? CHANWIDTH_80P80MHZ : CHANWIDTH_80MHZ;
+		break;
+	default:
+		chwidth = CHANWIDTH_USE_HT;
+		break;
+	}
+
+	hostapd_set_freq_params(&css.freq_params, iconf->hw_mode,
+				css.freq_params.freq,
+				css.freq_params.channel, iconf->enable_edmg,
+				iconf->edmg_channel,
+				css.freq_params.ht_enabled,
+				css.freq_params.vht_enabled,
+				css.freq_params.he_enabled,
+				css.freq_params.eht_enabled,
+				css.freq_params.sec_channel_offset,
+				chwidth, seg0, seg1,
+				iconf->vht_capab,
+				mode ? &mode->he_capab[IEEE80211_MODE_AP] :
+				NULL,
+				mode ? &mode->eht_capab[IEEE80211_MODE_AP] :
+				NULL,
+				hostapd_get_punct_bitmap(hapd));
+
+	for (i = 0; i < hapd->iface->num_bss; i++) {
+		struct hostapd_data *bss = hapd->iface->bss[i];
+
+		if (hostapd_switch_channel(bss, &css) != 0)
+			ret = UBUS_STATUS_NOT_SUPPORTED;
+	}
+
+	if (!ret || !tb[CSA_FORCE] || !blobmsg_get_bool(tb[CSA_FORCE]))
+		return ret;
+
+	freq_params = malloc(sizeof(*freq_params));
+	memcpy(freq_params, &css.freq_params, sizeof(*freq_params));
+	eloop_register_timeout(0, 1, switch_chan_fallback_cb,
+			       hapd->iface, freq_params);
+
+	return 0;
+#undef SET_CSA_SETTING
+}
+#endif
+
+enum {
+	VENDOR_ELEMENTS,
+	__VENDOR_ELEMENTS_MAX
+};
+
+static const struct blobmsg_policy ve_policy[__VENDOR_ELEMENTS_MAX] = {
+	/* vendor elements are provided as hex-string */
+	[VENDOR_ELEMENTS] = { "vendor_elements", BLOBMSG_TYPE_STRING },
+};
+
+static int
+hostapd_vendor_elements(struct ubus_context *ctx, struct ubus_object *obj,
+			struct ubus_request_data *req, const char *method,
+			struct blob_attr *msg)
+{
+	struct blob_attr *tb[__VENDOR_ELEMENTS_MAX];
+	struct hostapd_data *hapd = get_hapd_from_object(obj);
+	struct hostapd_bss_config *bss = hapd->conf;
+	struct wpabuf *elems;
+	const char *pos;
+	size_t len;
+
+	blobmsg_parse(ve_policy, __VENDOR_ELEMENTS_MAX, tb,
+		      blob_data(msg), blob_len(msg));
+
+	if (!tb[VENDOR_ELEMENTS])
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	pos = blobmsg_data(tb[VENDOR_ELEMENTS]);
+	len = os_strlen(pos);
+	if (len & 0x01)
+			return UBUS_STATUS_INVALID_ARGUMENT;
+
+	len /= 2;
+	if (len == 0) {
+		wpabuf_free(bss->vendor_elements);
+		bss->vendor_elements = NULL;
+		return 0;
+	}
+
+	elems = wpabuf_alloc(len);
+	if (elems == NULL)
+		return 1;
+
+	if (hexstr2bin(pos, wpabuf_put(elems, len), len)) {
+		wpabuf_free(elems);
+		return UBUS_STATUS_INVALID_ARGUMENT;
+	}
+
+	wpabuf_free(bss->vendor_elements);
+	bss->vendor_elements = elems;
+
+	/* update beacons if vendor elements were set successfully */
+	if (ieee802_11_update_beacons(hapd->iface) != 0)
+		return UBUS_STATUS_NOT_SUPPORTED;
+	return UBUS_STATUS_OK;
+}
+
+static void
+hostapd_rrm_print_nr(struct hostapd_neighbor_entry *nr)
+{
+	const u8 *data;
+	char *str;
+	int len;
+
+	blobmsg_printf(&b, "", MACSTR, MAC2STR(nr->bssid));
+
+	str = blobmsg_alloc_string_buffer(&b, "", nr->ssid.ssid_len + 1);
+	memcpy(str, nr->ssid.ssid, nr->ssid.ssid_len);
+	str[nr->ssid.ssid_len] = 0;
+	blobmsg_add_string_buffer(&b);
+
+	len = wpabuf_len(nr->nr);
+	str = blobmsg_alloc_string_buffer(&b, "", 2 * len + 1);
+	wpa_snprintf_hex(str, 2 * len + 1, wpabuf_head_u8(nr->nr), len);
+	blobmsg_add_string_buffer(&b);
+}
+
+enum {
+	BSS_MGMT_EN_NEIGHBOR,
+	BSS_MGMT_EN_BEACON,
+	BSS_MGMT_EN_LINK_MEASUREMENT,
+#ifdef CONFIG_WNM_AP
+	BSS_MGMT_EN_BSS_TRANSITION,
+#endif
+	__BSS_MGMT_EN_MAX
+};
+
+static bool
+__hostapd_bss_mgmt_enable_f(struct hostapd_data *hapd, int flag)
+{
+	struct hostapd_bss_config *bss = hapd->conf;
+	uint32_t flags;
+
+	switch (flag) {
+	case BSS_MGMT_EN_NEIGHBOR:
+		if (bss->radio_measurements[0] &
+		    WLAN_RRM_CAPS_NEIGHBOR_REPORT)
+			return false;
+
+		bss->radio_measurements[0] |=
+			WLAN_RRM_CAPS_NEIGHBOR_REPORT;
+		hostapd_neighbor_set_own_report(hapd);
+		return true;
+	case BSS_MGMT_EN_BEACON:
+		flags = WLAN_RRM_CAPS_BEACON_REPORT_PASSIVE |
+			WLAN_RRM_CAPS_BEACON_REPORT_ACTIVE |
+			WLAN_RRM_CAPS_BEACON_REPORT_TABLE;
+
+		if (bss->radio_measurements[0] & flags == flags)
+			return false;
+
+		bss->radio_measurements[0] |= (u8) flags;
+		return true;
+	case BSS_MGMT_EN_LINK_MEASUREMENT:
+		flags = WLAN_RRM_CAPS_LINK_MEASUREMENT;
+
+		if (bss->radio_measurements[0] & flags == flags)
+			return false;
+
+		bss->radio_measurements[0] |= (u8) flags;
+		return true;
+#ifdef CONFIG_WNM_AP
+	case BSS_MGMT_EN_BSS_TRANSITION:
+		if (bss->bss_transition)
+			return false;
+
+		bss->bss_transition = 1;
+		return true;
+#endif
+	}
+}
+
+static void
+__hostapd_bss_mgmt_enable(struct hostapd_data *hapd, uint32_t flags)
+{
+	bool update = false;
+	int i;
+
+	for (i = 0; i < __BSS_MGMT_EN_MAX; i++) {
+		if (!(flags & (1 << i)))
+			continue;
+
+		update |= __hostapd_bss_mgmt_enable_f(hapd, i);
+	}
+
+	if (update)
+		ieee802_11_update_beacons(hapd->iface);
+}
+
+
+static const struct blobmsg_policy bss_mgmt_enable_policy[__BSS_MGMT_EN_MAX] = {
+	[BSS_MGMT_EN_NEIGHBOR] = { "neighbor_report", BLOBMSG_TYPE_BOOL },
+	[BSS_MGMT_EN_BEACON] = { "beacon_report", BLOBMSG_TYPE_BOOL },
+	[BSS_MGMT_EN_LINK_MEASUREMENT] = { "link_measurement", BLOBMSG_TYPE_BOOL },
+#ifdef CONFIG_WNM_AP
+	[BSS_MGMT_EN_BSS_TRANSITION] = { "bss_transition", BLOBMSG_TYPE_BOOL },
+#endif
+};
+
+static int
+hostapd_bss_mgmt_enable(struct ubus_context *ctx, struct ubus_object *obj,
+		   struct ubus_request_data *req, const char *method,
+		   struct blob_attr *msg)
+
+{
+	struct hostapd_data *hapd = get_hapd_from_object(obj);
+	struct blob_attr *tb[__BSS_MGMT_EN_MAX];
+	struct blob_attr *cur;
+	uint32_t flags = 0;
+	int i;
+	bool neigh = false, beacon = false;
+
+	blobmsg_parse(bss_mgmt_enable_policy, __BSS_MGMT_EN_MAX, tb, blob_data(msg), blob_len(msg));
+
+	for (i = 0; i < ARRAY_SIZE(tb); i++) {
+		if (!tb[i] || !blobmsg_get_bool(tb[i]))
+			continue;
+
+		flags |= (1 << i);
+	}
+
+	__hostapd_bss_mgmt_enable(hapd, flags);
+
+	return 0;
+}
+
+
+static void
+hostapd_rrm_nr_enable(struct hostapd_data *hapd)
+{
+	__hostapd_bss_mgmt_enable(hapd, 1 << BSS_MGMT_EN_NEIGHBOR);
+}
+
+static int
+hostapd_rrm_nr_get_own(struct ubus_context *ctx, struct ubus_object *obj,
+		       struct ubus_request_data *req, const char *method,
+		       struct blob_attr *msg)
+{
+	struct hostapd_data *hapd = get_hapd_from_object(obj);
+	struct hostapd_neighbor_entry *nr;
+	void *c;
+
+	hostapd_rrm_nr_enable(hapd);
+
+	nr = hostapd_neighbor_get(hapd, hapd->own_addr, NULL);
+	if (!nr)
+		return UBUS_STATUS_NOT_FOUND;
+
+	blob_buf_init(&b, 0);
+
+	c = blobmsg_open_array(&b, "value");
+	hostapd_rrm_print_nr(nr);
+	blobmsg_close_array(&b, c);
+
+	ubus_send_reply(ctx, req, b.head);
+
+	return 0;
+}
+
+static int
+hostapd_rrm_nr_list(struct ubus_context *ctx, struct ubus_object *obj,
+		    struct ubus_request_data *req, const char *method,
+		    struct blob_attr *msg)
+{
+	struct hostapd_data *hapd = get_hapd_from_object(obj);
+	struct hostapd_neighbor_entry *nr;
+	void *c;
+
+	hostapd_rrm_nr_enable(hapd);
+	blob_buf_init(&b, 0);
+
+	c = blobmsg_open_array(&b, "list");
+	dl_list_for_each(nr, &hapd->nr_db, struct hostapd_neighbor_entry, list) {
+		void *cur;
+
+		if (!memcmp(nr->bssid, hapd->own_addr, ETH_ALEN))
+			continue;
+
+		cur = blobmsg_open_array(&b, NULL);
+		hostapd_rrm_print_nr(nr);
+		blobmsg_close_array(&b, cur);
+	}
+	blobmsg_close_array(&b, c);
+
+	ubus_send_reply(ctx, req, b.head);
+
+	return 0;
+}
+
+enum {
+	NR_SET_LIST,
+	__NR_SET_LIST_MAX
+};
+
+static const struct blobmsg_policy nr_set_policy[__NR_SET_LIST_MAX] = {
+	[NR_SET_LIST] = { "list", BLOBMSG_TYPE_ARRAY },
+};
+
+
+static void
+hostapd_rrm_nr_clear(struct hostapd_data *hapd)
+{
+	struct hostapd_neighbor_entry *nr;
+
+restart:
+	dl_list_for_each(nr, &hapd->nr_db, struct hostapd_neighbor_entry, list) {
+		if (!memcmp(nr->bssid, hapd->own_addr, ETH_ALEN))
+			continue;
+
+		hostapd_neighbor_remove(hapd, nr->bssid, &nr->ssid);
+		goto restart;
+	}
+}
+
+static int
+hostapd_rrm_nr_set(struct ubus_context *ctx, struct ubus_object *obj,
+		   struct ubus_request_data *req, const char *method,
+		   struct blob_attr *msg)
+{
+	static const struct blobmsg_policy nr_e_policy[] = {
+		{ .type = BLOBMSG_TYPE_STRING },
+		{ .type = BLOBMSG_TYPE_STRING },
+		{ .type = BLOBMSG_TYPE_STRING },
+	};
+	struct hostapd_data *hapd = get_hapd_from_object(obj);
+	struct blob_attr *tb_l[__NR_SET_LIST_MAX];
+	struct blob_attr *tb[ARRAY_SIZE(nr_e_policy)];
+	struct blob_attr *cur;
+	int rem;
+
+	hostapd_rrm_nr_enable(hapd);
+
+	blobmsg_parse(nr_set_policy, __NR_SET_LIST_MAX, tb_l, blob_data(msg), blob_len(msg));
+	if (!tb_l[NR_SET_LIST])
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	hostapd_rrm_nr_clear(hapd);
+	blobmsg_for_each_attr(cur, tb_l[NR_SET_LIST], rem) {
+		struct wpa_ssid_value ssid;
+		struct wpabuf *data;
+		u8 bssid[ETH_ALEN];
+		char *s, *nr_s;
+
+		blobmsg_parse_array(nr_e_policy, ARRAY_SIZE(nr_e_policy), tb, blobmsg_data(cur), blobmsg_data_len(cur));
+		if (!tb[0] || !tb[1] || !tb[2])
+			goto invalid;
+
+		/* Neighbor Report binary */
+		nr_s = blobmsg_get_string(tb[2]);
+		data = wpabuf_parse_bin(nr_s);
+		if (!data)
+			goto invalid;
+
+		/* BSSID */
+		s = blobmsg_get_string(tb[0]);
+		if (strlen(s) == 0) {
+			/* Copy BSSID from neighbor report */
+			if (hwaddr_compact_aton(nr_s, bssid))
+				goto invalid;
+		} else if (hwaddr_aton(s, bssid)) {
+			goto invalid;
+		}
+
+		/* SSID */
+		s = blobmsg_get_string(tb[1]);
+		if (strlen(s) == 0) {
+			/* Copy SSID from hostapd BSS conf */
+			memcpy(&ssid, &hapd->conf->ssid, sizeof(ssid));
+		} else {
+			ssid.ssid_len = strlen(s);
+			if (ssid.ssid_len > sizeof(ssid.ssid))
+				goto invalid;
+
+			memcpy(&ssid, s, ssid.ssid_len);
+		}
+
+		hostapd_neighbor_set(hapd, bssid, &ssid, data, NULL, NULL, 0, 0);
+		wpabuf_free(data);
+		continue;
+
+invalid:
+		return UBUS_STATUS_INVALID_ARGUMENT;
+	}
+
+	return 0;
+}
+
+enum {
+	BEACON_REQ_ADDR,
+	BEACON_REQ_MODE,
+	BEACON_REQ_OP_CLASS,
+	BEACON_REQ_CHANNEL,
+	BEACON_REQ_DURATION,
+	BEACON_REQ_BSSID,
+	BEACON_REQ_SSID,
+	__BEACON_REQ_MAX,
+};
+
+static const struct blobmsg_policy beacon_req_policy[__BEACON_REQ_MAX] = {
+	[BEACON_REQ_ADDR] = { "addr", BLOBMSG_TYPE_STRING },
+	[BEACON_REQ_OP_CLASS] { "op_class", BLOBMSG_TYPE_INT32 },
+	[BEACON_REQ_CHANNEL] { "channel", BLOBMSG_TYPE_INT32 },
+	[BEACON_REQ_DURATION] { "duration", BLOBMSG_TYPE_INT32 },
+	[BEACON_REQ_MODE] { "mode", BLOBMSG_TYPE_INT32 },
+	[BEACON_REQ_BSSID] { "bssid", BLOBMSG_TYPE_STRING },
+	[BEACON_REQ_SSID] { "ssid", BLOBMSG_TYPE_STRING },
+};
+
+static int
+hostapd_rrm_beacon_req(struct ubus_context *ctx, struct ubus_object *obj,
+		       struct ubus_request_data *ureq, const char *method,
+		       struct blob_attr *msg)
+{
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+	struct blob_attr *tb[__BEACON_REQ_MAX];
+	struct blob_attr *cur;
+	struct wpabuf *req;
+	u8 bssid[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+	u8 addr[ETH_ALEN];
+	int mode, rem, ret;
+	int buf_len = 13;
+
+	blobmsg_parse(beacon_req_policy, __BEACON_REQ_MAX, tb, blob_data(msg), blob_len(msg));
+
+	if (!tb[BEACON_REQ_ADDR] || !tb[BEACON_REQ_MODE] || !tb[BEACON_REQ_DURATION] ||
+	    !tb[BEACON_REQ_OP_CLASS] || !tb[BEACON_REQ_CHANNEL])
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	if (tb[BEACON_REQ_SSID])
+		buf_len += blobmsg_data_len(tb[BEACON_REQ_SSID]) + 2 - 1;
+
+	mode = blobmsg_get_u32(tb[BEACON_REQ_MODE]);
+	if (hwaddr_aton(blobmsg_data(tb[BEACON_REQ_ADDR]), addr))
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	if (tb[BEACON_REQ_BSSID] &&
+	    hwaddr_aton(blobmsg_data(tb[BEACON_REQ_BSSID]), bssid))
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	req = wpabuf_alloc(buf_len);
+	if (!req)
+		return UBUS_STATUS_UNKNOWN_ERROR;
+
+	/* 1: regulatory class */
+	wpabuf_put_u8(req, blobmsg_get_u32(tb[BEACON_REQ_OP_CLASS]));
+
+	/* 2: channel number */
+	wpabuf_put_u8(req, blobmsg_get_u32(tb[BEACON_REQ_CHANNEL]));
+
+	/* 3-4: randomization interval */
+	wpabuf_put_le16(req, 0);
+
+	/* 5-6: duration */
+	wpabuf_put_le16(req, blobmsg_get_u32(tb[BEACON_REQ_DURATION]));
+
+	/* 7: mode */
+	wpabuf_put_u8(req, blobmsg_get_u32(tb[BEACON_REQ_MODE]));
+
+	/* 8-13: BSSID */
+	wpabuf_put_data(req, bssid, ETH_ALEN);
+
+	if ((cur = tb[BEACON_REQ_SSID]) != NULL) {
+		wpabuf_put_u8(req, WLAN_EID_SSID);
+		wpabuf_put_u8(req, blobmsg_data_len(cur) - 1);
+		wpabuf_put_data(req, blobmsg_data(cur), blobmsg_data_len(cur) - 1);
+	}
+
+	ret = hostapd_send_beacon_req(hapd, addr, 0, req);
+	if (ret < 0)
+		return -ret;
+
+	return 0;
+}
+
+enum {
+	LM_REQ_ADDR,
+	LM_REQ_TX_POWER_USED,
+	LM_REQ_TX_POWER_MAX,
+	__LM_REQ_MAX,
+};
+
+static const struct blobmsg_policy lm_req_policy[__LM_REQ_MAX] = {
+	[LM_REQ_ADDR] = { "addr", BLOBMSG_TYPE_STRING },
+	[LM_REQ_TX_POWER_USED] = { "tx-power-used", BLOBMSG_TYPE_INT32 },
+	[LM_REQ_TX_POWER_MAX] = { "tx-power-max", BLOBMSG_TYPE_INT32 },
+};
+
+static int
+hostapd_rrm_lm_req(struct ubus_context *ctx, struct ubus_object *obj,
+		   struct ubus_request_data *ureq, const char *method,
+		   struct blob_attr *msg)
+{
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+	struct blob_attr *tb[__LM_REQ_MAX];
+	struct wpabuf *buf;
+	u8 addr[ETH_ALEN];
+	int ret;
+	int8_t txp_used, txp_max;
+
+	txp_used = 0;
+	txp_max = 0;
+
+	blobmsg_parse(lm_req_policy, __LM_REQ_MAX, tb, blob_data(msg), blob_len(msg));
+
+	if (!tb[LM_REQ_ADDR])
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	if (tb[LM_REQ_TX_POWER_USED])
+		txp_used = (int8_t) blobmsg_get_u32(tb[LM_REQ_TX_POWER_USED]);
+
+	if (tb[LM_REQ_TX_POWER_MAX])
+		txp_max = (int8_t) blobmsg_get_u32(tb[LM_REQ_TX_POWER_MAX]);
+
+	if (hwaddr_aton(blobmsg_data(tb[LM_REQ_ADDR]), addr))
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	buf = wpabuf_alloc(5);
+	if (!buf)
+		return UBUS_STATUS_UNKNOWN_ERROR;
+
+	wpabuf_put_u8(buf, WLAN_ACTION_RADIO_MEASUREMENT);
+	wpabuf_put_u8(buf, WLAN_RRM_LINK_MEASUREMENT_REQUEST);
+	wpabuf_put_u8(buf, 1);
+	/* TX-Power used */
+	wpabuf_put_u8(buf, txp_used);
+	/* Max TX Power */
+	wpabuf_put_u8(buf, txp_max);
+
+	ret = hostapd_drv_send_action(hapd, hapd->iface->freq, 0, addr,
+				      wpabuf_head(buf), wpabuf_len(buf));
+
+	wpabuf_free(buf);
+	if (ret < 0)
+		return -ret;
+
+	return 0;
+}
+
+
+void hostapd_ubus_handle_link_measurement(struct hostapd_data *hapd, const u8 *data, size_t len)
+{
+	const struct ieee80211_mgmt *mgmt = (const struct ieee80211_mgmt *) data;
+	const u8 *pos, *end;
+	u8 token;
+
+	end = data + len;
+	token = mgmt->u.action.u.rrm.dialog_token;
+	pos = mgmt->u.action.u.rrm.variable;
+
+	if (end - pos < 8)
+		return;
+
+	if (!hapd->ubus.obj.has_subscribers)
+		return;
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_macaddr(&b, "address", mgmt->sa);
+	blobmsg_add_u16(&b, "dialog-token", token);
+	blobmsg_add_u16(&b, "rx-antenna-id", pos[4]);
+	blobmsg_add_u16(&b, "tx-antenna-id", pos[5]);
+	blobmsg_add_u16(&b, "rcpi", pos[6]);
+	blobmsg_add_u16(&b, "rsni", pos[7]);
+
+	ubus_notify(ctx, &hapd->ubus.obj, "link-measurement-report", b.head, -1);
+}
+
+
+#ifdef CONFIG_WNM_AP
+
+static int
+hostapd_bss_tr_send(struct hostapd_data *hapd, u8 *addr, bool disassoc_imminent, bool abridged,
+		    u16 disassoc_timer, u8 validity_period, u8 dialog_token,
+		    struct blob_attr *neighbors, u8 mbo_reason, u8 cell_pref, u8 reassoc_delay)
+{
+	struct blob_attr *cur;
+	struct sta_info *sta;
+	int nr_len = 0;
+	int rem;
+	u8 *nr = NULL;
+	u8 req_mode = 0;
+	u8 mbo[10];
+	size_t mbo_len = 0;
+
+	sta = ap_get_sta(hapd, addr);
+	if (!sta)
+		return UBUS_STATUS_NOT_FOUND;
+
+	if (neighbors) {
+		u8 *nr_cur;
+
+		if (blobmsg_check_array(neighbors,
+					BLOBMSG_TYPE_STRING) < 0)
+			return UBUS_STATUS_INVALID_ARGUMENT;
+
+		blobmsg_for_each_attr(cur, neighbors, rem) {
+			int len = strlen(blobmsg_get_string(cur));
+
+			if (len % 2)
+				return UBUS_STATUS_INVALID_ARGUMENT;
+
+			nr_len += (len / 2) + 2;
+		}
+
+		if (nr_len) {
+			nr = os_zalloc(nr_len);
+			if (!nr)
+				return UBUS_STATUS_UNKNOWN_ERROR;
+		}
+
+		nr_cur = nr;
+		blobmsg_for_each_attr(cur, neighbors, rem) {
+			int len = strlen(blobmsg_get_string(cur)) / 2;
+
+			*nr_cur++ = WLAN_EID_NEIGHBOR_REPORT;
+			*nr_cur++ = (u8) len;
+			if (hexstr2bin(blobmsg_data(cur), nr_cur, len)) {
+				free(nr);
+				return UBUS_STATUS_INVALID_ARGUMENT;
+			}
+
+			nr_cur += len;
+		}
+	}
+
+	if (nr)
+		req_mode |= WNM_BSS_TM_REQ_PREF_CAND_LIST_INCLUDED;
+
+	if (abridged)
+		req_mode |= WNM_BSS_TM_REQ_ABRIDGED;
+
+	if (disassoc_imminent)
+		req_mode |= WNM_BSS_TM_REQ_DISASSOC_IMMINENT;
+
+#ifdef CONFIG_MBO
+	u8 *mbo_pos = mbo;
+
+	if (mbo_reason > MBO_TRANSITION_REASON_PREMIUM_AP)
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	if (cell_pref != 0 && cell_pref != 1 && cell_pref != 255)
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	if (reassoc_delay > 65535 || (reassoc_delay && !disassoc_imminent))
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	*mbo_pos++ = MBO_ATTR_ID_TRANSITION_REASON;
+	*mbo_pos++ = 1;
+	*mbo_pos++ = mbo_reason;
+	*mbo_pos++ = MBO_ATTR_ID_CELL_DATA_PREF;
+	*mbo_pos++ = 1;
+	*mbo_pos++ = cell_pref;
+
+	if (reassoc_delay) {
+		*mbo_pos++ = MBO_ATTR_ID_ASSOC_RETRY_DELAY;
+		*mbo_pos++ = 2;
+		WPA_PUT_LE16(mbo_pos, reassoc_delay);
+		mbo_pos += 2;
+	}
+
+	mbo_len = mbo_pos - mbo;
+#endif
+
+	if (wnm_send_bss_tm_req(hapd, sta, req_mode, disassoc_timer, validity_period, NULL,
+				dialog_token, NULL, nr, nr_len, mbo_len ? mbo : NULL, mbo_len))
+		return UBUS_STATUS_UNKNOWN_ERROR;
+
+	return 0;
+}
+
+enum {
+	BSS_TR_ADDR,
+	BSS_TR_DA_IMMINENT,
+	BSS_TR_DA_TIMER,
+	BSS_TR_VALID_PERIOD,
+	BSS_TR_NEIGHBORS,
+	BSS_TR_ABRIDGED,
+	BSS_TR_DIALOG_TOKEN,
+#ifdef CONFIG_MBO
+	BSS_TR_MBO_REASON,
+	BSS_TR_CELL_PREF,
+	BSS_TR_REASSOC_DELAY,
+#endif
+	__BSS_TR_DISASSOC_MAX
+};
+
+static const struct blobmsg_policy bss_tr_policy[__BSS_TR_DISASSOC_MAX] = {
+	[BSS_TR_ADDR] = { "addr", BLOBMSG_TYPE_STRING },
+	[BSS_TR_DA_IMMINENT] = { "disassociation_imminent", BLOBMSG_TYPE_BOOL },
+	[BSS_TR_DA_TIMER] = { "disassociation_timer", BLOBMSG_TYPE_INT32 },
+	[BSS_TR_VALID_PERIOD] = { "validity_period", BLOBMSG_TYPE_INT32 },
+	[BSS_TR_NEIGHBORS] = { "neighbors", BLOBMSG_TYPE_ARRAY },
+	[BSS_TR_ABRIDGED] = { "abridged", BLOBMSG_TYPE_BOOL },
+	[BSS_TR_DIALOG_TOKEN] = { "dialog_token", BLOBMSG_TYPE_INT32 },
+#ifdef CONFIG_MBO
+	[BSS_TR_MBO_REASON] = { "mbo_reason", BLOBMSG_TYPE_INT32 },
+	[BSS_TR_CELL_PREF] = { "cell_pref", BLOBMSG_TYPE_INT32 },
+	[BSS_TR_REASSOC_DELAY] = { "reassoc_delay", BLOBMSG_TYPE_INT32 },
+#endif
+};
+
+static int
+hostapd_bss_transition_request(struct ubus_context *ctx, struct ubus_object *obj,
+			       struct ubus_request_data *ureq, const char *method,
+			       struct blob_attr *msg)
+{
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+	struct blob_attr *tb[__BSS_TR_DISASSOC_MAX];
+	struct sta_info *sta;
+	u32 da_timer = 0;
+	u32 valid_period = 0;
+	u8 addr[ETH_ALEN];
+	u32 dialog_token = 1;
+	bool abridged;
+	bool da_imminent;
+	u8 mbo_reason;
+	u8 cell_pref;
+	u8 reassoc_delay;
+
+	blobmsg_parse(bss_tr_policy, __BSS_TR_DISASSOC_MAX, tb, blob_data(msg), blob_len(msg));
+
+	if (!tb[BSS_TR_ADDR])
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	if (hwaddr_aton(blobmsg_data(tb[BSS_TR_ADDR]), addr))
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	if (tb[BSS_TR_DA_TIMER])
+		da_timer = blobmsg_get_u32(tb[BSS_TR_DA_TIMER]);
+
+	if (tb[BSS_TR_VALID_PERIOD])
+		valid_period = blobmsg_get_u32(tb[BSS_TR_VALID_PERIOD]);
+
+	if (tb[BSS_TR_DIALOG_TOKEN])
+		dialog_token = blobmsg_get_u32(tb[BSS_TR_DIALOG_TOKEN]);
+
+	da_imminent = !!(tb[BSS_TR_DA_IMMINENT] && blobmsg_get_bool(tb[BSS_TR_DA_IMMINENT]));
+	abridged = !!(tb[BSS_TR_ABRIDGED] && blobmsg_get_bool(tb[BSS_TR_ABRIDGED]));
+
+#ifdef CONFIG_MBO
+	if (tb[BSS_TR_MBO_REASON])
+		mbo_reason = blobmsg_get_u32(tb[BSS_TR_MBO_REASON]);
+
+	if (tb[BSS_TR_CELL_PREF])
+		cell_pref = blobmsg_get_u32(tb[BSS_TR_CELL_PREF]);
+
+	if (tb[BSS_TR_REASSOC_DELAY])
+		reassoc_delay = blobmsg_get_u32(tb[BSS_TR_REASSOC_DELAY]);
+#endif
+
+	return hostapd_bss_tr_send(hapd, addr, da_imminent, abridged, da_timer, valid_period,
+				   dialog_token, tb[BSS_TR_NEIGHBORS], mbo_reason, cell_pref, reassoc_delay);
+}
+#endif
+
+#ifdef CONFIG_AIRTIME_POLICY
+enum {
+	UPDATE_AIRTIME_STA,
+	UPDATE_AIRTIME_WEIGHT,
+	__UPDATE_AIRTIME_MAX,
+};
+
+
+static const struct blobmsg_policy airtime_policy[__UPDATE_AIRTIME_MAX] = {
+	[UPDATE_AIRTIME_STA] = { "sta", BLOBMSG_TYPE_STRING },
+	[UPDATE_AIRTIME_WEIGHT] = { "weight", BLOBMSG_TYPE_INT32 },
+};
+
+static int
+hostapd_bss_update_airtime(struct ubus_context *ctx, struct ubus_object *obj,
+			   struct ubus_request_data *ureq, const char *method,
+			   struct blob_attr *msg)
+{
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+	struct blob_attr *tb[__UPDATE_AIRTIME_MAX];
+	struct sta_info *sta = NULL;
+	u8 addr[ETH_ALEN];
+	int weight;
+
+	blobmsg_parse(airtime_policy, __UPDATE_AIRTIME_MAX, tb, blob_data(msg), blob_len(msg));
+
+	if (!tb[UPDATE_AIRTIME_WEIGHT])
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	weight = blobmsg_get_u32(tb[UPDATE_AIRTIME_WEIGHT]);
+
+	if (!tb[UPDATE_AIRTIME_STA]) {
+		if (!weight)
+			return UBUS_STATUS_INVALID_ARGUMENT;
+
+		hapd->conf->airtime_weight = weight;
+		return 0;
+	}
+
+	if (hwaddr_aton(blobmsg_data(tb[UPDATE_AIRTIME_STA]), addr))
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	sta = ap_get_sta(hapd, addr);
+	if (!sta)
+		return UBUS_STATUS_NOT_FOUND;
+
+	sta->dyn_airtime_weight = weight;
+	airtime_policy_new_sta(hapd, sta);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_TAXONOMY
+static const struct blobmsg_policy addr_policy[] = {
+	{ "address", BLOBMSG_TYPE_STRING }
+};
+
+static bool
+hostapd_add_b64_data(const char *name, const struct wpabuf *buf)
+{
+	char *str;
+
+	if (!buf)
+		return false;
+
+	str = blobmsg_alloc_string_buffer(&b, name, B64_ENCODE_LEN(wpabuf_len(buf)));
+	b64_encode(wpabuf_head(buf), wpabuf_len(buf), str, B64_ENCODE_LEN(wpabuf_len(buf)));
+	blobmsg_add_string_buffer(&b);
+
+	return true;
+}
+
+static int
+hostapd_bss_get_sta_ies(struct ubus_context *ctx, struct ubus_object *obj,
+			struct ubus_request_data *req, const char *method,
+			struct blob_attr *msg)
+{
+	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
+	struct blob_attr *tb;
+	struct sta_info *sta;
+	u8 addr[ETH_ALEN];
+
+	blobmsg_parse(addr_policy, 1, &tb, blobmsg_data(msg), blobmsg_len(msg));
+
+	if (!tb || hwaddr_aton(blobmsg_data(tb), addr))
+		return UBUS_STATUS_INVALID_ARGUMENT;
+
+	sta = ap_get_sta(hapd, addr);
+	if (!sta || (!sta->probe_ie_taxonomy && !sta->assoc_ie_taxonomy))
+		return UBUS_STATUS_NOT_FOUND;
+
+	blob_buf_init(&b, 0);
+	hostapd_add_b64_data("probe_ie", sta->probe_ie_taxonomy);
+	hostapd_add_b64_data("assoc_ie", sta->assoc_ie_taxonomy);
+	ubus_send_reply(ctx, req, b.head);
+
+	return 0;
+}
+#endif
+
+
+static const struct ubus_method bss_methods[] = {
+	UBUS_METHOD_NOARG("reload", hostapd_bss_reload),
+	UBUS_METHOD_NOARG("get_clients", hostapd_bss_get_clients),
+#ifdef CONFIG_TAXONOMY
+	UBUS_METHOD("get_sta_ies", hostapd_bss_get_sta_ies, addr_policy),
+#endif
+	UBUS_METHOD_NOARG("get_status", hostapd_bss_get_status),
+	UBUS_METHOD("del_client", hostapd_bss_del_client, del_policy),
+#ifdef CONFIG_AIRTIME_POLICY
+	UBUS_METHOD("update_airtime", hostapd_bss_update_airtime, airtime_policy),
+#endif
+	UBUS_METHOD_NOARG("list_bans", hostapd_bss_list_bans),
+#ifdef CONFIG_WPS
+	UBUS_METHOD_NOARG("wps_start", hostapd_bss_wps_start),
+	UBUS_METHOD_NOARG("wps_status", hostapd_bss_wps_status),
+	UBUS_METHOD_NOARG("wps_cancel", hostapd_bss_wps_cancel),
+#endif
+	UBUS_METHOD_NOARG("update_beacon", hostapd_bss_update_beacon),
+	UBUS_METHOD_NOARG("get_features", hostapd_bss_get_features),
+#ifdef NEED_AP_MLME
+	UBUS_METHOD("switch_chan", hostapd_switch_chan, csa_policy),
+#endif
+	UBUS_METHOD("set_vendor_elements", hostapd_vendor_elements, ve_policy),
+	UBUS_METHOD("notify_response", hostapd_notify_response, notify_policy),
+	UBUS_METHOD("bss_mgmt_enable", hostapd_bss_mgmt_enable, bss_mgmt_enable_policy),
+	UBUS_METHOD_NOARG("rrm_nr_get_own", hostapd_rrm_nr_get_own),
+	UBUS_METHOD_NOARG("rrm_nr_list", hostapd_rrm_nr_list),
+	UBUS_METHOD("rrm_nr_set", hostapd_rrm_nr_set, nr_set_policy),
+	UBUS_METHOD("rrm_beacon_req", hostapd_rrm_beacon_req, beacon_req_policy),
+	UBUS_METHOD("link_measurement_req", hostapd_rrm_lm_req, lm_req_policy),
+#ifdef CONFIG_WNM_AP
+	UBUS_METHOD("bss_transition_request", hostapd_bss_transition_request, bss_tr_policy),
+#endif
+};
+
+static struct ubus_object_type bss_object_type =
+	UBUS_OBJECT_TYPE("hostapd_bss", bss_methods);
+
+static int avl_compare_macaddr(const void *k1, const void *k2, void *ptr)
+{
+	return memcmp(k1, k2, ETH_ALEN);
+}
+
+void hostapd_ubus_add_bss(struct hostapd_data *hapd)
+{
+	struct ubus_object *obj = &hapd->ubus.obj;
+	char *name;
+	int ret;
+
+#ifdef CONFIG_MESH
+	if (hapd->conf->mesh & MESH_ENABLED)
+		return;
+#endif
+
+	if (!hostapd_ubus_init())
+		return;
+
+	if (asprintf(&name, "hostapd.%s", hapd->conf->iface) < 0)
+		return;
+
+	avl_init(&hapd->ubus.banned, avl_compare_macaddr, false, NULL);
+	obj->name = name;
+	obj->type = &bss_object_type;
+	obj->methods = bss_object_type.methods;
+	obj->n_methods = bss_object_type.n_methods;
+	ret = ubus_add_object(ctx, obj);
+	hostapd_ubus_ref_inc();
+}
+
+void hostapd_ubus_free_bss(struct hostapd_data *hapd)
+{
+	struct ubus_object *obj = &hapd->ubus.obj;
+	char *name = (char *) obj->name;
+
+#ifdef CONFIG_MESH
+	if (hapd->conf->mesh & MESH_ENABLED)
+		return;
+#endif
+
+	if (!ctx)
+		return;
+
+	if (obj->id) {
+		ubus_remove_object(ctx, obj);
+		hostapd_ubus_ref_dec();
+	}
+
+	free(name);
+}
+
+static void
+hostapd_ubus_vlan_action(struct hostapd_data *hapd, struct hostapd_vlan *vlan,
+			 const char *action)
+{
+	struct vlan_description *desc = &vlan->vlan_desc;
+	void *c;
+	int i;
+
+	if (!hapd->ubus.obj.has_subscribers)
+		return;
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_string(&b, "ifname", vlan->ifname);
+	blobmsg_add_string(&b, "bridge", vlan->bridge);
+	blobmsg_add_u32(&b, "vlan_id", vlan->vlan_id);
+
+	if (desc->notempty) {
+		blobmsg_add_u32(&b, "untagged", desc->untagged);
+		c = blobmsg_open_array(&b, "tagged");
+		for (i = 0; i < ARRAY_SIZE(desc->tagged) && desc->tagged[i]; i++)
+			blobmsg_add_u32(&b, "", desc->tagged[i]);
+		blobmsg_close_array(&b, c);
+	}
+
+	ubus_notify(ctx, &hapd->ubus.obj, action, b.head, -1);
+}
+
+void hostapd_ubus_add_vlan(struct hostapd_data *hapd, struct hostapd_vlan *vlan)
+{
+	hostapd_ubus_vlan_action(hapd, vlan, "vlan_add");
+}
+
+void hostapd_ubus_remove_vlan(struct hostapd_data *hapd, struct hostapd_vlan *vlan)
+{
+	hostapd_ubus_vlan_action(hapd, vlan, "vlan_remove");
+}
+
+struct ubus_event_req {
+	struct ubus_notify_request nreq;
+	int resp;
+};
+
+static void
+ubus_event_cb(struct ubus_notify_request *req, int idx, int ret)
+{
+	struct ubus_event_req *ureq = container_of(req, struct ubus_event_req, nreq);
+
+	ureq->resp = ret;
+}
+
+int hostapd_ubus_handle_event(struct hostapd_data *hapd, struct hostapd_ubus_request *req)
+{
+	struct ubus_banned_client *ban;
+	const char *types[HOSTAPD_UBUS_TYPE_MAX] = {
+		[HOSTAPD_UBUS_PROBE_REQ] = "probe",
+		[HOSTAPD_UBUS_AUTH_REQ] = "auth",
+		[HOSTAPD_UBUS_ASSOC_REQ] = "assoc",
+	};
+	const char *type = "mgmt";
+	struct ubus_event_req ureq = {};
+	const u8 *addr;
+
+	if (req->mgmt_frame)
+		addr = req->mgmt_frame->sa;
+	else
+		addr = req->addr;
+
+	ban = avl_find_element(&hapd->ubus.banned, addr, ban, avl);
+	if (ban)
+		return WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA;
+
+	if (!hapd->ubus.obj.has_subscribers)
+		return WLAN_STATUS_SUCCESS;
+
+	if (req->type < ARRAY_SIZE(types))
+		type = types[req->type];
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_macaddr(&b, "address", addr);
+	blobmsg_add_string(&b, "ifname", hapd->conf->iface);
+	if (req->mgmt_frame)
+		blobmsg_add_macaddr(&b, "target", req->mgmt_frame->da);
+	if (req->ssi_signal)
+		blobmsg_add_u32(&b, "signal", req->ssi_signal);
+	blobmsg_add_u32(&b, "freq", hapd->iface->freq);
+
+	if (req->elems) {
+		if(req->elems->ht_capabilities)
+		{
+			struct ieee80211_ht_capabilities *ht_capabilities;
+			void *ht_cap, *ht_cap_mcs_set, *mcs_set;
+
+
+			ht_capabilities = (struct ieee80211_ht_capabilities*) req->elems->ht_capabilities;
+			ht_cap = blobmsg_open_table(&b, "ht_capabilities");
+			blobmsg_add_u16(&b, "ht_capabilities_info", ht_capabilities->ht_capabilities_info);
+			ht_cap_mcs_set = blobmsg_open_table(&b, "supported_mcs_set");
+			blobmsg_add_u16(&b, "a_mpdu_params", ht_capabilities->a_mpdu_params);
+			blobmsg_add_u16(&b, "ht_extended_capabilities", ht_capabilities->ht_extended_capabilities);
+			blobmsg_add_u32(&b, "tx_bf_capability_info", ht_capabilities->tx_bf_capability_info);
+			blobmsg_add_u16(&b, "asel_capabilities", ht_capabilities->asel_capabilities);
+			mcs_set = blobmsg_open_array(&b, "supported_mcs_set");
+			for (int i = 0; i < 16; i++) {
+				blobmsg_add_u16(&b, NULL, (u16) ht_capabilities->supported_mcs_set[i]);
+			}
+			blobmsg_close_array(&b, mcs_set);
+			blobmsg_close_table(&b, ht_cap_mcs_set);
+			blobmsg_close_table(&b, ht_cap);
+		}
+		if(req->elems->vht_capabilities)
+		{
+			struct ieee80211_vht_capabilities *vht_capabilities;
+			void *vht_cap, *vht_cap_mcs_set;
+
+			vht_capabilities = (struct ieee80211_vht_capabilities*) req->elems->vht_capabilities;
+			vht_cap = blobmsg_open_table(&b, "vht_capabilities");
+			blobmsg_add_u32(&b, "vht_capabilities_info", vht_capabilities->vht_capabilities_info);
+			vht_cap_mcs_set = blobmsg_open_table(&b, "vht_supported_mcs_set");
+			blobmsg_add_u16(&b, "rx_map", vht_capabilities->vht_supported_mcs_set.rx_map);
+			blobmsg_add_u16(&b, "rx_highest", vht_capabilities->vht_supported_mcs_set.rx_highest);
+			blobmsg_add_u16(&b, "tx_map", vht_capabilities->vht_supported_mcs_set.tx_map);
+			blobmsg_add_u16(&b, "tx_highest", vht_capabilities->vht_supported_mcs_set.tx_highest);
+			blobmsg_close_table(&b, vht_cap_mcs_set);
+			blobmsg_close_table(&b, vht_cap);
+		}
+	}
+
+	if (!hapd->ubus.notify_response) {
+		ubus_notify(ctx, &hapd->ubus.obj, type, b.head, -1);
+		return WLAN_STATUS_SUCCESS;
+	}
+
+	if (ubus_notify_async(ctx, &hapd->ubus.obj, type, b.head, &ureq.nreq))
+		return WLAN_STATUS_SUCCESS;
+
+	ureq.nreq.status_cb = ubus_event_cb;
+	ubus_complete_request(ctx, &ureq.nreq.req, 100);
+
+	if (ureq.resp)
+		return ureq.resp;
+
+	return WLAN_STATUS_SUCCESS;
+}
+
+void hostapd_ubus_notify(struct hostapd_data *hapd, const char *type, const u8 *addr)
+{
+	if (!hapd->ubus.obj.has_subscribers)
+		return;
+
+	if (!addr)
+		return;
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_macaddr(&b, "address", addr);
+	blobmsg_add_string(&b, "ifname", hapd->conf->iface);
+
+	ubus_notify(ctx, &hapd->ubus.obj, type, b.head, -1);
+}
+
+void hostapd_ubus_notify_authorized(struct hostapd_data *hapd, struct sta_info *sta,
+				    const char *auth_alg)
+{
+	if (!hapd->ubus.obj.has_subscribers)
+		return;
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_macaddr(&b, "address", sta->addr);
+	if (sta->vlan_id)
+		blobmsg_add_u32(&b, "vlan", sta->vlan_id);
+	blobmsg_add_string(&b, "ifname", hapd->conf->iface);
+	if (auth_alg)
+		blobmsg_add_string(&b, "auth-alg", auth_alg);
+
+	ubus_notify(ctx, &hapd->ubus.obj, "sta-authorized", b.head, -1);
+}
+
+void hostapd_ubus_notify_beacon_report(
+	struct hostapd_data *hapd, const u8 *addr, u8 token, u8 rep_mode,
+	struct rrm_measurement_beacon_report *rep, size_t len)
+{
+	if (!hapd->ubus.obj.has_subscribers)
+		return;
+
+	if (!addr || !rep)
+		return;
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_macaddr(&b, "address", addr);
+	blobmsg_add_u16(&b, "op-class", rep->op_class);
+	blobmsg_add_u16(&b, "channel", rep->channel);
+	blobmsg_add_u64(&b, "start-time", rep->start_time);
+	blobmsg_add_u16(&b, "duration", rep->duration);
+	blobmsg_add_u16(&b, "report-info", rep->report_info);
+	blobmsg_add_u16(&b, "rcpi", rep->rcpi);
+	blobmsg_add_u16(&b, "rsni", rep->rsni);
+	blobmsg_add_macaddr(&b, "bssid", rep->bssid);
+	blobmsg_add_u16(&b, "antenna-id", rep->antenna_id);
+	blobmsg_add_u16(&b, "parent-tsf", rep->parent_tsf);
+	blobmsg_add_u16(&b, "rep-mode", rep_mode);
+
+	ubus_notify(ctx, &hapd->ubus.obj, "beacon-report", b.head, -1);
+}
+
+void hostapd_ubus_notify_radar_detected(struct hostapd_iface *iface, int frequency,
+					int chan_width, int cf1, int cf2)
+{
+	struct hostapd_data *hapd;
+	int i;
+
+	if (!ctx)
+		return;
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_u16(&b, "frequency", frequency);
+	blobmsg_add_u16(&b, "width", chan_width);
+	blobmsg_add_u16(&b, "center1", cf1);
+	blobmsg_add_u16(&b, "center2", cf2);
+
+	for (i = 0; i < iface->num_bss; i++) {
+		hapd = iface->bss[i];
+		ubus_notify(ctx, &hapd->ubus.obj, "radar-detected", b.head, -1);
+	}
+}
+
+#ifdef CONFIG_WNM_AP
+static void hostapd_ubus_notify_bss_transition_add_candidate_list(
+	const u8 *candidate_list, u16 candidate_list_len)
+{
+	char *cl_str;
+	int i;
+
+	if (candidate_list_len == 0)
+		return;
+
+	cl_str = blobmsg_alloc_string_buffer(&b, "candidate-list", candidate_list_len * 2 + 1);
+	for (i = 0; i < candidate_list_len; i++)
+		snprintf(&cl_str[i*2], 3, "%02X", candidate_list[i]);
+	blobmsg_add_string_buffer(&b);
+
+}
+#endif
+
+void hostapd_ubus_notify_bss_transition_response(
+	struct hostapd_data *hapd, const u8 *addr, u8 dialog_token, u8 status_code,
+	u8 bss_termination_delay, const u8 *target_bssid,
+	const u8 *candidate_list, u16 candidate_list_len)
+{
+#ifdef CONFIG_WNM_AP
+	u16 i;
+
+	if (!hapd->ubus.obj.has_subscribers)
+		return;
+
+	if (!addr)
+		return;
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_macaddr(&b, "address", addr);
+	blobmsg_add_u8(&b, "dialog-token", dialog_token);
+	blobmsg_add_u8(&b, "status-code", status_code);
+	blobmsg_add_u8(&b, "bss-termination-delay", bss_termination_delay);
+	if (target_bssid)
+		blobmsg_add_macaddr(&b, "target-bssid", target_bssid);
+	
+	hostapd_ubus_notify_bss_transition_add_candidate_list(candidate_list, candidate_list_len);
+
+	ubus_notify(ctx, &hapd->ubus.obj, "bss-transition-response", b.head, -1);
+#endif
+}
+
+int hostapd_ubus_notify_bss_transition_query(
+	struct hostapd_data *hapd, const u8 *addr, u8 dialog_token, u8 reason,
+	const u8 *candidate_list, u16 candidate_list_len)
+{
+#ifdef CONFIG_WNM_AP
+	struct ubus_event_req ureq = {};
+	char *cl_str;
+	u16 i;
+
+	if (!hapd->ubus.obj.has_subscribers)
+		return 0;
+
+	if (!addr)
+		return 0;
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_macaddr(&b, "address", addr);
+	blobmsg_add_u8(&b, "dialog-token", dialog_token);
+	blobmsg_add_u8(&b, "reason", reason);
+	hostapd_ubus_notify_bss_transition_add_candidate_list(candidate_list, candidate_list_len);
+
+	if (!hapd->ubus.notify_response) {
+		ubus_notify(ctx, &hapd->ubus.obj, "bss-transition-query", b.head, -1);
+		return 0;
+	}
+
+	if (ubus_notify_async(ctx, &hapd->ubus.obj, "bss-transition-query", b.head, &ureq.nreq))
+		return 0;
+
+	ureq.nreq.status_cb = ubus_event_cb;
+	ubus_complete_request(ctx, &ureq.nreq.req, 100);
+
+	return ureq.resp;
+#endif
+}
+
+#ifdef CONFIG_APUP
+void hostapd_ubus_notify_apup_newpeer(
+	struct hostapd_data *hapd, const u8 *addr, const char *ifname)
+{
+	if (!hapd->ubus.obj.has_subscribers)
+		return;
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_macaddr(&b, "address", addr);
+	blobmsg_add_string(&b, "ifname", ifname);
+
+	ubus_notify(ctx, &hapd->ubus.obj, "apup-newpeer", b.head, -1);
+}
+#endif // def CONFIG_APUP
+
+void hostapd_ubus_notify_csa(struct hostapd_data *hapd, int freq)
+{
+	if (!hapd->ubus.obj.has_subscribers)
+		return;
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_string(&b, "ifname", hapd->conf->iface);
+	blobmsg_add_u32(&b, "freq", freq);
+	blobmsg_printf(&b, "bssid", MACSTR, MAC2STR(hapd->conf->bssid));
+
+	ubus_notify(ctx, &hapd->ubus.obj, "channel-switch", b.head, -1);
+}
diff --git a/src/ap/ubus.h b/src/ap/ubus.h
new file mode 100644
index 0000000..055a18c
--- /dev/null
+++ b/src/ap/ubus.h
@@ -0,0 +1,166 @@
+/*
+ * hostapd / ubus support
+ * Copyright (c) 2013, Felix Fietkau <nbd@nbd.name>
+ *
+ * This software may be distributed under the terms of the BSD license.
+ * See README for more details.
+ */
+#ifndef __HOSTAPD_UBUS_H
+#define __HOSTAPD_UBUS_H
+
+enum hostapd_ubus_event_type {
+	HOSTAPD_UBUS_PROBE_REQ,
+	HOSTAPD_UBUS_AUTH_REQ,
+	HOSTAPD_UBUS_ASSOC_REQ,
+	HOSTAPD_UBUS_TYPE_MAX
+};
+
+struct hostapd_ubus_request {
+	enum hostapd_ubus_event_type type;
+	const struct ieee80211_mgmt *mgmt_frame;
+	const struct ieee802_11_elems *elems;
+	int ssi_signal; /* dBm */
+	const u8 *addr;
+};
+
+struct hostapd_iface;
+struct hostapd_data;
+struct hapd_interfaces;
+struct rrm_measurement_beacon_report;
+struct sta_info;
+
+#ifdef UBUS_SUPPORT
+
+#include <libubox/avl.h>
+#include <libubus.h>
+
+struct hostapd_ubus_bss {
+	struct ubus_object obj;
+	struct avl_tree banned;
+	int notify_response;
+};
+
+void hostapd_ubus_add_iface(struct hostapd_iface *iface);
+void hostapd_ubus_free_iface(struct hostapd_iface *iface);
+void hostapd_ubus_add_bss(struct hostapd_data *hapd);
+void hostapd_ubus_free_bss(struct hostapd_data *hapd);
+void hostapd_ubus_add_vlan(struct hostapd_data *hapd, struct hostapd_vlan *vlan);
+void hostapd_ubus_remove_vlan(struct hostapd_data *hapd, struct hostapd_vlan *vlan);
+
+int hostapd_ubus_handle_event(struct hostapd_data *hapd, struct hostapd_ubus_request *req);
+void hostapd_ubus_handle_link_measurement(struct hostapd_data *hapd, const u8 *data, size_t len);
+void hostapd_ubus_notify(struct hostapd_data *hapd, const char *type, const u8 *mac);
+void hostapd_ubus_notify_beacon_report(struct hostapd_data *hapd,
+				       const u8 *addr, u8 token, u8 rep_mode,
+				       struct rrm_measurement_beacon_report *rep,
+				       size_t len);
+void hostapd_ubus_notify_radar_detected(struct hostapd_iface *iface, int frequency,
+					int chan_width, int cf1, int cf2);
+
+void hostapd_ubus_notify_bss_transition_response(
+	struct hostapd_data *hapd, const u8 *addr, u8 dialog_token, u8 status_code,
+	u8 bss_termination_delay, const u8 *target_bssid,
+	const u8 *candidate_list, u16 candidate_list_len);
+void hostapd_ubus_add(struct hapd_interfaces *interfaces);
+void hostapd_ubus_free(struct hapd_interfaces *interfaces);
+int hostapd_ubus_notify_bss_transition_query(
+	struct hostapd_data *hapd, const u8 *addr, u8 dialog_token, u8 reason,
+	const u8 *candidate_list, u16 candidate_list_len);
+void hostapd_ubus_notify_authorized(struct hostapd_data *hapd, struct sta_info *sta,
+				    const char *auth_alg);
+void hostapd_ubus_notify_csa(struct hostapd_data *hapd, int freq);
+
+#ifdef CONFIG_APUP
+void hostapd_ubus_notify_apup_newpeer(
+	struct hostapd_data *hapd, const u8 *addr, const char *ifname);
+#endif // def CONFIG_APUP
+
+#else
+
+struct hostapd_ubus_bss {};
+
+static inline void hostapd_ubus_add_iface(struct hostapd_iface *iface)
+{
+}
+
+static inline void hostapd_ubus_free_iface(struct hostapd_iface *iface)
+{
+}
+
+static inline void hostapd_ubus_add_bss(struct hostapd_data *hapd)
+{
+}
+
+static inline void hostapd_ubus_free_bss(struct hostapd_data *hapd)
+{
+}
+
+static inline void hostapd_ubus_add_vlan(struct hostapd_data *hapd, struct hostapd_vlan *vlan)
+{
+}
+
+static inline void hostapd_ubus_remove_vlan(struct hostapd_data *hapd, struct hostapd_vlan *vlan)
+{
+}
+
+static inline int hostapd_ubus_handle_event(struct hostapd_data *hapd, struct hostapd_ubus_request *req)
+{
+	return 0;
+}
+
+static inline void hostapd_ubus_handle_link_measurement(struct hostapd_data *hapd, const u8 *data, size_t len)
+{
+}
+
+static inline void hostapd_ubus_notify(struct hostapd_data *hapd, const char *type, const u8 *mac)
+{
+}
+
+static inline void hostapd_ubus_notify_beacon_report(struct hostapd_data *hapd,
+						     const u8 *addr, u8 token,
+						     u8 rep_mode,
+						     struct rrm_measurement_beacon_report *rep,
+						     size_t len)
+{
+}
+static inline void hostapd_ubus_notify_radar_detected(struct hostapd_iface *iface, int frequency,
+						      int chan_width, int cf1, int cf2)
+{
+}
+
+static inline void hostapd_ubus_notify_bss_transition_response(
+	struct hostapd_data *hapd, const u8 *addr, u8 dialog_token, u8 status_code,
+	u8 bss_termination_delay, const u8 *target_bssid,
+	const u8 *candidate_list, u16 candidate_list_len)
+{
+}
+
+static inline void hostapd_ubus_add(struct hapd_interfaces *interfaces)
+{
+}
+
+static inline void hostapd_ubus_free(struct hapd_interfaces *interfaces)
+{
+}
+
+static inline int hostapd_ubus_notify_bss_transition_query(
+	struct hostapd_data *hapd, const u8 *addr, u8 dialog_token, u8 reason,
+	const u8 *candidate_list, u16 candidate_list_len)
+{
+	return 0;
+}
+
+static inline void
+hostapd_ubus_notify_authorized(struct hostapd_data *hapd, struct sta_info *sta,
+			       const char *auth_alg)
+{
+}
+
+static inline void
+hostapd_ubus_notify_csa(struct hostapd_data *hapd, int freq)
+{
+}
+
+#endif
+
+#endif
diff --git a/src/ap/ucode.c b/src/ap/ucode.c
new file mode 100644
index 0000000..b08d1a7
--- /dev/null
+++ b/src/ap/ucode.c
@@ -0,0 +1,985 @@
+#include <sys/un.h>
+
+#include "utils/includes.h"
+#include "utils/common.h"
+#include "utils/ucode.h"
+#include "sta_info.h"
+#include "beacon.h"
+#include "hw_features.h"
+#include "ap_drv_ops.h"
+#include "dfs.h"
+#include "acs.h"
+#include "ieee802_11.h"
+#include <libubox/uloop.h>
+
+static uc_resource_type_t *global_type, *bss_type, *iface_type;
+static struct hapd_interfaces *interfaces;
+static uc_value_t *global, *bss_registry, *iface_registry;
+static uc_vm_t *vm;
+
+static uc_value_t *
+hostapd_ucode_bss_get_uval(struct hostapd_data *hapd)
+{
+	uc_value_t *val;
+
+	if (hapd->ucode.idx)
+		return wpa_ucode_registry_get(bss_registry, hapd->ucode.idx);
+
+	val = uc_resource_new(bss_type, hapd);
+	hapd->ucode.idx = wpa_ucode_registry_add(bss_registry, val);
+
+	return val;
+}
+
+static uc_value_t *
+hostapd_ucode_iface_get_uval(struct hostapd_iface *hapd)
+{
+	uc_value_t *val;
+
+	if (hapd->ucode.idx)
+		return wpa_ucode_registry_get(iface_registry, hapd->ucode.idx);
+
+	val = uc_resource_new(iface_type, hapd);
+	hapd->ucode.idx = wpa_ucode_registry_add(iface_registry, val);
+
+	return val;
+}
+
+static void
+hostapd_ucode_update_bss_list(struct hostapd_iface *iface, uc_value_t *if_bss, uc_value_t *bss)
+{
+	uc_value_t *list;
+	int i;
+
+	list = ucv_array_new(vm);
+	for (i = 0; iface->bss && i < iface->num_bss; i++) {
+		struct hostapd_data *hapd = iface->bss[i];
+		uc_value_t *val = hostapd_ucode_bss_get_uval(hapd);
+
+		ucv_array_set(list, i, ucv_get(ucv_string_new(hapd->conf->iface)));
+		ucv_object_add(bss, hapd->conf->iface, ucv_get(val));
+	}
+	ucv_object_add(if_bss, iface->phy, ucv_get(list));
+}
+
+static void
+hostapd_ucode_update_interfaces(void)
+{
+	uc_value_t *ifs = ucv_object_new(vm);
+	uc_value_t *if_bss = ucv_array_new(vm);
+	uc_value_t *bss = ucv_object_new(vm);
+	int i;
+
+	for (i = 0; i < interfaces->count; i++) {
+		struct hostapd_iface *iface = interfaces->iface[i];
+
+		ucv_object_add(ifs, iface->phy, ucv_get(hostapd_ucode_iface_get_uval(iface)));
+		hostapd_ucode_update_bss_list(iface, if_bss, bss);
+	}
+
+	ucv_object_add(ucv_prototype_get(global), "interfaces", ucv_get(ifs));
+	ucv_object_add(ucv_prototype_get(global), "interface_bss", ucv_get(if_bss));
+	ucv_object_add(ucv_prototype_get(global), "bss", ucv_get(bss));
+	ucv_gc(vm);
+}
+
+static uc_value_t *
+uc_hostapd_add_iface(uc_vm_t *vm, size_t nargs)
+{
+	uc_value_t *iface = uc_fn_arg(0);
+	char *data;
+	int ret;
+
+	if (ucv_type(iface) != UC_STRING)
+		return ucv_int64_new(-1);
+
+	data = strdup(ucv_string_get(iface));
+	ret = hostapd_add_iface(interfaces, data);
+	free(data);
+
+	hostapd_ucode_update_interfaces();
+
+	return ucv_int64_new(ret);
+}
+
+static uc_value_t *
+uc_hostapd_remove_iface(uc_vm_t *vm, size_t nargs)
+{
+	uc_value_t *iface = uc_fn_arg(0);
+
+	if (ucv_type(iface) != UC_STRING)
+		return NULL;
+
+	hostapd_remove_iface(interfaces, ucv_string_get(iface));
+	hostapd_ucode_update_interfaces();
+
+	return NULL;
+}
+
+static struct hostapd_vlan *
+bss_conf_find_vlan(struct hostapd_bss_config *bss, int id)
+{
+	struct hostapd_vlan *vlan;
+
+	for (vlan = bss->vlan; vlan; vlan = vlan->next)
+		if (vlan->vlan_id == id)
+			return vlan;
+
+	return NULL;
+}
+
+static int
+bss_conf_rename_vlan(struct hostapd_data *hapd, struct hostapd_vlan *vlan,
+		     const char *ifname)
+{
+	if (!strcmp(ifname, vlan->ifname))
+		return 0;
+
+	hostapd_drv_if_rename(hapd, WPA_IF_AP_VLAN, vlan->ifname, ifname);
+	os_strlcpy(vlan->ifname, ifname, sizeof(vlan->ifname));
+
+	return 0;
+}
+
+static int
+bss_reload_vlans(struct hostapd_data *hapd, struct hostapd_bss_config *bss)
+{
+	struct hostapd_bss_config *old_bss = hapd->conf;
+	struct hostapd_vlan *vlan, *vlan_new, *wildcard;
+	char ifname[IFNAMSIZ + 1], vlan_ifname[IFNAMSIZ + 1], *pos;
+	int ret;
+
+	vlan = bss_conf_find_vlan(old_bss, VLAN_ID_WILDCARD);
+	wildcard = bss_conf_find_vlan(bss, VLAN_ID_WILDCARD);
+	if (!!vlan != !!wildcard)
+		return -1;
+
+	if (vlan && wildcard && strcmp(vlan->ifname, wildcard->ifname) != 0)
+		strcpy(vlan->ifname, wildcard->ifname);
+	else
+		wildcard = NULL;
+
+	for (vlan = bss->vlan; vlan; vlan = vlan->next) {
+		if (vlan->vlan_id == VLAN_ID_WILDCARD ||
+		    vlan->dynamic_vlan > 0)
+			continue;
+
+		if (!bss_conf_find_vlan(old_bss, vlan->vlan_id))
+			return -1;
+	}
+
+	for (vlan = old_bss->vlan; vlan; vlan = vlan->next) {
+		if (vlan->vlan_id == VLAN_ID_WILDCARD)
+			continue;
+
+		if (vlan->dynamic_vlan == 0) {
+			vlan_new = bss_conf_find_vlan(bss, vlan->vlan_id);
+			if (!vlan_new)
+				return -1;
+
+			if (bss_conf_rename_vlan(hapd, vlan, vlan_new->ifname))
+				return -1;
+
+			continue;
+		}
+
+		if (!wildcard)
+			continue;
+
+		os_strlcpy(ifname, wildcard->ifname, sizeof(ifname));
+		pos = os_strchr(ifname, '#');
+		if (!pos)
+			return -1;
+
+		*pos++ = '\0';
+		ret = os_snprintf(vlan_ifname, sizeof(vlan_ifname), "%s%d%s",
+				  ifname, vlan->vlan_id, pos);
+	        if (os_snprintf_error(sizeof(vlan_ifname), ret))
+			return -1;
+
+		if (bss_conf_rename_vlan(hapd, vlan, vlan_ifname))
+			return -1;
+	}
+
+	return 0;
+}
+
+static uc_value_t *
+uc_hostapd_bss_set_config(uc_vm_t *vm, size_t nargs)
+{
+	struct hostapd_data *hapd = uc_fn_thisval("hostapd.bss");
+	struct hostapd_bss_config *old_bss;
+	struct hostapd_iface *iface;
+	struct hostapd_config *conf;
+	uc_value_t *file = uc_fn_arg(0);
+	uc_value_t *index = uc_fn_arg(1);
+	uc_value_t *files_only = uc_fn_arg(2);
+	unsigned int i, idx = 0;
+	int ret = -1;
+
+	if (!hapd || ucv_type(file) != UC_STRING)
+		goto out;
+
+	if (ucv_type(index) == UC_INTEGER)
+		idx = ucv_int64_get(index);
+
+	iface = hapd->iface;
+	conf = interfaces->config_read_cb(ucv_string_get(file));
+	if (!conf)
+		goto out;
+
+	if (idx > conf->num_bss || !conf->bss[idx])
+		goto free;
+
+	if (ucv_boolean_get(files_only)) {
+		struct hostapd_bss_config *bss = conf->bss[idx];
+		struct hostapd_bss_config *old_bss = hapd->conf;
+
+#define swap_field(name)				\
+	do {								\
+		void *ptr = old_bss->name;		\
+		old_bss->name = bss->name;		\
+		bss->name = ptr;				\
+	} while (0)
+
+		swap_field(ssid.wpa_psk_file);
+		ret = bss_reload_vlans(hapd, bss);
+		goto done;
+	}
+
+	hostapd_bss_deinit_no_free(hapd);
+	hostapd_drv_stop_ap(hapd);
+	hostapd_free_hapd_data(hapd);
+
+	old_bss = hapd->conf;
+	for (i = 0; i < iface->conf->num_bss; i++)
+		if (iface->conf->bss[i] == hapd->conf)
+			iface->conf->bss[i] = conf->bss[idx];
+	hapd->conf = conf->bss[idx];
+	conf->bss[idx] = old_bss;
+
+	hostapd_setup_bss(hapd, hapd == iface->bss[0], true);
+	hostapd_ucode_update_interfaces();
+	hostapd_owe_update_trans(iface);
+
+done:
+	ret = 0;
+free:
+	hostapd_config_free(conf);
+out:
+	return ucv_int64_new(ret);
+}
+
+static void
+hostapd_remove_iface_bss_conf(struct hostapd_config *iconf,
+			      struct hostapd_bss_config *conf)
+{
+	int i;
+
+	for (i = 0; i < iconf->num_bss; i++)
+		if (iconf->bss[i] == conf)
+			break;
+
+	if (i == iconf->num_bss)
+		return;
+
+	for (i++; i < iconf->num_bss; i++)
+		iconf->bss[i - 1] = iconf->bss[i];
+	iconf->num_bss--;
+}
+
+
+static uc_value_t *
+uc_hostapd_bss_delete(uc_vm_t *vm, size_t nargs)
+{
+	struct hostapd_data *hapd = uc_fn_thisval("hostapd.bss");
+	struct hostapd_iface *iface;
+	int i, idx;
+
+	if (!hapd)
+		return NULL;
+
+	iface = hapd->iface;
+	if (iface->num_bss == 1) {
+		wpa_printf(MSG_ERROR, "trying to delete last bss of an iface: %s\n", hapd->conf->iface);
+		return NULL;
+	}
+
+	for (idx = 0; idx < iface->num_bss; idx++)
+		if (iface->bss[idx] == hapd)
+			break;
+
+	if (idx == iface->num_bss)
+		return NULL;
+
+	for (i = idx + 1; i < iface->num_bss; i++)
+		iface->bss[i - 1] = iface->bss[i];
+
+	iface->num_bss--;
+
+	iface->bss[0]->interface_added = 0;
+	hostapd_drv_set_first_bss(iface->bss[0]);
+	hapd->interface_added = 1;
+
+	hostapd_drv_stop_ap(hapd);
+	hostapd_bss_deinit(hapd);
+	hostapd_remove_iface_bss_conf(iface->conf, hapd->conf);
+	hostapd_config_free_bss(hapd->conf);
+	os_free(hapd);
+
+	hostapd_ucode_update_interfaces();
+	ucv_gc(vm);
+
+	return NULL;
+}
+
+static uc_value_t *
+uc_hostapd_iface_add_bss(uc_vm_t *vm, size_t nargs)
+{
+	struct hostapd_iface *iface = uc_fn_thisval("hostapd.iface");
+	struct hostapd_bss_config *bss;
+	struct hostapd_config *conf;
+	struct hostapd_data *hapd;
+	uc_value_t *file = uc_fn_arg(0);
+	uc_value_t *index = uc_fn_arg(1);
+	unsigned int idx = 0;
+	uc_value_t *ret = NULL;
+
+	if (!iface || ucv_type(file) != UC_STRING)
+		goto out;
+
+	if (ucv_type(index) == UC_INTEGER)
+		idx = ucv_int64_get(index);
+
+	conf = interfaces->config_read_cb(ucv_string_get(file));
+	if (!conf || idx > conf->num_bss || !conf->bss[idx])
+		goto out;
+
+	bss = conf->bss[idx];
+	hapd = hostapd_alloc_bss_data(iface, iface->conf, bss);
+	if (!hapd)
+		goto out;
+
+	hapd->driver = iface->bss[0]->driver;
+	hapd->drv_priv = iface->bss[0]->drv_priv;
+	if (interfaces->ctrl_iface_init &&
+	    interfaces->ctrl_iface_init(hapd) < 0)
+		goto free_hapd;
+
+	if (iface->state == HAPD_IFACE_ENABLED &&
+	    hostapd_setup_bss(hapd, -1, true))
+		goto deinit_ctrl;
+
+	iface->bss = os_realloc_array(iface->bss, iface->num_bss + 1,
+				      sizeof(*iface->bss));
+	iface->bss[iface->num_bss++] = hapd;
+
+	iface->conf->bss = os_realloc_array(iface->conf->bss,
+					    iface->conf->num_bss + 1,
+					    sizeof(*iface->conf->bss));
+	iface->conf->bss[iface->conf->num_bss] = bss;
+	conf->bss[idx] = NULL;
+	ret = hostapd_ucode_bss_get_uval(hapd);
+	hostapd_ucode_update_interfaces();
+	hostapd_owe_update_trans(iface);
+	goto out;
+
+deinit_ctrl:
+	if (interfaces->ctrl_iface_deinit)
+		interfaces->ctrl_iface_deinit(hapd);
+free_hapd:
+	hostapd_free_hapd_data(hapd);
+	os_free(hapd);
+out:
+	hostapd_config_free(conf);
+	return ret;
+}
+
+static uc_value_t *
+uc_hostapd_iface_set_bss_order(uc_vm_t *vm, size_t nargs)
+{
+	struct hostapd_iface *iface = uc_fn_thisval("hostapd.iface");
+	uc_value_t *bss_list = uc_fn_arg(0);
+	struct hostapd_data **new_bss;
+	struct hostapd_bss_config **new_conf;
+
+	if (!iface)
+		return NULL;
+
+	if (ucv_type(bss_list) != UC_ARRAY ||
+	    ucv_array_length(bss_list) != iface->num_bss)
+		return NULL;
+
+	new_bss = calloc(iface->num_bss, sizeof(*new_bss));
+	new_conf = calloc(iface->num_bss, sizeof(*new_conf));
+	for (size_t i = 0; i < iface->num_bss; i++) {
+		struct hostapd_data *bss;
+
+		bss = ucv_resource_data(ucv_array_get(bss_list, i), "hostapd.bss");
+		if (bss->iface != iface)
+			goto free;
+
+		for (size_t k = 0; k < i; k++)
+			if (new_bss[k] == bss)
+				goto free;
+
+		new_bss[i] = bss;
+		new_conf[i] = bss->conf;
+	}
+
+	new_bss[0]->interface_added = 0;
+	for (size_t i = 1; i < iface->num_bss; i++)
+		new_bss[i]->interface_added = 1;
+
+	free(iface->bss);
+	iface->bss = new_bss;
+
+	free(iface->conf->bss);
+	iface->conf->bss = new_conf;
+	iface->conf->num_bss = iface->num_bss;
+	hostapd_drv_set_first_bss(iface->bss[0]);
+
+	return ucv_boolean_new(true);
+
+free:
+	free(new_bss);
+	free(new_conf);
+	return NULL;
+}
+
+static uc_value_t *
+uc_hostapd_bss_ctrl(uc_vm_t *vm, size_t nargs)
+{
+	struct hostapd_data *hapd = uc_fn_thisval("hostapd.bss");
+	uc_value_t *arg = uc_fn_arg(0);
+	struct sockaddr_storage from = {};
+	static char reply[4096];
+	int reply_len;
+
+	if (!hapd || !interfaces->ctrl_iface_recv ||
+	    ucv_type(arg) != UC_STRING)
+		return NULL;
+
+	reply_len = interfaces->ctrl_iface_recv(hapd, ucv_string_get(arg),
+						reply, sizeof(reply),
+						&from, sizeof(from));
+	if (reply_len < 0)
+		return NULL;
+
+	if (reply_len && reply[reply_len - 1] == '\n')
+		reply_len--;
+
+	return ucv_string_new_length(reply, reply_len);
+}
+
+static void
+uc_hostapd_disable_iface(struct hostapd_iface *iface)
+{
+	switch (iface->state) {
+	case HAPD_IFACE_DISABLED:
+		break;
+#ifdef CONFIG_ACS
+	case HAPD_IFACE_ACS:
+		acs_cleanup(iface);
+		iface->scan_cb = NULL;
+		/* fallthrough */
+#endif
+	default:
+		hostapd_disable_iface(iface);
+		break;
+	}
+}
+
+static uc_value_t *
+uc_hostapd_iface_stop(uc_vm_t *vm, size_t nargs)
+{
+	struct hostapd_iface *iface = uc_fn_thisval("hostapd.iface");
+	struct hostapd_data *first_hapd;
+	struct hostapd_bss_config *conf;
+	int i, j;
+
+	if (!iface)
+		return NULL;
+
+	wpa_printf(MSG_INFO, "ucode: mtk: stop iface for %s in state %s\n",
+		   iface->phy, hostapd_state_text(iface->state));
+
+	if (iface->state != HAPD_IFACE_ENABLED)
+		uc_hostapd_disable_iface(iface);
+
+	for (i = 0; i < iface->num_bss; i++) {
+		struct hostapd_data *hapd = iface->bss[i];
+
+		hostapd_drv_stop_ap(hapd);
+		hapd->beacon_set_done = 0;
+	}
+
+#ifdef CONFIG_IEEE80211BE
+	first_hapd = iface->bss[0];
+	conf = first_hapd->conf;
+	for (i = 0; conf->mld_ap && i < iface->interfaces->count; i++) {
+		struct hostapd_iface *h = iface->interfaces->iface[i];
+		struct hostapd_data *h_hapd = h->bss[0];
+		struct hostapd_bss_config *hconf = h_hapd->conf;
+
+		if (h == iface) {
+			wpa_printf(MSG_DEBUG, "MLD: Skip own interface");
+			continue;
+		}
+
+		if (!hconf->mld_ap) {
+			wpa_printf(MSG_DEBUG,
+				   "MLD: Skip non MLD");
+			continue;
+		}
+
+		if (hostapd_is_ml_partner(first_hapd, h_hapd)) {
+			for (j = 0; j < h->num_bss; j++) {
+				hostapd_drv_stop_ap(h->bss[j]);
+				h->bss[j]->beacon_set_done = 0;
+			}
+		}
+	}
+#endif /* CONFIG_IEEE80211BE */
+
+	return NULL;
+}
+
+static uc_value_t *
+uc_hostapd_iface_start(uc_vm_t *vm, size_t nargs)
+{
+	struct hostapd_iface *iface = uc_fn_thisval("hostapd.iface");
+	struct hostapd_data *tmp_hapd;
+	uc_value_t *info = uc_fn_arg(0);
+	struct hostapd_config *conf;
+	bool changed = false;
+	uint64_t intval;
+	int i, radio_idx;
+
+	wpa_printf(MSG_INFO, "ucode: mtk: start iface for %s in state %s\n",
+		   iface->phy, hostapd_state_text(iface->state));
+
+	if (!iface)
+		return NULL;
+
+	if (!info) {
+		iface->freq = 0;
+		goto out;
+	}
+
+	if (ucv_type(info) != UC_OBJECT)
+		return NULL;
+
+	intval = ucv_int64_get(ucv_object_get(info, "radio_idx", NULL));
+	radio_idx = intval;
+	if (errno)
+		radio_idx = iface->current_hw_info ? iface->current_hw_info->hw_idx : 0;
+
+#ifdef CONFIG_IEEE80211BE
+	if (hostapd_is_mld_ap(iface->bss[0])) {
+		for_each_mld_link(tmp_hapd, iface->bss[0]) {
+			if (tmp_hapd->iface->current_hw_info &&
+			    radio_idx == tmp_hapd->iface->current_hw_info->hw_idx) {
+				wpa_printf(MSG_INFO,
+					   "ucode: mtk: MLD: switch to iface with radio_idx %d\n",
+					   radio_idx);
+				iface = tmp_hapd->iface;
+				break;
+			}
+		}
+	}
+
+	if (iface->current_hw_info && radio_idx != iface->current_hw_info->hw_idx)
+		return NULL;
+#endif /* CONFIG_IEEE80211BE */
+
+#define UPDATE_VAL(field, name)							\
+	do {									\
+		intval = ucv_int64_get(ucv_object_get(info, name, NULL));	\
+		if (!errno && intval != conf->field) {				\
+			conf->field = intval;					\
+			changed = true;						\
+		}								\
+	} while(0)
+
+	conf = iface->conf;
+	UPDATE_VAL(op_class, "op_class");
+	UPDATE_VAL(hw_mode, "hw_mode");
+	UPDATE_VAL(channel, "channel");
+
+	intval = ucv_int64_get(ucv_object_get(info, "sec_channel", NULL));
+	if (!errno) {
+		conf->secondary_channel = intval;
+		changed = true;
+	}
+
+	if (!changed &&
+	    (iface->bss[0]->beacon_set_done ||
+	     iface->state == HAPD_IFACE_DFS))
+		return ucv_boolean_new(true);
+
+	intval = ucv_int64_get(ucv_object_get(info, "center_seg0_idx", NULL));
+	if (!errno)
+		hostapd_set_oper_centr_freq_seg0_idx(conf, intval);
+
+	intval = ucv_int64_get(ucv_object_get(info, "center_seg1_idx", NULL));
+	if (!errno)
+		hostapd_set_oper_centr_freq_seg1_idx(conf, intval);
+
+	intval = ucv_int64_get(ucv_object_get(info, "oper_chwidth", NULL));
+	if (!errno)
+		hostapd_set_oper_chwidth(conf, intval);
+
+	intval = ucv_int64_get(ucv_object_get(info, "punct_bitmap", NULL));
+	if (!errno)
+		conf->punct_bitmap = intval;
+
+	conf->pp_mode = PP_USR_MODE;
+	if (iface->state == HAPD_IFACE_ENABLED &&
+	    hostapd_drv_pp_mode_set(iface->bss[0]) != 0)
+		return NULL;
+
+	intval = ucv_int64_get(ucv_object_get(info, "frequency", NULL));
+	if (!errno)
+		iface->freq = intval;
+	else
+		iface->freq = 0;
+	conf->acs = 0;
+
+out:
+	switch (iface->state) {
+	case HAPD_IFACE_ENABLED:
+		if (!hostapd_is_dfs_required(iface) ||
+			hostapd_is_dfs_chan_available(iface))
+			break;
+		wpa_printf(MSG_INFO, "DFS CAC required on new channel, restart interface");
+		/* fallthrough */
+	default:
+		uc_hostapd_disable_iface(iface);
+		break;
+	}
+
+	if (conf->channel && !iface->freq)
+		iface->freq = hostapd_hw_get_freq(iface->bss[0], conf->channel);
+
+	if (iface->state != HAPD_IFACE_ENABLED) {
+		hostapd_enable_iface(iface);
+		return ucv_boolean_new(true);
+	}
+
+	wpa_printf(MSG_INFO, "ucode: mtk: updated channel information:\n");
+	wpa_printf(MSG_INFO, "    * channel: %d\n", conf->channel);
+	wpa_printf(MSG_INFO, "    * op_class: %d\n", conf->op_class);
+	wpa_printf(MSG_INFO, "    * secondary channel: %d\n", conf->secondary_channel);
+	wpa_printf(MSG_INFO, "    * seg0: %d\n",
+		   hostapd_get_oper_centr_freq_seg0_idx(conf));
+	wpa_printf(MSG_INFO, "    * seg1: %d\n",
+		   hostapd_get_oper_centr_freq_seg1_idx(conf));
+	wpa_printf(MSG_INFO, "    * oper_chwidth: %d\n",
+		   hostapd_get_oper_chwidth(conf));
+
+	for (i = 0; i < iface->num_bss; i++) {
+		struct hostapd_data *hapd = iface->bss[i];
+		int ret;
+
+		hapd->conf->start_disabled = 0;
+		hostapd_set_freq(hapd, conf->hw_mode, iface->freq,
+				 conf->channel,
+				 conf->enable_edmg,
+				 conf->edmg_channel,
+				 conf->ieee80211n,
+				 conf->ieee80211ac,
+				 conf->ieee80211ax,
+				 conf->ieee80211be,
+				 conf->secondary_channel,
+				 hostapd_get_oper_chwidth(conf),
+				 hostapd_get_oper_centr_freq_seg0_idx(conf),
+				 hostapd_get_oper_centr_freq_seg1_idx(conf));
+
+		ieee802_11_set_beacon(hapd);
+	}
+	hostapd_owe_update_trans(iface);
+
+	return ucv_boolean_new(true);
+}
+
+static uc_value_t *
+uc_hostapd_iface_switch_channel(uc_vm_t *vm, size_t nargs)
+{
+	struct hostapd_iface *iface = uc_fn_thisval("hostapd.iface");
+	uc_value_t *info = uc_fn_arg(0);
+	struct hostapd_config *conf;
+	struct csa_settings csa = {};
+	uint64_t intval;
+	int i, ret = 0, radio_idx;
+
+	wpa_printf(MSG_INFO, "ucode: mtk: channel switch for %s\n", iface->phy);
+	if (!iface || ucv_type(info) != UC_OBJECT)
+		return NULL;
+
+	conf = iface->conf;
+	if ((intval = ucv_int64_get(ucv_object_get(info, "csa_count", NULL))) && !errno)
+		csa.cs_count = intval;
+	if ((intval = ucv_int64_get(ucv_object_get(info, "sec_channel", NULL))) && !errno)
+		csa.freq_params.sec_channel_offset = intval;
+
+	csa.freq_params.ht_enabled = conf->ieee80211n;
+	csa.freq_params.vht_enabled = conf->ieee80211ac;
+	csa.freq_params.he_enabled = conf->ieee80211ax;
+#ifdef CONFIG_IEEE80211BE
+	csa.freq_params.eht_enabled = conf->ieee80211be;
+#endif
+	intval = ucv_int64_get(ucv_object_get(info, "oper_chwidth", NULL));
+	if (errno)
+		intval = hostapd_get_oper_chwidth(conf);
+	if (intval)
+		csa.freq_params.bandwidth = 40 <<
+			(intval == CONF_OPER_CHWIDTH_320MHZ ? 3 : intval);
+	else
+		csa.freq_params.bandwidth = csa.freq_params.sec_channel_offset ? 40 : 20;
+
+	if ((intval = ucv_int64_get(ucv_object_get(info, "frequency", NULL))) && !errno)
+		csa.freq_params.freq = intval;
+	if ((intval = ucv_int64_get(ucv_object_get(info, "center_freq1", NULL))) && !errno)
+		csa.freq_params.center_freq1 = intval;
+	if ((intval = ucv_int64_get(ucv_object_get(info, "center_freq2", NULL))) && !errno)
+		csa.freq_params.center_freq2 = intval;
+	if ((intval = ucv_int64_get(ucv_object_get(info, "punct_bitmap", NULL))) && !errno)
+		csa.freq_params.punct_bitmap = intval;
+
+	intval = ucv_int64_get(ucv_object_get(info, "radio_idx", NULL));
+	radio_idx = intval;
+	if (errno)
+		radio_idx = iface->current_hw_info ? iface->current_hw_info->hw_idx : 0;
+
+	wpa_printf(MSG_INFO, "ucode: mtk: switch channel information:\n");
+	wpa_printf(MSG_INFO, "    * freq is %d\n", csa.freq_params.freq);
+	wpa_printf(MSG_INFO, "    * bandwidth is %d\n", csa.freq_params.bandwidth);
+	wpa_printf(MSG_INFO, "    * sec_chan_offset is %d\n",
+		   csa.freq_params.sec_channel_offset);
+	wpa_printf(MSG_INFO, "    * center_freq1 is %d\n",
+		   csa.freq_params.center_freq1);
+	wpa_printf(MSG_INFO, "    * center_freq2 is %d\n",
+		   csa.freq_params.center_freq2);
+	wpa_printf(MSG_INFO, "    * punct_bitmap is %d\n",
+		   csa.freq_params.punct_bitmap);
+	wpa_printf(MSG_INFO, "    * radio_idx is %d\n", radio_idx);
+
+#ifdef CONFIG_IEEE80211BE
+	for (i = 0; i < iface->interfaces->count; i++) {
+		struct hostapd_iface *tmp_iface = iface->interfaces->iface[i];
+
+		if (tmp_iface->current_hw_info &&
+		    radio_idx == tmp_iface->current_hw_info->hw_idx) {
+			wpa_printf(MSG_INFO,
+				   "ucode: mtk: MLD: switch to iface with radio_idx %d\n",
+				   radio_idx);
+			iface = tmp_iface;
+			break;
+		}
+	}
+
+	if (iface->current_hw_info && radio_idx != iface->current_hw_info->hw_idx)
+		return NULL;
+#endif /* CONFIG_IEEE80211BE */
+
+	for (i = 0; i < iface->num_bss; i++) {
+		ret = hostapd_switch_channel(iface->bss[i], &csa);
+
+		if (iface->bss[i]->conf->mld_ap)
+			hostapd_update_aff_link_beacon(iface->bss[i], csa.cs_count);
+	}
+
+	return ucv_boolean_new(!ret);
+}
+
+static uc_value_t *
+uc_hostapd_iface_is_mld_finished(uc_vm_t *vm, size_t nargs)
+{
+	struct hostapd_iface *iface = uc_fn_thisval("hostapd.iface");
+	bool finished = true;
+	int i;
+
+	for (i = 0; i < iface->num_bss; i++) {
+		if (iface->bss[i]->conf->mld_ap) {
+			struct hostapd_data *p_hapd;
+			u16 valid_links = 0;
+
+			for_each_mld_link(p_hapd, iface->bss[i])
+				valid_links |= BIT(p_hapd->mld_link_id);
+
+			if (iface->bss[i]->conf->mld_allowed_links > 0 &&
+			    valid_links != iface->bss[i]->conf->mld_allowed_links) {
+				finished = false;
+				break;
+			}
+		}
+	}
+
+	return ucv_boolean_new(finished);
+}
+
+static uc_value_t *
+uc_hostapd_bss_rename(uc_vm_t *vm, size_t nargs)
+{
+	struct hostapd_data *hapd = uc_fn_thisval("hostapd.bss");
+	uc_value_t *ifname_arg = uc_fn_arg(0);
+	char prev_ifname[IFNAMSIZ + 1];
+	struct sta_info *sta;
+	const char *ifname;
+	int ret;
+
+	if (!hapd || ucv_type(ifname_arg) != UC_STRING)
+		return NULL;
+
+	os_strlcpy(prev_ifname, hapd->conf->iface, sizeof(prev_ifname));
+	ifname = ucv_string_get(ifname_arg);
+
+	hostapd_ubus_free_bss(hapd);
+	if (interfaces->ctrl_iface_deinit)
+		interfaces->ctrl_iface_deinit(hapd);
+
+	ret = hostapd_drv_if_rename(hapd, WPA_IF_AP_BSS, NULL, ifname);
+	if (ret)
+		goto out;
+
+	for (sta = hapd->sta_list; sta; sta = sta->next) {
+		char cur_name[IFNAMSIZ + 1], new_name[IFNAMSIZ + 1];
+
+		if (!(sta->flags & WLAN_STA_WDS) || sta->pending_wds_enable)
+			continue;
+
+		snprintf(cur_name, sizeof(cur_name), "%s.sta%d", prev_ifname, sta->aid);
+		snprintf(new_name, sizeof(new_name), "%s.sta%d", ifname, sta->aid);
+		hostapd_drv_if_rename(hapd, WPA_IF_AP_VLAN, cur_name, new_name);
+	}
+
+	if (!strncmp(hapd->conf->ssid.vlan, hapd->conf->iface, sizeof(hapd->conf->ssid.vlan)))
+		os_strlcpy(hapd->conf->ssid.vlan, ifname, sizeof(hapd->conf->ssid.vlan));
+	os_strlcpy(hapd->conf->iface, ifname, sizeof(hapd->conf->iface));
+	hostapd_ubus_add_bss(hapd);
+
+	hostapd_ucode_update_interfaces();
+	hostapd_owe_update_trans(hapd->iface);
+out:
+	if (interfaces->ctrl_iface_init)
+		interfaces->ctrl_iface_init(hapd);
+
+	return ret ? NULL : ucv_boolean_new(true);
+}
+
+
+int hostapd_ucode_init(struct hapd_interfaces *ifaces)
+{
+	static const uc_function_list_t global_fns[] = {
+		{ "printf",	uc_wpa_printf },
+		{ "getpid", uc_wpa_getpid },
+		{ "sha1", uc_wpa_sha1 },
+		{ "freq_info", uc_wpa_freq_info },
+		{ "add_iface", uc_hostapd_add_iface },
+		{ "remove_iface", uc_hostapd_remove_iface },
+		{ "udebug_set", uc_wpa_udebug_set },
+	};
+	static const uc_function_list_t bss_fns[] = {
+		{ "ctrl", uc_hostapd_bss_ctrl },
+		{ "set_config", uc_hostapd_bss_set_config },
+		{ "rename", uc_hostapd_bss_rename },
+		{ "delete", uc_hostapd_bss_delete },
+	};
+	static const uc_function_list_t iface_fns[] = {
+		{ "set_bss_order", uc_hostapd_iface_set_bss_order },
+		{ "add_bss", uc_hostapd_iface_add_bss },
+		{ "stop", uc_hostapd_iface_stop },
+		{ "start", uc_hostapd_iface_start },
+		{ "switch_channel", uc_hostapd_iface_switch_channel },
+		{ "is_mld_finished", uc_hostapd_iface_is_mld_finished },
+	};
+	uc_value_t *data, *proto;
+
+	interfaces = ifaces;
+	vm = wpa_ucode_create_vm();
+
+	global_type = uc_type_declare(vm, "hostapd.global", global_fns, NULL);
+	bss_type = uc_type_declare(vm, "hostapd.bss", bss_fns, NULL);
+	iface_type = uc_type_declare(vm, "hostapd.iface", iface_fns, NULL);
+
+	bss_registry = ucv_array_new(vm);
+	uc_vm_registry_set(vm, "hostap.bss_registry", bss_registry);
+
+	iface_registry = ucv_array_new(vm);
+	uc_vm_registry_set(vm, "hostap.iface_registry", iface_registry);
+
+	global = wpa_ucode_global_init("hostapd", global_type);
+
+	if (wpa_ucode_run(HOSTAPD_UC_PATH "hostapd.uc"))
+		goto free_vm;
+	ucv_gc(vm);
+
+	return 0;
+
+free_vm:
+	wpa_ucode_free_vm();
+	return -1;
+}
+
+void hostapd_ucode_free(void)
+{
+	if (wpa_ucode_call_prepare("shutdown") == 0)
+		ucv_put(wpa_ucode_call(0));
+	wpa_ucode_free_vm();
+}
+
+void hostapd_ucode_free_iface(struct hostapd_iface *iface)
+{
+	wpa_ucode_registry_remove(iface_registry, iface->ucode.idx);
+}
+
+void hostapd_ucode_bss_cb(struct hostapd_data *hapd, const char *type)
+{
+	uc_value_t *val;
+
+	if (wpa_ucode_call_prepare(type))
+		return;
+
+	val = hostapd_ucode_bss_get_uval(hapd);
+	uc_value_push(ucv_get(ucv_string_new(hapd->iface->phy)));
+	uc_value_push(ucv_get(ucv_string_new(hapd->conf->iface)));
+	uc_value_push(ucv_get(val));
+	ucv_put(wpa_ucode_call(3));
+	ucv_gc(vm);
+}
+
+void hostapd_ucode_free_bss(struct hostapd_data *hapd)
+{
+	uc_value_t *val;
+
+	val = wpa_ucode_registry_remove(bss_registry, hapd->ucode.idx);
+	if (!val)
+		return;
+
+	hapd->ucode.idx = 0;
+	if (wpa_ucode_call_prepare("bss_remove"))
+		return;
+
+	uc_value_push(ucv_string_new(hapd->conf->iface));
+	uc_value_push(ucv_get(val));
+	ucv_put(wpa_ucode_call(2));
+	ucv_gc(vm);
+}
+
+#ifdef CONFIG_APUP
+void hostapd_ucode_apup_newpeer(struct hostapd_data *hapd, const char *ifname)
+{
+	uc_value_t *val;
+
+	if (wpa_ucode_call_prepare("apup_newpeer"))
+		return;
+
+	val = hostapd_ucode_bss_get_uval(hapd);
+	uc_value_push(ucv_get(ucv_string_new(hapd->conf->iface))); // BSS ifname
+	uc_value_push(ucv_get(val));
+	uc_value_push(ucv_get(ucv_string_new(ifname))); // APuP peer ifname
+	ucv_put(wpa_ucode_call(2));
+	ucv_gc(vm);
+}
+#endif // def CONFIG_APUP
diff --git a/src/ap/ucode.h b/src/ap/ucode.h
new file mode 100644
index 0000000..2f7bcd6
--- /dev/null
+++ b/src/ap/ucode.h
@@ -0,0 +1,69 @@
+#ifndef __HOSTAPD_AP_UCODE_H
+#define __HOSTAPD_AP_UCODE_H
+
+#include "utils/ucode.h"
+
+struct hostapd_data;
+
+struct hostapd_ucode_bss {
+#ifdef UCODE_SUPPORT
+	int idx;
+#endif
+};
+
+struct hostapd_ucode_iface {
+#ifdef UCODE_SUPPORT
+	int idx;
+#endif
+};
+
+#ifdef UCODE_SUPPORT
+
+int hostapd_ucode_init(struct hapd_interfaces *ifaces);
+
+void hostapd_ucode_free(void);
+void hostapd_ucode_free_iface(struct hostapd_iface *iface);
+void hostapd_ucode_free_bss(struct hostapd_data *hapd);
+void hostapd_ucode_bss_cb(struct hostapd_data *hapd, const char *type);
+
+#ifdef CONFIG_APUP
+void hostapd_ucode_apup_newpeer(struct hostapd_data *hapd, const char *ifname);
+#endif // def CONFIG_APUP
+
+#else
+
+static inline int hostapd_ucode_init(struct hapd_interfaces *ifaces)
+{
+	return -EINVAL;
+}
+static inline void hostapd_ucode_free(void)
+{
+}
+static inline void hostapd_ucode_free_iface(struct hostapd_iface *iface)
+{
+}
+static inline void hostapd_ucode_bss_cb(struct hostapd_data *hapd, const char *type)
+{
+}
+static inline void hostapd_ucode_free_bss(struct hostapd_data *hapd)
+{
+}
+
+#endif
+
+static inline void hostapd_ucode_create_bss(struct hostapd_data *hapd)
+{
+	hostapd_ucode_bss_cb(hapd, "bss_create");
+}
+
+static inline void hostapd_ucode_add_bss(struct hostapd_data *hapd)
+{
+	hostapd_ucode_bss_cb(hapd, "bss_add");
+}
+
+static inline void hostapd_ucode_reload_bss(struct hostapd_data *hapd)
+{
+	hostapd_ucode_bss_cb(hapd, "bss_reload");
+}
+
+#endif
diff --git a/src/ap/vlan_full.c b/src/ap/vlan_full.c
index 19aa3c6..053d633 100644
--- a/src/ap/vlan_full.c
+++ b/src/ap/vlan_full.c
@@ -475,6 +475,9 @@ void vlan_newlink(const char *ifname, struct hostapd_data *hapd)
 	if (!vlan)
 		return;
 
+	if (hapd->conf->ssid.vlan_no_bridge)
+		goto out;
+
 	vlan->configured = 1;
 
 	notempty = vlan->vlan_desc.notempty;
@@ -506,6 +509,7 @@ void vlan_newlink(const char *ifname, struct hostapd_data *hapd)
 				    ifname, br_name, tagged[i], hapd);
 	}
 
+out:
 	ifconfig_up(ifname);
 }
 
diff --git a/src/ap/vlan_init.c b/src/ap/vlan_init.c
index 53eacfb..b69f3de 100644
--- a/src/ap/vlan_init.c
+++ b/src/ap/vlan_init.c
@@ -22,6 +22,7 @@
 static int vlan_if_add(struct hostapd_data *hapd, struct hostapd_vlan *vlan,
 		       int existsok)
 {
+	bool vlan_exists = iface_exists(vlan->ifname);
 	int ret;
 #ifdef CONFIG_WEP
 	int i;
@@ -36,7 +37,7 @@ static int vlan_if_add(struct hostapd_data *hapd, struct hostapd_vlan *vlan,
 	}
 #endif /* CONFIG_WEP */
 
-	if (!iface_exists(vlan->ifname))
+	if (!vlan_exists)
 		ret = hostapd_vlan_if_add(hapd, vlan->ifname);
 	else if (!existsok)
 		return -1;
@@ -51,6 +52,9 @@ static int vlan_if_add(struct hostapd_data *hapd, struct hostapd_vlan *vlan,
 	if (hapd->wpa_auth)
 		ret = wpa_auth_ensure_group(hapd->wpa_auth, vlan->vlan_id);
 
+	if (!ret && !vlan_exists)
+		hostapd_ubus_add_vlan(hapd, vlan);
+
 	if (ret == 0)
 		return ret;
 
@@ -77,6 +81,8 @@ int vlan_if_remove(struct hostapd_data *hapd, struct hostapd_vlan *vlan)
 			   "WPA deinitialization for VLAN %d failed (%d)",
 			   vlan->vlan_id, ret);
 
+	hostapd_ubus_remove_vlan(hapd, vlan);
+
 	return hostapd_vlan_if_remove(hapd, vlan->ifname);
 }
 
diff --git a/src/ap/wnm_ap.c b/src/ap/wnm_ap.c
index af8ccca..4ac96b1 100644
--- a/src/ap/wnm_ap.c
+++ b/src/ap/wnm_ap.c
@@ -20,6 +20,7 @@
 #include "ap/wpa_auth.h"
 #include "mbo_ap.h"
 #include "wnm_ap.h"
+#include "ap/neighbor_db.h"
 
 #define MAX_TFS_IE_LEN  1024
 
@@ -390,13 +391,24 @@ static int ieee802_11_send_bss_trans_mgmt_request(struct hostapd_data *hapd,
 	u8 *pos;
 	int res;
 
-	mgmt = os_zalloc(sizeof(*mgmt));
-	if (mgmt == NULL)
+	int nr_num = hostapd_neighbor_count(hapd);
+	int nr_size = ETH_ALEN + 4 + 1 + 1 + 1 + 5;
+	int total_nr_size = nr_num * nr_size;
+	u8 *nr_data = os_malloc(total_nr_size);
+	int nr_data_len = 0;
+	if(nr_data == NULL) {
+		wpa_printf (MSG_ERROR, "Failed to allocate memory");
+	} else {
+	    nr_data_len = hostapd_neighbor_insert_buffer(hapd, nr_data, total_nr_size);
+	}
+	mgmt = os_zalloc(sizeof(*mgmt) + nr_data_len);
+	if (mgmt == NULL) {
+		wpa_printf (MSG_ERROR, "Failed to allocate memory for mgmt frame");
 		return -1;
+	}
 
 	sta = ap_get_sta(hapd, addr);
 	own_addr = wnm_ap_get_own_addr(hapd, sta);
-
 	os_memcpy(mgmt->da, addr, ETH_ALEN);
 	os_memcpy(mgmt->sa, own_addr, ETH_ALEN);
 	os_memcpy(mgmt->bssid, own_addr, ETH_ALEN);
@@ -406,10 +418,19 @@ static int ieee802_11_send_bss_trans_mgmt_request(struct hostapd_data *hapd,
 	mgmt->u.action.u.bss_tm_req.action = WNM_BSS_TRANS_MGMT_REQ;
 	mgmt->u.action.u.bss_tm_req.dialog_token = dialog_token;
 	mgmt->u.action.u.bss_tm_req.req_mode = 0;
+	if(nr_num) {
+		mgmt->u.action.u.bss_tm_req.req_mode |= WNM_BSS_TM_REQ_PREF_CAND_LIST_INCLUDED;
+	}
 	mgmt->u.action.u.bss_tm_req.disassoc_timer = host_to_le16(0);
 	mgmt->u.action.u.bss_tm_req.validity_interval = 1;
 	pos = mgmt->u.action.u.bss_tm_req.variable;
 
+	if(nr_num) {
+		os_memcpy(pos, nr_data, nr_data_len);
+		pos += nr_data_len;
+	}
+
+	hapd->openwrt_stats.wnm.bss_transition_request_tx++;
 	wpa_printf(MSG_DEBUG, "WNM: Send BSS Transition Management Request to "
 		   MACSTR " dialog_token=%u req_mode=0x%x disassoc_timer=%u "
 		   "validity_interval=%u",
@@ -478,7 +499,8 @@ static void ieee802_11_rx_bss_trans_mgmt_query(struct hostapd_data *hapd,
 		MAC2STR(addr), reason, hex ? " neighbor=" : "", hex);
 	os_free(hex);
 
-	ieee802_11_send_bss_trans_mgmt_request(hapd, addr, dialog_token);
+	if (!hostapd_ubus_notify_bss_transition_query(hapd, addr, dialog_token, reason, pos, end - pos))
+		ieee802_11_send_bss_trans_mgmt_request(hapd, addr, dialog_token);
 }
 
 
@@ -500,7 +522,7 @@ static void ieee802_11_rx_bss_trans_mgmt_resp(struct hostapd_data *hapd,
 					      size_t len)
 {
 	u8 dialog_token, status_code, bss_termination_delay;
-	const u8 *pos, *end;
+	const u8 *pos, *end, *target_bssid = NULL;
 	int enabled = hapd->conf->bss_transition;
 	struct sta_info *sta;
 
@@ -547,6 +569,7 @@ static void ieee802_11_rx_bss_trans_mgmt_resp(struct hostapd_data *hapd,
 			wpa_printf(MSG_DEBUG, "WNM: not enough room for Target BSSID field");
 			return;
 		}
+		target_bssid = pos;
 		sta->agreed_to_steer = 1;
 		eloop_cancel_timeout(ap_sta_reset_steer_flag_timer, hapd, sta);
 		eloop_register_timeout(2, 0, ap_sta_reset_steer_flag_timer,
@@ -566,6 +589,10 @@ static void ieee802_11_rx_bss_trans_mgmt_resp(struct hostapd_data *hapd,
 			MAC2STR(addr), status_code, bss_termination_delay);
 	}
 
+	hostapd_ubus_notify_bss_transition_response(hapd, sta->addr, dialog_token,
+						    status_code, bss_termination_delay,
+						    target_bssid, pos, end - pos);
+
 	wpa_hexdump(MSG_DEBUG, "WNM: BSS Transition Candidate List Entries",
 		    pos, end - pos);
 }
@@ -814,10 +841,12 @@ int ieee802_11_rx_wnm_action_ap(struct hostapd_data *hapd,
 					       plen);
 		return 0;
 	case WNM_BSS_TRANS_MGMT_QUERY:
+		hapd->openwrt_stats.wnm.bss_transition_query_rx++;
 		ieee802_11_rx_bss_trans_mgmt_query(hapd, mgmt->sa, payload,
 						   plen);
 		return 0;
 	case WNM_BSS_TRANS_MGMT_RESP:
+		hapd->openwrt_stats.wnm.bss_transition_response_rx++;
 		ieee802_11_rx_bss_trans_mgmt_resp(hapd, mgmt->sa, payload,
 						  plen);
 		return 0;
@@ -865,6 +894,7 @@ int wnm_send_disassoc_imminent(struct hostapd_data *hapd,
 
 	pos = mgmt->u.action.u.bss_tm_req.variable;
 
+	hapd->openwrt_stats.wnm.bss_transition_request_tx++;
 	wpa_printf(MSG_DEBUG, "WNM: Send BSS Transition Management Request frame to indicate imminent disassociation (disassoc_timer=%d) to "
 		   MACSTR, disassoc_timer, MAC2STR(sta->addr));
 	if (hostapd_drv_send_mlme(hapd, buf, pos - buf, 0, NULL, 0, 0) < 0) {
@@ -905,6 +935,22 @@ static void set_disassoc_timer(struct hostapd_data *hapd, struct sta_info *sta,
 }
 
 
+void bss_termination_disable_iface(void *eloop_ctx, void *timeout_ctx)
+{
+	struct hostapd_data *hapd = eloop_ctx;
+	hostapd_disable_iface(hapd->iface);
+}
+
+
+static void set_disable_iface_timer(struct hostapd_data *hapd, struct sta_info *sta,
+			       int disable_iface_timer)
+{
+	wpa_printf(MSG_DEBUG, "Disable interface timer set to %d secs", disable_iface_timer);
+	eloop_register_timeout(disable_iface_timer, 0,
+			       bss_termination_disable_iface, hapd, NULL);
+}
+
+
 int wnm_send_ess_disassoc_imminent(struct hostapd_data *hapd,
 				   struct sta_info *sta, const char *url,
 				   int disassoc_timer)
@@ -947,6 +993,7 @@ int wnm_send_ess_disassoc_imminent(struct hostapd_data *hapd,
 		return -1;
 	}
 
+	hapd->openwrt_stats.wnm.bss_transition_request_tx++;
 	if (disassoc_timer) {
 		/* send disassociation frame after time-out */
 		set_disassoc_timer(hapd, sta, disassoc_timer);
@@ -995,6 +1042,7 @@ int wnm_send_bss_tm_req(struct hostapd_data *hapd, struct sta_info *sta,
 	    bss_term_dur) {
 		os_memcpy(pos, bss_term_dur, 12);
 		pos += 12;
+		set_disable_iface_timer(hapd, sta, hapd->conf->bss_termination_tsf);
 	}
 
 	if (url) {
@@ -1028,6 +1076,7 @@ int wnm_send_bss_tm_req(struct hostapd_data *hapd, struct sta_info *sta,
 	}
 	os_free(buf);
 
+	hapd->openwrt_stats.wnm.bss_transition_request_tx++;
 	if (disassoc_timer) {
 #ifdef CONFIG_IEEE80211BE
 		if (ap_sta_is_mld(hapd, sta)) {
diff --git a/src/ap/wpa_auth.c b/src/ap/wpa_auth.c
index 49866c2..ae62ec3 100644
--- a/src/ap/wpa_auth.c
+++ b/src/ap/wpa_auth.c
@@ -86,7 +86,7 @@ static const int dot11RSNAConfigPMKReauthThreshold = 70;
 static const int dot11RSNAConfigSATimeout = 60;
 
 
-static const u8 * wpa_auth_get_aa(const struct wpa_state_machine *sm)
+const u8 * wpa_auth_get_aa(const struct wpa_state_machine *sm)
 {
 #ifdef CONFIG_IEEE80211BE
 	if (sm->mld_assoc_link_id >= 0)
@@ -96,7 +96,7 @@ static const u8 * wpa_auth_get_aa(const struct wpa_state_machine *sm)
 }
 
 
-static const u8 * wpa_auth_get_spa(const struct wpa_state_machine *sm)
+const u8 * wpa_auth_get_spa(const struct wpa_state_machine *sm)
 {
 #ifdef CONFIG_IEEE80211BE
 	if (sm->mld_assoc_link_id >= 0)
@@ -4486,6 +4486,12 @@ static size_t wpa_auth_ml_kdes_len(struct wpa_state_machine *sm)
 		struct wpa_authenticator *wpa_auth;
 		const u8 *ie;
 
+		/* FIXME: This is a temporary workaround for MTK
+		 * sta IoT issue in WiFi7 cert.
+		 */
+		if (!sm->mld_links[link_id].valid)
+			continue;
+
 		wpa_auth = wpa_get_link_auth(sm->wpa_auth, link_id);
 		if (!wpa_auth)
 			continue;
@@ -4548,9 +4554,16 @@ static u8 * wpa_auth_ml_kdes(struct wpa_state_machine *sm, u8 *pos)
 	for (link_id = 0; link_id < MAX_NUM_MLD_LINKS; link_id++) {
 		struct wpa_authenticator *wpa_auth;
 		const u8 *rsne, *rsnxe, *rsnoe, *rsno2e, *rsnxoe;
+		u8 *mlo_link_len_pos;
 		size_t rsne_len, rsnxe_len, rsnoe_len, rsno2e_len, rsnxoe_len;
 		size_t kde_len;
 
+		/* FIXME: This is a temporary workaround for MTK
+		 * sta IoT issue in WiFi7 cert.
+		 */
+		if (!sm->mld_links[link_id].valid)
+			continue;
+
 		wpa_auth = wpa_get_link_auth(sm->wpa_auth, link_id);
 		if (!wpa_auth)
 			continue;
@@ -4570,6 +4583,7 @@ static u8 * wpa_auth_ml_kdes(struct wpa_state_machine *sm, u8 *pos)
 
 		/* MLO Link KDE */
 		*pos++ = WLAN_EID_VENDOR_SPECIFIC;
+		mlo_link_len_pos = pos;
 		*pos++ = RSN_SELECTOR_LEN + 1 + ETH_ALEN +
 			rsne_len + rsnxe_len;
 
@@ -4590,6 +4604,24 @@ static u8 * wpa_auth_ml_kdes(struct wpa_state_machine *sm, u8 *pos)
 		if (rsne_len) {
 			os_memcpy(pos, rsne, rsne_len);
 			pos += rsne_len;
+#ifdef CONFIG_IEEE80211R_AP
+			if (wpa_key_mgmt_ft(sm->wpa_key_mgmt)) {
+				int res;
+
+				pos -= rsne_len;
+				res = wpa_insert_pmkid(pos, &rsne_len, sm->pmk_r1_name,
+						       true);
+				if (res < 0) {
+					wpa_printf(MSG_ERROR,
+						   "FT: Failed to insert PMKR1Name into"
+						   " RSN IE in EAPOL-Key data");
+					return NULL;
+				}
+				*mlo_link_len_pos = RSN_SELECTOR_LEN + 1 + ETH_ALEN +
+					rsne_len + rsnxe_len;
+				pos += rsne_len;
+			}
+#endif /* CONFIG_IEEE80211R_AP */
 		}
 
 		if (rsnxe_len) {
@@ -4875,23 +4907,24 @@ SM_STATE(WPA_PTK, PTKINITNEGOTIATING)
 	if (!is_mld) {
 		os_memcpy(pos, wpa_ie, wpa_ie_len);
 		pos += wpa_ie_len;
-	}
 #ifdef CONFIG_IEEE80211R_AP
-	if (wpa_key_mgmt_ft(sm->wpa_key_mgmt)) {
-		int res;
-		size_t elen;
+		if (wpa_key_mgmt_ft(sm->wpa_key_mgmt)) {
+			int res;
+			size_t elen;
 
-		elen = pos - kde;
-		res = wpa_insert_pmkid(kde, &elen, sm->pmk_r1_name, true);
-		if (res < 0) {
-			wpa_printf(MSG_ERROR,
-				   "FT: Failed to insert PMKR1Name into RSN IE in EAPOL-Key data");
-			goto done;
+			elen = pos - kde;
+			res = wpa_insert_pmkid(kde, &elen, sm->pmk_r1_name, true);
+			if (res < 0) {
+				wpa_printf(MSG_ERROR,
+					   "FT: Failed to insert PMKR1Name into RSN IE"
+					   " in EAPOL-Key data");
+				goto done;
+			}
+			pos -= wpa_ie_len;
+			pos += elen;
 		}
-		pos -= wpa_ie_len;
-		pos += elen;
-	}
 #endif /* CONFIG_IEEE80211R_AP */
+	}
 	hdr[1] = 0;
 
 	if (sm->use_ext_key_id) {
@@ -4946,6 +4979,15 @@ SM_STATE(WPA_PTK, PTKINITNEGOTIATING)
 		*pos++ = WLAN_TIMEOUT_KEY_LIFETIME;
 		WPA_PUT_LE32(pos, conf->r0_key_lifetime);
 		pos += 4;
+
+		/* Add MDE back in MLD's case */
+		if (is_mld) {
+			res = wpa_write_mdie(&sm->wpa_auth->conf, pos,
+					     kde + kde_len - pos);
+			if (res < 0)
+				goto done;
+			pos += res;
+		}
 	}
 #endif /* CONFIG_IEEE80211R_AP */
 #ifdef CONFIG_P2P
@@ -6141,6 +6183,7 @@ static const char * wpa_bool_txt(int val)
 	return val ? "TRUE" : "FALSE";
 }
 
+#ifdef CONFIG_CTRL_IFACE_MIB
 
 #define RSN_SUITE "%02x-%02x-%02x-%d"
 #define RSN_SUITE_ARG(s) \
@@ -6293,7 +6336,7 @@ int wpa_get_mib_sta(struct wpa_state_machine *sm, char *buf, size_t buflen)
 
 	return len;
 }
-
+#endif
 
 void wpa_auth_countermeasures_start(struct wpa_authenticator *wpa_auth)
 {
@@ -6594,6 +6637,31 @@ wpa_auth_get_pmksa_cache(struct wpa_authenticator *wpa_auth)
 }
 
 
+struct rsn_pmksa_cache_entry *
+link_wpa_auth_pmksa_get(struct wpa_authenticator *wpa_auth, const u8 *sta_addr,
+			const u8 *pmkid)
+{
+	unsigned int link_id;
+	struct wpa_authenticator *link_wpa_auth;
+	struct rsn_pmksa_cache_entry *pmksa = NULL;
+
+	if (!wpa_auth || !wpa_auth->pmksa)
+		return NULL;
+
+	for (link_id = 0; link_id < MAX_NUM_MLD_LINKS; link_id++) {
+		link_wpa_auth = wpa_get_link_auth(wpa_auth, link_id);
+		if (!link_wpa_auth || !link_wpa_auth->pmksa)
+			continue;
+
+		pmksa = pmksa_cache_auth_get(link_wpa_auth->pmksa, sta_addr, pmkid);
+		if (pmksa)
+			break;
+	}
+
+	return pmksa;
+}
+
+
 struct rsn_pmksa_cache_entry *
 wpa_auth_pmksa_get(struct wpa_authenticator *wpa_auth, const u8 *sta_addr,
 		   const u8 *pmkid)
@@ -7461,3 +7529,9 @@ void wpa_auth_set_ml_info(struct wpa_state_machine *sm,
 	}
 #endif /* CONFIG_IEEE80211BE */
 }
+
+void switch_setup_wpa_auth(struct wpa_state_machine *sm,
+			   struct wpa_authenticator *wpa_auth)
+{
+	sm->wpa_auth = wpa_auth;
+}
diff --git a/src/ap/wpa_auth.h b/src/ap/wpa_auth.h
index 82d09f0..9ab42a9 100644
--- a/src/ap/wpa_auth.h
+++ b/src/ap/wpa_auth.h
@@ -527,6 +527,9 @@ int wpa_auth_pmksa_add_entry(struct wpa_authenticator *wpa_auth,
 struct rsn_pmksa_cache *
 wpa_auth_get_pmksa_cache(struct wpa_authenticator *wpa_auth);
 struct rsn_pmksa_cache_entry *
+link_wpa_auth_pmksa_get(struct wpa_authenticator *wpa_auth, const u8 *sta_addr,
+			const u8 *pmkid);
+struct rsn_pmksa_cache_entry *
 wpa_auth_pmksa_get(struct wpa_authenticator *wpa_auth, const u8 *sta_addr,
 		   const u8 *pmkid);
 struct rsn_pmksa_cache_entry *
@@ -683,4 +686,9 @@ void wpa_release_link_auth_ref(struct wpa_state_machine *sm,
 		    sm->mld_links[link_id].wpa_auth &&			\
 		    sm->wpa_auth != sm->mld_links[link_id].wpa_auth)
 
+void switch_setup_wpa_auth(struct wpa_state_machine *sm,
+			   struct wpa_authenticator *wpa_auth);
+const u8 * wpa_auth_get_aa(const struct wpa_state_machine *sm);
+const u8 * wpa_auth_get_spa(const struct wpa_state_machine *sm);
+
 #endif /* WPA_AUTH_H */
diff --git a/src/ap/wpa_auth_ft.c b/src/ap/wpa_auth_ft.c
index de16c31..56b755a 100644
--- a/src/ap/wpa_auth_ft.c
+++ b/src/ap/wpa_auth_ft.c
@@ -2151,17 +2151,17 @@ int wpa_auth_derive_ptk_ft(struct wpa_state_machine *sm, struct wpa_ptk *ptk,
 	}
 
 	if (wpa_derive_pmk_r0(mpmk, mpmk_len, ssid, ssid_len, mdid,
-			      r0kh, r0kh_len, sm->addr,
+			      r0kh, r0kh_len, wpa_auth_get_spa(sm),
 			      pmk_r0, pmk_r0_name,
 			      sm->wpa_key_mgmt) < 0 ||
-	    wpa_derive_pmk_r1(pmk_r0, pmk_r0_len, pmk_r0_name, r1kh, sm->addr,
-			      pmk_r1, sm->pmk_r1_name) < 0)
+	    wpa_derive_pmk_r1(pmk_r0, pmk_r0_len, pmk_r0_name, r1kh,
+			      wpa_auth_get_spa(sm), pmk_r1, sm->pmk_r1_name) < 0)
 		return -1;
 
 	return wpa_pmk_r1_to_ptk(pmk_r1, pmk_r1_len, sm->SNonce, sm->ANonce,
-				 sm->addr, sm->wpa_auth->addr, sm->pmk_r1_name,
-				 ptk, ptk_name, sm->wpa_key_mgmt, sm->pairwise,
-				 kdk_len);
+				 wpa_auth_get_spa(sm), wpa_auth_get_aa(sm),
+				 sm->pmk_r1_name, ptk, ptk_name,
+				 sm->wpa_key_mgmt, sm->pairwise, kdk_len);
 }
 
 
diff --git a/src/ap/wpa_auth_glue.c b/src/ap/wpa_auth_glue.c
index 9fa9f19..8ae561b 100644
--- a/src/ap/wpa_auth_glue.c
+++ b/src/ap/wpa_auth_glue.c
@@ -328,6 +328,7 @@ static void hostapd_wpa_auth_psk_failure_report(void *ctx, const u8 *addr)
 	struct hostapd_data *hapd = ctx;
 	wpa_msg(hapd->msg_ctx, MSG_INFO, AP_STA_POSSIBLE_PSK_MISMATCH MACSTR,
 		MAC2STR(addr));
+	hostapd_ubus_notify(hapd, "key-mismatch", addr);
 }
 
 
@@ -1814,8 +1815,12 @@ int hostapd_setup_wpa(struct hostapd_data *hapd)
 	    wpa_key_mgmt_ft(hapd->conf->wpa_key_mgmt)) {
 		const char *ft_iface;
 
-		ft_iface = hapd->conf->bridge[0] ? hapd->conf->bridge :
-			   hapd->conf->iface;
+		if (hapd->conf->ft_iface[0])
+			ft_iface = hapd->conf->ft_iface;
+		else if (hapd->conf->bridge[0])
+			ft_iface = hapd->conf->bridge;
+		else
+			ft_iface = hapd->conf->iface;
 		hapd->l2 = l2_packet_init(ft_iface, NULL, ETH_P_RRB,
 					  hostapd_rrb_receive, hapd, 1);
 		if (!hapd->l2) {
diff --git a/src/ap/wpa_auth_ie.c b/src/ap/wpa_auth_ie.c
index 6998f98..02e0c15 100644
--- a/src/ap/wpa_auth_ie.c
+++ b/src/ap/wpa_auth_ie.c
@@ -1245,8 +1245,19 @@ wpa_validate_wpa_ie(struct wpa_authenticator *wpa_auth,
 	for (i = 0; i < data.num_pmkid; i++) {
 		wpa_hexdump(MSG_DEBUG, "RSN IE: STA PMKID",
 			    &data.pmkid[i * PMKID_LEN], PMKID_LEN);
-		sm->pmksa = pmksa_cache_auth_get(wpa_auth->pmksa, sm->addr,
-						 &data.pmkid[i * PMKID_LEN]);
+
+		/* FIXME This is a workaround for not synchronizing PMKSA cache
+		 * during link removal and addition.
+		 * All links' PMKSA cache are checked for RSN Element with PMKID
+		 * from the STA MLD
+		 */
+		if (sm->mld_assoc_link_id >= 0)
+			sm->pmksa = link_wpa_auth_pmksa_get(wpa_auth, sm->addr,
+							    &data.pmkid[i * PMKID_LEN]);
+		else
+			sm->pmksa = pmksa_cache_auth_get(wpa_auth->pmksa, sm->addr,
+							 &data.pmkid[i * PMKID_LEN]);
+
 		if (!sm->pmksa && !is_zero_ether_addr(sm->p2p_dev_addr))
 			sm->pmksa = pmksa_cache_auth_get(
 				wpa_auth->pmksa, sm->p2p_dev_addr,
diff --git a/src/ap/wps_hostapd.c b/src/ap/wps_hostapd.c
index 82d4d5f..0429080 100644
--- a/src/ap/wps_hostapd.c
+++ b/src/ap/wps_hostapd.c
@@ -394,9 +394,8 @@ static int hapd_wps_reconfig_in_memory(struct hostapd_data *hapd,
 				bss->wpa_pairwise |= WPA_CIPHER_GCMP;
 			else
 				bss->wpa_pairwise |= WPA_CIPHER_CCMP;
-		}
 #ifndef CONFIG_NO_TKIP
-		if (cred->encr_type & WPS_ENCR_TKIP)
+		} else if (cred->encr_type & WPS_ENCR_TKIP)
 			bss->wpa_pairwise |= WPA_CIPHER_TKIP;
 #endif /* CONFIG_NO_TKIP */
 		bss->rsn_pairwise = bss->wpa_pairwise;
@@ -769,9 +768,12 @@ static int wps_pwd_auth_fail(struct hostapd_data *hapd, void *ctx)
 		eloop_cancel_timeout(hostapd_wps_reenable_ap_pin, hapd, NULL);
 		wpa_printf(MSG_DEBUG, "WPS: AP PIN disabled indefinitely");
 	} else if (!hapd->conf->ap_setup_locked) {
-		if (hapd->ap_pin_lockout_time == 0)
-			hapd->ap_pin_lockout_time = 60;
-		else if (hapd->ap_pin_lockout_time < 365 * 24 * 60 * 60 &&
+		if (hapd->ap_pin_lockout_time == 0) {
+			if (hapd->conf->ap_pin_lockout_time)
+				hapd->ap_pin_lockout_time = hapd->conf->ap_pin_lockout_time;
+			else
+				hapd->ap_pin_lockout_time = 60;
+		} else if (hapd->ap_pin_lockout_time < 365 * 24 * 60 * 60 &&
 			 (hapd->ap_pin_failures % 3) == 0)
 			hapd->ap_pin_lockout_time *= 2;
 
@@ -1181,8 +1183,7 @@ int hostapd_init_wps(struct hostapd_data *hapd,
 					  WPA_CIPHER_GCMP_256)) {
 			wps->encr_types |= WPS_ENCR_AES;
 			wps->encr_types_rsn |= WPS_ENCR_AES;
-		}
-		if (conf->rsn_pairwise & WPA_CIPHER_TKIP) {
+		} else if (conf->rsn_pairwise & WPA_CIPHER_TKIP) {
 #ifdef CONFIG_NO_TKIP
 			wpa_printf(MSG_INFO, "WPS: TKIP not supported");
 			goto fail;
@@ -1222,9 +1223,10 @@ int hostapd_init_wps(struct hostapd_data *hapd,
 		wps->auth_types |= WPS_AUTH_OPEN;
 	}
 
-	if (conf->ssid.wpa_psk_file) {
-		/* Use per-device PSKs */
-	} else if (conf->ssid.wpa_passphrase) {
+	if (conf->ssid.wpa_psk_file)
+		wpa_printf(MSG_DEBUG, "WPS: allow using per-device PSKs");
+
+	if (conf->ssid.wpa_passphrase) {
 		wps->network_key = (u8 *) os_strdup(conf->ssid.wpa_passphrase);
 		wps->network_key_len = os_strlen(conf->ssid.wpa_passphrase);
 	} else if (conf->ssid.wpa_psk) {
diff --git a/src/ap/x_snoop.c b/src/ap/x_snoop.c
index 029f4de..4c20f13 100644
--- a/src/ap/x_snoop.c
+++ b/src/ap/x_snoop.c
@@ -33,28 +33,31 @@ int x_snoop_init(struct hostapd_data *hapd)
 
 	hapd->x_snoop_initialized = true;
 
-	if (hostapd_drv_br_port_set_attr(hapd, DRV_BR_PORT_ATTR_HAIRPIN_MODE,
+	if (!conf->snoop_iface[0] &&
+	    hostapd_drv_br_port_set_attr(hapd, DRV_BR_PORT_ATTR_HAIRPIN_MODE,
 					 1)) {
 		wpa_printf(MSG_DEBUG,
 			   "x_snoop: Failed to enable hairpin_mode on the bridge port");
 		return -1;
 	}
 
-	if (hostapd_drv_br_port_set_attr(hapd, DRV_BR_PORT_ATTR_PROXYARP, 1)) {
+	if (!conf->snoop_iface[0] &&
+	    hostapd_drv_br_port_set_attr(hapd, DRV_BR_PORT_ATTR_PROXYARP, 1)) {
 		wpa_printf(MSG_DEBUG,
 			   "x_snoop: Failed to enable proxyarp on the bridge port");
 		return -1;
 	}
 
 	if (hostapd_drv_br_set_net_param(hapd, DRV_BR_NET_PARAM_GARP_ACCEPT,
-					 1)) {
+					 conf->snoop_iface[0] ? conf->snoop_iface : NULL, 1)) {
 		wpa_printf(MSG_DEBUG,
 			   "x_snoop: Failed to enable accepting gratuitous ARP on the bridge");
 		return -1;
 	}
 
 #ifdef CONFIG_IPV6
-	if (hostapd_drv_br_set_net_param(hapd, DRV_BR_MULTICAST_SNOOPING, 1)) {
+	if (!conf->snoop_iface[0] &&
+	    hostapd_drv_br_set_net_param(hapd, DRV_BR_MULTICAST_SNOOPING, NULL, 1)) {
 		wpa_printf(MSG_DEBUG,
 			   "x_snoop: Failed to enable multicast snooping on the bridge");
 		return -1;
@@ -73,8 +76,12 @@ x_snoop_get_l2_packet(struct hostapd_data *hapd,
 {
 	struct hostapd_bss_config *conf = hapd->conf;
 	struct l2_packet_data *l2;
+	const char *ifname = conf->bridge;
+
+	if (conf->snoop_iface[0])
+		ifname = conf->snoop_iface;
 
-	l2 = l2_packet_init(conf->bridge, NULL, ETH_P_ALL, handler, hapd, 1);
+	l2 = l2_packet_init(ifname, NULL, ETH_P_ALL, handler, hapd, 1);
 	if (l2 == NULL) {
 		wpa_printf(MSG_DEBUG,
 			   "x_snoop: Failed to initialize L2 packet processing %s",
@@ -127,9 +134,12 @@ void x_snoop_mcast_to_ucast_convert_send(struct hostapd_data *hapd,
 
 void x_snoop_deinit(struct hostapd_data *hapd)
 {
+	struct hostapd_bss_config *conf = hapd->conf;
+
 	if (!hapd->x_snoop_initialized)
 		return;
-	hostapd_drv_br_set_net_param(hapd, DRV_BR_NET_PARAM_GARP_ACCEPT, 0);
+	hostapd_drv_br_set_net_param(hapd, DRV_BR_NET_PARAM_GARP_ACCEPT,
+				     conf->snoop_iface[0] ? conf->snoop_iface : NULL, 0);
 	hostapd_drv_br_port_set_attr(hapd, DRV_BR_PORT_ATTR_PROXYARP, 0);
 	hostapd_drv_br_port_set_attr(hapd, DRV_BR_PORT_ATTR_HAIRPIN_MODE, 0);
 	hapd->x_snoop_initialized = false;
diff --git a/src/common/defs.h b/src/common/defs.h
index 7bce6a6..c7dec0f 100644
--- a/src/common/defs.h
+++ b/src/common/defs.h
@@ -63,6 +63,10 @@
 			 WPA_KEY_MGMT_FT_FILS_SHA256 | \
 			 WPA_KEY_MGMT_FT_FILS_SHA384)
 
+/* Maximum number of supported rates (from both Supported Rates and Extended
+ * Supported Rates IEs). */
+#define WLAN_SUPP_RATES_MAX 32
+
 static inline int wpa_key_mgmt_wpa_ieee8021x(int akm)
 {
 	return !!(akm & (WPA_KEY_MGMT_IEEE8021X |
diff --git a/src/common/dpp_crypto.c b/src/common/dpp_crypto.c
index f17f95a..39d39f4 100644
--- a/src/common/dpp_crypto.c
+++ b/src/common/dpp_crypto.c
@@ -269,6 +269,12 @@ int dpp_get_pubkey_hash(struct crypto_ec_key *key, u8 *hash)
 
 struct crypto_ec_key * dpp_gen_keypair(const struct dpp_curve_params *curve)
 {
+	if (curve == NULL) {
+		wpa_printf(MSG_DEBUG,
+		           "DPP: %s curve must be initialized", __func__);
+		return NULL;
+	}
+
 	struct crypto_ec_key *key;
 
 	wpa_printf(MSG_DEBUG, "DPP: Generating a keypair");
@@ -1582,7 +1588,9 @@ dpp_pkex_derive_Qr(const struct dpp_curve_params *curve, const u8 *mac_resp,
 	Pr = crypto_ec_key_get_public_key(Pr_key);
 	Qr = crypto_ec_point_init(ec);
 	hash_bn = crypto_bignum_init_set(hash, curve->hash_len);
-	if (!Pr || !Qr || !hash_bn || crypto_ec_point_mul(ec, Pr, hash_bn, Qr))
+	if (!Pr || !Qr || !hash_bn ||
+	    crypto_bignum_mod(hash_bn, crypto_ec_get_prime(ec), hash_bn) ||
+	    crypto_ec_point_mul(ec, Pr, hash_bn, Qr))
 		goto fail;
 
 	if (crypto_ec_point_is_at_infinity(ec, Qr)) {
diff --git a/src/common/hw_features_common.c b/src/common/hw_features_common.c
index bffb440..848b94b 100644
--- a/src/common/hw_features_common.c
+++ b/src/common/hw_features_common.c
@@ -481,6 +481,7 @@ int hostapd_set_freq_params(struct hostapd_freq_params *data,
 	data->sec_channel_offset = sec_channel_offset;
 	data->center_freq1 = freq + sec_channel_offset * 10;
 	data->center_freq2 = 0;
+	data->punct_bitmap = punct_bitmap;
 	if (oper_chwidth == CONF_OPER_CHWIDTH_80MHZ)
 		data->bandwidth = 80;
 	else if (oper_chwidth == CONF_OPER_CHWIDTH_160MHZ ||
@@ -898,6 +899,7 @@ int ieee80211ac_cap_check(u32 hw, u32 conf)
 	VHT_CAP_CHECK(VHT_CAP_VHT_LINK_ADAPTATION_VHT_MRQ_MFB);
 	VHT_CAP_CHECK(VHT_CAP_RX_ANTENNA_PATTERN);
 	VHT_CAP_CHECK(VHT_CAP_TX_ANTENNA_PATTERN);
+	VHT_CAP_CHECK(VHT_CAP_EXTENDED_NSS_BW_SUPPORT);
 
 #undef VHT_CAP_CHECK
 #undef VHT_CAP_CHECK_MAX
diff --git a/src/common/ieee802_11_common.c b/src/common/ieee802_11_common.c
index 4a35479..26360a5 100644
--- a/src/common/ieee802_11_common.c
+++ b/src/common/ieee802_11_common.c
@@ -2462,7 +2462,7 @@ const struct oper_class_map global_op_class[] = {
 	{ HOSTAPD_MODE_IEEE80211A, 136, 2, 2, 4, BW20, NO_P2P_SUPP },
 
 	/* IEEE P802.11be/D5.0, Table E-4 (Global operating classes) */
-	{ HOSTAPD_MODE_IEEE80211A, 137, 31, 191, 32, BW320, NO_P2P_SUPP },
+	{ HOSTAPD_MODE_IEEE80211A, 137, 1, 233, 64, BW320, NO_P2P_SUPP },
 
 	/*
 	 * IEEE Std 802.11ad-2012 and P802.ay/D5.0 60 GHz operating classes.
diff --git a/src/common/ieee802_11_defs.h b/src/common/ieee802_11_defs.h
index 4b431b0..e061a07 100644
--- a/src/common/ieee802_11_defs.h
+++ b/src/common/ieee802_11_defs.h
@@ -778,6 +778,36 @@
 #define WLAN_PROT_FTM 2
 #define WLAN_PROT_FTM_REPORT 3
 
+/* Protected EHT action codes */
+#define WLAN_PROTECTED_EHT_ACTION_EML_OMN 6
+
+/* EML Operating Mode Notification frame */
+#define EHT_EML_OMN_CONTROL_EMLSR_MODE 0x1
+#define EHT_EML_OMN_CONTROL_EMLMR_MODE 0x2
+#define EHT_EML_OMN_CONTROL_EMLSR_PARA_UPDATE_COUNT 0x4
+#define EHT_EML_OMN_CONTROL_INDEV_COEX_ACTIVITIES 0x8
+
+/* EMLSR Parameter Update field */
+#define EHT_EML_OMN_EMLSR_PADDING_DELAY_MASK 0x07
+#define EHT_EML_OMN_EMLSR_TRANSITION_DELAY_MASK 0x38
+
+struct eml_omn_element {
+	u8 dialog_token;
+	u8 control;
+	le16 bitmap;
+	union {
+		struct {
+			u8 emlsr_para_update;
+		} STRUCT_PACKED emlsr_info;
+		struct {
+			u8 mcs_map_count_control;
+			u8 mcs_map_bw80[3];
+			u8 mcs_map_bw160[3];
+			u8 mcs_map_bw320[3];
+		} STRUCT_PACKED emlmr_info;
+	} u;
+} STRUCT_PACKED;
+
 /* Radio Measurement capabilities (from RM Enabled Capabilities element)
  * IEEE Std 802.11-2020, 9.4.2.44, Table 9-179 */
 /* byte 1 (out of 5) */
@@ -1164,6 +1194,15 @@ struct ieee80211_mgmt {
 					u8 dialog_token;
 					u8 variable[];
 				} STRUCT_PACKED rrm;
+				struct {
+					u8 action;
+					u8 variable[];
+				} STRUCT_PACKED eht_prot;
+				struct {
+					u8 action;
+					u8 dialog_token;
+					u8 variable[];
+				} STRUCT_PACKED scs;
 			} u;
 		} STRUCT_PACKED action;
 	} u;
@@ -1402,6 +1441,8 @@ struct ieee80211_ampe_ie {
 #define VHT_CAP_VHT_LINK_ADAPTATION_VHT_MRQ_MFB     ((u32) BIT(26) | BIT(27))
 #define VHT_CAP_RX_ANTENNA_PATTERN                  ((u32) BIT(28))
 #define VHT_CAP_TX_ANTENNA_PATTERN                  ((u32) BIT(29))
+#define VHT_CAP_EXTENDED_NSS_BW_SUPPORT		    ((u32) BIT(30))
+#define VHT_CAP_EXTENDED_NSS_BW_SUPPORT_MASK	    ((u32) BIT(30) | BIT(31))
 
 #define VHT_OPMODE_CHANNEL_WIDTH_MASK		    ((u8) BIT(0) | BIT(1))
 #define VHT_OPMODE_CHANNEL_RxNSS_MASK		    ((u8) BIT(4) | BIT(5) | \
@@ -2498,6 +2539,9 @@ struct ieee80211_spatial_reuse {
 #define HE_PHYCAP_CHANNEL_WIDTH_SET_160MHZ_IN_5G	((u8) BIT(3))
 #define HE_PHYCAP_CHANNEL_WIDTH_SET_80PLUS80MHZ_IN_5G	((u8) BIT(4))
 
+#define HE_PHYCAP_LDPC_CODING_IN_PAYLOAD_IDX	1
+#define HE_PHYCAP_LDPC_CODING_IN_PAYLOAD	((u8) BIT(5))
+
 #define HE_PHYCAP_SU_BEAMFORMER_CAPAB_IDX	3
 #define HE_PHYCAP_SU_BEAMFORMER_CAPAB		((u8) BIT(7))
 #define HE_PHYCAP_SU_BEAMFORMEE_CAPAB_IDX	4
@@ -2937,6 +2981,19 @@ struct ieee80211_bw_ind_element {
 
 #define BW_IND_PARAMETER_DISABLED_SUBCHAN_BITMAP_PRESENT       BIT(1)
 
+/* IEEE P802.11be/D5.0, 9.4.2.314 - TID-to-Link Mapping control */
+#define IEEE80211_TTLM_CONTROL_DIRECTION		0x0003
+#define IEEE80211_TTLM_CONTROL_DEF_LINK_MAP		0x0004
+#define IEEE80211_TTLM_CONTROL_SWITCH_TIME_PRESENT	0x0008
+#define IEEE80211_TTLM_CONTROL_EXPECTED_DUR_PRESENT	0x0010
+#define IEEE80211_TTLM_CONTROL_LINK_MAP_SIZE		0x0020
+#define IEEE80211_TTLM_CONTROL_INDICATOR		0xff00
+
+/* TTLM direction */
+#define IEEE80211_TTLM_DIRECTION_DOWN		0
+#define IEEE80211_TTLM_DIRECTION_UP		1
+#define IEEE80211_TTLM_DIRECTION_BOTH		2
+
 /* IEEE P802.11ay/D4.0, 9.4.2.251 - EDMG Operation element */
 #define EDMG_BSS_OPERATING_CHANNELS_OFFSET	6
 #define EDMG_OPERATING_CHANNEL_WIDTH_OFFSET	7
diff --git a/src/common/mtk_vendor.h b/src/common/mtk_vendor.h
new file mode 100644
index 0000000..b85e737
--- /dev/null
+++ b/src/common/mtk_vendor.h
@@ -0,0 +1,558 @@
+// SPDX-License-Identifier: ISC
+/* Copyright (C) 2020 Felix Fietkau <nbd@nbd.name> */
+#ifndef MTK_VENDOR_H
+#define MTK_VENDOR_H
+
+#define OUI_MTK    0x000ce7
+
+enum mtk_nl80211_vendor_subcmds {
+	MTK_NL80211_VENDOR_SUBCMD_AMNT_CTRL = 0xae,
+	MTK_NL80211_VENDOR_SUBCMD_CSI_CTRL = 0xc2,
+	MTK_NL80211_VENDOR_SUBCMD_RFEATURE_CTRL = 0xc3,
+	MTK_NL80211_VENDOR_SUBCMD_WIRELESS_CTRL = 0xc4,
+	MTK_NL80211_VENDOR_SUBCMD_MU_CTRL = 0xc5,
+	MTK_NL80211_VENDOR_SUBCMD_PHY_CAPA_CTRL= 0xc6,
+	MTK_NL80211_VENDOR_SUBCMD_EDCCA_CTRL = 0xc7,
+	MTK_NL80211_VENDOR_SUBCMD_3WIRE_CTRL = 0xc8,
+	MTK_NL80211_VENDOR_SUBCMD_IBF_CTRL = 0xc9,
+	MTK_NL80211_VENDOR_SUBCMD_BSS_COLOR_CTRL = 0xca,
+	MTK_NL80211_VENDOR_SUBCMD_BACKGROUND_RADAR_CTRL = 0xcb,
+	MTK_NL80211_VENDOR_SUBCMD_PP_CTRL = 0xcc,
+	MTK_NL80211_VENDOR_SUBCMD_BEACON_CTRL = 0xcd,
+	MTK_NL80211_VENDOR_SUBCMD_TXPOWER_CTRL = 0xce,
+	MTK_NL80211_VENDOR_SUBCMD_SCS_CTRL = 0xd0,
+	MTK_NL80211_VENDOR_SUBCMD_EML_CTRL = 0xd3,
+};
+
+enum mtk_nl80211_vendor_subevents {
+	MTK_NL80211_VENDOR_EVENT_PP_BMP_UPDATE = 0x5,
+};
+
+enum mtk_vendor_attr_edcca_ctrl {
+	MTK_VENDOR_ATTR_EDCCA_THRESHOLD_INVALID = 0,
+
+	MTK_VENDOR_ATTR_EDCCA_CTRL_MODE,
+	MTK_VENDOR_ATTR_EDCCA_CTRL_PRI20_VAL,
+	MTK_VENDOR_ATTR_EDCCA_CTRL_SEC20_VAL,
+	MTK_VENDOR_ATTR_EDCCA_CTRL_SEC40_VAL,
+	MTK_VENDOR_ATTR_EDCCA_CTRL_SEC80_VAL,
+	MTK_VENDOR_ATTR_EDCCA_CTRL_COMPENSATE,
+	MTK_VENDOR_ATTR_EDCCA_CTRL_SEC160_VAL,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_EDCCA_CTRL,
+	MTK_VENDOR_ATTR_EDCCA_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_EDCCA_CTRL - 1
+};
+
+enum mtk_vendor_attr_edcca_dump {
+	MTK_VENDOR_ATTR_EDCCA_DUMP_UNSPEC = 0,
+
+	MTK_VENDOR_ATTR_EDCCA_DUMP_MODE,
+	MTK_VENDOR_ATTR_EDCCA_DUMP_PRI20_VAL,
+	MTK_VENDOR_ATTR_EDCCA_DUMP_SEC40_VAL,
+	MTK_VENDOR_ATTR_EDCCA_DUMP_SEC80_VAL,
+	MTK_VENDOR_ATTR_EDCCA_DUMP_SEC160_VAL,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_EDCCA_DUMP,
+	MTK_VENDOR_ATTR_EDCCA_DUMP_MAX =
+		NUM_MTK_VENDOR_ATTRS_EDCCA_DUMP - 1
+};
+
+enum mtk_vendor_attr_3wire_ctrl {
+	MTK_VENDOR_ATTR_3WIRE_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_3WIRE_CTRL_MODE,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_3WIRE_CTRL,
+	MTK_VENDOR_ATTR_3WIRE_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_3WIRE_CTRL - 1
+};
+
+enum mtk_vendor_attr_csi_ctrl {
+	MTK_VENDOR_ATTR_CSI_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_CSI_CTRL_CFG,
+	MTK_VENDOR_ATTR_CSI_CTRL_CFG_MODE,
+	MTK_VENDOR_ATTR_CSI_CTRL_CFG_TYPE,
+	MTK_VENDOR_ATTR_CSI_CTRL_CFG_VAL1,
+	MTK_VENDOR_ATTR_CSI_CTRL_CFG_VAL2,
+	MTK_VENDOR_ATTR_CSI_CTRL_MAC_ADDR,
+
+	MTK_VENDOR_ATTR_CSI_CTRL_DUMP_NUM,
+
+	MTK_VENDOR_ATTR_CSI_CTRL_DATA,
+
+	MTK_VENDOR_ATTR_CSI_CTRL_RADIO_IDX,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_CSI_CTRL,
+	MTK_VENDOR_ATTR_CSI_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_CSI_CTRL - 1
+};
+
+enum mtk_vendor_attr_csi_data {
+	MTK_VENDOR_ATTR_CSI_DATA_UNSPEC,
+	MTK_VENDOR_ATTR_CSI_DATA_PAD,
+
+	MTK_VENDOR_ATTR_CSI_DATA_VER,
+	MTK_VENDOR_ATTR_CSI_DATA_TS,
+	MTK_VENDOR_ATTR_CSI_DATA_RSSI,
+	MTK_VENDOR_ATTR_CSI_DATA_SNR,
+	MTK_VENDOR_ATTR_CSI_DATA_BW,
+	MTK_VENDOR_ATTR_CSI_DATA_CH_IDX,
+	MTK_VENDOR_ATTR_CSI_DATA_TA,
+	MTK_VENDOR_ATTR_CSI_DATA_NUM,
+	MTK_VENDOR_ATTR_CSI_DATA_I,
+	MTK_VENDOR_ATTR_CSI_DATA_Q,
+	MTK_VENDOR_ATTR_CSI_DATA_INFO,
+	MTK_VENDOR_ATTR_CSI_DATA_RSVD1,
+	MTK_VENDOR_ATTR_CSI_DATA_RSVD2,
+	MTK_VENDOR_ATTR_CSI_DATA_RSVD3,
+	MTK_VENDOR_ATTR_CSI_DATA_RSVD4,
+	MTK_VENDOR_ATTR_CSI_DATA_TX_ANT,
+	MTK_VENDOR_ATTR_CSI_DATA_RX_ANT,
+	MTK_VENDOR_ATTR_CSI_DATA_MODE,
+	MTK_VENDOR_ATTR_CSI_DATA_CHAIN_INFO,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_CSI_DATA,
+	MTK_VENDOR_ATTR_CSI_DATA_MAX =
+		NUM_MTK_VENDOR_ATTRS_CSI_DATA - 1
+};
+
+enum mtk_vendor_attr_mnt_ctrl {
+	MTK_VENDOR_ATTR_AMNT_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_AMNT_CTRL_SET,
+	MTK_VENDOR_ATTR_AMNT_CTRL_DUMP,
+	MTK_VENDOR_ATTR_AMNT_CTRL_LINK_ID,
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_AMNT_CTRL,
+	MTK_VENDOR_ATTR_AMNT_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_AMNT_CTRL - 1
+};
+
+enum mtk_vendor_attr_mnt_set {
+	MTK_VENDOR_ATTR_AMNT_SET_UNSPEC,
+
+	MTK_VENDOR_ATTR_AMNT_SET_INDEX,
+	MTK_VENDOR_ATTR_AMNT_SET_MACADDR,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_AMNT_SET,
+	MTK_VENDOR_ATTR_AMNT_SET_MAX =
+		NUM_MTK_VENDOR_ATTRS_AMNT_SET - 1
+};
+
+enum mtk_vendor_attr_mnt_dump {
+	MTK_VENDOR_ATTR_AMNT_DUMP_UNSPEC,
+
+	MTK_VENDOR_ATTR_AMNT_DUMP_INDEX,
+	MTK_VENDOR_ATTR_AMNT_DUMP_LEN,
+	MTK_VENDOR_ATTR_AMNT_DUMP_RESULT,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_AMNT_DUMP,
+	MTK_VENDOR_ATTR_AMNT_DUMP_MAX =
+		NUM_MTK_VENDOR_ATTRS_AMNT_DUMP - 1
+};
+
+enum mtk_vendor_attr_wireless_ctrl {
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_FIXED_MCS,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_FIXED_OFDMA,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_PPDU_TX_TYPE,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_NUSERS_OFDMA,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_BA_BUFFER_SIZE,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_MIMO,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_AMSDU,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_CERT = 9,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_RTS_SIGTA,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_MU_EDCA,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_LINK_ID,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_WIRELESS_CTRL,
+	MTK_VENDOR_ATTR_WIRELESS_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_WIRELESS_CTRL - 1
+};
+
+enum mtk_vendor_attr_wireless_dump {
+	MTK_VENDOR_ATTR_WIRELESS_DUMP_UNSPEC,
+
+	MTK_VENDOR_ATTR_WIRELESS_DUMP_AMSDU,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_WIRELESS_DUMP,
+	MTK_VENDOR_ATTR_WIRELESS_DUMP_MAX =
+		NUM_MTK_VENDOR_ATTRS_WIRELESS_DUMP - 1
+};
+
+enum mtk_vendor_attr_rfeature_ctrl {
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_HE_GI,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_HE_LTF,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE_CFG,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE_EN,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_ACK_PLCY,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TXBF,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_VARIANT_TYPE,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_CODING_TYPE,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_LINK_ID,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_RFEATURE_CTRL,
+	MTK_VENDOR_ATTR_RFEATURE_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_RFEATURE_CTRL - 1
+};
+
+enum mtk_vendor_attr_mu_ctrl {
+	MTK_VENDOR_ATTR_MU_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_MU_CTRL_ONOFF,
+	MTK_VENDOR_ATTR_MU_CTRL_DUMP,
+	/**
+	 * The above attrs are also used by connac 2. It is best not to modify the
+	 * above data structure.
+	 */
+	MTK_VENDOR_ATTR_MU_CTRL_STRUCT,
+	MTK_VENDOR_ATTR_MU_CTRL_RADIO_IDX,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_MU_CTRL,
+	MTK_VENDOR_ATTR_MU_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_MU_CTRL - 1
+};
+
+enum mtk_vendor_attr_ibf_ctrl {
+	MTK_VENDOR_ATTR_IBF_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_IBF_CTRL_ENABLE,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_IBF_CTRL,
+	MTK_VENDOR_ATTR_IBF_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_IBF_CTRL - 1
+};
+
+enum mtk_vendor_attr_ibf_dump {
+	MTK_VENDOR_ATTR_IBF_DUMP_UNSPEC,
+
+	MTK_VENDOR_ATTR_IBF_DUMP_ENABLE,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_IBF_DUMP,
+	MTK_VENDOR_ATTR_IBF_DUMP_MAX =
+		NUM_MTK_VENDOR_ATTRS_IBF_DUMP - 1
+};
+
+enum mtk_vendor_attr_bss_color_ctrl {
+	MTK_VENDOR_ATTR_BSS_COLOR_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_AVAL_BSS_COLOR_BMP,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_BSS_COLOR_CTRL,
+	MTK_VENDOR_ATTR_BSS_COLOR_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_BSS_COLOR_CTRL - 1
+};
+
+enum mtk_vendor_attr_background_radar_ctrl {
+	MTK_VENDOR_ATTR_BACKGROUND_RADAR_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_BACKGROUND_RADAR_CTRL_MODE,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_BACKGROUND_RADAR_CTRL,
+	MTK_VENDOR_ATTR_BACKGROUND_RADAR_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_BACKGROUND_RADAR_CTRL - 1
+};
+
+enum mtk_vendor_attr_pp_ctrl {
+	MTK_VENDOR_ATTR_PP_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_PP_MODE,
+	MTK_VENDOR_ATTR_PP_LINK_ID,
+	MTK_VENDOR_ATTR_PP_BITMAP,
+	MTK_VENDOR_ATTR_PP_CURR_FREQ,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_PP_CTRL,
+	MTK_VENDOR_ATTR_PP_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_PP_CTRL - 1
+};
+
+enum mtk_vendor_attr_beacon_ctrl {
+	MTK_VENDOR_ATTR_BEACON_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_BEACON_CTRL_MODE,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_BEACON_CTRL,
+	MTK_VENDOR_ATTR_BEACON_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_BEACON_CTRL - 1
+};
+
+enum mtk_vendor_attr_eml_ctrl {
+
+	MTK_VENDOR_ATTR_EML_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_EML_LINK_ID,
+	MTK_VENDOR_ATTR_EML_STA_ADDR,
+	MTK_VENDOR_ATTR_EML_CTRL_STRUCT,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_EML_CTRL,
+	MTK_VENDOR_ATTR_EML_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_EML_CTRL -1
+};
+
+enum mtk_vendor_attr_txpower_ctrl {
+	MTK_VENDOR_ATTR_TXPOWER_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_TXPOWER_CTRL_LPI_PSD,
+	MTK_VENDOR_ATTR_TXPOWER_CTRL_SKU_IDX,
+	MTK_VENDOR_ATTR_TXPOWER_CTRL_LPI_BCN_ENHANCE,
+	MTK_VENDOR_ATTR_TXPOWER_CTRL_LINK_ID,
+	MTK_VENDOR_ATTR_TXPOWER_CTRL_AFC_TABLE,
+	MTK_VENDOR_ATTR_TXPOWER_CTRL_AFC_LPI,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_TXPOWER_CTRL,
+	MTK_VENDOR_ATTR_TXPOWER_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_TXPOWER_CTRL - 1
+};
+
+enum mtk_vendor_attr_scs_ctrl {
+	MTK_VENDOR_ATTR_SCS_CTRL_UNSPEC,
+
+	MTK_VENDOR_ATTR_SCS_ID,
+	MTK_VENDOR_ATTR_SCS_REQ_TYPE,
+	MTK_VENDOR_ATTR_SCS_DIR,
+	MTK_VENDOR_ATTR_SCS_QOS_IE,
+	MTK_VENDOR_ATTR_SCS_MAC_ADDR,
+	MTK_VENDOR_ATTR_SCS_LINK_ID,
+
+	/* keep last */
+	NUM_MTK_VENDOR_ATTRS_SCS_CTRL,
+	MTK_VENDOR_ATTR_SCS_CTRL_MAX =
+		NUM_MTK_VENDOR_ATTRS_SCS_CTRL - 1
+};
+
+#define CSI_BW20_DATA_COUNT	64
+#define CSI_BW40_DATA_COUNT	128
+#define CSI_BW80_DATA_COUNT	256
+#define CSI_BW160_DATA_COUNT	512
+#define CSI_BW320_DATA_COUNT	1024
+#define ETH_ALEN 6
+
+struct csi_data {
+	u8 ch_bw;
+	u16 data_num;
+	s16 data_i[CSI_BW320_DATA_COUNT];
+	s16 data_q[CSI_BW320_DATA_COUNT];
+	u8 band;
+	s8 rssi;
+	u8 snr;
+	u32 ts;
+	u8 data_bw;
+	u8 pri_ch_idx;
+	u8 ta[ETH_ALEN];
+	u32 ext_info;
+	u8 rx_mode;
+	u32 chain_info;
+	u16 tx_idx;
+	u16 rx_idx;
+	u32 segment_num;
+	u8 remain_last;
+	u16 pkt_sn;
+	u8 tr_stream;
+};
+
+struct csi_resp_data {
+	u16 usr_need_cnt;
+	u16 buf_cnt;
+	struct csi_data *csi_buf;
+};
+
+#define AIR_MONITOR_MAX_ENTRY 16
+
+struct amnt_data {
+	u8 idx;
+	u8 addr[ETH_ALEN];
+	s8 rssi[4];
+	u32 last_seen;
+};
+
+struct amnt_resp_data {
+	u8 sta_num;
+	struct amnt_data resp_data[0];
+};
+
+enum {
+	MU_CTRL_UPDATE,
+	MU_CTRL_ONOFF,
+};
+
+struct connac3_muru_comm {
+	u8 pda_pol;
+	u8 band;
+	u8 spe_idx;
+	u8 proc_type;
+
+	le16 mlo_ctrl;
+	u8 sch_type;
+	u8 ppdu_format;
+	u8 ac;
+	u8 _rsv[3];
+};
+
+struct connac3_muru_dl {
+	u8 user_num;
+	u8 tx_mode;
+	u8 bw;
+	u8 gi;
+
+	u8 ltf;
+	u8 mcs;
+	u8 dcm;
+	u8 cmprs;
+
+	le16 ru[16];
+
+	u8 c26[2];
+	u8 ack_policy;
+	u8 tx_power;
+
+	le16 mu_ppdu_duration;
+	u8 agc_disp_order;
+	u8 _rsv1;
+
+	u8 agc_disp_pol;
+	u8 agc_disp_ratio;
+	le16 agc_disp_linkMFG;
+
+	le16 prmbl_punc_bmp;
+	u8 _rsv2[2];
+
+	struct {
+		le16 wlan_idx;
+		u8 ru_alloc_seg;
+		u8 ru_idx;
+		u8 ldpc;
+		u8 nss;
+		u8 mcs;
+		u8 mu_group_idx;
+		u8 vht_groud_id;
+		u8 vht_up;
+		u8 he_start_stream;
+		u8 he_mu_spatial;
+		le16 tx_power_alpha;
+		u8 ack_policy;
+		u8 ru_allo_ps160;
+	} usr[16];
+};
+
+struct connac3_muru_ul {
+	u8 user_num;
+	u8 tx_mode;
+
+	u8 ba_type;
+	u8 _rsv;
+
+	u8 bw;
+	u8 gi_ltf;
+	le16 ul_len;
+
+	le16 trig_cnt;
+	u8 pad;
+	u8 trig_type;
+
+	le16 trig_intv;
+	u8 trig_ta[ETH_ALEN];
+	le16 ul_ru[16];
+
+	u8 c26[2];
+	le16 agc_disp_linkMFG;
+
+	u8 agc_disp_mu_len;
+	u8 agc_disp_pol;
+	u8 agc_disp_ratio;
+	u8 agc_disp_pu_idx;
+
+	struct {
+		le16 wlan_idx;
+		u8 ru_alloc_seg;
+		u8 ru_idx;
+		u8 ldpc;
+		u8 nss;
+		u8 mcs;
+		u8 target_rssi;
+		le32 trig_pkt_size;
+		u8 ru_allo_ps160;
+		u8 _rsv2[3];
+	} usr[16];
+};
+
+struct connac3_muru_dbg {
+	/* HE TB RX Debug */
+	le32 rx_hetb_nonsf_en_bitmap;
+	le32 rx_hetb_cfg[2];
+};
+
+struct connac3_muru {
+	le32 cfg_comm;
+	le32 cfg_dl;
+	le32 cfg_ul;
+	le32 cfg_dbg;
+
+	struct connac3_muru_comm comm;
+	struct connac3_muru_dl dl;
+	struct connac3_muru_ul ul;
+	struct connac3_muru_dbg dbg;
+};
+
+#define MURU_OFDMA_SCH_TYPE_DL	BIT(0)
+#define MURU_OFDMA_SCH_TYPE_UL	BIT(1)
+#define MURU_PPDU_HE_TRIG	BIT(2)
+#define MURU_PPDU_HE_MU		BIT(3)
+
+/* Common Config */
+#define MURU_COMM_PPDU_FMT	BIT(0)
+#define MURU_COMM_BAND		BIT(2)
+#define MURU_COMM_WMM		BIT(3)
+#define MURU_COMM_SPE_IDX	BIT(4)
+#define MURU_COMM_SET		(MURU_COMM_PPDU_FMT | MURU_COMM_BAND | \
+				 MURU_COMM_WMM | MURU_COMM_SPE_IDX)
+
+/* DL Common config */
+#define MURU_FIXED_DL_BW		BIT(0)
+#define MURU_FIXED_DL_GI		BIT(1)
+#define MURU_FIXED_DL_TONE_PLAN		BIT(3)
+#define MURU_FIXED_DL_TOTAL_USER_CNT	BIT(4)
+#define MURU_FIXED_DL_LTF		BIT(5)
+#define MURU_FIXED_DL_ACK_PLY		BIT(9)
+
+/* DL Per User Config */
+#define MURU_FIXED_USER_DL_COD		BIT(17)
+#define MURU_FIXED_USER_DL_MCS		BIT(18)
+#define MURU_FIXED_USER_DL_RU_ALLOC	BIT(20)
+
+/* UL Common Config */
+#define MURU_FIXED_UL_TOTAL_USER_CNT	BIT(4)
+#define MURU_FIXED_UL_BW		BIT(5)
+#define MURU_FIXED_UL_GILTF		BIT(6)
+
+/* UL Per User Config */
+#define MURU_FIXED_USER_UL_COD		BIT(18)
+#define MURU_FIXED_USER_UL_MCS		BIT(19)
+#define MURU_FIXED_USER_UL_NSS		BIT(20)
+#define MURU_FIXED_USER_UL_RU_ALLOC	BIT(21)
+
+#endif /* MTK_VENDOR_H */
diff --git a/src/common/sae.c b/src/common/sae.c
index 3584855..3e66b0b 100644
--- a/src/common/sae.c
+++ b/src/common/sae.c
@@ -1279,6 +1279,13 @@ void sae_deinit_pt(struct sae_pt *pt)
 static int sae_derive_commit_element_ecc(struct sae_data *sae,
 					 struct crypto_bignum *mask)
 {
+	if (sae->tmp->pwe_ecc == NULL) {
+		wpa_printf(MSG_DEBUG,
+		           "SAE: %s sae->tmp->pwe_ecc must be initialized",
+		           __func__);
+		return -1;
+	}
+
 	/* COMMIT-ELEMENT = inverse(scalar-op(mask, PWE)) */
 	if (!sae->tmp->own_commit_element_ecc) {
 		sae->tmp->own_commit_element_ecc =
diff --git a/src/common/wpa_ctrl.c b/src/common/wpa_ctrl.c
index 7e197f0..791fdbf 100644
--- a/src/common/wpa_ctrl.c
+++ b/src/common/wpa_ctrl.c
@@ -135,7 +135,7 @@ try_again:
 		return NULL;
 	}
 	tries++;
-#ifdef ANDROID
+
 	/* Set client socket file permissions so that bind() creates the client
 	 * socket with these permissions and there is no need to try to change
 	 * them with chmod() after bind() which would have potential issues with
@@ -147,7 +147,7 @@ try_again:
 	 * operations to allow the response to go through. Those are using the
 	 * no-deference-symlinks version to avoid races. */
 	fchmod(ctrl->s, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
-#endif /* ANDROID */
+
 	if (bind(ctrl->s, (struct sockaddr *) &ctrl->local,
 		    sizeof(ctrl->local)) < 0) {
 		if (errno == EADDRINUSE && tries < 2) {
@@ -165,7 +165,11 @@ try_again:
 		return NULL;
 	}
 
-#ifdef ANDROID
+#ifndef ANDROID
+	/* Set group even if we do not have privileges to change owner */
+	lchown(ctrl->local.sun_path, -1, 101);
+	lchown(ctrl->local.sun_path, 101, 101);
+#else
 	/* Set group even if we do not have privileges to change owner */
 	lchown(ctrl->local.sun_path, -1, AID_WIFI);
 	lchown(ctrl->local.sun_path, AID_SYSTEM, AID_WIFI);
diff --git a/src/common/wpa_ctrl.h b/src/common/wpa_ctrl.h
index 2ea8ab3..aab7580 100644
--- a/src/common/wpa_ctrl.h
+++ b/src/common/wpa_ctrl.h
@@ -391,6 +391,7 @@ extern "C" {
 #define DFS_EVENT_CAC_COMPLETED "DFS-CAC-COMPLETED "
 #define DFS_EVENT_NOP_FINISHED "DFS-NOP-FINISHED "
 #define DFS_EVENT_PRE_CAC_EXPIRED "DFS-PRE-CAC-EXPIRED "
+#define DFS_EVENT_STA_UPDATE "DFS-STA-UPDATE "
 
 #define AP_CSA_FINISHED "AP-CSA-FINISHED "
 
diff --git a/src/crypto/Makefile b/src/crypto/Makefile
index ce09970..96bac94 100644
--- a/src/crypto/Makefile
+++ b/src/crypto/Makefile
@@ -1,10 +1,121 @@
-CFLAGS += -DCONFIG_CRYPTO_INTERNAL
-CFLAGS += -DCONFIG_TLS_INTERNAL_CLIENT
-CFLAGS += -DCONFIG_TLS_INTERNAL_SERVER
 #CFLAGS += -DALL_DH_GROUPS
 CFLAGS += -DCONFIG_SHA256
 CFLAGS += -DCONFIG_SHA384
+CFLAGS += -DCONFIG_HMAC_SHA256_KDF
 CFLAGS += -DCONFIG_HMAC_SHA384_KDF
+
+# crypto_module_tests.c
+CFLAGS += -DCONFIG_MODULE_TESTS
+CFLAGS += -DCONFIG_DPP
+#CFLAGS += -DCONFIG_DPP2
+#CFLAGS += -DCONFIG_DPP3
+CFLAGS += -DCONFIG_ECC
+CFLAGS += -DCONFIG_MESH
+CFLAGS += -DEAP_PSK
+CFLAGS += -DEAP_FAST
+
+ifeq ($(CONFIG_TLS),mbedtls)
+
+# (enable features for 'cd tests; make run-tests CONFIG_TLS=mbedtls')
+CFLAGS += -DCRYPTO_RSA_OAEP_SHA256
+CFLAGS += -DCONFIG_DES
+CFLAGS += -DEAP_IKEV2
+CFLAGS += -DEAP_MSCHAPv2
+CFLAGS += -DEAP_SIM
+
+LIB_OBJS = tls_mbedtls.o crypto_mbedtls.o
+LIB_OBJS+= \
+	aes-eax.o \
+	aes-siv.o \
+	dh_groups.o \
+	milenage.o \
+	ms_funcs.o
+
+else
+ifeq ($(CONFIG_TLS),openssl)
+
+# (enable features for 'cd tests; make run-tests CONFIG_TLS=openssl')
+ifndef CONFIG_TLS_DEFAULT_CIPHERS
+CONFIG_TLS_DEFAULT_CIPHERS = "DEFAULT:!EXP:!LOW"
+endif
+CFLAGS += -DTLS_DEFAULT_CIPHERS=\"$(CONFIG_TLS_DEFAULT_CIPHERS)\"
+CFLAGS += -DCRYPTO_RSA_OAEP_SHA256
+CFLAGS += -DEAP_TLS_OPENSSL
+
+LIB_OBJS = tls_openssl.o fips_prf_openssl.o crypto_openssl.o
+LIB_OBJS+= \
+	aes-ctr.o \
+	aes-eax.o \
+	aes-encblock.o \
+	aes-siv.o \
+	dh_groups.o \
+	milenage.o \
+	ms_funcs.o \
+	sha1-prf.o \
+	sha1-tlsprf.o \
+	sha1-tprf.o \
+	sha256-kdf.o \
+	sha256-prf.o \
+	sha256-tlsprf.o
+
+else
+ifeq ($(CONFIG_TLS),wolfssl)
+
+# (wolfssl libraries must be built with ./configure --enable-wpas)
+# (enable features for 'cd tests; make run-tests CONFIG_TLS=wolfssl')
+CFLAGS += -DWOLFSSL_DER_LOAD
+CFLAGS += -DCONFIG_DES
+
+LIB_OBJS = tls_wolfssl.o fips_prf_wolfssl.o crypto_wolfssl.o
+LIB_OBJS+= \
+	aes-ctr.o \
+	aes-eax.o \
+	aes-encblock.o \
+	aes-siv.o \
+	dh_groups.o \
+	milenage.o \
+	ms_funcs.o \
+	sha1-prf.o \
+	sha1-tlsprf.o \
+	sha1-tprf.o \
+	sha256-kdf.o \
+	sha256-prf.o \
+	sha256-tlsprf.o
+
+else
+ifeq ($(CONFIG_TLS),gnutls)
+
+# (enable features for 'cd tests; make run-tests CONFIG_TLS=gnutls')
+LIB_OBJS = tls_gnutls.o crypto_gnutls.o
+LIB_OBJS+= \
+	aes-cbc.o \
+	aes-ctr.o \
+	aes-eax.o \
+	aes-encblock.o \
+	aes-omac1.o \
+	aes-siv.o \
+	aes-unwrap.o \
+	aes-wrap.o \
+	dh_group5.o \
+	dh_groups.o \
+	milenage.o \
+	ms_funcs.o \
+	rc4.o \
+	sha1-pbkdf2.o \
+	sha1-prf.o \
+	fips_prf_internal.o \
+	sha1-internal.o \
+	sha1-tlsprf.o \
+	sha1-tprf.o \
+	sha256-kdf.o \
+	sha256-prf.o \
+	sha256-tlsprf.o
+
+else
+
+CFLAGS += -DCONFIG_CRYPTO_INTERNAL
+CFLAGS += -DCONFIG_TLS_INTERNAL_CLIENT
+CFLAGS += -DCONFIG_TLS_INTERNAL_SERVER
 CFLAGS += -DCONFIG_INTERNAL_SHA384
 
 LIB_OBJS= \
@@ -13,7 +124,6 @@ LIB_OBJS= \
 	aes-ctr.o \
 	aes-eax.o \
 	aes-encblock.o \
-	aes-gcm.o \
 	aes-internal.o \
 	aes-internal-dec.o \
 	aes-internal-enc.o \
@@ -37,6 +147,7 @@ LIB_OBJS= \
 	sha1-tlsprf.o \
 	sha1-tprf.o \
 	sha256.o \
+	sha256-kdf.o \
 	sha256-prf.o \
 	sha256-tlsprf.o \
 	sha256-internal.o \
@@ -53,6 +164,16 @@ LIB_OBJS += crypto_internal-modexp.o
 LIB_OBJS += crypto_internal-rsa.o
 LIB_OBJS += tls_internal.o
 LIB_OBJS += fips_prf_internal.o
+
+endif
+endif
+endif
+endif
+
+
+# (used by wlantest/{bip,gcmp,rx_mgmt}.c and tests/test-aes.c)
+LIB_OBJS += aes-gcm.o
+
 ifndef TEST_FUZZ
 LIB_OBJS += random.o
 endif
diff --git a/src/crypto/crypto_mbedtls.c b/src/crypto/crypto_mbedtls.c
new file mode 100644
index 0000000..7a91c96
--- /dev/null
+++ b/src/crypto/crypto_mbedtls.c
@@ -0,0 +1,4228 @@
+/*
+ * crypto wrapper functions for mbed TLS
+ *
+ * SPDX-FileCopyrightText: 2022 Glenn Strauss <gstrauss@gluelogic.com>
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include "utils/includes.h"
+#include "utils/common.h"
+
+#include <mbedtls/version.h>
+#include <mbedtls/entropy.h>
+#include <mbedtls/ctr_drbg.h>
+#include <mbedtls/platform_util.h> /* mbedtls_platform_zeroize() */
+#include <mbedtls/asn1.h>
+#include <mbedtls/asn1write.h>
+#include <mbedtls/aes.h>
+#include <mbedtls/md.h>
+#include <mbedtls/md5.h>
+#include <mbedtls/sha1.h>
+#include <mbedtls/sha256.h>
+#include <mbedtls/sha512.h>
+
+#ifndef MBEDTLS_PRIVATE
+#define MBEDTLS_PRIVATE(x) x
+#endif
+
+/* hostapd/wpa_supplicant provides forced_memzero(),
+ * but prefer mbedtls_platform_zeroize() */
+#define forced_memzero(ptr,sz) mbedtls_platform_zeroize(ptr,sz)
+
+#ifndef __has_attribute
+#define __has_attribute(x) 0
+#endif
+
+#ifndef __GNUC_PREREQ
+#define __GNUC_PREREQ(maj,min) 0
+#endif
+
+#ifndef __attribute_cold__
+#if __has_attribute(cold) \
+ || __GNUC_PREREQ(4,3)
+#define __attribute_cold__  __attribute__((__cold__))
+#else
+#define __attribute_cold__
+#endif
+#endif
+
+#ifndef __attribute_noinline__
+#if __has_attribute(noinline) \
+ || __GNUC_PREREQ(3,1)
+#define __attribute_noinline__  __attribute__((__noinline__))
+#else
+#define __attribute_noinline__
+#endif
+#endif
+
+#include "crypto.h"
+#include "aes_wrap.h"
+#include "aes.h"
+#include "md5.h"
+#include "sha1.h"
+#include "sha256.h"
+#include "sha384.h"
+#include "sha512.h"
+
+
+/*
+ * selective code inclusion based on preprocessor defines
+ *
+ * future: additional code could be wrapped with preprocessor checks if
+ * wpa_supplicant/Makefile and hostap/Makefile were more consistent with
+ * setting preprocessor defines for named groups of functionality
+ */
+
+#if defined(CONFIG_FIPS)
+#undef MBEDTLS_MD4_C     /* omit md4_vector() */
+#undef MBEDTLS_MD5_C     /* omit md5_vector() hmac_md5_vector() hmac_md5() */
+#undef MBEDTLS_DES_C     /* omit des_encrypt() */
+#undef MBEDTLS_NIST_KW_C /* omit aes_wrap() aes_unwrap() */
+#define CRYPTO_MBEDTLS_CONFIG_FIPS
+#endif
+
+#if !defined(CONFIG_FIPS)
+#if defined(EAP_PWD) \
+ || defined(EAP_LEAP) || defined(EAP_LEAP_DYNAMIC) \
+ || defined(EAP_TTLS) || defined(EAP_TTLS_DYNAMIC) \
+ || defined(EAP_MSCHAPv2) || defined(EAP_MSCHAPv2_DYNAMIC) \
+ || defined(EAP_SERVER_MSCHAPV2)
+#ifndef MBEDTLS_MD4_C    /* (MD4 not in mbedtls 3.x) */
+#include "md4-internal.c"/* pull in hostap local implementation */
+#endif /* md4_vector() */
+#else
+#undef MBEDTLS_MD4_C     /* omit md4_vector() */
+#endif
+#endif
+
+#if !defined(CONFIG_NO_RC4) && !defined(CONFIG_NO_WPA)
+#ifndef MBEDTLS_ARC4_C   /* (RC4 not in mbedtls 3.x) */
+#include "rc4.c"         /* pull in hostap local implementation */
+#endif /* rc4_skip() */
+#else
+#undef MBEDTLS_ARC4_C    /* omit rc4_skip() */
+#endif
+
+#if defined(CONFIG_MACSEC)     \
+ || defined(CONFIG_NO_RADIUS)  \
+ || defined(CONFIG_IEEE80211R) \
+ || defined(EAP_SERVER_FAST)   \
+ || defined(EAP_SERVER_TEAP)   \
+ || !defined(CONFIG_NO_WPA)
+       /* aes_wrap() aes_unwrap() */
+#else
+#undef MBEDTLS_NIST_KW_C /* omit aes_wrap() aes_unwrap() */
+#endif
+
+#if !defined(CONFIG_SHA256)
+#undef MBEDTLS_SHA256_C
+#endif
+
+#if !defined(CONFIG_SHA384) && !defined(CONFIG_SHA512)
+#undef MBEDTLS_SHA512_C
+#endif
+
+#if defined(CONFIG_HMAC_SHA256_KDF)
+#define CRYPTO_MBEDTLS_HMAC_KDF_SHA256
+#endif
+#if defined(CONFIG_HMAC_SHA384_KDF)
+#define CRYPTO_MBEDTLS_HMAC_KDF_SHA384
+#endif
+#if defined(CONFIG_HMAC_SHA512_KDF)
+#define CRYPTO_MBEDTLS_HMAC_KDF_SHA512
+#endif
+
+#if defined(EAP_SIM) || defined(EAP_SIM_DYNAMIC) || defined(EAP_SERVER_SIM) \
+ || defined(EAP_AKA) || defined(EAP_AKA_DYNAMIC) || defined(EAP_SERVER_AKA)
+/* EAP_SIM=y EAP_AKA=y */
+#define CRYPTO_MBEDTLS_FIPS186_2_PRF
+#endif
+
+#if defined(EAP_FAST) || defined(EAP_FAST_DYNAMIC) || defined(EAP_SERVER_FAST) \
+ || defined(EAP_TEAP) || defined(EAP_TEAP_DYNAMIC) || defined(EAP_SERVER_FAST)
+#define CRYPTO_MBEDTLS_SHA1_T_PRF
+#endif
+
+#if defined(CONFIG_DES)
+#define CRYPTO_MBEDTLS_DES_ENCRYPT
+#endif /* des_encrypt() */
+
+#if !defined(CONFIG_NO_PBKDF2)
+#define CRYPTO_MBEDTLS_PBKDF2_SHA1
+#endif /* pbkdf2_sha1() */
+
+#if defined(EAP_IKEV2) \
+ || defined(EAP_IKEV2_DYNAMIC) \
+ || defined(EAP_SERVER_IKEV2) /* CONFIG_EAP_IKEV2=y */
+#define CRYPTO_MBEDTLS_CRYPTO_CIPHER
+#endif /* crypto_cipher_*() */
+
+#if defined(EAP_PWD) || defined(EAP_SERVER_PWD) /* CONFIG_EAP_PWD=y */
+#define CRYPTO_MBEDTLS_CRYPTO_HASH
+#endif /* crypto_hash_*() */
+
+#if defined(EAP_PWD) || defined(EAP_SERVER_PWD) /* CONFIG_EAP_PWD=y */ \
+ || defined(CONFIG_SAE) /* CONFIG_SAE=y */
+#define CRYPTO_MBEDTLS_CRYPTO_BIGNUM
+#endif /* crypto_bignum_*() */
+
+#if defined(EAP_PWD)          /* CONFIG_EAP_PWD=y */    \
+ || defined(EAP_EKE)          /* CONFIG_EAP_EKE=y */    \
+ || defined(EAP_EKE_DYNAMIC)  /* CONFIG_EAP_EKE=y */    \
+ || defined(EAP_SERVER_EKE)   /* CONFIG_EAP_EKE=y */    \
+ || defined(EAP_IKEV2)        /* CONFIG_EAP_IKEV2y */   \
+ || defined(EAP_IKEV2_DYNAMIC)/* CONFIG_EAP_IKEV2=y */  \
+ || defined(EAP_SERVER_IKEV2) /* CONFIG_EAP_IKEV2=y */  \
+ || defined(CONFIG_SAE)       /* CONFIG_SAE=y */        \
+ || defined(CONFIG_WPS)       /* CONFIG_WPS=y */
+#define CRYPTO_MBEDTLS_CRYPTO_DH
+#if defined(CONFIG_WPS_NFC)
+#define CRYPTO_MBEDTLS_DH5_INIT_FIXED
+#endif /* dh5_init_fixed() */
+#endif /* crypto_dh_*() */
+
+#if !defined(CONFIG_NO_WPA) /* CONFIG_NO_WPA= */
+#define CRYPTO_MBEDTLS_CRYPTO_ECDH
+#endif /* crypto_ecdh_*() */
+
+#if defined(CONFIG_ECC)
+#define CRYPTO_MBEDTLS_CRYPTO_BIGNUM
+#define CRYPTO_MBEDTLS_CRYPTO_EC
+#endif /* crypto_ec_*() crypto_ec_key_*() */
+
+#if defined(CONFIG_DPP) /* CONFIG_DPP=y */
+#define CRYPTO_MBEDTLS_CRYPTO_EC_DPP /* extra for DPP */
+#define CRYPTO_MBEDTLS_CRYPTO_CSR
+#endif /* crypto_csr_*() */
+
+#if defined(CONFIG_DPP3) /* CONFIG_DPP3=y */
+#define CRYPTO_MBEDTLS_CRYPTO_HPKE
+#endif
+
+#if defined(CONFIG_DPP2) /* CONFIG_DPP2=y */
+#define CRYPTO_MBEDTLS_CRYPTO_PKCS7
+#endif /* crypto_pkcs7_*() */
+
+#if defined(EAP_SIM) || defined(EAP_SIM_DYNAMIC) || defined(EAP_SERVER_SIM) \
+ || defined(EAP_AKA) || defined(EAP_AKA_DYNAMIC) || defined(EAP_SERVER_AKA) \
+ || defined(CONFIG_AP) || defined(HOSTAPD)
+/* CONFIG_EAP_SIM=y CONFIG_EAP_AKA=y CONFIG_AP=y HOSTAPD */
+#if defined(CRYPTO_RSA_OAEP_SHA256)
+#define CRYPTO_MBEDTLS_CRYPTO_RSA
+#endif
+#endif /* crypto_rsa_*() */
+
+
+static int ctr_drbg_init_state;
+static mbedtls_ctr_drbg_context ctr_drbg;
+static mbedtls_entropy_context entropy;
+
+#ifdef CRYPTO_MBEDTLS_CRYPTO_BIGNUM
+#include <mbedtls/bignum.h>
+static mbedtls_mpi mpi_sw_A;
+#endif
+
+__attribute_cold__
+__attribute_noinline__
+static mbedtls_ctr_drbg_context * ctr_drbg_init(void)
+{
+	mbedtls_ctr_drbg_init(&ctr_drbg);
+	mbedtls_entropy_init(&entropy);
+	if (mbedtls_ctr_drbg_seed(&ctr_drbg, mbedtls_entropy_func, &entropy,
+	                          NULL, 0)) {
+		wpa_printf(MSG_ERROR, "Init of random number generator failed");
+		/* XXX: abort? */
+	}
+	else
+		ctr_drbg_init_state = 1;
+
+	return &ctr_drbg;
+}
+
+__attribute_cold__
+void crypto_unload(void)
+{
+	if (ctr_drbg_init_state) {
+		mbedtls_ctr_drbg_free(&ctr_drbg);
+		mbedtls_entropy_free(&entropy);
+	  #ifdef CRYPTO_MBEDTLS_CRYPTO_BIGNUM
+		mbedtls_mpi_free(&mpi_sw_A);
+	  #endif
+		ctr_drbg_init_state = 0;
+	}
+}
+
+/* init ctr_drbg on first use
+ * crypto_global_init() and crypto_global_deinit() are not available here
+ * (available only when CONFIG_TLS=internal, which is not CONFIG_TLS=mbedtls) */
+mbedtls_ctr_drbg_context * crypto_mbedtls_ctr_drbg(void); /*(not in header)*/
+inline
+mbedtls_ctr_drbg_context * crypto_mbedtls_ctr_drbg(void)
+{
+	return ctr_drbg_init_state ? &ctr_drbg : ctr_drbg_init();
+}
+
+#ifdef CRYPTO_MBEDTLS_CONFIG_FIPS
+int crypto_get_random(void *buf, size_t len)
+{
+	return mbedtls_ctr_drbg_random(crypto_mbedtls_ctr_drbg(),buf,len) ? -1 : 0;
+}
+#endif
+
+
+#if 1
+
+/* tradeoff: slightly smaller code size here at cost of slight increase
+ * in instructions and function calls at runtime versus the expanded
+ * per-message-digest code that follows in #else (~0.5 kib .text larger) */
+
+__attribute_noinline__
+static int md_vector(size_t num_elem, const u8 *addr[], const size_t *len,
+                     u8 *mac, mbedtls_md_type_t md_type)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	mbedtls_md_context_t ctx;
+	mbedtls_md_init(&ctx);
+	if (mbedtls_md_setup(&ctx, mbedtls_md_info_from_type(md_type), 0) != 0){
+		mbedtls_md_free(&ctx);
+		return -1;
+	}
+	mbedtls_md_starts(&ctx);
+	for (size_t i = 0; i < num_elem; ++i)
+		mbedtls_md_update(&ctx, addr[i], len[i]);
+	mbedtls_md_finish(&ctx, mac);
+	mbedtls_md_free(&ctx);
+	return 0;
+}
+
+#ifdef MBEDTLS_SHA512_C
+int sha512_vector(size_t num_elem, const u8 *addr[], const size_t *len, u8 *mac)
+{
+	return md_vector(num_elem, addr, len, mac, MBEDTLS_MD_SHA512);
+}
+
+int sha384_vector(size_t num_elem, const u8 *addr[], const size_t *len, u8 *mac)
+{
+	return md_vector(num_elem, addr, len, mac, MBEDTLS_MD_SHA384);
+}
+#endif
+
+#ifdef MBEDTLS_SHA256_C
+int sha256_vector(size_t num_elem, const u8 *addr[], const size_t *len, u8 *mac)
+{
+	return md_vector(num_elem, addr, len, mac, MBEDTLS_MD_SHA256);
+}
+#endif
+
+#ifdef MBEDTLS_SHA1_C
+int sha1_vector(size_t num_elem, const u8 *addr[], const size_t *len, u8 *mac)
+{
+	return md_vector(num_elem, addr, len, mac, MBEDTLS_MD_SHA1);
+}
+#endif
+
+#ifdef MBEDTLS_MD5_C
+int md5_vector(size_t num_elem, const u8 *addr[], const size_t *len, u8 *mac)
+{
+	return md_vector(num_elem, addr, len, mac, MBEDTLS_MD_MD5);
+}
+#endif
+
+#ifdef MBEDTLS_MD4_C
+#include <mbedtls/md4.h>
+int md4_vector(size_t num_elem, const u8 *addr[], const size_t *len, u8 *mac)
+{
+	return md_vector(num_elem, addr, len, mac, MBEDTLS_MD_MD4);
+}
+#endif
+
+#else  /* expanded per-message-digest functions */
+
+#ifdef MBEDTLS_SHA512_C
+#include <mbedtls/sha512.h>
+__attribute_noinline__
+static int sha384_512_vector(size_t num_elem, const u8 *addr[],
+                             const size_t *len, u8 *mac, int is384)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	struct mbedtls_sha512_context ctx;
+	mbedtls_sha512_init(&ctx);
+  #if MBEDTLS_VERSION_MAJOR >= 3
+	mbedtls_sha512_starts(&ctx, is384);
+	for (size_t i = 0; i < num_elem; ++i)
+		mbedtls_sha512_update(&ctx, addr[i], len[i]);
+	mbedtls_sha512_finish(&ctx, mac);
+  #else
+	mbedtls_sha512_starts_ret(&ctx, is384);
+	for (size_t i = 0; i < num_elem; ++i)
+		mbedtls_sha512_update_ret(&ctx, addr[i], len[i]);
+	mbedtls_sha512_finish_ret(&ctx, mac);
+  #endif
+	mbedtls_sha512_free(&ctx);
+	return 0;
+}
+
+int sha512_vector(size_t num_elem, const u8 *addr[], const size_t *len, u8 *mac)
+{
+	return sha384_512_vector(num_elem, addr, len, mac, 0);
+}
+
+int sha384_vector(size_t num_elem, const u8 *addr[], const size_t *len, u8 *mac)
+{
+	return sha384_512_vector(num_elem, addr, len, mac, 1);
+}
+#endif
+
+#ifdef MBEDTLS_SHA256_C
+#include <mbedtls/sha256.h>
+int sha256_vector(size_t num_elem, const u8 *addr[], const size_t *len, u8 *mac)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	struct mbedtls_sha256_context ctx;
+	mbedtls_sha256_init(&ctx);
+  #if MBEDTLS_VERSION_MAJOR >= 3
+	mbedtls_sha256_starts(&ctx, 0);
+	for (size_t i = 0; i < num_elem; ++i)
+		mbedtls_sha256_update(&ctx, addr[i], len[i]);
+	mbedtls_sha256_finish(&ctx, mac);
+  #else
+	mbedtls_sha256_starts_ret(&ctx, 0);
+	for (size_t i = 0; i < num_elem; ++i)
+		mbedtls_sha256_update_ret(&ctx, addr[i], len[i]);
+	mbedtls_sha256_finish_ret(&ctx, mac);
+  #endif
+	mbedtls_sha256_free(&ctx);
+	return 0;
+}
+#endif
+
+#ifdef MBEDTLS_SHA1_C
+#include <mbedtls/sha1.h>
+int sha1_vector(size_t num_elem, const u8 *addr[], const size_t *len, u8 *mac)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	struct mbedtls_sha1_context ctx;
+	mbedtls_sha1_init(&ctx);
+  #if MBEDTLS_VERSION_MAJOR >= 3
+	mbedtls_sha1_starts(&ctx);
+	for (size_t i = 0; i < num_elem; ++i)
+		mbedtls_sha1_update(&ctx, addr[i], len[i]);
+	mbedtls_sha1_finish(&ctx, mac);
+  #else
+	mbedtls_sha1_starts_ret(&ctx);
+	for (size_t i = 0; i < num_elem; ++i)
+		mbedtls_sha1_update_ret(&ctx, addr[i], len[i]);
+	mbedtls_sha1_finish_ret(&ctx, mac);
+  #endif
+	mbedtls_sha1_free(&ctx);
+	return 0;
+}
+#endif
+
+#ifdef MBEDTLS_MD5_C
+#include <mbedtls/md5.h>
+int md5_vector(size_t num_elem, const u8 *addr[], const size_t *len, u8 *mac)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	struct mbedtls_md5_context ctx;
+	mbedtls_md5_init(&ctx);
+  #if MBEDTLS_VERSION_MAJOR >= 3
+	mbedtls_md5_starts(&ctx);
+	for (size_t i = 0; i < num_elem; ++i)
+		mbedtls_md5_update(&ctx, addr[i], len[i]);
+	mbedtls_md5_finish(&ctx, mac);
+  #else
+	mbedtls_md5_starts_ret(&ctx);
+	for (size_t i = 0; i < num_elem; ++i)
+		mbedtls_md5_update_ret(&ctx, addr[i], len[i]);
+	mbedtls_md5_finish_ret(&ctx, mac);
+  #endif
+	mbedtls_md5_free(&ctx);
+	return 0;
+}
+#endif
+
+#ifdef MBEDTLS_MD4_C
+#include <mbedtls/md4.h>
+int md4_vector(size_t num_elem, const u8 *addr[], const size_t *len, u8 *mac)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	struct mbedtls_md4_context ctx;
+	mbedtls_md4_init(&ctx);
+	mbedtls_md4_starts_ret(&ctx);
+	for (size_t i = 0; i < num_elem; ++i)
+		mbedtls_md4_update_ret(&ctx, addr[i], len[i]);
+	mbedtls_md4_finish_ret(&ctx, mac);
+	mbedtls_md4_free(&ctx);
+	return 0;
+}
+#endif
+
+#endif /* expanded per-message-digest functions */
+
+
+__attribute_noinline__
+static int hmac_vector(const u8 *key, size_t key_len, size_t num_elem,
+                       const u8 *addr[], const size_t *len, u8 *mac,
+                       mbedtls_md_type_t md_type)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	mbedtls_md_context_t ctx;
+	mbedtls_md_init(&ctx);
+	if (mbedtls_md_setup(&ctx, mbedtls_md_info_from_type(md_type), 1) != 0){
+		mbedtls_md_free(&ctx);
+		return -1;
+	}
+	mbedtls_md_hmac_starts(&ctx, key, key_len);
+	for (size_t i = 0; i < num_elem; ++i)
+		mbedtls_md_hmac_update(&ctx, addr[i], len[i]);
+	mbedtls_md_hmac_finish(&ctx, mac);
+	mbedtls_md_free(&ctx);
+	return 0;
+}
+
+#ifdef MBEDTLS_SHA512_C
+int hmac_sha512_vector(const u8 *key, size_t key_len, size_t num_elem,
+                       const u8 *addr[], const size_t *len, u8 *mac)
+{
+	return hmac_vector(key, key_len, num_elem, addr, len, mac,
+			   MBEDTLS_MD_SHA512);
+}
+
+int hmac_sha512(const u8 *key, size_t key_len, const u8 *data, size_t data_len,
+                u8 *mac)
+{
+	return hmac_vector(key, key_len, 1, &data, &data_len, mac,
+			   MBEDTLS_MD_SHA512);
+}
+
+int hmac_sha384_vector(const u8 *key, size_t key_len, size_t num_elem,
+                       const u8 *addr[], const size_t *len, u8 *mac)
+{
+	return hmac_vector(key, key_len, num_elem, addr, len, mac,
+			   MBEDTLS_MD_SHA384);
+}
+
+int hmac_sha384(const u8 *key, size_t key_len, const u8 *data, size_t data_len,
+                u8 *mac)
+{
+	return hmac_vector(key, key_len, 1, &data, &data_len, mac,
+			   MBEDTLS_MD_SHA384);
+}
+#endif
+
+#ifdef MBEDTLS_SHA256_C
+int hmac_sha256_vector(const u8 *key, size_t key_len, size_t num_elem,
+                       const u8 *addr[], const size_t *len, u8 *mac)
+{
+	return hmac_vector(key, key_len, num_elem, addr, len, mac,
+			   MBEDTLS_MD_SHA256);
+}
+
+int hmac_sha256(const u8 *key, size_t key_len, const u8 *data, size_t data_len,
+                u8 *mac)
+{
+	return hmac_vector(key, key_len, 1, &data, &data_len, mac,
+			   MBEDTLS_MD_SHA256);
+}
+#endif
+
+#ifdef MBEDTLS_SHA1_C
+int hmac_sha1_vector(const u8 *key, size_t key_len, size_t num_elem,
+                     const u8 *addr[], const size_t *len, u8 *mac)
+{
+	return hmac_vector(key, key_len, num_elem, addr, len, mac,
+			   MBEDTLS_MD_SHA1);
+}
+
+int hmac_sha1(const u8 *key, size_t key_len, const u8 *data, size_t data_len,
+              u8 *mac)
+{
+	return hmac_vector(key, key_len, 1, &data, &data_len, mac,
+			   MBEDTLS_MD_SHA1);
+}
+#endif
+
+#ifdef MBEDTLS_MD5_C
+int hmac_md5_vector(const u8 *key, size_t key_len, size_t num_elem,
+                    const u8 *addr[], const size_t *len, u8 *mac)
+{
+	return hmac_vector(key, key_len, num_elem, addr, len, mac,
+			   MBEDTLS_MD_MD5);
+}
+
+int hmac_md5(const u8 *key, size_t key_len, const u8 *data, size_t data_len,
+             u8 *mac)
+{
+	return hmac_vector(key, key_len, 1, &data, &data_len, mac,
+			   MBEDTLS_MD_MD5);
+}
+#endif
+
+
+#if defined(MBEDTLS_SHA256_C) || defined(MBEDTLS_SHA512_C)
+
+#if defined(CRYPTO_MBEDTLS_HMAC_KDF_SHA256) \
+ || defined(CRYPTO_MBEDTLS_HMAC_KDF_SHA384) \
+ || defined(CRYPTO_MBEDTLS_HMAC_KDF_SHA512)
+
+#include <mbedtls/hkdf.h>
+
+/* sha256-kdf.c sha384-kdf.c sha512-kdf.c */
+
+/* HMAC-SHA256 KDF (RFC 5295) and HKDF-Expand(SHA256) (RFC 5869) */
+/* HMAC-SHA384 KDF (RFC 5295) and HKDF-Expand(SHA384) (RFC 5869) */
+/* HMAC-SHA512 KDF (RFC 5295) and HKDF-Expand(SHA512) (RFC 5869) */
+__attribute_noinline__
+static int hmac_kdf_expand(const u8 *prk, size_t prk_len,
+                           const char *label, const u8 *info, size_t info_len,
+                           u8 *okm, size_t okm_len, mbedtls_md_type_t md_type)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	const mbedtls_md_info_t *md_info = mbedtls_md_info_from_type(md_type);
+  #ifdef MBEDTLS_HKDF_C
+	if (label == NULL)  /* RFC 5869 HKDF-Expand when (label == NULL) */
+		return mbedtls_hkdf_expand(md_info, prk, prk_len, info,
+		                           info_len, okm, okm_len) ? -1 : 0;
+  #endif
+
+	const size_t mac_len = mbedtls_md_get_size(md_info);
+	/* okm_len must not exceed 255 times hash len (RFC 5869 Section 2.3) */
+	if (okm_len > ((mac_len << 8) - mac_len))
+		return -1;
+
+	mbedtls_md_context_t ctx;
+	mbedtls_md_init(&ctx);
+	if (mbedtls_md_setup(&ctx, md_info, 1) != 0) {
+		mbedtls_md_free(&ctx);
+		return -1;
+	}
+	mbedtls_md_hmac_starts(&ctx, prk, prk_len);
+
+	u8 iter = 1;
+	const u8 *addr[4] = { okm, (const u8 *)label, info, &iter };
+	size_t len[4] = { 0, label ? os_strlen(label)+1 : 0, info_len, 1 };
+
+	for (; okm_len >= mac_len; okm_len -= mac_len, ++iter) {
+		for (size_t i = 0; i < ARRAY_SIZE(addr); ++i)
+			mbedtls_md_hmac_update(&ctx, addr[i], len[i]);
+		mbedtls_md_hmac_finish(&ctx, okm);
+		mbedtls_md_hmac_reset(&ctx);
+		addr[0] = okm;
+		okm += mac_len;
+		len[0] = mac_len; /*(include digest in subsequent rounds)*/
+	}
+
+	if (okm_len) {
+		u8 hash[MBEDTLS_MD_MAX_SIZE];
+		for (size_t i = 0; i < ARRAY_SIZE(addr); ++i)
+			mbedtls_md_hmac_update(&ctx, addr[i], len[i]);
+		mbedtls_md_hmac_finish(&ctx, hash);
+		os_memcpy(okm, hash, okm_len);
+		forced_memzero(hash, mac_len);
+	}
+
+	mbedtls_md_free(&ctx);
+	return 0;
+}
+
+#ifdef MBEDTLS_SHA512_C
+#ifdef CRYPTO_MBEDTLS_HMAC_KDF_SHA512
+int hmac_sha512_kdf(const u8 *secret, size_t secret_len,
+		    const char *label, const u8 *seed, size_t seed_len,
+		    u8 *out, size_t outlen)
+{
+	return hmac_kdf_expand(secret, secret_len, label, seed, seed_len,
+	                       out, outlen, MBEDTLS_MD_SHA512);
+}
+#endif
+
+#ifdef CRYPTO_MBEDTLS_HMAC_KDF_SHA384
+int hmac_sha384_kdf(const u8 *secret, size_t secret_len,
+		    const char *label, const u8 *seed, size_t seed_len,
+		    u8 *out, size_t outlen)
+{
+	return hmac_kdf_expand(secret, secret_len, label, seed, seed_len,
+	                       out, outlen, MBEDTLS_MD_SHA384);
+}
+#endif
+#endif
+
+#ifdef MBEDTLS_SHA256_C
+#ifdef CRYPTO_MBEDTLS_HMAC_KDF_SHA256
+int hmac_sha256_kdf(const u8 *secret, size_t secret_len,
+		    const char *label, const u8 *seed, size_t seed_len,
+		    u8 *out, size_t outlen)
+{
+	return hmac_kdf_expand(secret, secret_len, label, seed, seed_len,
+	                       out, outlen, MBEDTLS_MD_SHA256);
+}
+#endif
+#endif
+
+#endif /* CRYPTO_MBEDTLS_HMAC_KDF_* */
+
+
+/* sha256-prf.c sha384-prf.c sha512-prf.c */
+
+/* hmac_prf_bits - IEEE Std 802.11ac-2013, 11.6.1.7.2 Key derivation function */
+__attribute_noinline__
+static int hmac_prf_bits(const u8 *key, size_t key_len, const char *label,
+                         const u8 *data, size_t data_len, u8 *buf,
+                         size_t buf_len_bits, mbedtls_md_type_t md_type)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	mbedtls_md_context_t ctx;
+	mbedtls_md_init(&ctx);
+	const mbedtls_md_info_t *md_info = mbedtls_md_info_from_type(md_type);
+	if (mbedtls_md_setup(&ctx, md_info, 1) != 0) {
+		mbedtls_md_free(&ctx);
+		return -1;
+	}
+	mbedtls_md_hmac_starts(&ctx, key, key_len);
+
+	u16 ctr, n_le = host_to_le16(buf_len_bits);
+	const u8 * const addr[] = { (u8 *)&ctr,(u8 *)label,data,(u8 *)&n_le };
+	const size_t len[] =      { 2, os_strlen(label), data_len, 2 };
+	const size_t mac_len = mbedtls_md_get_size(md_info);
+	size_t buf_len = (buf_len_bits + 7) / 8;
+	for (ctr = 1; buf_len >= mac_len; buf_len -= mac_len, ++ctr) {
+	  #if __BYTE_ORDER == __BIG_ENDIAN
+		ctr = host_to_le16(ctr);
+	  #endif
+		for (size_t i = 0; i < ARRAY_SIZE(addr); ++i)
+			mbedtls_md_hmac_update(&ctx, addr[i], len[i]);
+		mbedtls_md_hmac_finish(&ctx, buf);
+		mbedtls_md_hmac_reset(&ctx);
+		buf += mac_len;
+	  #if __BYTE_ORDER == __BIG_ENDIAN
+		ctr = le_to_host16(ctr);
+	  #endif
+	}
+
+	if (buf_len) {
+		u8 hash[MBEDTLS_MD_MAX_SIZE];
+	  #if __BYTE_ORDER == __BIG_ENDIAN
+		ctr = host_to_le16(ctr);
+	  #endif
+		for (size_t i = 0; i < ARRAY_SIZE(addr); ++i)
+			mbedtls_md_hmac_update(&ctx, addr[i], len[i]);
+		mbedtls_md_hmac_finish(&ctx, hash);
+		os_memcpy(buf, hash, buf_len);
+		buf += buf_len;
+		forced_memzero(hash, mac_len);
+	}
+
+	/* Mask out unused bits in last octet if it does not use all the bits */
+	if ((buf_len_bits &= 0x7))
+		buf[-1] &= (u8)(0xff << (8 - buf_len_bits));
+
+	mbedtls_md_free(&ctx);
+	return 0;
+}
+
+#ifdef MBEDTLS_SHA512_C
+int sha512_prf(const u8 *key, size_t key_len, const char *label,
+               const u8 *data, size_t data_len, u8 *buf, size_t buf_len)
+{
+	return hmac_prf_bits(key, key_len, label, data, data_len, buf,
+	                     buf_len * 8, MBEDTLS_MD_SHA512);
+}
+
+int sha384_prf(const u8 *key, size_t key_len, const char *label,
+               const u8 *data, size_t data_len, u8 *buf, size_t buf_len)
+{
+	return hmac_prf_bits(key, key_len, label, data, data_len, buf,
+	                     buf_len * 8, MBEDTLS_MD_SHA384);
+}
+#endif
+
+#ifdef MBEDTLS_SHA256_C
+int sha256_prf(const u8 *key, size_t key_len, const char *label,
+               const u8 *data, size_t data_len, u8 *buf, size_t buf_len)
+{
+	return hmac_prf_bits(key, key_len, label, data, data_len, buf,
+	                     buf_len * 8, MBEDTLS_MD_SHA256);
+}
+
+int sha256_prf_bits(const u8 *key, size_t key_len, const char *label,
+                    const u8 *data, size_t data_len, u8 *buf,
+                    size_t buf_len_bits)
+{
+	return hmac_prf_bits(key, key_len, label, data, data_len, buf,
+	                     buf_len_bits, MBEDTLS_MD_SHA256);
+}
+#endif
+
+#endif /* MBEDTLS_SHA256_C || MBEDTLS_SHA512_C */
+
+
+#ifdef MBEDTLS_SHA1_C
+
+/* sha1-prf.c */
+
+/* sha1_prf - SHA1-based Pseudo-Random Function (PRF) (IEEE 802.11i, 8.5.1.1) */
+
+int sha1_prf(const u8 *key, size_t key_len, const char *label,
+	     const u8 *data, size_t data_len, u8 *buf, size_t buf_len)
+{
+	/*(note: algorithm differs from hmac_prf_bits() */
+	/*(note: smaller code size instead of expanding hmac_sha1_vector()
+	 * as is done in hmac_prf_bits(); not expecting large num of loops) */
+	u8 counter = 0;
+	const u8 *addr[] = { (u8 *)label, data, &counter };
+	const size_t len[] = { os_strlen(label)+1, data_len, 1 };
+
+	for (; buf_len >= SHA1_MAC_LEN; buf_len -= SHA1_MAC_LEN, ++counter) {
+		if (hmac_sha1_vector(key, key_len, 3, addr, len, buf))
+			return -1;
+		buf += SHA1_MAC_LEN;
+	}
+
+	if (buf_len) {
+		u8 hash[SHA1_MAC_LEN];
+		if (hmac_sha1_vector(key, key_len, 3, addr, len, hash))
+			return -1;
+		os_memcpy(buf, hash, buf_len);
+		forced_memzero(hash, sizeof(hash));
+	}
+
+	return 0;
+}
+
+#ifdef CRYPTO_MBEDTLS_SHA1_T_PRF
+
+/* sha1-tprf.c */
+
+/* sha1_t_prf - EAP-FAST Pseudo-Random Function (T-PRF) (RFC 4851,Section 5.5)*/
+
+int sha1_t_prf(const u8 *key, size_t key_len, const char *label,
+	       const u8 *seed, size_t seed_len, u8 *buf, size_t buf_len)
+{
+	/*(note: algorithm differs from hmac_prf_bits() and hmac_kdf() above)*/
+	/*(note: smaller code size instead of expanding hmac_sha1_vector()
+	 * as is done in hmac_prf_bits(); not expecting large num of loops) */
+	u8 ctr;
+	u16 olen = host_to_be16(buf_len);
+	const u8 *addr[] = { buf, (u8 *)label, seed, (u8 *)&olen, &ctr };
+	size_t len[] = { 0, os_strlen(label)+1, seed_len, 2, 1 };
+
+	for (ctr = 1; buf_len >= SHA1_MAC_LEN; buf_len -= SHA1_MAC_LEN, ++ctr) {
+		if (hmac_sha1_vector(key, key_len, 5, addr, len, buf))
+			return -1;
+		addr[0] = buf;
+		buf += SHA1_MAC_LEN;
+		len[0] = SHA1_MAC_LEN; /*(include digest in subsequent rounds)*/
+	}
+
+	if (buf_len) {
+		u8 hash[SHA1_MAC_LEN];
+		if (hmac_sha1_vector(key, key_len, 5, addr, len, hash))
+			return -1;
+		os_memcpy(buf, hash, buf_len);
+		forced_memzero(hash, sizeof(hash));
+	}
+
+	return 0;
+}
+
+#endif /* CRYPTO_MBEDTLS_SHA1_T_PRF */
+
+#ifdef CRYPTO_MBEDTLS_FIPS186_2_PRF
+
+/* fips_prf_internal.c sha1-internal.c */
+
+/* used only by src/eap_common/eap_sim_common.c:eap_sim_prf()
+ * for eap_sim_derive_keys() and eap_sim_derive_keys_reauth()
+ * where xlen is 160 */
+
+int fips186_2_prf(const u8 *seed, size_t seed_len, u8 *x, size_t xlen)
+{
+	/* FIPS 186-2 + change notice 1 */
+
+	mbedtls_sha1_context ctx;
+	u8 * const xkey = ctx.MBEDTLS_PRIVATE(buffer);
+	u32 * const xstate = ctx.MBEDTLS_PRIVATE(state);
+	const u32 xstate_init[] =
+	  { 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0 };
+
+	mbedtls_sha1_init(&ctx);
+	os_memcpy(xkey, seed, seed_len < 64 ? seed_len : 64);
+
+	/* note: does not fill extra bytes if (xlen % 20) (SHA1_MAC_LEN) */
+	for (; xlen >= 20; xlen -= 20) {
+		/* XSEED_j = 0 */
+		/* XVAL = (XKEY + XSEED_j) mod 2^b */
+
+		/* w_i = G(t, XVAL) */
+		os_memcpy(xstate, xstate_init, sizeof(xstate_init));
+		mbedtls_internal_sha1_process(&ctx, xkey);
+
+	  #if __BYTE_ORDER == __LITTLE_ENDIAN
+		xstate[0] = host_to_be32(xstate[0]);
+		xstate[1] = host_to_be32(xstate[1]);
+		xstate[2] = host_to_be32(xstate[2]);
+		xstate[3] = host_to_be32(xstate[3]);
+		xstate[4] = host_to_be32(xstate[4]);
+	  #endif
+		os_memcpy(x, xstate, 20);
+		if (xlen == 20) /*(done; skip prep for next loop)*/
+			break;
+
+		/* XKEY = (1 + XKEY + w_i) mod 2^b */
+		for (u32 carry = 1, k = 20; k-- > 0; carry >>= 8)
+			xkey[k] = (carry += xkey[k] + x[k]) & 0xff;
+		x += 20;
+		/* x_j = w_0|w_1 (each pair of iterations through loop)*/
+	}
+
+	mbedtls_sha1_free(&ctx);
+	return 0;
+}
+
+#endif /* CRYPTO_MBEDTLS_FIPS186_2_PRF */
+
+#endif /* MBEDTLS_SHA1_C */
+
+
+#ifdef CRYPTO_MBEDTLS_DES_ENCRYPT
+#ifdef MBEDTLS_DES_C
+#include <mbedtls/des.h>
+int des_encrypt(const u8 *clear, const u8 *key, u8 *cypher)
+{
+	u8 pkey[8], next, tmp;
+	int i;
+
+	/* Add parity bits to the key */
+	next = 0;
+	for (i = 0; i < 7; i++) {
+		tmp = key[i];
+		pkey[i] = (tmp >> i) | next | 1;
+		next = tmp << (7 - i);
+	}
+	pkey[i] = next | 1;
+
+	mbedtls_des_context des;
+	mbedtls_des_init(&des);
+	int ret = mbedtls_des_setkey_enc(&des, pkey)
+	       || mbedtls_des_crypt_ecb(&des, clear, cypher) ? -1 : 0;
+	mbedtls_des_free(&des);
+	return ret;
+}
+#else
+#include "des-internal.c"/* pull in hostap local implementation */
+#endif
+#endif
+
+
+#ifdef CRYPTO_MBEDTLS_PBKDF2_SHA1
+/* sha1-pbkdf2.c */
+#include <mbedtls/pkcs5.h>
+int pbkdf2_sha1(const char *passphrase, const u8 *ssid, size_t ssid_len,
+                int iterations, u8 *buf, size_t buflen)
+{
+  #if MBEDTLS_VERSION_NUMBER >= 0x03020200 /* mbedtls 3.2.2 */
+	return mbedtls_pkcs5_pbkdf2_hmac_ext(MBEDTLS_MD_SHA1,
+			(const u8 *)passphrase, os_strlen(passphrase),
+			ssid, ssid_len, iterations, 32, buf) ? -1 : 0;
+  #else
+	const mbedtls_md_info_t *md_info;
+	md_info = mbedtls_md_info_from_type(MBEDTLS_MD_SHA1);
+	if (md_info == NULL)
+		return -1;
+	mbedtls_md_context_t ctx;
+	mbedtls_md_init(&ctx);
+	int ret = mbedtls_md_setup(&ctx, md_info, 1)
+	       || mbedtls_pkcs5_pbkdf2_hmac(&ctx,
+			(const u8 *)passphrase, os_strlen(passphrase),
+			ssid, ssid_len, iterations, 32, buf) ? -1 : 0;
+	mbedtls_md_free(&ctx);
+	return ret;
+  #endif
+}
+#endif
+
+
+/*#include "aes.h"*/ /* prototypes also included in "crypto.h" */
+
+static void *aes_crypt_init_mode(const u8 *key, size_t len, int mode)
+{
+	if (TEST_FAIL())
+		return NULL;
+
+	mbedtls_aes_context *aes = os_malloc(sizeof(*aes));
+	if (!aes)
+		return NULL;
+
+	mbedtls_aes_init(aes);
+	if ((mode == MBEDTLS_AES_ENCRYPT
+	    ? mbedtls_aes_setkey_enc(aes, key, len * 8)
+	    : mbedtls_aes_setkey_dec(aes, key, len * 8)) == 0)
+		return aes;
+
+	mbedtls_aes_free(aes);
+	os_free(aes);
+	return NULL;
+}
+
+void *aes_encrypt_init(const u8 *key, size_t len)
+{
+	return aes_crypt_init_mode(key, len, MBEDTLS_AES_ENCRYPT);
+}
+
+int aes_encrypt(void *ctx, const u8 *plain, u8 *crypt)
+{
+	return mbedtls_aes_crypt_ecb(ctx, MBEDTLS_AES_ENCRYPT, plain, crypt);
+}
+
+void aes_encrypt_deinit(void *ctx)
+{
+	mbedtls_aes_free(ctx);
+	os_free(ctx);
+}
+
+void *aes_decrypt_init(const u8 *key, size_t len)
+{
+	return aes_crypt_init_mode(key, len, MBEDTLS_AES_DECRYPT);
+}
+
+int aes_decrypt(void *ctx, const u8 *crypt, u8 *plain)
+{
+	return mbedtls_aes_crypt_ecb(ctx, MBEDTLS_AES_DECRYPT, crypt, plain);
+}
+
+void aes_decrypt_deinit(void *ctx)
+{
+	mbedtls_aes_free(ctx);
+	os_free(ctx);
+}
+
+
+#include "aes_wrap.h"
+
+
+#ifdef MBEDTLS_NIST_KW_C
+
+#include <mbedtls/nist_kw.h>
+
+/* aes-wrap.c */
+int aes_wrap(const u8 *kek, size_t kek_len, int n, const u8 *plain, u8 *cipher)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	mbedtls_nist_kw_context ctx;
+	mbedtls_nist_kw_init(&ctx);
+	size_t olen;
+	int ret = mbedtls_nist_kw_setkey(&ctx, MBEDTLS_CIPHER_ID_AES,
+	                                 kek, kek_len*8, 1)
+	       || mbedtls_nist_kw_wrap(&ctx, MBEDTLS_KW_MODE_KW, plain, n*8,
+	                               cipher, &olen, (n+1)*8) ? -1 : 0;
+	mbedtls_nist_kw_free(&ctx);
+	return ret;
+}
+
+/* aes-unwrap.c */
+int aes_unwrap(const u8 *kek, size_t kek_len, int n, const u8 *cipher, u8 *plain)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	mbedtls_nist_kw_context ctx;
+	mbedtls_nist_kw_init(&ctx);
+	size_t olen;
+	int ret = mbedtls_nist_kw_setkey(&ctx, MBEDTLS_CIPHER_ID_AES,
+	                                 kek, kek_len*8, 0)
+	       || mbedtls_nist_kw_unwrap(&ctx, MBEDTLS_KW_MODE_KW, cipher,
+	                                 (n+1)*8, plain, &olen, n*8) ? -1 : 0;
+	mbedtls_nist_kw_free(&ctx);
+	return ret;
+}
+
+#else
+
+#ifndef CRYPTO_MBEDTLS_CONFIG_FIPS
+#include "aes-wrap.c"    /* pull in hostap local implementation */
+#include "aes-unwrap.c"  /* pull in hostap local implementation */
+#endif
+
+#endif /* MBEDTLS_NIST_KW_C */
+
+
+#ifdef MBEDTLS_CMAC_C
+
+/* aes-omac1.c */
+
+#include <mbedtls/cmac.h>
+
+int omac1_aes_vector(
+    const u8 *key, size_t key_len, size_t num_elem, const u8 *addr[],
+    const size_t *len, u8 *mac)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	mbedtls_cipher_type_t cipher_type;
+	switch (key_len) {
+	case 16: cipher_type = MBEDTLS_CIPHER_AES_128_ECB; break;
+	case 24: cipher_type = MBEDTLS_CIPHER_AES_192_ECB; break;
+	case 32: cipher_type = MBEDTLS_CIPHER_AES_256_ECB; break;
+	default: return -1;
+	}
+	const mbedtls_cipher_info_t *cipher_info;
+	cipher_info = mbedtls_cipher_info_from_type(cipher_type);
+	if (cipher_info == NULL)
+		return -1;
+
+	mbedtls_cipher_context_t ctx;
+	mbedtls_cipher_init(&ctx);
+	int ret = -1;
+	if (mbedtls_cipher_setup(&ctx, cipher_info) == 0
+	    && mbedtls_cipher_cmac_starts(&ctx, key, key_len*8) == 0) {
+		ret = 0;
+		for (size_t i = 0; i < num_elem && ret == 0; ++i)
+			ret = mbedtls_cipher_cmac_update(&ctx, addr[i], len[i]);
+	}
+	if (ret == 0)
+		ret = mbedtls_cipher_cmac_finish(&ctx, mac);
+	mbedtls_cipher_free(&ctx);
+	return ret ? -1 : 0;
+}
+
+int omac1_aes_128_vector(const u8 *key, size_t num_elem,
+			 const u8 *addr[], const size_t *len,
+			 u8 *mac)
+{
+	return omac1_aes_vector(key, 16, num_elem, addr, len, mac);
+}
+
+int omac1_aes_128(const u8 *key, const u8 *data, size_t data_len, u8 *mac)
+{
+	return omac1_aes_vector(key, 16, 1, &data, &data_len, mac);
+}
+
+int omac1_aes_256(const u8 *key, const u8 *data, size_t data_len, u8 *mac)
+{
+	return omac1_aes_vector(key, 32, 1, &data, &data_len, mac);
+}
+
+#else
+
+#include "aes-omac1.c"  /* pull in hostap local implementation */
+
+#ifndef MBEDTLS_AES_BLOCK_SIZE
+#define MBEDTLS_AES_BLOCK_SIZE 16
+#endif
+
+#endif /* MBEDTLS_CMAC_C */
+
+
+/* These interfaces can be inefficient when used in loops, as the overhead of
+ * initialization each call is large for each block input (e.g. 16 bytes) */
+
+
+/* aes-encblock.c */
+int aes_128_encrypt_block(const u8 *key, const u8 *in, u8 *out)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	mbedtls_aes_context aes;
+	mbedtls_aes_init(&aes);
+	int ret = mbedtls_aes_setkey_enc(&aes, key, 128)
+	       || mbedtls_aes_crypt_ecb(&aes, MBEDTLS_AES_ENCRYPT, in, out)
+	  ? -1
+	  : 0;
+	mbedtls_aes_free(&aes);
+	return ret;
+}
+
+
+/* aes-ctr.c */
+int aes_ctr_encrypt(const u8 *key, size_t key_len, const u8 *nonce,
+		    u8 *data, size_t data_len)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	unsigned char counter[MBEDTLS_AES_BLOCK_SIZE];
+	unsigned char stream_block[MBEDTLS_AES_BLOCK_SIZE];
+	os_memcpy(counter, nonce, MBEDTLS_AES_BLOCK_SIZE);/*(must be writable)*/
+
+	mbedtls_aes_context ctx;
+	mbedtls_aes_init(&ctx);
+	size_t nc_off = 0;
+	int ret = mbedtls_aes_setkey_enc(&ctx, key, key_len*8)
+	       || mbedtls_aes_crypt_ctr(&ctx, data_len, &nc_off,
+	                                counter, stream_block,
+	                                data, data) ? -1 : 0;
+	forced_memzero(stream_block, sizeof(stream_block));
+	mbedtls_aes_free(&ctx);
+	return ret;
+}
+
+int aes_128_ctr_encrypt(const u8 *key, const u8 *nonce,
+			u8 *data, size_t data_len)
+{
+	return aes_ctr_encrypt(key, 16, nonce, data, data_len);
+}
+
+
+/* aes-cbc.c */
+static int aes_128_cbc_oper(const u8 *key, const u8 *iv,
+                            u8 *data, size_t data_len, int mode)
+{
+	unsigned char ivec[MBEDTLS_AES_BLOCK_SIZE];
+	os_memcpy(ivec, iv, MBEDTLS_AES_BLOCK_SIZE); /*(must be writable)*/
+
+	mbedtls_aes_context ctx;
+	mbedtls_aes_init(&ctx);
+	int ret = (mode == MBEDTLS_AES_ENCRYPT
+	           ? mbedtls_aes_setkey_enc(&ctx, key, 128)
+	           : mbedtls_aes_setkey_dec(&ctx, key, 128))
+	       || mbedtls_aes_crypt_cbc(&ctx, mode, data_len, ivec, data, data);
+	mbedtls_aes_free(&ctx);
+	return ret ? -1 : 0;
+}
+
+int aes_128_cbc_encrypt(const u8 *key, const u8 *iv, u8 *data, size_t data_len)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	return aes_128_cbc_oper(key, iv, data, data_len, MBEDTLS_AES_ENCRYPT);
+}
+
+int aes_128_cbc_decrypt(const u8 *key, const u8 *iv, u8 *data, size_t data_len)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	return aes_128_cbc_oper(key, iv, data, data_len, MBEDTLS_AES_DECRYPT);
+}
+
+
+/*
+ * Much of the following is documented in crypto.h as for CONFIG_TLS=internal
+ * but such comments are not accurate:
+ *
+ * "This function is only used with internal TLSv1 implementation
+ *  (CONFIG_TLS=internal). If that is not used, the crypto wrapper does not need
+ *  to implement this."
+ */
+
+
+#ifdef CRYPTO_MBEDTLS_CRYPTO_CIPHER
+
+#include <mbedtls/cipher.h>
+
+struct crypto_cipher
+{
+	mbedtls_cipher_context_t ctx_enc;
+	mbedtls_cipher_context_t ctx_dec;
+};
+
+struct crypto_cipher * crypto_cipher_init(enum crypto_cipher_alg alg,
+					  const u8 *iv, const u8 *key,
+					  size_t key_len)
+{
+	/* IKEv2 src/eap_common/ikev2_common.c:ikev2_{encr,decr}_encrypt()
+	 * uses one of CRYPTO_CIPHER_ALG_AES or CRYPTO_CIPHER_ALG_3DES */
+
+	mbedtls_cipher_type_t cipher_type;
+	size_t iv_len;
+	switch (alg) {
+  #ifdef MBEDTLS_ARC4_C
+  #if 0
+	case CRYPTO_CIPHER_ALG_RC4:
+		cipher_type = MBEDTLS_CIPHER_ARC4_128;
+		iv_len = 0;
+		break;
+  #endif
+  #endif
+  #ifdef MBEDTLS_AES_C
+	case CRYPTO_CIPHER_ALG_AES:
+		if (key_len == 16) cipher_type = MBEDTLS_CIPHER_AES_128_CTR;
+		if (key_len == 24) cipher_type = MBEDTLS_CIPHER_AES_192_CTR;
+		if (key_len == 32) cipher_type = MBEDTLS_CIPHER_AES_256_CTR;
+		iv_len = 16;
+		break;
+  #endif
+  #ifdef MBEDTLS_DES_C
+	case CRYPTO_CIPHER_ALG_3DES:
+		cipher_type = MBEDTLS_CIPHER_DES_EDE3_CBC;
+		iv_len = 8;
+		break;
+  #if 0
+	case CRYPTO_CIPHER_ALG_DES:
+		cipher_type = MBEDTLS_CIPHER_DES_CBC;
+		iv_len = 8;
+		break;
+  #endif
+  #endif
+	default:
+		return NULL;
+	}
+
+	const mbedtls_cipher_info_t *cipher_info;
+	cipher_info = mbedtls_cipher_info_from_type(cipher_type);
+	if (cipher_info == NULL)
+		return NULL;
+
+	key_len *= 8; /* key_bitlen */
+  #if 0 /*(were key_bitlen not already available)*/
+  #if MBEDTLS_VERSION_NUMBER >= 0x03010000 /* mbedtls 3.1.0 */
+	key_len = mbedtls_cipher_info_get_key_bitlen(cipher_info);
+  #else
+	key_len = cipher_info->MBEDTLS_PRIVATE(key_bitlen);
+  #endif
+  #endif
+
+  #if 0 /*(were iv_len not known above, would need MBEDTLS_PRIVATE(iv_size))*/
+	iv_len = cipher_info->MBEDTLS_PRIVATE(iv_size);
+  #endif
+
+	struct crypto_cipher *ctx = os_malloc(sizeof(*ctx));
+	if (!ctx)
+		return NULL;
+
+	mbedtls_cipher_init(&ctx->ctx_enc);
+	mbedtls_cipher_init(&ctx->ctx_dec);
+	if (   mbedtls_cipher_setup(&ctx->ctx_enc,cipher_info) == 0
+	    && mbedtls_cipher_setup(&ctx->ctx_dec,cipher_info) == 0
+	    && mbedtls_cipher_setkey(&ctx->ctx_enc,key,key_len,MBEDTLS_ENCRYPT) == 0
+	    && mbedtls_cipher_setkey(&ctx->ctx_dec,key,key_len,MBEDTLS_DECRYPT) == 0
+	    && mbedtls_cipher_set_iv(&ctx->ctx_enc,iv,iv_len) == 0
+	    && mbedtls_cipher_set_iv(&ctx->ctx_dec,iv,iv_len) == 0
+	    && mbedtls_cipher_reset(&ctx->ctx_enc) == 0
+	    && mbedtls_cipher_reset(&ctx->ctx_dec) == 0) {
+		return ctx;
+	}
+
+	mbedtls_cipher_free(&ctx->ctx_enc);
+	mbedtls_cipher_free(&ctx->ctx_dec);
+	os_free(ctx);
+	return NULL;
+}
+
+int crypto_cipher_encrypt(struct crypto_cipher *ctx,
+			  const u8 *plain, u8 *crypt, size_t len)
+{
+	size_t olen = 0; /*(poor interface above; unknown size of u8 *crypt)*/
+	return (mbedtls_cipher_update(&ctx->ctx_enc, plain, len, crypt, &olen)
+	        || mbedtls_cipher_finish(&ctx->ctx_enc, crypt + olen, &olen)) ? -1 : 0;
+}
+
+int crypto_cipher_decrypt(struct crypto_cipher *ctx,
+			  const u8 *crypt, u8 *plain, size_t len)
+{
+	size_t olen = 0; /*(poor interface above; unknown size of u8 *plain)*/
+	return (mbedtls_cipher_update(&ctx->ctx_dec, crypt, len, plain, &olen)
+	        || mbedtls_cipher_finish(&ctx->ctx_dec, plain + olen, &olen)) ? -1 : 0;
+}
+
+void crypto_cipher_deinit(struct crypto_cipher *ctx)
+{
+	mbedtls_cipher_free(&ctx->ctx_enc);
+	mbedtls_cipher_free(&ctx->ctx_dec);
+	os_free(ctx);
+}
+
+#endif /* CRYPTO_MBEDTLS_CRYPTO_CIPHER */
+
+
+#ifdef CRYPTO_MBEDTLS_CRYPTO_HASH
+
+struct crypto_hash * crypto_hash_init(enum crypto_hash_alg alg, const u8 *key,
+				      size_t key_len)
+{
+	mbedtls_md_type_t md_type;
+	int is_hmac = 0;
+
+	switch (alg) {
+  #ifdef MBEDTLS_MD5_C
+	case CRYPTO_HASH_ALG_MD5:
+		md_type = MBEDTLS_MD_MD5;
+		break;
+  #endif
+  #ifdef MBEDTLS_SHA1_C
+	case CRYPTO_HASH_ALG_SHA1:
+		md_type = MBEDTLS_MD_SHA1;
+		break;
+  #endif
+  #ifdef MBEDTLS_MD5_C
+	case CRYPTO_HASH_ALG_HMAC_MD5:
+		md_type = MBEDTLS_MD_MD5;
+		is_hmac = 1;
+		break;
+  #endif
+  #ifdef MBEDTLS_SHA1_C
+	case CRYPTO_HASH_ALG_HMAC_SHA1:
+		md_type = MBEDTLS_MD_SHA1;
+		is_hmac = 1;
+		break;
+  #endif
+  #ifdef MBEDTLS_SHA256_C
+	case CRYPTO_HASH_ALG_SHA256:
+		md_type = MBEDTLS_MD_SHA256;
+		break;
+	case CRYPTO_HASH_ALG_HMAC_SHA256:
+		md_type = MBEDTLS_MD_SHA256;
+		is_hmac = 1;
+		break;
+  #endif
+  #ifdef MBEDTLS_SHA512_C
+	case CRYPTO_HASH_ALG_SHA384:
+		md_type = MBEDTLS_MD_SHA384;
+		break;
+	case CRYPTO_HASH_ALG_SHA512:
+		md_type = MBEDTLS_MD_SHA512;
+		break;
+  #endif
+	default:
+		return NULL;
+	}
+
+	const mbedtls_md_info_t *md_info = mbedtls_md_info_from_type(md_type);
+	if (!md_info)
+		return NULL;
+
+	mbedtls_md_context_t *mctx = os_malloc(sizeof(*mctx));
+	if (mctx == NULL)
+		return NULL;
+
+	mbedtls_md_init(mctx);
+	if (mbedtls_md_setup(mctx, md_info, is_hmac) != 0) {
+		os_free(mctx);
+		return NULL;
+	}
+
+	if (is_hmac)
+		mbedtls_md_hmac_starts(mctx, key, key_len);
+	else
+		mbedtls_md_starts(mctx);
+	return (struct crypto_hash *)((uintptr_t)mctx | is_hmac);
+}
+
+void crypto_hash_update(struct crypto_hash *ctx, const u8 *data, size_t len)
+{
+	mbedtls_md_context_t *mctx = (mbedtls_md_context_t*)((uintptr_t)ctx & ~1uL);
+  #if 0
+	/*(mbedtls_md_hmac_update() and mbedtls_md_update()
+	 * make same modifications under the hood in mbedtls)*/
+	if ((uintptr_t)ctx & 1uL)
+		mbedtls_md_hmac_update(mctx, data, len);
+	else
+  #endif
+		mbedtls_md_update(mctx, data, len);
+}
+
+int crypto_hash_finish(struct crypto_hash *ctx, u8 *mac, size_t *len)
+{
+	mbedtls_md_context_t *mctx = (mbedtls_md_context_t*)((uintptr_t)ctx & ~1uL);
+	if (mac != NULL && len != NULL) { /*(NULL if caller just freeing context)*/
+	  #if MBEDTLS_VERSION_NUMBER >= 0x03020000 /* mbedtls 3.2.0 */
+		const mbedtls_md_info_t *md_info = mbedtls_md_info_from_ctx(mctx);
+	  #else
+		const mbedtls_md_info_t *md_info = mctx->MBEDTLS_PRIVATE(md_info);
+	  #endif
+		size_t maclen = mbedtls_md_get_size(md_info);
+		if (*len < maclen) {
+			*len = maclen;
+			/*(note: ctx not freed; can call again with larger *len)*/
+			return -1;
+		}
+		*len = maclen;
+		if ((uintptr_t)ctx & 1uL)
+			mbedtls_md_hmac_finish(mctx, mac);
+		else
+			mbedtls_md_finish(mctx, mac);
+	}
+	mbedtls_md_free(mctx);
+	os_free(mctx);
+
+	if (TEST_FAIL())
+		return -1;
+
+	return 0;
+}
+
+#endif /* CRYPTO_MBEDTLS_CRYPTO_HASH */
+
+
+#ifdef CRYPTO_MBEDTLS_CRYPTO_BIGNUM
+
+#include <mbedtls/bignum.h>
+
+/* crypto.h bignum interfaces */
+
+struct crypto_bignum *crypto_bignum_init(void)
+{
+	if (TEST_FAIL())
+		return NULL;
+
+	mbedtls_mpi *bn = os_malloc(sizeof(*bn));
+	if (bn)
+		mbedtls_mpi_init(bn);
+	return (struct crypto_bignum *)bn;
+}
+
+struct crypto_bignum *crypto_bignum_init_set(const u8 *buf, size_t len)
+{
+	if (TEST_FAIL())
+		return NULL;
+
+	mbedtls_mpi *bn = os_malloc(sizeof(*bn));
+	if (bn) {
+		mbedtls_mpi_init(bn);
+		if (mbedtls_mpi_read_binary(bn, buf, len) == 0)
+			return (struct crypto_bignum *)bn;
+	}
+
+	os_free(bn);
+	return NULL;
+}
+
+struct crypto_bignum *crypto_bignum_init_uint(unsigned int val)
+{
+	if (TEST_FAIL())
+		return NULL;
+
+  #if 0 /*(hostap use of this interface passes int, not uint)*/
+	val = host_to_be32(val);
+	return crypto_bignum_init_set((const u8 *)&val, sizeof(val));
+  #else
+	mbedtls_mpi *bn = os_malloc(sizeof(*bn));
+	if (bn) {
+		mbedtls_mpi_init(bn);
+		if (mbedtls_mpi_lset(bn, (int)val) == 0)
+			return (struct crypto_bignum *)bn;
+	}
+
+	os_free(bn);
+	return NULL;
+  #endif
+}
+
+void crypto_bignum_deinit(struct crypto_bignum *n, int clear)
+{
+	mbedtls_mpi_free((mbedtls_mpi *)n);
+	os_free(n);
+}
+
+int crypto_bignum_to_bin(const struct crypto_bignum *a,
+			 u8 *buf, size_t buflen, size_t padlen)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	size_t n = mbedtls_mpi_size((mbedtls_mpi *)a);
+	if (n < padlen)
+		n = padlen;
+	return n > buflen || mbedtls_mpi_write_binary((mbedtls_mpi *)a, buf, n)
+	  ? -1
+	  : (int)(n);
+}
+
+int crypto_bignum_rand(struct crypto_bignum *r, const struct crypto_bignum *m)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	/*assert(r != m);*//* r must not be same as m for mbedtls_mpi_random()*/
+  #if MBEDTLS_VERSION_NUMBER >= 0x021B0000 /* mbedtls 2.27.0 */
+	return mbedtls_mpi_random((mbedtls_mpi *)r, 0, (mbedtls_mpi *)m,
+				  mbedtls_ctr_drbg_random,
+				  crypto_mbedtls_ctr_drbg()) ? -1 : 0;
+  #else
+	/* (needed by EAP_PWD, SAE, DPP) */
+	wpa_printf(MSG_ERROR,
+	           "mbedtls 2.27.0 or later required for mbedtls_mpi_random()");
+	return -1;
+  #endif
+}
+
+int crypto_bignum_add(const struct crypto_bignum *a,
+		      const struct crypto_bignum *b,
+		      struct crypto_bignum *c)
+{
+	return mbedtls_mpi_add_mpi((mbedtls_mpi *)c,
+				   (const mbedtls_mpi *)a,
+				   (const mbedtls_mpi *)b) ? -1 : 0;
+}
+
+int crypto_bignum_mod(const struct crypto_bignum *a,
+		      const struct crypto_bignum *b,
+		      struct crypto_bignum *c)
+{
+	return mbedtls_mpi_mod_mpi((mbedtls_mpi *)c,
+				   (const mbedtls_mpi *)a,
+				   (const mbedtls_mpi *)b) ? -1 : 0;
+}
+
+int crypto_bignum_exptmod(const struct crypto_bignum *a,
+			  const struct crypto_bignum *b,
+			  const struct crypto_bignum *c,
+			  struct crypto_bignum *d)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	/* (check if input params match d; d is the result) */
+	/* (a == d) is ok in current mbedtls implementation */
+	if (b == d || c == d) { /*(not ok; store result in intermediate)*/
+		mbedtls_mpi R;
+		mbedtls_mpi_init(&R);
+		int rc = mbedtls_mpi_exp_mod(&R,
+		                             (const mbedtls_mpi *)a,
+		                             (const mbedtls_mpi *)b,
+		                             (const mbedtls_mpi *)c,
+		                             NULL)
+		      || mbedtls_mpi_copy((mbedtls_mpi *)d, &R) ? -1 : 0;
+		mbedtls_mpi_free(&R);
+		return rc;
+	}
+	else {
+		return mbedtls_mpi_exp_mod((mbedtls_mpi *)d,
+		                           (const mbedtls_mpi *)a,
+		                           (const mbedtls_mpi *)b,
+		                           (const mbedtls_mpi *)c,
+		                           NULL) ? -1 : 0;
+	}
+}
+
+int crypto_bignum_inverse(const struct crypto_bignum *a,
+			  const struct crypto_bignum *b,
+			  struct crypto_bignum *c)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	return mbedtls_mpi_inv_mod((mbedtls_mpi *)c,
+				   (const mbedtls_mpi *)a,
+				   (const mbedtls_mpi *)b) ? -1 : 0;
+}
+
+int crypto_bignum_sub(const struct crypto_bignum *a,
+		      const struct crypto_bignum *b,
+		      struct crypto_bignum *c)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	return mbedtls_mpi_sub_mpi((mbedtls_mpi *)c,
+				   (const mbedtls_mpi *)a,
+				   (const mbedtls_mpi *)b) ? -1 : 0;
+}
+
+int crypto_bignum_div(const struct crypto_bignum *a,
+		      const struct crypto_bignum *b,
+		      struct crypto_bignum *c)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	/*(most current use of this crypto.h interface has a == c (result),
+	 * so store result in an intermediate to avoid overwritten input)*/
+	mbedtls_mpi R;
+	mbedtls_mpi_init(&R);
+	int rc = mbedtls_mpi_div_mpi(&R, NULL,
+				     (const mbedtls_mpi *)a,
+				     (const mbedtls_mpi *)b)
+	      || mbedtls_mpi_copy((mbedtls_mpi *)c, &R) ? -1 : 0;
+	mbedtls_mpi_free(&R);
+	return rc;
+}
+
+int crypto_bignum_addmod(const struct crypto_bignum *a,
+			 const struct crypto_bignum *b,
+			 const struct crypto_bignum *c,
+			 struct crypto_bignum *d)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	return mbedtls_mpi_add_mpi((mbedtls_mpi *)d,
+				   (const mbedtls_mpi *)a,
+				   (const mbedtls_mpi *)b)
+	    || mbedtls_mpi_mod_mpi((mbedtls_mpi *)d,
+				   (mbedtls_mpi *)d,
+				   (const mbedtls_mpi *)c) ? -1 : 0;
+}
+
+int crypto_bignum_mulmod(const struct crypto_bignum *a,
+			 const struct crypto_bignum *b,
+			 const struct crypto_bignum *c,
+			 struct crypto_bignum *d)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	return mbedtls_mpi_mul_mpi((mbedtls_mpi *)d,
+				   (const mbedtls_mpi *)a,
+				   (const mbedtls_mpi *)b)
+	    || mbedtls_mpi_mod_mpi((mbedtls_mpi *)d,
+				   (mbedtls_mpi *)d,
+				   (const mbedtls_mpi *)c) ? -1 : 0;
+}
+
+int crypto_bignum_sqrmod(const struct crypto_bignum *a,
+			 const struct crypto_bignum *b,
+			 struct crypto_bignum *c)
+{
+	if (TEST_FAIL())
+		return -1;
+
+  #if 1
+	return crypto_bignum_mulmod(a, a, b, c);
+  #else
+	mbedtls_mpi bn;
+	mbedtls_mpi_init(&bn);
+	if (mbedtls_mpi_lset(&bn, 2)) /* alt?: mbedtls_mpi_set_bit(&bn, 1) */
+		return -1;
+	int ret = mbedtls_mpi_exp_mod((mbedtls_mpi *)c,
+				      (const mbedtls_mpi *)a, &bn,
+				      (const mbedtls_mpi *)b, NULL) ? -1 : 0;
+	mbedtls_mpi_free(&bn);
+	return ret;
+  #endif
+}
+
+int crypto_bignum_rshift(const struct crypto_bignum *a, int n,
+			 struct crypto_bignum *r)
+{
+	return mbedtls_mpi_copy((mbedtls_mpi *)r, (const mbedtls_mpi *)a)
+	    || mbedtls_mpi_shift_r((mbedtls_mpi *)r, n) ? -1 : 0;
+}
+
+int crypto_bignum_cmp(const struct crypto_bignum *a,
+		      const struct crypto_bignum *b)
+{
+	return mbedtls_mpi_cmp_mpi((const mbedtls_mpi *)a, (const mbedtls_mpi *)b);
+}
+
+int crypto_bignum_is_zero(const struct crypto_bignum *a)
+{
+	/* XXX: src/common/sae.c:sswu() contains comment:
+	 * "TODO: Make sure crypto_bignum_is_zero() is constant time"
+	 * Note: mbedtls_mpi_cmp_int() *is not* constant time */
+	return (mbedtls_mpi_cmp_int((const mbedtls_mpi *)a, 0) == 0);
+}
+
+int crypto_bignum_is_one(const struct crypto_bignum *a)
+{
+	return (mbedtls_mpi_cmp_int((const mbedtls_mpi *)a, 1) == 0);
+}
+
+int crypto_bignum_is_odd(const struct crypto_bignum *a)
+{
+	return mbedtls_mpi_get_bit((const mbedtls_mpi *)a, 0);
+}
+
+#include "utils/const_time.h"
+int crypto_bignum_legendre(const struct crypto_bignum *a,
+			   const struct crypto_bignum *p)
+{
+	if (TEST_FAIL())
+		return -2;
+
+	/* Security Note:
+	 * mbedtls_mpi_exp_mod() is not documented to run in constant time,
+	 * though mbedtls/library/bignum.c uses constant_time_internal.h funcs.
+	 * Compare to crypto_openssl.c:crypto_bignum_legendre()
+	 * which uses openssl BN_mod_exp_mont_consttime()
+	 * mbedtls/library/ecp.c has further countermeasures to timing attacks,
+	 * (but ecp.c funcs are not used here) */
+
+	mbedtls_mpi exp, tmp;
+	mbedtls_mpi_init(&exp);
+	mbedtls_mpi_init(&tmp);
+
+	/* exp = (p-1) / 2 */
+	int res;
+	if (mbedtls_mpi_sub_int(&exp, (const mbedtls_mpi *)p, 1) == 0
+	    && mbedtls_mpi_shift_r(&exp, 1) == 0
+	    && mbedtls_mpi_exp_mod(&tmp, (const mbedtls_mpi *)a, &exp,
+	                           (const mbedtls_mpi *)p, NULL) == 0) {
+		/*(modified from crypto_openssl.c:crypto_bignum_legendre())*/
+		/* Return 1 if tmp == 1, 0 if tmp == 0, or -1 otherwise. Need
+		 * to use constant time selection to avoid branches here. */
+		unsigned int mask;
+		res = -1;
+		mask = const_time_eq((mbedtls_mpi_cmp_int(&tmp, 1) == 0), 1);
+		res = const_time_select_int(mask, 1, res);
+		mask = const_time_eq((mbedtls_mpi_cmp_int(&tmp, 0) == 0), 1);
+		res = const_time_select_int(mask, 0, res);
+	} else {
+		res = -2;
+	}
+
+	mbedtls_mpi_free(&tmp);
+	mbedtls_mpi_free(&exp);
+	return res;
+}
+
+#endif /* CRYPTO_MBEDTLS_CRYPTO_BIGNUM */
+
+
+#ifdef CRYPTO_MBEDTLS_CRYPTO_DH
+
+/* crypto_internal-modexp.c */
+
+#include <mbedtls/bignum.h>
+#include <mbedtls/dhm.h>
+
+#if 0 /* crypto_dh_init() and crypto_dh_derive_secret() prefer to use mbedtls */
+int crypto_mod_exp(const u8 *base, size_t base_len,
+		   const u8 *power, size_t power_len,
+		   const u8 *modulus, size_t modulus_len,
+		   u8 *result, size_t *result_len)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	mbedtls_mpi bn_base, bn_exp, bn_modulus, bn_result;
+	mbedtls_mpi_init(&bn_base);
+	mbedtls_mpi_init(&bn_exp);
+	mbedtls_mpi_init(&bn_modulus);
+	mbedtls_mpi_init(&bn_result);
+
+	size_t len;
+	int ret =  mbedtls_mpi_read_binary(&bn_base, base, base_len)
+	        || mbedtls_mpi_read_binary(&bn_exp, power, power_len)
+	        || mbedtls_mpi_read_binary(&bn_modulus, modulus, modulus_len)
+	        || mbedtls_mpi_exp_mod(&bn_result,&bn_base,&bn_exp,&bn_modulus,NULL)
+	        || (len = mbedtls_mpi_size(&bn_result)) > *result_len
+	        || mbedtls_mpi_write_binary(&bn_result, result, (*result_len = len))
+	  ? -1
+	  : 0;
+
+	mbedtls_mpi_free(&bn_base);
+	mbedtls_mpi_free(&bn_exp);
+	mbedtls_mpi_free(&bn_modulus);
+	mbedtls_mpi_free(&bn_result);
+	return ret;
+}
+#endif
+
+static int crypto_mbedtls_dh_set_bin_pg(mbedtls_dhm_context *ctx, u8 generator,
+                                        const u8 *prime, size_t prime_len)
+{
+	/*(could set these directly in MBEDTLS_PRIVATE members)*/
+	mbedtls_mpi P, G;
+	mbedtls_mpi_init(&P);
+	mbedtls_mpi_init(&G);
+	int ret = mbedtls_mpi_lset(&G, generator)
+	       || mbedtls_mpi_read_binary(&P, prime, prime_len)
+	       || mbedtls_dhm_set_group(ctx, &P, &G);
+	mbedtls_mpi_free(&P);
+	mbedtls_mpi_free(&G);
+	return ret;
+}
+
+__attribute_noinline__
+static int crypto_mbedtls_dh_init_public(mbedtls_dhm_context *ctx, u8 generator,
+                                         const u8 *prime, size_t prime_len,
+                                         u8 *privkey, u8 *pubkey)
+{
+	if (crypto_mbedtls_dh_set_bin_pg(ctx, generator, prime, prime_len)
+	    || mbedtls_dhm_make_public(ctx, (int)prime_len, pubkey, prime_len,
+	                               mbedtls_ctr_drbg_random,
+	                               crypto_mbedtls_ctr_drbg()))
+		return -1;
+
+  /*(enable later when upstream mbedtls interface changes require)*/
+  #if 0 && MBEDTLS_VERSION_NUMBER >= 0x03000000 /* mbedtls 3.0.0 */
+	mbedtls_mpi X;
+	mbedtls_mpi_init(&X);
+	int ret = mbedtls_dhm_get_value(ctx, MBEDTLS_DHM_PARAM_X, &X)
+	       || mbedtls_mpi_write_binary(&X, privkey, prime_len) ? -1 : 0;
+	mbedtls_mpi_free(&X);
+	return ret;
+  #else
+	return mbedtls_mpi_write_binary(&ctx->MBEDTLS_PRIVATE(X),
+	                                privkey, prime_len) ? -1 : 0;
+  #endif
+}
+
+int crypto_dh_init(u8 generator, const u8 *prime, size_t prime_len, u8 *privkey,
+		   u8 *pubkey)
+{
+	if (TEST_FAIL())
+		return -1;
+
+  #if 0 /*(crypto_dh_init() duplicated (and identical) in crypto_*.c modules)*/
+	size_t pubkey_len, pad;
+
+	if (os_get_random(privkey, prime_len) < 0)
+		return -1;
+	if (os_memcmp(privkey, prime, prime_len) > 0) {
+		/* Make sure private value is smaller than prime */
+		privkey[0] = 0;
+	}
+
+	pubkey_len = prime_len;
+	if (crypto_mod_exp(&generator, 1, privkey, prime_len, prime, prime_len,
+			   pubkey, &pubkey_len) < 0)
+		return -1;
+	if (pubkey_len < prime_len) {
+		pad = prime_len - pubkey_len;
+		os_memmove(pubkey + pad, pubkey, pubkey_len);
+		os_memset(pubkey, 0, pad);
+	}
+
+	return 0;
+  #else
+	/* Prefer to use mbedtls to derive our public/private key, as doing so
+	 * leverages mbedtls to properly format output and to perform blinding*/
+	mbedtls_dhm_context ctx;
+	mbedtls_dhm_init(&ctx);
+	int ret = crypto_mbedtls_dh_init_public(&ctx, generator, prime,
+	                                        prime_len, privkey, pubkey);
+	mbedtls_dhm_free(&ctx);
+	return ret;
+  #endif
+}
+
+/*(crypto_dh_derive_secret() could be implemented using crypto.h APIs
+ * instead of being reimplemented in each crypto_*.c)*/
+int crypto_dh_derive_secret(u8 generator, const u8 *prime, size_t prime_len,
+			    const u8 *order, size_t order_len,
+			    const u8 *privkey, size_t privkey_len,
+			    const u8 *pubkey, size_t pubkey_len,
+			    u8 *secret, size_t *len)
+{
+	if (TEST_FAIL())
+		return -1;
+
+  #if 0
+	if (pubkey_len > prime_len ||
+	    (pubkey_len == prime_len &&
+	     os_memcmp(pubkey, prime, prime_len) >= 0))
+		return -1;
+
+	int res = 0;
+	mbedtls_mpi pub;
+	mbedtls_mpi_init(&pub);
+	if (mbedtls_mpi_read_binary(&pub, pubkey, pubkey_len)
+	    || mbedtls_mpi_cmp_int(&pub, 1) <= 0) {
+		res = -1;
+	} else if (order) {
+		mbedtls_mpi p, q, tmp;
+		mbedtls_mpi_init(&p);
+		mbedtls_mpi_init(&q);
+		mbedtls_mpi_init(&tmp);
+
+		/* verify: pubkey^q == 1 mod p */
+		res = (mbedtls_mpi_read_binary(&p, prime, prime_len)
+		    || mbedtls_mpi_read_binary(&q, order, order_len)
+		    || mbedtls_mpi_exp_mod(&tmp, &pub, &q, &p, NULL)
+		    || mbedtls_mpi_cmp_int(&tmp, 1) != 0);
+
+		mbedtls_mpi_free(&p);
+		mbedtls_mpi_free(&q);
+		mbedtls_mpi_free(&tmp);
+	}
+	mbedtls_mpi_free(&pub);
+
+	return (res == 0)
+	  ? crypto_mod_exp(pubkey, pubkey_len, privkey, privkey_len,
+			   prime, prime_len, secret, len)
+	  : -1;
+  #else
+	/* Prefer to use mbedtls to derive DH shared secret, as doing so
+	 * leverages mbedtls to validate params and to perform blinding.
+	 *
+	 * Attempt to reconstitute DH context to derive shared secret
+	 * (due to limitations of the interface, which ought to pass context).
+	 * Force provided G (our private key) into context without validation.
+	 * Regenerating GX (our public key) not needed to derive shared secret.
+	 */
+	/*(older compilers might not support VLAs)*/
+	/*unsigned char buf[2+prime_len+2+1+2+pubkey_len];*/
+	unsigned char buf[2+MBEDTLS_MPI_MAX_SIZE+2+1+2+MBEDTLS_MPI_MAX_SIZE];
+	unsigned char *p = buf + 2 + prime_len;
+	if (2+prime_len+2+1+2+pubkey_len > sizeof(buf))
+		return -1;
+	WPA_PUT_BE16(buf, prime_len);  /*(2-byte big-endian size of prime)*/
+	p[0] = 0;                      /*(2-byte big-endian size of generator)*/
+	p[1] = 1;
+	p[2] = generator;
+	WPA_PUT_BE16(p+3, pubkey_len); /*(2-byte big-endian size of pubkey)*/
+	os_memcpy(p+5, pubkey, pubkey_len);
+	os_memcpy(buf+2, prime, prime_len);
+
+	mbedtls_dhm_context ctx;
+	mbedtls_dhm_init(&ctx);
+	p = buf;
+	int ret = mbedtls_dhm_read_params(&ctx, &p, p+2+prime_len+5+pubkey_len)
+	       || mbedtls_mpi_read_binary(&ctx.MBEDTLS_PRIVATE(X),
+	                                  privkey, privkey_len)
+	       || mbedtls_dhm_calc_secret(&ctx, secret, *len, len,
+	                                  mbedtls_ctr_drbg_random,
+	                                  crypto_mbedtls_ctr_drbg()) ? -1 : 0;
+	mbedtls_dhm_free(&ctx);
+	return ret;
+  #endif
+}
+
+/* dh_group5.c */
+
+#include "dh_group5.h"
+
+/* RFC3526_PRIME_1536[] and RFC3526_GENERATOR_1536[] from crypto_wolfssl.c */
+
+static const unsigned char RFC3526_PRIME_1536[] = {
+	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC9, 0x0F, 0xDA, 0xA2,
+	0x21, 0x68, 0xC2, 0x34, 0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,
+	0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74, 0x02, 0x0B, 0xBE, 0xA6,
+	0x3B, 0x13, 0x9B, 0x22, 0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,
+	0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B, 0x30, 0x2B, 0x0A, 0x6D,
+	0xF2, 0x5F, 0x14, 0x37, 0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,
+	0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6, 0xF4, 0x4C, 0x42, 0xE9,
+	0xA6, 0x37, 0xED, 0x6B, 0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,
+	0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5, 0xAE, 0x9F, 0x24, 0x11,
+	0x7C, 0x4B, 0x1F, 0xE6, 0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D,
+	0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05, 0x98, 0xDA, 0x48, 0x36,
+	0x1C, 0x55, 0xD3, 0x9A, 0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,
+	0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96, 0x1C, 0x62, 0xF3, 0x56,
+	0x20, 0x85, 0x52, 0xBB, 0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D,
+	0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04, 0xF1, 0x74, 0x6C, 0x08,
+	0xCA, 0x23, 0x73, 0x27, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
+};
+
+static const unsigned char RFC3526_GENERATOR_1536[] = {
+	0x02
+};
+
+void * dh5_init(struct wpabuf **priv, struct wpabuf **publ)
+{
+	const unsigned char * const prime = RFC3526_PRIME_1536;
+	const size_t prime_len = sizeof(RFC3526_PRIME_1536);
+	const u8 generator = *RFC3526_GENERATOR_1536;
+	struct wpabuf *wpubl = NULL, *wpriv = NULL;
+
+	mbedtls_dhm_context *ctx = os_malloc(sizeof(*ctx));
+	if (ctx == NULL)
+		return NULL;
+	mbedtls_dhm_init(ctx);
+
+	if (   (wpubl = wpabuf_alloc(prime_len))
+	    && (wpriv = wpabuf_alloc(prime_len))
+	    && crypto_mbedtls_dh_init_public(ctx, generator, prime, prime_len,
+	                                     wpabuf_put(wpriv, prime_len),
+	                                     wpabuf_put(wpubl, prime_len))==0) {
+		wpabuf_free(*publ);
+		wpabuf_clear_free(*priv);
+		*publ = wpubl;
+		*priv = wpriv;
+		return ctx;
+	}
+
+	wpabuf_clear_free(wpriv);
+	wpabuf_free(wpubl);
+	mbedtls_dhm_free(ctx);
+	os_free(ctx);
+	return NULL;
+}
+
+#ifdef CRYPTO_MBEDTLS_DH5_INIT_FIXED
+void * dh5_init_fixed(const struct wpabuf *priv, const struct wpabuf *publ)
+{
+	const unsigned char * const prime = RFC3526_PRIME_1536;
+	const size_t prime_len = sizeof(RFC3526_PRIME_1536);
+	const u8 generator = *RFC3526_GENERATOR_1536;
+
+	mbedtls_dhm_context *ctx = os_malloc(sizeof(*ctx));
+	if (ctx == NULL)
+		return NULL;
+	mbedtls_dhm_init(ctx);
+
+	if (crypto_mbedtls_dh_set_bin_pg(ctx, generator, prime, prime_len)==0
+	   #if 0 /*(ignore; not required to derive shared secret)*/
+	    && mbedtls_mpi_read_binary(&ctx->MBEDTLS_PRIVATE(GX),
+				       wpabuf_head(publ),wpabuf_len(publ))==0
+	   #endif
+	    && mbedtls_mpi_read_binary(&ctx->MBEDTLS_PRIVATE(X),
+				       wpabuf_head(priv),wpabuf_len(priv))==0) {
+		return ctx;
+	}
+
+	mbedtls_dhm_free(ctx);
+	os_free(ctx);
+	return NULL;
+}
+#endif
+
+struct wpabuf * dh5_derive_shared(void *ctx, const struct wpabuf *peer_public,
+				  const struct wpabuf *own_private)
+{
+	/*((mbedtls_dhm_context *)ctx must already contain own_private)*/
+	/* mbedtls 2.x: prime_len = ctx->len; */
+	/* mbedtls 3.x: prime_len = mbedtls_dhm_get_len(ctx); */
+	size_t olen = sizeof(RFC3526_PRIME_1536); /*(sizeof(); prime known)*/
+	struct wpabuf *buf = wpabuf_alloc(olen);
+	if (buf == NULL)
+		return NULL;
+	if (mbedtls_dhm_read_public((mbedtls_dhm_context *)ctx,
+	                            wpabuf_head(peer_public),
+	                            wpabuf_len(peer_public)) == 0
+	    && mbedtls_dhm_calc_secret(ctx, wpabuf_mhead(buf), olen, &olen,
+	                               mbedtls_ctr_drbg_random,
+	                               crypto_mbedtls_ctr_drbg()) == 0) {
+		wpabuf_put(buf, olen);
+		return buf;
+	}
+
+	wpabuf_free(buf);
+	return NULL;
+}
+
+void dh5_free(void *ctx)
+{
+	mbedtls_dhm_free(ctx);
+	os_free(ctx);
+}
+
+#endif /* CRYPTO_MBEDTLS_CRYPTO_DH */
+
+
+#if defined(CRYPTO_MBEDTLS_CRYPTO_ECDH) || defined(CRYPTO_MBEDTLS_CRYPTO_EC)
+
+#include <mbedtls/ecp.h>
+
+#define CRYPTO_EC_pbits(e) (((mbedtls_ecp_group *)(e))->pbits)
+#define CRYPTO_EC_plen(e) ((((mbedtls_ecp_group *)(e))->pbits+7)>>3)
+#define CRYPTO_EC_P(e)    (&((mbedtls_ecp_group *)(e))->P)
+#define CRYPTO_EC_N(e)    (&((mbedtls_ecp_group *)(e))->N)
+#define CRYPTO_EC_A(e)    (&((mbedtls_ecp_group *)(e))->A)
+#define CRYPTO_EC_B(e)    (&((mbedtls_ecp_group *)(e))->B)
+#define CRYPTO_EC_G(e)    (&((mbedtls_ecp_group *)(e))->G)
+
+static mbedtls_ecp_group_id crypto_mbedtls_ecp_group_id_from_ike_id(int group)
+{
+	/* https://www.iana.org/assignments/ikev2-parameters/ikev2-parameters.xhtml */
+	switch (group) {
+  #ifdef MBEDTLS_ECP_DP_SECP256R1_ENABLED
+	case 19: return MBEDTLS_ECP_DP_SECP256R1;
+  #endif
+  #ifdef MBEDTLS_ECP_DP_SECP384R1_ENABLED
+	case 20: return MBEDTLS_ECP_DP_SECP384R1;
+  #endif
+  #ifdef MBEDTLS_ECP_DP_SECP521R1_ENABLED
+	case 21: return MBEDTLS_ECP_DP_SECP521R1;
+  #endif
+  #ifdef MBEDTLS_ECP_DP_SECP192R1_ENABLED
+	case 25: return MBEDTLS_ECP_DP_SECP192R1;
+  #endif
+  #ifdef MBEDTLS_ECP_DP_SECP224R1_ENABLED
+	case 26: return MBEDTLS_ECP_DP_SECP224R1;
+  #endif
+  #ifdef MBEDTLS_ECP_DP_BP256R1_ENABLED
+	case 28: return MBEDTLS_ECP_DP_BP256R1;
+  #endif
+  #ifdef MBEDTLS_ECP_DP_BP384R1_ENABLED
+	case 29: return MBEDTLS_ECP_DP_BP384R1;
+  #endif
+  #ifdef MBEDTLS_ECP_DP_BP512R1_ENABLED
+	case 30: return MBEDTLS_ECP_DP_BP512R1;
+  #endif
+  #ifdef MBEDTLS_ECP_DP_CURVE25519_ENABLED
+	case 31: return MBEDTLS_ECP_DP_CURVE25519;
+  #endif
+  #ifdef MBEDTLS_ECP_DP_CURVE448_ENABLED
+	case 32: return MBEDTLS_ECP_DP_CURVE448;
+  #endif
+	default: return MBEDTLS_ECP_DP_NONE;
+	}
+}
+
+#ifdef CRYPTO_MBEDTLS_CRYPTO_EC
+static int crypto_mbedtls_ike_id_from_ecp_group_id(mbedtls_ecp_group_id grp_id)
+{
+	/* https://www.iana.org/assignments/ikev2-parameters/ikev2-parameters.xhtml */
+	/*(for crypto_ec_key_group())*/
+	switch (grp_id) {
+  #ifdef MBEDTLS_ECP_DP_SECP256R1_ENABLED
+	case MBEDTLS_ECP_DP_SECP256R1:  return 19;
+  #endif
+  #ifdef MBEDTLS_ECP_DP_SECP384R1_ENABLED
+	case MBEDTLS_ECP_DP_SECP384R1:  return 20;
+  #endif
+  #ifdef MBEDTLS_ECP_DP_SECP521R1_ENABLED
+	case MBEDTLS_ECP_DP_SECP521R1:  return 21;
+  #endif
+  #ifdef MBEDTLS_ECP_DP_SECP192R1_ENABLED
+	case MBEDTLS_ECP_DP_SECP192R1:  return 25;
+  #endif
+  #ifdef MBEDTLS_ECP_DP_SECP224R1_ENABLED
+	case MBEDTLS_ECP_DP_SECP224R1:  return 26;
+  #endif
+  #ifdef MBEDTLS_ECP_DP_BP256R1_ENABLED
+	case MBEDTLS_ECP_DP_BP256R1:    return 28;
+  #endif
+  #ifdef MBEDTLS_ECP_DP_BP384R1_ENABLED
+	case MBEDTLS_ECP_DP_BP384R1:    return 29;
+  #endif
+  #ifdef MBEDTLS_ECP_DP_BP512R1_ENABLED
+	case MBEDTLS_ECP_DP_BP512R1:    return 30;
+  #endif
+  #ifdef MBEDTLS_ECP_DP_CURVE25519_ENABLED
+	case MBEDTLS_ECP_DP_CURVE25519: return 31;
+  #endif
+  #ifdef MBEDTLS_ECP_DP_CURVE448_ENABLED
+	case MBEDTLS_ECP_DP_CURVE448:   return 32;
+  #endif
+	default: return -1;
+	}
+}
+#endif
+
+#endif /* CRYPTO_MBEDTLS_CRYPTO_ECDH || CRYPTO_MBEDTLS_CRYPTO_EC */
+
+
+#if defined(CRYPTO_MBEDTLS_CRYPTO_ECDH) || defined(CRYPTO_MBEDTLS_CRYPTO_EC_DPP)
+
+#include <mbedtls/ecp.h>
+#include <mbedtls/pk.h>
+
+static int crypto_mbedtls_keypair_gen(int group, mbedtls_pk_context *pk)
+{
+	mbedtls_ecp_group_id grp_id =
+	  crypto_mbedtls_ecp_group_id_from_ike_id(group);
+	if (grp_id == MBEDTLS_ECP_DP_NONE)
+		return -1;
+	const mbedtls_pk_info_t *pk_info =
+	  mbedtls_pk_info_from_type(MBEDTLS_PK_ECKEY);
+	if (pk_info == NULL)
+		return -1;
+	return mbedtls_pk_setup(pk, pk_info)
+	    || mbedtls_ecp_gen_key(grp_id, mbedtls_pk_ec(*pk),
+	                           mbedtls_ctr_drbg_random,
+	                           crypto_mbedtls_ctr_drbg()) ? -1 : 0;
+}
+
+#endif
+
+
+#ifdef CRYPTO_MBEDTLS_CRYPTO_ECDH
+
+#include <mbedtls/ecdh.h>
+#include <mbedtls/ecdsa.h>
+#include <mbedtls/ecp.h>
+#include <mbedtls/pk.h>
+
+/* wrap mbedtls_ecdh_context for more future-proof direct access to components
+ * (mbedtls_ecdh_context internal implementation may change between releases)
+ *
+ * If mbedtls_pk_context -- specifically underlying mbedtls_ecp_keypair --
+ * lifetime were guaranteed to be longer than that of mbedtls_ecdh_context,
+ * then mbedtls_pk_context or mbedtls_ecp_keypair could be stored in crypto_ecdh
+ * (or crypto_ec_key could be stored in crypto_ecdh, and crypto_ec_key could
+ *  wrap mbedtls_ecp_keypair and components, to avoid MBEDTLS_PRIVATE access) */
+struct crypto_ecdh {
+	mbedtls_ecdh_context ctx;
+	mbedtls_ecp_group grp;
+	mbedtls_ecp_point Q;
+};
+
+struct crypto_ecdh * crypto_ecdh_init(int group)
+{
+	mbedtls_pk_context pk;
+	mbedtls_pk_init(&pk);
+	struct crypto_ecdh *ecdh = crypto_mbedtls_keypair_gen(group, &pk) == 0
+	  ? crypto_ecdh_init2(group, (struct crypto_ec_key *)&pk)
+	  : NULL;
+	mbedtls_pk_free(&pk);
+	return ecdh;
+}
+
+struct crypto_ecdh * crypto_ecdh_init2(int group,
+				       struct crypto_ec_key *own_key)
+{
+	mbedtls_ecp_group_id grp_id =
+	  crypto_mbedtls_ecp_group_id_from_ike_id(group);
+	if (grp_id == MBEDTLS_ECP_DP_NONE)
+		return NULL;
+	mbedtls_ecp_keypair *ecp_kp = mbedtls_pk_ec(*(mbedtls_pk_context *)own_key);
+	struct crypto_ecdh *ecdh = os_malloc(sizeof(*ecdh));
+	if (ecdh == NULL)
+		return NULL;
+	mbedtls_ecdh_init(&ecdh->ctx);
+	mbedtls_ecp_group_init(&ecdh->grp);
+	mbedtls_ecp_point_init(&ecdh->Q);
+	if (mbedtls_ecdh_setup(&ecdh->ctx, grp_id) == 0
+	    && mbedtls_ecdh_get_params(&ecdh->ctx,ecp_kp,MBEDTLS_ECDH_OURS) == 0) {
+		/* copy grp and Q for later use
+		 * (retrieving this info later is more convoluted
+		 *  even if mbedtls_ecdh_make_public() is considered)*/
+	  #if MBEDTLS_VERSION_NUMBER >= 0x03020000 /* mbedtls 3.2.0 */
+		mbedtls_mpi d;
+		mbedtls_mpi_init(&d);
+		if (mbedtls_ecp_export(ecp_kp, &ecdh->grp, &d, &ecdh->Q) == 0) {
+			mbedtls_mpi_free(&d);
+			return ecdh;
+		}
+		mbedtls_mpi_free(&d);
+	  #else
+		if (mbedtls_ecp_group_load(&ecdh->grp, grp_id) == 0
+		    && mbedtls_ecp_copy(&ecdh->Q, &ecp_kp->MBEDTLS_PRIVATE(Q)) == 0)
+			return ecdh;
+	  #endif
+	}
+
+	mbedtls_ecp_point_free(&ecdh->Q);
+	mbedtls_ecp_group_free(&ecdh->grp);
+	mbedtls_ecdh_free(&ecdh->ctx);
+	os_free(ecdh);
+	return NULL;
+}
+
+struct wpabuf * crypto_ecdh_get_pubkey(struct crypto_ecdh *ecdh, int inc_y)
+{
+	mbedtls_ecp_group *grp = &ecdh->grp;
+	size_t prime_len = CRYPTO_EC_plen(grp);
+	size_t output_len = prime_len;
+	u8 output_offset = 0;
+	u8 buf[256];
+
+  #ifdef MBEDTLS_ECP_MONTGOMERY_ENABLED
+	/* len */
+  #endif
+  #ifdef MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED
+	if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
+		output_len = inc_y ? prime_len * 2 + 1 : prime_len + 1;
+		output_offset = 1;
+	}
+  #endif
+
+	if (output_len > sizeof(buf))
+		return NULL;
+
+	inc_y = inc_y ? MBEDTLS_ECP_PF_UNCOMPRESSED : MBEDTLS_ECP_PF_COMPRESSED;
+	if (mbedtls_ecp_point_write_binary(grp, &ecdh->Q, inc_y, &output_len,
+	                                   buf, output_len) == 0) {
+		return wpabuf_alloc_copy(buf + output_offset, output_len - output_offset);
+	}
+
+	return NULL;
+}
+
+#if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
+static int crypto_mbedtls_short_weierstrass_derive_y(mbedtls_ecp_group *grp,
+                                                     mbedtls_mpi *bn,
+                                                     int parity_bit)
+{
+	/* y^2 = x^3 + ax + b
+	 * sqrt(w) = w^((p+1)/4) mod p   (for prime p where p = 3 mod 4) */
+	mbedtls_mpi *cy2 = (mbedtls_mpi *)
+	  crypto_ec_point_compute_y_sqr((struct crypto_ec *)grp,
+	                                (const struct crypto_bignum *)bn); /*x*/
+	if (cy2 == NULL)
+		return -1;
+
+	/*mbedtls_mpi_free(bn);*/
+	/*(reuse bn to store result (y))*/
+
+	mbedtls_mpi exp;
+	mbedtls_mpi_init(&exp);
+	int ret = mbedtls_mpi_get_bit(&grp->P, 0) != 1 /*(p = 3 mod 4)*/
+	       || mbedtls_mpi_get_bit(&grp->P, 1) != 1 /*(p = 3 mod 4)*/
+	       || mbedtls_mpi_add_int(&exp, &grp->P, 1)
+	       || mbedtls_mpi_shift_r(&exp, 2)
+	       || mbedtls_mpi_exp_mod(bn, cy2, &exp, &grp->P, NULL)
+	       || (mbedtls_mpi_get_bit(bn, 0) != parity_bit
+	           && mbedtls_mpi_sub_mpi(bn, &grp->P, bn));
+	mbedtls_mpi_free(&exp);
+	mbedtls_mpi_free(cy2);
+	os_free(cy2);
+	return ret;
+}
+#endif
+
+struct wpabuf * crypto_ecdh_set_peerkey(struct crypto_ecdh *ecdh, int inc_y,
+					const u8 *key, size_t len)
+{
+	if (len == 0) /*(invalid peer key)*/
+		return NULL;
+
+	mbedtls_ecp_group *grp = &ecdh->grp;
+
+  #if defined(MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED)
+	if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
+		/* add header for mbedtls_ecdh_read_public() */
+		u8 buf[256];
+		if (sizeof(buf)-1 < len)
+			return NULL;
+		buf[0] = (u8)(len);
+		os_memcpy(buf+1, key, len);
+
+		if (inc_y) {
+			if (!(len & 1)) { /*(dpp code/tests does not include tag?!?)*/
+				if (sizeof(buf)-2 < len)
+					return NULL;
+				buf[0] = (u8)(1+len);
+				buf[1] = 0x04;
+				os_memcpy(buf+2, key, len);
+			}
+			len >>= 1; /*(repurpose len to prime_len)*/
+		} else { /* (inc_y == 0) */
+			/* mbedtls_ecp_point_read_binary() does not currently support
+			 * MBEDTLS_ECP_PF_COMPRESSED format (buf[1] = 0x02 or 0x03)
+			 * (returns MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE) */
+
+			/* derive y, amend buf[] with y for UNCOMPRESSED format */
+			if (sizeof(buf)-2 < len*2 || len == 0)
+				return NULL;
+
+			buf[0] = (u8)(1+len*2);
+			buf[1] = 0x04;
+			os_memcpy(buf+2, key, len);
+
+			mbedtls_mpi bn;
+			mbedtls_mpi_init(&bn);
+			int ret = mbedtls_mpi_read_binary(&bn, key, len)
+			       || crypto_mbedtls_short_weierstrass_derive_y(grp, &bn, 0)
+			       || mbedtls_mpi_write_binary(&bn, buf+2+len, len);
+			mbedtls_mpi_free(&bn);
+			if (ret != 0)
+				return NULL;
+		}
+
+		if (mbedtls_ecdh_read_public(&ecdh->ctx, buf, buf[0]+1))
+			return NULL;
+	}
+  #endif
+  #if defined(MBEDTLS_ECP_MONTGOMERY_ENABLED)
+	if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_MONTGOMERY) {
+		if (mbedtls_ecdh_read_public(&ecdh->ctx, key, len))
+			return NULL;
+	}
+  #endif
+
+	struct wpabuf *buf = wpabuf_alloc(len);
+	if (buf == NULL)
+		return NULL;
+
+	if (mbedtls_ecdh_calc_secret(&ecdh->ctx, &len,
+	                             wpabuf_mhead(buf), len,
+	                             mbedtls_ctr_drbg_random,
+	                             crypto_mbedtls_ctr_drbg()) == 0) {
+		wpabuf_put(buf, len);
+		return buf;
+	}
+
+	wpabuf_clear_free(buf);
+	return NULL;
+}
+
+void crypto_ecdh_deinit(struct crypto_ecdh *ecdh)
+{
+	if (ecdh == NULL)
+		return;
+	mbedtls_ecp_point_free(&ecdh->Q);
+	mbedtls_ecp_group_free(&ecdh->grp);
+	mbedtls_ecdh_free(&ecdh->ctx);
+	os_free(ecdh);
+}
+
+size_t crypto_ecdh_prime_len(struct crypto_ecdh *ecdh)
+{
+	return CRYPTO_EC_plen(&ecdh->grp);
+}
+
+#endif /* CRYPTO_MBEDTLS_CRYPTO_ECDH */
+
+
+#ifdef CRYPTO_MBEDTLS_CRYPTO_EC
+
+#include <mbedtls/ecp.h>
+
+struct crypto_ec *crypto_ec_init(int group)
+{
+	mbedtls_ecp_group_id grp_id =
+	  crypto_mbedtls_ecp_group_id_from_ike_id(group);
+	if (grp_id == MBEDTLS_ECP_DP_NONE)
+		return NULL;
+	mbedtls_ecp_group *e = os_malloc(sizeof(*e));
+	if (e == NULL)
+		return NULL;
+	mbedtls_ecp_group_init(e);
+	if (mbedtls_ecp_group_load(e, grp_id) == 0)
+		return (struct crypto_ec *)e;
+
+	mbedtls_ecp_group_free(e);
+	os_free(e);
+	return NULL;
+}
+
+void crypto_ec_deinit(struct crypto_ec *e)
+{
+	mbedtls_ecp_group_free((mbedtls_ecp_group *)e);
+	os_free(e);
+}
+
+size_t crypto_ec_prime_len(struct crypto_ec *e)
+{
+	return CRYPTO_EC_plen(e);
+}
+
+size_t crypto_ec_prime_len_bits(struct crypto_ec *e)
+{
+	return CRYPTO_EC_pbits(e);
+}
+
+size_t crypto_ec_order_len(struct crypto_ec *e)
+{
+	return (mbedtls_mpi_bitlen(CRYPTO_EC_N(e)) + 7) / 8;
+}
+
+const struct crypto_bignum *crypto_ec_get_prime(struct crypto_ec *e)
+{
+	return (const struct crypto_bignum *)CRYPTO_EC_P(e);
+}
+
+const struct crypto_bignum *crypto_ec_get_order(struct crypto_ec *e)
+{
+	return (const struct crypto_bignum *)CRYPTO_EC_N(e);
+}
+
+const struct crypto_bignum *crypto_ec_get_a(struct crypto_ec *e)
+{
+	static const uint8_t secp256r1_a[] =
+	  {0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x01,
+	   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	   0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,
+	   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc};
+	static const uint8_t secp384r1_a[] =
+	  {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+	   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+	   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+	   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,
+	   0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,
+	   0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xfc};
+	static const uint8_t secp521r1_a[] =
+	  {0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+	   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+	   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+	   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+	   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+	   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+	   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+	   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+	   0xff,0xfc};
+	static const uint8_t secp192r1_a[] =
+	  {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+	   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,
+	   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc};
+	static const uint8_t secp224r1_a[] =
+	  {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+	   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,
+	   0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+	   0xff,0xff,0xff,0xfe};
+
+	const uint8_t *bin = NULL;
+	size_t len = 0;
+
+	/* (mbedtls groups matching supported sswu_curve_param() IKE groups) */
+	switch (((mbedtls_ecp_group *)e)->id) {
+  #ifdef MBEDTLS_ECP_DP_SECP256R1_ENABLED
+	case MBEDTLS_ECP_DP_SECP256R1:
+		bin = secp256r1_a;
+		len = sizeof(secp256r1_a);
+		break;
+  #endif
+  #ifdef MBEDTLS_ECP_DP_SECP384R1_ENABLED
+	case MBEDTLS_ECP_DP_SECP384R1:
+		bin = secp384r1_a;
+		len = sizeof(secp384r1_a);
+		break;
+  #endif
+  #ifdef MBEDTLS_ECP_DP_SECP521R1_ENABLED
+	case MBEDTLS_ECP_DP_SECP521R1:
+		bin = secp521r1_a;
+		len = sizeof(secp521r1_a);
+		break;
+  #endif
+  #ifdef MBEDTLS_ECP_DP_SECP192R1_ENABLED
+	case MBEDTLS_ECP_DP_SECP192R1:
+		bin = secp192r1_a;
+		len = sizeof(secp192r1_a);
+		break;
+  #endif
+  #ifdef MBEDTLS_ECP_DP_SECP224R1_ENABLED
+	case MBEDTLS_ECP_DP_SECP224R1:
+		bin = secp224r1_a;
+		len = sizeof(secp224r1_a);
+		break;
+  #endif
+  #ifdef MBEDTLS_ECP_DP_BP256R1_ENABLED
+	case MBEDTLS_ECP_DP_BP256R1:
+		return (const struct crypto_bignum *)CRYPTO_EC_A(e);
+  #endif
+  #ifdef MBEDTLS_ECP_DP_BP384R1_ENABLED
+	case MBEDTLS_ECP_DP_BP384R1:
+		return (const struct crypto_bignum *)CRYPTO_EC_A(e);
+  #endif
+  #ifdef MBEDTLS_ECP_DP_BP512R1_ENABLED
+	case MBEDTLS_ECP_DP_BP512R1:
+		return (const struct crypto_bignum *)CRYPTO_EC_A(e);
+  #endif
+  #ifdef MBEDTLS_ECP_DP_CURVE25519_ENABLED
+	case MBEDTLS_ECP_DP_CURVE25519:
+		return (const struct crypto_bignum *)CRYPTO_EC_A(e);
+  #endif
+  #ifdef MBEDTLS_ECP_DP_CURVE448_ENABLED
+	case MBEDTLS_ECP_DP_CURVE448:
+		return (const struct crypto_bignum *)CRYPTO_EC_A(e);
+  #endif
+	default:
+		return NULL;
+	}
+
+	/*(note: not thread-safe; returns file-scoped static storage)*/
+	if (mbedtls_mpi_read_binary(&mpi_sw_A, bin, len) == 0)
+		return (const struct crypto_bignum *)&mpi_sw_A;
+	return NULL;
+}
+
+const struct crypto_bignum *crypto_ec_get_b(struct crypto_ec *e)
+{
+	return (const struct crypto_bignum *)CRYPTO_EC_B(e);
+}
+
+const struct crypto_ec_point * crypto_ec_get_generator(struct crypto_ec *e)
+{
+	return (const struct crypto_ec_point *)CRYPTO_EC_G(e);
+}
+
+struct crypto_ec_point *crypto_ec_point_init(struct crypto_ec *e)
+{
+	if (TEST_FAIL())
+		return NULL;
+
+	mbedtls_ecp_point *p = os_malloc(sizeof(*p));
+	if (p != NULL)
+		mbedtls_ecp_point_init(p);
+	return (struct crypto_ec_point *)p;
+}
+
+void crypto_ec_point_deinit(struct crypto_ec_point *p, int clear)
+{
+	mbedtls_ecp_point_free((mbedtls_ecp_point *)p);
+	os_free(p);
+}
+
+int crypto_ec_point_x(struct crypto_ec *e, const struct crypto_ec_point *p,
+		      struct crypto_bignum *x)
+{
+	mbedtls_mpi *px = &((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(X);
+	return mbedtls_mpi_copy((mbedtls_mpi *)x, px)
+	  ? -1
+	  : 0;
+}
+
+int crypto_ec_point_to_bin(struct crypto_ec *e,
+			   const struct crypto_ec_point *point, u8 *x, u8 *y)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	/* crypto.h documents crypto_ec_point_to_bin() output is big-endian */
+	size_t len = CRYPTO_EC_plen(e);
+	if (x) {
+		mbedtls_mpi *px = &((mbedtls_ecp_point *)point)->MBEDTLS_PRIVATE(X);
+		if (mbedtls_mpi_write_binary(px, x, len))
+			return -1;
+	}
+	if (y) {
+	  #if 0 /*(should not be necessary; py mpi should be in initial state)*/
+	  #ifdef MBEDTLS_ECP_MONTGOMERY_ENABLED
+		if (mbedtls_ecp_get_type((mbedtls_ecp_group *)e)
+		    == MBEDTLS_ECP_TYPE_MONTGOMERY) {
+			os_memset(y, 0, len);
+			return 0;
+		}
+	  #endif
+	  #endif
+		mbedtls_mpi *py = &((mbedtls_ecp_point *)point)->MBEDTLS_PRIVATE(Y);
+		if (mbedtls_mpi_write_binary(py, y, len))
+			return -1;
+	}
+	return 0;
+}
+
+struct crypto_ec_point * crypto_ec_point_from_bin(struct crypto_ec *e,
+						  const u8 *val)
+{
+	if (TEST_FAIL())
+		return NULL;
+
+	size_t len = CRYPTO_EC_plen(e);
+	mbedtls_ecp_point *p = os_malloc(sizeof(*p));
+	u8 buf[1+MBEDTLS_MPI_MAX_SIZE*2];
+	if (p == NULL)
+		return NULL;
+	mbedtls_ecp_point_init(p);
+
+  #ifdef MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED
+	if (mbedtls_ecp_get_type((mbedtls_ecp_group *)e)
+	    == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
+	  #if 0 /* prefer alternative to MBEDTLS_PRIVATE() access */
+		mbedtls_mpi *px = &((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(X);
+		mbedtls_mpi *py = &((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Y);
+		mbedtls_mpi *pz = &((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Z);
+
+		if (mbedtls_mpi_read_binary(px, val, len) == 0
+		    && mbedtls_mpi_read_binary(py, val + len, len) == 0
+		    && mbedtls_mpi_lset(pz, 1) == 0)
+			return (struct crypto_ec_point *)p;
+	  #else
+		buf[0] = 0x04;
+		os_memcpy(buf+1, val, len*2);
+		if (mbedtls_ecp_point_read_binary((mbedtls_ecp_group *)e, p,
+		                                  buf, 1+len*2) == 0)
+			return (struct crypto_ec_point *)p;
+	  #endif
+	}
+  #endif
+  #ifdef MBEDTLS_ECP_MONTGOMERY_ENABLED
+	if (mbedtls_ecp_get_type((mbedtls_ecp_group *)e)
+	    == MBEDTLS_ECP_TYPE_MONTGOMERY) {
+		/* crypto.h interface documents crypto_ec_point_from_bin()
+		 * val is length: prime_len * 2 and is big-endian
+		 * (Short Weierstrass is assumed by hostap)
+		 * Reverse to little-endian format for Montgomery */
+		for (unsigned int i = 0; i < len; ++i)
+			buf[i] = val[len-1-i];
+		if (mbedtls_ecp_point_read_binary((mbedtls_ecp_group *)e, p,
+		                                  buf, len) == 0)
+			return (struct crypto_ec_point *)p;
+	}
+  #endif
+
+	mbedtls_ecp_point_free(p);
+	os_free(p);
+	return NULL;
+}
+
+int crypto_ec_point_add(struct crypto_ec *e, const struct crypto_ec_point *a,
+			const struct crypto_ec_point *b,
+			struct crypto_ec_point *c)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	/* mbedtls does not provide an mbedtls_ecp_point add function */
+	mbedtls_mpi one;
+	mbedtls_mpi_init(&one);
+	int ret = mbedtls_mpi_lset(&one, 1)
+	       || mbedtls_ecp_muladd(
+			(mbedtls_ecp_group *)e, (mbedtls_ecp_point *)c,
+			&one, (const mbedtls_ecp_point *)a,
+			&one, (const mbedtls_ecp_point *)b) ? -1 : 0;
+	mbedtls_mpi_free(&one);
+	return ret;
+}
+
+int crypto_ec_point_mul(struct crypto_ec *e, const struct crypto_ec_point *p,
+			const struct crypto_bignum *b,
+			struct crypto_ec_point *res)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	return mbedtls_ecp_mul(
+		(mbedtls_ecp_group *)e, (mbedtls_ecp_point *)res,
+		(const mbedtls_mpi *)b, (const mbedtls_ecp_point *)p,
+		mbedtls_ctr_drbg_random, crypto_mbedtls_ctr_drbg()) ? -1 : 0;
+}
+
+int crypto_ec_point_invert(struct crypto_ec *e, struct crypto_ec_point *p)
+{
+	if (TEST_FAIL())
+		return -1;
+
+	if (mbedtls_ecp_get_type((mbedtls_ecp_group *)e)
+	    == MBEDTLS_ECP_TYPE_MONTGOMERY) {
+		/* e.g. MBEDTLS_ECP_DP_CURVE25519 and MBEDTLS_ECP_DP_CURVE448 */
+		wpa_printf(MSG_ERROR,
+		           "%s not implemented for Montgomery curves",__func__);
+		return -1;
+	}
+
+	/* mbedtls does not provide an mbedtls_ecp_point invert function */
+	/* below works for Short Weierstrass; incorrect for Montgomery curves */
+	mbedtls_mpi *py = &((mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Y);
+	return mbedtls_ecp_is_zero((mbedtls_ecp_point *)p) /*point at infinity*/
+	    || mbedtls_mpi_cmp_int(py, 0) == 0      /*point is its own inverse*/
+	    || mbedtls_mpi_sub_abs(py, CRYPTO_EC_P(e), py) == 0 ? 0 : -1;
+}
+
+#ifdef MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED
+static int
+crypto_ec_point_y_sqr_weierstrass(mbedtls_ecp_group *e, const mbedtls_mpi *x,
+                                  mbedtls_mpi *y2)
+{
+	/* MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS  y^2 = x^3 + a x + b    */
+
+	/* Short Weierstrass elliptic curve group w/o A set treated as A = -3 */
+	/* Attempt to match mbedtls/library/ecp.c:ecp_check_pubkey_sw() behavior
+	 * and elsewhere in mbedtls/library/ecp.c where if A is not set, it is
+	 * treated as if A = -3. */
+
+  #if 0
+	/* y^2 = x^3 + ax + b */
+	mbedtls_mpi *A = &e->A;
+	mbedtls_mpi t, A_neg3;
+	if (&e->A.p == NULL) {
+		mbedtls_mpi_init(&A_neg3);
+		if (mbedtls_mpi_lset(&A_neg3, -3) != 0) {
+			mbedtls_mpi_free(&A_neg3);
+			return -1;
+		}
+		A = &A_neg3;
+	}
+	mbedtls_mpi_init(&t);
+	int ret = /* x^3 */
+	          mbedtls_mpi_lset(&t, 3)
+	       || mbedtls_mpi_exp_mod(y2,  x, &t, &e->P, NULL)
+		  /* ax */
+	       || mbedtls_mpi_mul_mpi(y2, y2, A)
+	       || mbedtls_mpi_mod_mpi(&t, &t, &e->P)
+		  /* ax + b */
+	       || mbedtls_mpi_add_mpi(&t, &t, &e->B)
+	       || mbedtls_mpi_mod_mpi(&t, &t, &e->P)
+		  /* x^3 + ax + b */
+	       || mbedtls_mpi_add_mpi(&t, &t, y2) /* ax + b + x^3 */
+	       || mbedtls_mpi_mod_mpi(y2, &t, &e->P);
+	mbedtls_mpi_free(&t);
+	if (A == &A_neg3)
+		mbedtls_mpi_free(&A_neg3);
+	return ret; /* 0: success, non-zero: failure */
+  #else
+	/* y^2 = x^3 + ax + b = (x^2 + a)x + b */
+	return    /* x^2 */
+	          mbedtls_mpi_mul_mpi(y2,  x, x)
+	       || mbedtls_mpi_mod_mpi(y2, y2, &e->P)
+		  /* x^2 + a */
+	       || (e->A.MBEDTLS_PRIVATE(p)
+	           ? mbedtls_mpi_add_mpi(y2, y2, &e->A)
+	           : mbedtls_mpi_sub_int(y2, y2, 3))
+	       || mbedtls_mpi_mod_mpi(y2, y2, &e->P)
+		  /* (x^2 + a)x */
+	       || mbedtls_mpi_mul_mpi(y2, y2, x)
+	       || mbedtls_mpi_mod_mpi(y2, y2, &e->P)
+		  /* (x^2 + a)x + b */
+	       || mbedtls_mpi_add_mpi(y2, y2, &e->B)
+	       || mbedtls_mpi_mod_mpi(y2, y2, &e->P);
+  #endif
+}
+#endif /* MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED */
+
+#if 0 /* not used by hostap */
+#ifdef MBEDTLS_ECP_MONTGOMERY_ENABLED
+static int
+crypto_ec_point_y_sqr_montgomery(mbedtls_ecp_group *e, const mbedtls_mpi *x,
+                                 mbedtls_mpi *y2)
+{
+	/* XXX: !!! must be reviewed and audited for correctness !!! */
+
+	/* MBEDTLS_ECP_TYPE_MONTGOMERY         y^2 = x^3 + a x^2 + x  */
+
+	/* y^2 = x^3 + a x^2 + x = (x + a)x^2 + x */
+	mbedtls_mpi x2;
+	mbedtls_mpi_init(&x2);
+	int ret = /* x^2 */
+	          mbedtls_mpi_mul_mpi(&x2, x, x)
+	       || mbedtls_mpi_mod_mpi(&x2, &x2, &e->P)
+		  /* x + a */
+	       || mbedtls_mpi_add_mpi(y2,  x, &e->A)
+	       || mbedtls_mpi_mod_mpi(y2, y2, &e->P)
+		  /* (x + a)x^2 */
+	       || mbedtls_mpi_mul_mpi(y2, y2, &x2)
+	       || mbedtls_mpi_mod_mpi(y2, y2, &e->P)
+		  /* (x + a)x^2 + x */
+	       || mbedtls_mpi_add_mpi(y2, y2, x)
+	       || mbedtls_mpi_mod_mpi(y2, y2, &e->P);
+	mbedtls_mpi_free(&x2);
+	return ret; /* 0: success, non-zero: failure */
+}
+#endif /* MBEDTLS_ECP_MONTGOMERY_ENABLED */
+#endif
+
+struct crypto_bignum *
+crypto_ec_point_compute_y_sqr(struct crypto_ec *e,
+			      const struct crypto_bignum *x)
+{
+	if (TEST_FAIL())
+		return NULL;
+
+	mbedtls_mpi *y2 = os_malloc(sizeof(*y2));
+	if (y2 == NULL)
+		return NULL;
+	mbedtls_mpi_init(y2);
+
+  #ifdef MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED
+	if (mbedtls_ecp_get_type((mbedtls_ecp_group *)e)
+	      == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS
+	    && crypto_ec_point_y_sqr_weierstrass((mbedtls_ecp_group *)e,
+	                                         (const mbedtls_mpi *)x,
+	                                         y2) == 0)
+		return (struct crypto_bignum *)y2;
+  #endif
+  #if 0 /* not used by hostap */
+  #ifdef MBEDTLS_ECP_MONTGOMERY_ENABLED
+	if (mbedtls_ecp_get_type((mbedtls_ecp_group *)e)
+	      == MBEDTLS_ECP_TYPE_MONTGOMERY
+	    && crypto_ec_point_y_sqr_montgomery((mbedtls_ecp_group *)e,
+	                                        (const mbedtls_mpi *)x,
+	                                        y2) == 0)
+		return (struct crypto_bignum *)y2;
+  #endif
+  #endif
+
+	mbedtls_mpi_free(y2);
+	os_free(y2);
+	return NULL;
+}
+
+int crypto_ec_point_is_at_infinity(struct crypto_ec *e,
+				   const struct crypto_ec_point *p)
+{
+	return mbedtls_ecp_is_zero((mbedtls_ecp_point *)p);
+}
+
+int crypto_ec_point_is_on_curve(struct crypto_ec *e,
+				const struct crypto_ec_point *p)
+{
+  #if 1
+	return mbedtls_ecp_check_pubkey((const mbedtls_ecp_group *)e,
+	                                (const mbedtls_ecp_point *)p) == 0;
+  #else
+	/* compute y^2 mod P and compare to y^2 mod P */
+	/*(ref: src/eap_common/eap_pwd_common.c:compute_password_element())*/
+	const mbedtls_mpi *px = &((const mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(X);
+	mbedtls_mpi *cy2 = (mbedtls_mpi *)
+	  crypto_ec_point_compute_y_sqr(e, (const struct crypto_bignum *)px);
+	if (cy2 == NULL)
+		return 0;
+
+	mbedtls_mpi y2;
+	mbedtls_mpi_init(&y2);
+	const mbedtls_mpi *py = &((const mbedtls_ecp_point *)p)->MBEDTLS_PRIVATE(Y);
+	int is_on_curve = mbedtls_mpi_mul_mpi(&y2, py, py) /* y^2 mod P */
+	               || mbedtls_mpi_mod_mpi(&y2, &y2, CRYPTO_EC_P(e))
+	               || mbedtls_mpi_cmp_mpi(&y2, cy2) != 0 ? 0 : 1;
+
+	mbedtls_mpi_free(&y2);
+	mbedtls_mpi_free(cy2);
+	os_free(cy2);
+	return is_on_curve;
+  #endif
+}
+
+int crypto_ec_point_cmp(const struct crypto_ec *e,
+			const struct crypto_ec_point *a,
+			const struct crypto_ec_point *b)
+{
+	return mbedtls_ecp_point_cmp((const mbedtls_ecp_point *)a,
+	                             (const mbedtls_ecp_point *)b);
+}
+
+#if !defined(CONFIG_NO_STDOUT_DEBUG)
+void crypto_ec_point_debug_print(const struct crypto_ec *e,
+				 const struct crypto_ec_point *p,
+				 const char *title)
+{
+	u8 x[MBEDTLS_MPI_MAX_SIZE];
+	u8 y[MBEDTLS_MPI_MAX_SIZE];
+	size_t len = CRYPTO_EC_plen(e);
+	/* crypto_ec_point_to_bin ought to take (const struct crypto_ec *e) */
+	struct crypto_ec *ee;
+	*(const struct crypto_ec **)&ee = e; /*(cast away const)*/
+	if (crypto_ec_point_to_bin(ee, p, x, y) == 0) {
+		if (title)
+			wpa_printf(MSG_DEBUG, "%s", title);
+		wpa_hexdump(MSG_DEBUG, "x:", x, len);
+		wpa_hexdump(MSG_DEBUG, "y:", y, len);
+	}
+}
+#endif
+
+
+struct crypto_ec_key * crypto_ec_key_parse_priv(const u8 *der, size_t der_len)
+{
+	mbedtls_pk_context *ctx = os_malloc(sizeof(*ctx));
+	if (ctx == NULL)
+		return NULL;
+	mbedtls_pk_init(ctx);
+  #if MBEDTLS_VERSION_NUMBER < 0x03000000 /* mbedtls 3.0.0 */
+	if (mbedtls_pk_parse_key(ctx, der, der_len, NULL, 0) == 0)
+  #else
+	if (mbedtls_pk_parse_key(ctx, der, der_len, NULL, 0,
+	                         mbedtls_ctr_drbg_random,
+	                         crypto_mbedtls_ctr_drbg()) == 0)
+  #endif
+		return (struct crypto_ec_key *)ctx;
+
+	mbedtls_pk_free(ctx);
+	os_free(ctx);
+	return NULL;
+}
+
+#ifdef CRYPTO_MBEDTLS_CRYPTO_HPKE
+#ifdef CONFIG_MODULE_TESTS
+/*(for crypto_module_tests.c)*/
+struct crypto_ec_key * crypto_ec_key_set_priv(int group,
+					      const u8 *raw, size_t raw_len)
+{
+	mbedtls_ecp_group_id grp_id =
+	  crypto_mbedtls_ecp_group_id_from_ike_id(group);
+	if (grp_id == MBEDTLS_ECP_DP_NONE)
+		return NULL;
+	const mbedtls_pk_info_t *pk_info =
+	  mbedtls_pk_info_from_type(MBEDTLS_PK_ECKEY);
+	if (pk_info == NULL)
+		return NULL;
+	mbedtls_pk_context *ctx = os_malloc(sizeof(*ctx));
+	if (ctx == NULL)
+		return NULL;
+	mbedtls_pk_init(ctx);
+	if (mbedtls_pk_setup(ctx, pk_info) == 0
+	    && mbedtls_ecp_read_key(grp_id,mbedtls_pk_ec(*ctx),raw,raw_len) == 0) {
+		return (struct crypto_ec_key *)ctx;
+	}
+
+	mbedtls_pk_free(ctx);
+	os_free(ctx);
+	return NULL;
+}
+#endif
+#endif
+
+#include <mbedtls/error.h>
+#include <mbedtls/oid.h>
+static int crypto_mbedtls_pk_parse_subpubkey_compressed(mbedtls_pk_context *ctx, const u8 *der, size_t der_len)
+{
+    /* The following is modified from:
+     *   mbedtls/library/pkparse.c:mbedtls_pk_parse_subpubkey()
+     *   mbedtls/library/pkparse.c:pk_get_pk_alg()
+     *   mbedtls/library/pkparse.c:pk_use_ecparams()
+     */
+    mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;
+    const mbedtls_pk_info_t *pk_info;
+    int ret;
+    size_t len;
+    const unsigned char *end = der+der_len;
+    unsigned char *p;
+    *(const unsigned char **)&p = der;
+
+    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
+                    MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
+    {
+        return( MBEDTLS_ERROR_ADD( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT, ret ) );
+    }
+
+    end = p + len;
+
+    /*
+    if( ( ret = pk_get_pk_alg( &p, end, &pk_alg, &alg_params ) ) != 0 )
+        return( ret );
+    */
+    mbedtls_asn1_buf alg_oid, params;
+    memset( &params, 0, sizeof(mbedtls_asn1_buf) );
+    if( ( ret = mbedtls_asn1_get_alg( &p, end, &alg_oid, &params ) ) != 0 )
+        return( MBEDTLS_ERROR_ADD( MBEDTLS_ERR_PK_INVALID_ALG, ret ) );
+    if( mbedtls_oid_get_pk_alg( &alg_oid, &pk_alg ) != 0 )
+        return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );
+
+    if( ( ret = mbedtls_asn1_get_bitstring_null( &p, end, &len ) ) != 0 )
+        return( MBEDTLS_ERROR_ADD( MBEDTLS_ERR_PK_INVALID_PUBKEY, ret ) );
+
+    if( p + len != end )
+        return( MBEDTLS_ERROR_ADD( MBEDTLS_ERR_PK_INVALID_PUBKEY,
+                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH ) );
+
+    if( ( pk_info = mbedtls_pk_info_from_type( pk_alg ) ) == NULL )
+        return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );
+
+    if( ( ret = mbedtls_pk_setup( ctx, pk_info ) ) != 0 )
+        return( ret );
+
+    /* assume mbedtls_pk_parse_subpubkey(&der, der+der_len, ctx)
+     * has already run with ctx initialized up to pk_get_ecpubkey(),
+     * and pk_get_ecpubkey() has returned MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE
+     *
+     * mbedtls mbedtls_ecp_point_read_binary()
+     * does not handle point in COMPRESSED format
+     *
+     * (validate assumption that algorithm is EC) */
+    mbedtls_ecp_keypair *ecp_kp = mbedtls_pk_ec(*ctx);
+    if (ecp_kp == NULL)
+        return( MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE );
+    mbedtls_ecp_group *ecp_kp_grp = &ecp_kp->MBEDTLS_PRIVATE(grp);
+    mbedtls_ecp_point *ecp_kp_Q = &ecp_kp->MBEDTLS_PRIVATE(Q);
+    mbedtls_ecp_group_id grp_id;
+
+
+    /* mbedtls/library/pkparse.c:pk_use_ecparams() */
+
+    if( params.tag == MBEDTLS_ASN1_OID )
+    {
+        if( mbedtls_oid_get_ec_grp( &params, &grp_id ) != 0 )
+            return( MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE );
+    }
+    else
+    {
+#if defined(MBEDTLS_PK_PARSE_EC_EXTENDED)
+        /*(large code block not copied from mbedtls; unsupported)*/
+      #if 0
+        if( ( ret = pk_group_id_from_specified( &params, &grp_id ) ) != 0 )
+            return( ret );
+      #endif
+#endif
+        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
+    }
+
+    /*
+     * grp may already be initialized; if so, make sure IDs match
+     */
+    if( ecp_kp_grp->id != MBEDTLS_ECP_DP_NONE && ecp_kp_grp->id != grp_id )
+        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
+
+    if( ( ret = mbedtls_ecp_group_load( ecp_kp_grp, grp_id ) ) != 0 )
+        return( ret );
+
+
+    /* (validate assumption that EC point is in COMPRESSED format) */
+    len = CRYPTO_EC_plen(ecp_kp_grp);
+    if( mbedtls_ecp_get_type(ecp_kp_grp) != MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS
+        || (end - p) != 1+len
+        || (*p != 0x02 && *p != 0x03) )
+        return( MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE );
+
+    /* Instead of calling mbedtls/library/pkparse.c:pk_get_ecpubkey() to call
+     * mbedtls_ecp_point_read_binary(), manually parse point into ecp_kp_Q */
+    mbedtls_mpi *X = &ecp_kp_Q->MBEDTLS_PRIVATE(X);
+    mbedtls_mpi *Y = &ecp_kp_Q->MBEDTLS_PRIVATE(Y);
+    mbedtls_mpi *Z = &ecp_kp_Q->MBEDTLS_PRIVATE(Z);
+    ret = mbedtls_mpi_lset(Z, 1);
+    if (ret != 0)
+        return( ret );
+    ret = mbedtls_mpi_read_binary(X, p+1, len);
+    if (ret != 0)
+        return( ret );
+    /* derive Y
+     * (similar derivation of Y in crypto_mbedtls.c:crypto_ecdh_set_peerkey())*/
+    ret = mbedtls_mpi_copy(Y, X) /*(Y is used as input and output obj below)*/
+       || crypto_mbedtls_short_weierstrass_derive_y(ecp_kp_grp, Y, (*p & 1));
+    if (ret != 0)
+        return( ret );
+
+    return mbedtls_ecp_check_pubkey( ecp_kp_grp, ecp_kp_Q );
+}
+
+struct crypto_ec_key * crypto_ec_key_parse_pub(const u8 *der, size_t der_len)
+{
+	mbedtls_pk_context *ctx = os_malloc(sizeof(*ctx));
+	if (ctx == NULL)
+		return NULL;
+	mbedtls_pk_init(ctx);
+	/*int rc = mbedtls_pk_parse_subpubkey(&der, der+der_len, ctx);*/
+	int rc = mbedtls_pk_parse_public_key(ctx, der, der_len);
+	if (rc == 0)
+		return (struct crypto_ec_key *)ctx;
+	else if (rc == MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE) {
+		/* mbedtls mbedtls_ecp_point_read_binary()
+		 * does not handle point in COMPRESSED format; parse internally */
+		rc = crypto_mbedtls_pk_parse_subpubkey_compressed(ctx,der,der_len);
+		if (rc == 0)
+			return (struct crypto_ec_key *)ctx;
+	}
+
+	mbedtls_pk_free(ctx);
+	os_free(ctx);
+	return NULL;
+}
+
+#ifdef CRYPTO_MBEDTLS_CRYPTO_EC_DPP
+
+static struct crypto_ec_key *
+crypto_ec_key_set_pub_point_for_group(mbedtls_ecp_group_id grp_id,
+                                      const mbedtls_ecp_point *pub,
+                                      const u8 *buf, size_t len)
+{
+	const mbedtls_pk_info_t *pk_info =
+	  mbedtls_pk_info_from_type(MBEDTLS_PK_ECKEY);
+	if (pk_info == NULL)
+		return NULL;
+	mbedtls_pk_context *ctx = os_malloc(sizeof(*ctx));
+	if (ctx == NULL)
+		return NULL;
+	mbedtls_pk_init(ctx);
+	if (mbedtls_pk_setup(ctx, pk_info) == 0) {
+		/* (Is private key generation necessary for callers?)
+		 * alt: gen key then overwrite Q
+		 *   mbedtls_ecp_gen_key(grp_id, ecp_kp,
+	         *                       mbedtls_ctr_drbg_random,
+	         *                       crypto_mbedtls_ctr_drbg()) == 0
+	         */
+		mbedtls_ecp_keypair *ecp_kp = mbedtls_pk_ec(*ctx);
+		mbedtls_ecp_group *ecp_kp_grp = &ecp_kp->MBEDTLS_PRIVATE(grp);
+		mbedtls_ecp_point *ecp_kp_Q = &ecp_kp->MBEDTLS_PRIVATE(Q);
+		mbedtls_mpi *ecp_kp_d = &ecp_kp->MBEDTLS_PRIVATE(d);
+		if (mbedtls_ecp_group_load(ecp_kp_grp, grp_id) == 0
+		    && (pub
+		         ? mbedtls_ecp_copy(ecp_kp_Q, pub) == 0
+		         : mbedtls_ecp_point_read_binary(ecp_kp_grp, ecp_kp_Q,
+		                                         buf, len) == 0)
+		    && mbedtls_ecp_gen_privkey(ecp_kp_grp, ecp_kp_d,
+		                               mbedtls_ctr_drbg_random,
+		                               crypto_mbedtls_ctr_drbg()) == 0){
+			return (struct crypto_ec_key *)ctx;
+		}
+	}
+
+	mbedtls_pk_free(ctx);
+	os_free(ctx);
+	return NULL;
+}
+
+struct crypto_ec_key * crypto_ec_key_set_pub(int group, const u8 *x,
+					     const u8 *y, size_t len)
+{
+	mbedtls_ecp_group_id grp_id =
+	  crypto_mbedtls_ecp_group_id_from_ike_id(group);
+	if (grp_id == MBEDTLS_ECP_DP_NONE)
+		return NULL;
+	if (len > MBEDTLS_MPI_MAX_SIZE)
+		return NULL;
+	u8 buf[1+MBEDTLS_MPI_MAX_SIZE*2];
+	buf[0] = 0x04; /* assume x,y for Short Weierstrass */
+	os_memcpy(buf+1, x, len);
+	os_memcpy(buf+1+len, y, len);
+
+	return crypto_ec_key_set_pub_point_for_group(grp_id,NULL,buf,1+len*2);
+}
+
+struct crypto_ec_key *
+crypto_ec_key_set_pub_point(struct crypto_ec *e,
+			    const struct crypto_ec_point *pub)
+{
+	mbedtls_ecp_group_id grp_id = ((mbedtls_ecp_group *)e)->id;
+	mbedtls_ecp_point *p = (mbedtls_ecp_point *)pub;
+	return crypto_ec_key_set_pub_point_for_group(grp_id, p, NULL, 0);
+}
+
+
+struct crypto_ec_key * crypto_ec_key_gen(int group)
+{
+	mbedtls_pk_context *ctx = os_malloc(sizeof(*ctx));
+	if (ctx == NULL)
+		return NULL;
+	mbedtls_pk_init(ctx);
+	if (crypto_mbedtls_keypair_gen(group, ctx) == 0)
+		return (struct crypto_ec_key *)ctx;
+	mbedtls_pk_free(ctx);
+	os_free(ctx);
+	return NULL;
+}
+
+#endif /* CRYPTO_MBEDTLS_CRYPTO_EC_DPP */
+
+void crypto_ec_key_deinit(struct crypto_ec_key *key)
+{
+	mbedtls_pk_free((mbedtls_pk_context *)key);
+	os_free(key);
+}
+
+struct wpabuf * crypto_ec_key_get_subject_public_key(struct crypto_ec_key *key)
+{
+	/* (similar to crypto_ec_key_get_pubkey_point(),
+	 *  but compressed point format and ASN.1 DER wrapping)*/
+#ifndef MBEDTLS_PK_ECP_PUB_DER_MAX_BYTES /*(mbedtls/library/pkwrite.h)*/
+#define MBEDTLS_PK_ECP_PUB_DER_MAX_BYTES    ( 30 + 2 * MBEDTLS_ECP_MAX_BYTES )
+#endif
+	unsigned char buf[MBEDTLS_PK_ECP_PUB_DER_MAX_BYTES];
+	int len = mbedtls_pk_write_pubkey_der((mbedtls_pk_context *)key,
+	                                      buf, sizeof(buf));
+	if (len < 0)
+		return NULL;
+	/*  Note: data is written at the end of the buffer! Use the
+	 *        return value to determine where you should start
+	 *        using the buffer */
+	unsigned char *p = buf+sizeof(buf)-len;
+
+  #ifdef MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED
+	mbedtls_ecp_keypair *ecp_kp = mbedtls_pk_ec(*(mbedtls_pk_context *)key);
+	if (ecp_kp == NULL)
+		return NULL;
+	mbedtls_ecp_group *grp = &ecp_kp->MBEDTLS_PRIVATE(grp);
+	/*  Note: sae_pk.c expects pubkey point in compressed format,
+	 *        but mbedtls_pk_write_pubkey_der() writes uncompressed format.
+	 *        Manually translate format and update lengths in DER format */
+	if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS) {
+		unsigned char *end = buf+sizeof(buf);
+		size_t n;
+		/* SubjectPublicKeyInfo SEQUENCE */
+		mbedtls_asn1_get_tag(&p, end, &n,
+		    MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE);
+		/* algorithm AlgorithmIdentifier */
+		unsigned char *a = p;
+		size_t alen;
+		mbedtls_asn1_get_tag(&p, end, &alen,
+		    MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE);
+		p += alen;
+		alen = (size_t)(p - a);
+		/* subjectPublicKey BIT STRING */
+		mbedtls_asn1_get_tag(&p, end, &n, MBEDTLS_ASN1_BIT_STRING);
+		/* rewrite into compressed point format and rebuild ASN.1 */
+		p[1] = (buf[sizeof(buf)-1] & 1) ? 0x03 : 0x02;
+		n = 1 + 1 + (n-2)/2;
+		len = mbedtls_asn1_write_len(&p, buf, n) + (int)n;
+		len += mbedtls_asn1_write_tag(&p, buf, MBEDTLS_ASN1_BIT_STRING);
+		os_memmove(p-alen, a, alen);
+		len += alen;
+		p -= alen;
+		len += mbedtls_asn1_write_len(&p, buf, (size_t)len);
+		len += mbedtls_asn1_write_tag(&p, buf,
+		    MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE);
+	}
+  #endif
+	return wpabuf_alloc_copy(p, (size_t)len);
+}
+
+#ifdef CRYPTO_MBEDTLS_CRYPTO_EC_DPP
+
+struct wpabuf * crypto_ec_key_get_ecprivate_key(struct crypto_ec_key *key,
+						bool include_pub)
+{
+#ifndef MBEDTLS_PK_ECP_PRV_DER_MAX_BYTES /*(mbedtls/library/pkwrite.h)*/
+#define MBEDTLS_PK_ECP_PRV_DER_MAX_BYTES    ( 29 + 3 * MBEDTLS_ECP_MAX_BYTES )
+#endif
+	unsigned char priv[MBEDTLS_PK_ECP_PRV_DER_MAX_BYTES];
+	int privlen = mbedtls_pk_write_key_der((mbedtls_pk_context *)key,
+	                                       priv, sizeof(priv));
+	if (privlen < 0)
+		return NULL;
+
+	struct wpabuf *wbuf;
+
+	/*  Note: data is written at the end of the buffer! Use the
+	 *        return value to determine where you should start
+	 *        using the buffer */
+	/* mbedtls_pk_write_key_der() includes publicKey in DER */
+	if (include_pub)
+		wbuf = wpabuf_alloc_copy(priv+sizeof(priv)-privlen, privlen);
+	else {
+		/* calculate publicKey offset and skip from end of buffer */
+		unsigned char *p = priv+sizeof(priv)-privlen;
+		unsigned char *end = priv+sizeof(priv);
+		size_t len;
+		/* ECPrivateKey SEQUENCE */
+		mbedtls_asn1_get_tag(&p, end, &len,
+		    MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE);
+		/* version INTEGER */
+		unsigned char *v = p;
+		mbedtls_asn1_get_tag(&p, end, &len, MBEDTLS_ASN1_INTEGER);
+		p += len;
+		/* privateKey OCTET STRING */
+		mbedtls_asn1_get_tag(&p, end, &len, MBEDTLS_ASN1_OCTET_STRING);
+		p += len;
+		/* parameters ECParameters */
+		mbedtls_asn1_get_tag(&p, end, &len,
+		    MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED);
+		p += len;
+
+		/* write new SEQUENCE header (we know that it fits in priv[]) */
+		len = (size_t)(p - v);
+		p = v;
+		len += mbedtls_asn1_write_len(&p, priv, len);
+		len += mbedtls_asn1_write_tag(&p, priv,
+		    MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE);
+		wbuf = wpabuf_alloc_copy(p, len);
+	}
+
+	forced_memzero(priv, sizeof(priv));
+	return wbuf;
+}
+
+struct wpabuf * crypto_ec_key_get_pubkey_point(struct crypto_ec_key *key,
+					       int prefix)
+{
+	/*(similarities to crypto_ecdh_get_pubkey(), but different struct)*/
+	mbedtls_ecp_keypair *ecp_kp = mbedtls_pk_ec(*(mbedtls_pk_context *)key);
+	if (ecp_kp == NULL)
+		return NULL;
+	mbedtls_ecp_group *grp = &ecp_kp->MBEDTLS_PRIVATE(grp);
+	size_t len = CRYPTO_EC_plen(grp);
+  #ifdef MBEDTLS_ECP_MONTGOMERY_ENABLED
+	/* len */
+  #endif
+  #ifdef MBEDTLS_ECP_SHORT_WEIERSTRASS_ENABLED
+	if (mbedtls_ecp_get_type(grp) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS)
+		len = len*2+1;
+  #endif
+	struct wpabuf *buf = wpabuf_alloc(len);
+	if (buf == NULL)
+		return NULL;
+	mbedtls_ecp_point *ecp_kp_Q = &ecp_kp->MBEDTLS_PRIVATE(Q);
+	if (mbedtls_ecp_point_write_binary(grp, ecp_kp_Q,
+	                                   MBEDTLS_ECP_PF_UNCOMPRESSED, &len,
+	                                   wpabuf_mhead_u8(buf), len) == 0) {
+		if (!prefix) /* Remove 0x04 prefix if requested */
+			os_memmove(wpabuf_mhead(buf),wpabuf_mhead(buf)+1,--len);
+		wpabuf_put(buf, len);
+		return buf;
+	}
+
+	wpabuf_free(buf);
+	return NULL;
+}
+
+struct crypto_ec_point *
+crypto_ec_key_get_public_key(struct crypto_ec_key *key)
+{
+	mbedtls_ecp_keypair *ecp_kp = mbedtls_pk_ec(*(mbedtls_pk_context *)key);
+	if (ecp_kp == NULL)
+		return NULL;
+	mbedtls_ecp_point *p = os_malloc(sizeof(*p));
+	if (p != NULL) {
+		/*(mbedtls_ecp_export() uses &ecp_kp->MBEDTLS_PRIVATE(grp))*/
+		mbedtls_ecp_point_init(p);
+		mbedtls_ecp_point *ecp_kp_Q = &ecp_kp->MBEDTLS_PRIVATE(Q);
+		if (mbedtls_ecp_copy(p, ecp_kp_Q)) {
+			mbedtls_ecp_point_free(p);
+			os_free(p);
+			p = NULL;
+		}
+	}
+	return (struct crypto_ec_point *)p;
+}
+
+struct crypto_bignum *
+crypto_ec_key_get_private_key(struct crypto_ec_key *key)
+{
+	mbedtls_ecp_keypair *ecp_kp = mbedtls_pk_ec(*(mbedtls_pk_context *)key);
+	if (ecp_kp == NULL)
+		return NULL;
+	mbedtls_mpi *bn = os_malloc(sizeof(*bn));
+	if (bn) {
+		/*(mbedtls_ecp_export() uses &ecp_kp->MBEDTLS_PRIVATE(grp))*/
+		mbedtls_mpi_init(bn);
+		mbedtls_mpi *ecp_kp_d = &ecp_kp->MBEDTLS_PRIVATE(d);
+		if (mbedtls_mpi_copy(bn, ecp_kp_d)) {
+			mbedtls_mpi_free(bn);
+			os_free(bn);
+			bn = NULL;
+		}
+	}
+	return (struct crypto_bignum *)bn;
+}
+
+#endif /* CRYPTO_MBEDTLS_CRYPTO_EC_DPP */
+
+static mbedtls_md_type_t crypto_ec_key_sign_md(size_t len)
+{
+	/* get mbedtls_md_type_t from length of hash data to be signed */
+	switch (len) {
+	case 64: return MBEDTLS_MD_SHA512;
+	case 48: return MBEDTLS_MD_SHA384;
+	case 32: return MBEDTLS_MD_SHA256;
+	case 20: return MBEDTLS_MD_SHA1;
+	case 16: return MBEDTLS_MD_MD5;
+	default: return MBEDTLS_MD_NONE;
+	}
+}
+
+struct wpabuf * crypto_ec_key_sign(struct crypto_ec_key *key, const u8 *data,
+				   size_t len)
+{
+  #ifndef MBEDTLS_PK_SIGNATURE_MAX_SIZE /*(defined since mbedtls 2.20.0)*/
+  #if MBEDTLS_ECDSA_MAX_LEN > MBEDTLS_MPI_MAX_SIZE
+  #define MBEDTLS_PK_SIGNATURE_MAX_SIZE MBEDTLS_ECDSA_MAX_LEN
+  #else
+  #define MBEDTLS_PK_SIGNATURE_MAX_SIZE MBEDTLS_MPI_MAX_SIZE
+  #endif
+  #endif
+	size_t sig_len = MBEDTLS_PK_SIGNATURE_MAX_SIZE;
+	struct wpabuf *buf = wpabuf_alloc(sig_len);
+	if (buf == NULL)
+		return NULL;
+	if (mbedtls_pk_sign((mbedtls_pk_context *)key,
+	                    crypto_ec_key_sign_md(len), data, len,
+	                    wpabuf_mhead_u8(buf),
+  #if MBEDTLS_VERSION_NUMBER >= 0x03000000 /* mbedtls 3.0.0 */
+	                    sig_len,
+  #endif
+	                    &sig_len,
+	                    mbedtls_ctr_drbg_random,
+	                    crypto_mbedtls_ctr_drbg()) == 0) {
+		wpabuf_put(buf, sig_len);
+		return buf;
+	}
+
+	wpabuf_free(buf);
+	return NULL;
+}
+
+#ifdef CRYPTO_MBEDTLS_CRYPTO_EC_DPP
+struct wpabuf * crypto_ec_key_sign_r_s(struct crypto_ec_key *key,
+				       const u8 *data, size_t len)
+{
+	mbedtls_ecp_keypair *ecp_kp = mbedtls_pk_ec(*(mbedtls_pk_context *)key);
+	if (ecp_kp == NULL)
+		return NULL;
+
+	size_t sig_len = MBEDTLS_ECDSA_MAX_LEN;
+	u8 buf[MBEDTLS_ECDSA_MAX_LEN];
+	if (mbedtls_ecdsa_write_signature(ecp_kp, crypto_ec_key_sign_md(len),
+	                                  data, len, buf,
+  #if MBEDTLS_VERSION_NUMBER >= 0x03000000 /* mbedtls 3.0.0 */
+	                                  sig_len,
+  #endif
+	                                  &sig_len,
+	                                  mbedtls_ctr_drbg_random,
+	                                  crypto_mbedtls_ctr_drbg())) {
+		return NULL;
+	}
+
+	/*(mbedtls_ecdsa_write_signature() writes signature in ASN.1)*/
+	/* parse ASN.1 to get r and s and lengths */
+	u8 *p = buf, *r, *s;
+	u8 *end = p + sig_len;
+	size_t rlen, slen;
+	mbedtls_asn1_get_tag(&p, end, &rlen,
+	  MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE);
+	mbedtls_asn1_get_tag(&p, end, &rlen, MBEDTLS_ASN1_INTEGER);
+	r = p;
+	p += rlen;
+	mbedtls_asn1_get_tag(&p, end, &slen, MBEDTLS_ASN1_INTEGER);
+	s = p;
+
+	/* write raw r and s into out
+	 * (including removal of leading 0 if added for ASN.1 integer)
+	 * note: DPP caller expects raw r, s each padded to prime len */
+	mbedtls_ecp_group *ecp_kp_grp = &ecp_kp->MBEDTLS_PRIVATE(grp);
+	size_t plen = CRYPTO_EC_plen(ecp_kp_grp);
+	if (rlen > plen) {
+		r += (rlen - plen);
+		rlen = plen;
+	}
+	if (slen > plen) {
+		s += (slen - plen);
+		slen = plen;
+	}
+	struct wpabuf *out = wpabuf_alloc(plen*2);
+	if (out) {
+		wpabuf_put(out, plen*2);
+		p = wpabuf_mhead_u8(out);
+		os_memset(p, 0, plen*2);
+		os_memcpy(p+plen*1-rlen, r, rlen);
+		os_memcpy(p+plen*2-slen, s, slen);
+	}
+	return out;
+}
+#endif /* CRYPTO_MBEDTLS_CRYPTO_EC_DPP */
+
+int crypto_ec_key_verify_signature(struct crypto_ec_key *key, const u8 *data,
+				   size_t len, const u8 *sig, size_t sig_len)
+{
+	switch (mbedtls_pk_verify((mbedtls_pk_context *)key,
+	                          crypto_ec_key_sign_md(len), data, len,
+	                          sig, sig_len)) {
+	case 0:
+	/*case MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH:*//* XXX: allow? */
+		return 1;
+	case MBEDTLS_ERR_ECP_VERIFY_FAILED:
+		return 0;
+	default:
+		return -1;
+	}
+}
+
+#ifdef CRYPTO_MBEDTLS_CRYPTO_EC_DPP
+int crypto_ec_key_verify_signature_r_s(struct crypto_ec_key *key,
+				       const u8 *data, size_t len,
+				       const u8 *r, size_t r_len,
+				       const u8 *s, size_t s_len)
+{
+	/* reimplement mbedtls_ecdsa_read_signature() without encoding r and s
+	 * into ASN.1 just for mbedtls_ecdsa_read_signature() to decode ASN.1 */
+	mbedtls_ecp_keypair *ecp_kp = mbedtls_pk_ec(*(mbedtls_pk_context *)key);
+	if (ecp_kp == NULL)
+		return -1;
+	mbedtls_ecp_group *ecp_kp_grp = &ecp_kp->MBEDTLS_PRIVATE(grp);
+	mbedtls_ecp_point *ecp_kp_Q = &ecp_kp->MBEDTLS_PRIVATE(Q);
+
+	mbedtls_mpi mpi_r;
+	mbedtls_mpi mpi_s;
+	mbedtls_mpi_init(&mpi_r);
+	mbedtls_mpi_init(&mpi_s);
+	int ret = mbedtls_mpi_read_binary(&mpi_r, r, r_len)
+	       || mbedtls_mpi_read_binary(&mpi_s, s, s_len) ? -1 : 0;
+	if (ret == 0) {
+		ret = mbedtls_ecdsa_verify(ecp_kp_grp, data, len,
+		                           ecp_kp_Q, &mpi_r, &mpi_s);
+		ret = ret ? ret == MBEDTLS_ERR_ECP_BAD_INPUT_DATA ? 0 : -1 : 1;
+	}
+	mbedtls_mpi_free(&mpi_r);
+	mbedtls_mpi_free(&mpi_s);
+	return ret;
+}
+#endif /* CRYPTO_MBEDTLS_CRYPTO_EC_DPP */
+
+int crypto_ec_key_group(struct crypto_ec_key *key)
+{
+	mbedtls_ecp_keypair *ecp_kp = mbedtls_pk_ec(*(mbedtls_pk_context *)key);
+	if (ecp_kp == NULL)
+		return -1;
+	mbedtls_ecp_group *ecp_group = &ecp_kp->MBEDTLS_PRIVATE(grp);
+	return crypto_mbedtls_ike_id_from_ecp_group_id(ecp_group->id);
+}
+
+#ifdef CRYPTO_MBEDTLS_CRYPTO_EC_DPP
+
+int crypto_ec_key_cmp(struct crypto_ec_key *key1, struct crypto_ec_key *key2)
+{
+#if 0 /*(DPP is passing two public keys; unable to use pk_check_pair())*/
+  #if MBEDTLS_VERSION_NUMBER < 0x03000000 /* mbedtls 3.0.0 */
+	return mbedtls_pk_check_pair((const mbedtls_pk_context *)key1,
+	                             (const mbedtls_pk_context *)key2) ? -1 : 0;
+  #else
+	return mbedtls_pk_check_pair((const mbedtls_pk_context *)key1,
+	                             (const mbedtls_pk_context *)key2,
+	                             mbedtls_ctr_drbg_random,
+	                             crypto_mbedtls_ctr_drbg()) ? -1 : 0;
+  #endif
+#else
+	mbedtls_ecp_keypair *ecp_kp1=mbedtls_pk_ec(*(mbedtls_pk_context *)key1);
+	mbedtls_ecp_keypair *ecp_kp2=mbedtls_pk_ec(*(mbedtls_pk_context *)key2);
+	if (ecp_kp1 == NULL || ecp_kp2 == NULL)
+		return -1;
+	mbedtls_ecp_group *ecp_kp1_grp = &ecp_kp1->MBEDTLS_PRIVATE(grp);
+	mbedtls_ecp_group *ecp_kp2_grp = &ecp_kp2->MBEDTLS_PRIVATE(grp);
+	mbedtls_ecp_point *ecp_kp1_Q = &ecp_kp1->MBEDTLS_PRIVATE(Q);
+	mbedtls_ecp_point *ecp_kp2_Q = &ecp_kp2->MBEDTLS_PRIVATE(Q);
+	return ecp_kp1_grp->id != ecp_kp2_grp->id
+	    || mbedtls_ecp_point_cmp(ecp_kp1_Q, ecp_kp2_Q) ? -1 : 0;
+#endif
+}
+
+void crypto_ec_key_debug_print(const struct crypto_ec_key *key,
+			       const char *title)
+{
+	/* TBD: what info is desirable here and in what human readable format?*/
+	/*(crypto_openssl.c prints a human-readably public key and attributes)*/
+  #if 0
+	struct mbedtls_pk_debug_item debug_item;
+	if (mbedtls_pk_debug((const mbedtls_pk_context *)key, &debug_item))
+		return;
+	/* ... */
+  #endif
+	wpa_printf(MSG_DEBUG, "%s: %s not implemented", title, __func__);
+}
+
+#endif /* CRYPTO_MBEDTLS_CRYPTO_EC_DPP */
+
+#endif /* CRYPTO_MBEDTLS_CRYPTO_EC */
+
+
+#ifdef CRYPTO_MBEDTLS_CRYPTO_CSR
+
+#include <mbedtls/x509_csr.h>
+#include <mbedtls/oid.h>
+
+struct crypto_csr * crypto_csr_init(void)
+{
+	mbedtls_x509write_csr *csr = os_malloc(sizeof(*csr));
+	if (csr != NULL)
+		mbedtls_x509write_csr_init(csr);
+	return (struct crypto_csr *)csr;
+}
+
+struct crypto_csr * crypto_csr_verify(const struct wpabuf *req)
+{
+	/* future: look for alternatives to MBEDTLS_PRIVATE() access */
+
+	/* sole caller src/common/dpp_crypto.c:dpp_validate_csr()
+	 * uses (mbedtls_x509_csr *) to obtain CSR_ATTR_CHALLENGE_PASSWORD
+	 * so allocate different object (mbedtls_x509_csr *) and special-case
+	 * object when used in crypto_csr_get_attribute() and when free()d in
+	 * crypto_csr_deinit(). */
+
+	mbedtls_x509_csr *csr = os_malloc(sizeof(*csr));
+	if (csr == NULL)
+		return NULL;
+	mbedtls_x509_csr_init(csr);
+	const mbedtls_md_info_t *md_info;
+	unsigned char digest[MBEDTLS_MD_MAX_SIZE];
+	if (mbedtls_x509_csr_parse_der(csr,wpabuf_head(req),wpabuf_len(req))==0
+	    && (md_info=mbedtls_md_info_from_type(csr->MBEDTLS_PRIVATE(sig_md)))
+	       != NULL
+	    && mbedtls_md(md_info, csr->cri.p, csr->cri.len, digest) == 0) {
+		switch (mbedtls_pk_verify(&csr->pk,csr->MBEDTLS_PRIVATE(sig_md),
+		                          digest, mbedtls_md_get_size(md_info),
+		                          csr->MBEDTLS_PRIVATE(sig).p,
+		                          csr->MBEDTLS_PRIVATE(sig).len)) {
+		case 0:
+		/*case MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH:*//* XXX: allow? */
+			return (struct crypto_csr *)((uintptr_t)csr | 1uL);
+		default:
+			break;
+		}
+	}
+
+	mbedtls_x509_csr_free(csr);
+	os_free(csr);
+	return NULL;
+}
+
+void crypto_csr_deinit(struct crypto_csr *csr)
+{
+	if ((uintptr_t)csr & 1uL) {
+		csr = (struct crypto_csr *)((uintptr_t)csr & ~1uL);
+		mbedtls_x509_csr_free((mbedtls_x509_csr *)csr);
+	}
+	else
+		mbedtls_x509write_csr_free((mbedtls_x509write_csr *)csr);
+	os_free(csr);
+}
+
+int crypto_csr_set_ec_public_key(struct crypto_csr *csr,
+				 struct crypto_ec_key *key)
+{
+	mbedtls_x509write_csr_set_key((mbedtls_x509write_csr *)csr,
+	                              (mbedtls_pk_context *)key);
+	return 0;
+}
+
+int crypto_csr_set_name(struct crypto_csr *csr, enum crypto_csr_name type,
+			const char *name)
+{
+	/* specialized for src/common/dpp_crypto.c */
+
+	/* sole caller src/common/dpp_crypto.c:dpp_build_csr()
+	 * calls this function only once, using type == CSR_NAME_CN
+	 * (If called more than once, this code would need to append
+	 *  components to the subject name, which we could do by
+	 *  appending to (mbedtls_x509write_csr *) private member
+	 *  mbedtls_asn1_named_data *MBEDTLS_PRIVATE(subject)) */
+
+	const char *label;
+	switch (type) {
+	case CSR_NAME_CN: label = "CN="; break;
+	case CSR_NAME_SN: label = "SN="; break;
+	case CSR_NAME_C:  label = "C=";  break;
+	case CSR_NAME_O:  label = "O=";  break;
+	case CSR_NAME_OU: label = "OU="; break;
+	default: return -1;
+	}
+
+	size_t len = strlen(name);
+	struct wpabuf *buf = wpabuf_alloc(3+len+1);
+	if (buf == NULL)
+		return -1;
+	wpabuf_put_data(buf, label, strlen(label));
+	wpabuf_put_data(buf, name, len+1); /*(include trailing '\0')*/
+	/* Note: 'name' provided is set as given and should be backslash-escaped
+	 * by caller when necessary, e.g. literal ',' which are not separating
+	 * components should be backslash-escaped */
+
+	int ret =
+	  mbedtls_x509write_csr_set_subject_name((mbedtls_x509write_csr *)csr,
+	                                         wpabuf_head(buf)) ? -1 : 0;
+	wpabuf_free(buf);
+	return ret;
+}
+
+/* OBJ_pkcs9_challengePassword  1 2 840 113549 1 9 7 */
+static const char OBJ_pkcs9_challengePassword[] = MBEDTLS_OID_PKCS9 "\x07";
+
+int crypto_csr_set_attribute(struct crypto_csr *csr, enum crypto_csr_attr attr,
+			     int attr_type, const u8 *value, size_t len)
+{
+	/* specialized for src/common/dpp_crypto.c */
+	/* sole caller src/common/dpp_crypto.c:dpp_build_csr() passes
+	 *   attr      == CSR_ATTR_CHALLENGE_PASSWORD
+	 *   attr_type == ASN1_TAG_UTF8STRING */
+
+	const char *oid;
+	size_t oid_len;
+	switch (attr) {
+	case CSR_ATTR_CHALLENGE_PASSWORD:
+		oid = OBJ_pkcs9_challengePassword;
+		oid_len = sizeof(OBJ_pkcs9_challengePassword)-1;
+		break;
+	default:
+		return -1;
+	}
+
+  #if 0 /*(incorrect; sets an extension, not an attribute)*/
+	return mbedtls_x509write_csr_set_extension((mbedtls_x509write_csr *)csr,
+	                                           oid, oid_len,
+	  #if MBEDTLS_VERSION_NUMBER >= 0x03000000 /* mbedtls 3.0.0 */
+	                                           0, /*(critical flag)*/
+	  #endif
+	                                           value, len) ? -1 : 0;
+  #else
+	(void)oid;
+	(void)oid_len;
+  #endif
+
+	/* mbedtls does not currently provide way to set an attribute in a CSR:
+	 *   https://github.com/Mbed-TLS/mbedtls/issues/4886 */
+	wpa_printf(MSG_ERROR,
+	  "mbedtls does not currently support setting challengePassword "
+	  "attribute in CSR");
+	return -1;
+}
+
+const u8 * mbedtls_x509_csr_attr_oid_value(mbedtls_x509_csr *csr,
+                                           const char *oid, size_t oid_len,
+                                           size_t *vlen, int *vtype)
+{
+	/* Note: mbedtls_x509_csr_parse_der() has parsed and validated CSR,
+	 *	   so validation checks are not repeated here
+	 *
+	 * It would be nicer if (mbedtls_x509_csr *) had an mbedtls_x509_buf of
+	 * Attributes (or at least a pointer) since mbedtls_x509_csr_parse_der()
+	 * already parsed the rest of CertificationRequestInfo, some of which is
+	 * repeated here to step to Attributes.  Since csr->subject_raw.p points
+	 * into csr->cri.p, which points into csr->raw.p, step over version and
+	 * subject of CertificationRequestInfo (SEQUENCE) */
+	unsigned char *p = csr->subject_raw.p + csr->subject_raw.len;
+	unsigned char *end = csr->cri.p + csr->cri.len, *ext;
+	size_t len;
+
+	/* step over SubjectPublicKeyInfo */
+	mbedtls_asn1_get_tag(&p, end, &len,
+	    MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE);
+	p += len;
+
+	/* Attributes
+	 *   { ATTRIBUTE:IOSet } ::= SET OF { SEQUENCE { OID, value } }
+	 */
+	if (mbedtls_asn1_get_tag(&p, end, &len,
+	      MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_CONTEXT_SPECIFIC) != 0) {
+		return NULL;
+	}
+	while (p < end) {
+		if (mbedtls_asn1_get_tag(&p, end, &len,
+		      MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE) != 0) {
+			return NULL;
+		}
+		ext = p;
+		p += len;
+
+		if (mbedtls_asn1_get_tag(&ext,end,&len,MBEDTLS_ASN1_OID) != 0)
+			return NULL;
+		if (oid_len != len || 0 != memcmp(ext, oid, oid_len))
+			continue;
+
+		/* found oid; return value */
+		*vtype = *ext++; /* tag */
+		return (mbedtls_asn1_get_len(&ext,end,vlen) == 0) ? ext : NULL;
+	}
+
+	return NULL;
+}
+
+const u8 * crypto_csr_get_attribute(struct crypto_csr *csr,
+				    enum crypto_csr_attr attr,
+				    size_t *len, int *type)
+{
+	/* specialized for src/common/dpp_crypto.c */
+	/* sole caller src/common/dpp_crypto.c:dpp_build_csr() passes
+	 *   attr == CSR_ATTR_CHALLENGE_PASSWORD */
+
+	const char *oid;
+	size_t oid_len;
+	switch (attr) {
+	case CSR_ATTR_CHALLENGE_PASSWORD:
+		oid = OBJ_pkcs9_challengePassword;
+		oid_len = sizeof(OBJ_pkcs9_challengePassword)-1;
+		break;
+	default:
+		return NULL;
+	}
+
+	/* see crypto_csr_verify(); expecting (mbedtls_x509_csr *) tagged |=1 */
+	if (!((uintptr_t)csr & 1uL))
+		return NULL;
+	csr = (struct crypto_csr *)((uintptr_t)csr & ~1uL);
+
+	return mbedtls_x509_csr_attr_oid_value((mbedtls_x509_csr *)csr,
+	                                       oid, oid_len, len, type);
+}
+
+struct wpabuf * crypto_csr_sign(struct crypto_csr *csr,
+				struct crypto_ec_key *key,
+				enum crypto_hash_alg algo)
+{
+	mbedtls_md_type_t sig_md;
+	switch (algo) {
+  #ifdef MBEDTLS_SHA256_C
+	case CRYPTO_HASH_ALG_SHA256: sig_md = MBEDTLS_MD_SHA256; break;
+  #endif
+  #ifdef MBEDTLS_SHA512_C
+	case CRYPTO_HASH_ALG_SHA384: sig_md = MBEDTLS_MD_SHA384; break;
+	case CRYPTO_HASH_ALG_SHA512: sig_md = MBEDTLS_MD_SHA512; break;
+  #endif
+	default:
+		return NULL;
+	}
+	mbedtls_x509write_csr_set_md_alg((mbedtls_x509write_csr *)csr, sig_md);
+
+  #if 0
+	unsigned char key_usage = MBEDTLS_X509_KU_DIGITAL_SIGNATURE
+	                        | MBEDTLS_X509_KU_KEY_CERT_SIGN;
+	if (mbedtls_x509write_csr_set_key_usage((mbedtls_x509write_csr *)csr,
+	                                        key_usage))
+		return NULL;
+  #endif
+
+  #if 0
+	unsigned char ns_cert_type = MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT
+	                           | MBEDTLS_X509_NS_CERT_TYPE_EMAIL;
+	if (mbedtls_x509write_csr_set_ns_cert_type((mbedtls_x509write_csr *)csr,
+	                                           ns_cert_type))
+		return NULL;
+  #endif
+
+  #if 0
+	/* mbedtls does not currently provide way to set an attribute in a CSR:
+	 *   https://github.com/Mbed-TLS/mbedtls/issues/4886
+	 * XXX: hwsim dpp_enterprise test fails due to this limitation.
+	 *
+	 * Current usage of this function is solely by dpp_build_csr(),
+	 * so as a kludge, might consider custom (struct crypto_csr *)
+	 * containing (mbedtls_x509write_csr *) and a list of attributes
+	 * (i.e. challengePassword).  Might have to totally reimplement
+	 * mbedtls_x509write_csr_der(); underlying x509write_csr_der_internal()
+	 * handles signing the CSR.  (This is more work that appending an
+	 * Attributes section to end of CSR and adjusting ASN.1 length of CSR.)
+	 */
+  #endif
+
+	unsigned char buf[4096]; /* XXX: large enough?  too large? */
+	int len = mbedtls_x509write_csr_der((mbedtls_x509write_csr *)csr,
+	                                    buf, sizeof(buf),
+	                                    mbedtls_ctr_drbg_random,
+	                                    crypto_mbedtls_ctr_drbg());
+	if (len < 0)
+		return NULL;
+	/*  Note: data is written at the end of the buffer! Use the
+	 *        return value to determine where you should start
+	 *        using the buffer */
+	return wpabuf_alloc_copy(buf+sizeof(buf)-len, (size_t)len);
+}
+
+#endif /* CRYPTO_MBEDTLS_CRYPTO_CSR */
+
+
+#ifdef CRYPTO_MBEDTLS_CRYPTO_PKCS7
+
+#if 0
+#include <mbedtls/pkcs7.h> /* PKCS7 is not currently supported in mbedtls */
+#include <mbedtls/pem.h>
+#endif
+
+struct wpabuf * crypto_pkcs7_get_certificates(const struct wpabuf *pkcs7)
+{
+	/* PKCS7 is not currently supported in mbedtls */
+	return NULL;
+
+#if 0
+	/* https://github.com/naynajain/mbedtls-1 branch: development-pkcs7
+	 * (??? potential future contribution to mbedtls ???) */
+
+	/* Note: PKCS7 signature *is not* verified by this function.
+	 * The function interface does not provide for passing a certificate */
+
+	mbedtls_pkcs7 mpkcs7;
+	mbedtls_pkcs7_init(&mpkcs7);
+	int pkcs7_type = mbedtls_pkcs7_parse_der(wpabuf_head(pkcs7),
+	                                         wpabuf_len(pkcs7),
+	                                         &mpkcs7);
+	wpabuf *buf = NULL;
+	do {
+		if (pkcs7_type < 0)
+			break;
+
+		/* src/common/dpp.c:dpp_parse_cred_dot1x() interested in certs
+		 * for wpa_supplicant/dpp_supplicant.c:wpas_dpp_add_network()
+		 * (? are adding certificate headers and footers desired ?) */
+
+		/* development-pkcs7 branch does not currently provide
+		 * additional interfaces to retrieve the parsed data */
+
+		mbedtls_x509_crt *certs =
+		  &mpkcs7.MBEDTLS_PRIVATE(signed_data).MBEDTLS_PRIVATE(certs);
+		int ncerts =
+		  mpkcs7.MBEDTLS_PRIVATE(signed_data).MBEDTLS_PRIVATE(no_of_certs);
+
+		/* allocate buffer for PEM (base64-encoded DER)
+		 * plus header, footer, newlines, and some extra */
+		buf = wpabuf_alloc((wpabuf_len(pkcs7)+2)/3*4 + ncerts*64);
+		if (buf == NULL)
+			break;
+
+		#define PEM_BEGIN_CRT "-----BEGIN CERTIFICATE-----\n"
+		#define PEM_END_CRT   "-----END CERTIFICATE-----\n"
+		size_t olen;
+		for (int i = 0; i < ncerts; ++i) {
+			int ret = mbedtls_pem_write_buffer(
+			            PEM_BEGIN_CRT, PEM_END_CRT,
+			            certs[i].raw.p, certs[i].raw.len,
+			            wpabuf_mhead(buf, 0), wpabuf_tailroom(buf),
+			            &olen));
+			if (ret == 0)
+				wpabuf_put(buf, olen);
+			} else {
+				if (ret == MBEDTLS_ERR_BASE64_BUFFER_TOO_SMALL)
+					ret = wpabuf_resize(
+					        &buf,olen-wpabuf_tailroom(buf));
+				if (ret == 0) {
+					--i;/*(adjust loop iterator for retry)*/
+					continue;
+				}
+				wpabuf_free(buf);
+				buf = NULL;
+				break;
+			}
+		}
+	} while (0);
+
+	mbedtls_pkcs7_free(&mpkcs7);
+	return buf;
+#endif
+}
+
+#endif /* CRYPTO_MBEDTLS_CRYPTO_PKCS7 */
+
+
+#ifdef MBEDTLS_ARC4_C
+#include <mbedtls/arc4.h>
+int rc4_skip(const u8 *key, size_t keylen, size_t skip,
+	     u8 *data, size_t data_len)
+{
+	mbedtls_arc4_context ctx;
+	mbedtls_arc4_init(&ctx);
+	mbedtls_arc4_setup(&ctx, key, keylen);
+
+	if (skip) {
+		/*(prefer [16] on ancient hardware with smaller cache lines)*/
+		unsigned char skip_buf[64]; /*('skip' is generally small)*/
+		/*os_memset(skip_buf, 0, sizeof(skip_buf));*/ /*(necessary?)*/
+		size_t len;
+		do {
+			len = skip > sizeof(skip_buf) ? sizeof(skip_buf) : skip;
+			mbedtls_arc4_crypt(&ctx, len, skip_buf, skip_buf);
+		} while ((skip -= len));
+	}
+
+	int ret = mbedtls_arc4_crypt(&ctx, data_len, data, data);
+	mbedtls_arc4_free(&ctx);
+	return ret;
+}
+#endif
+
+
+/* duplicated in tls_mbedtls.c:tls_mbedtls_readfile()*/
+__attribute_noinline__
+static int crypto_mbedtls_readfile(const char *path, u8 **buf, size_t *n)
+{
+  #if 0 /* #ifdef MBEDTLS_FS_IO */
+	/*(includes +1 for '\0' needed by mbedtls PEM parsing funcs)*/
+	if (mbedtls_pk_load_file(path, (unsigned char **)buf, n) != 0) {
+		wpa_printf(MSG_ERROR, "error: mbedtls_pk_load_file %s", path);
+		return -1;
+	}
+  #else
+	/*(use os_readfile() so that we can use os_free()
+	 *(if we use mbedtls_pk_load_file() above, macros prevent calling free()
+	 * directly #if defined(OS_REJECT_C_LIB_FUNCTIONS) and calling os_free()
+	 * on buf aborts in tests if buf not allocated via os_malloc())*/
+	*buf = (u8 *)os_readfile(path, n);
+	if (!*buf) {
+		wpa_printf(MSG_ERROR, "error: os_readfile %s", path);
+		return -1;
+	}
+	u8 *buf0 = os_realloc(*buf, *n+1);
+	if (!buf0) {
+		bin_clear_free(*buf, *n);
+		*buf = NULL;
+		return -1;
+	}
+	buf0[(*n)++] = '\0';
+	*buf = buf0;
+  #endif
+	return 0;
+}
+
+
+#ifdef CRYPTO_MBEDTLS_CRYPTO_RSA
+#ifdef MBEDTLS_RSA_C
+
+#include <mbedtls/pk.h>
+#include <mbedtls/rsa.h>
+
+struct crypto_rsa_key * crypto_rsa_key_read(const char *file, bool private_key)
+{
+	/* mbedtls_pk_parse_keyfile() and mbedtls_pk_parse_public_keyfile()
+	 * require #ifdef MBEDTLS_FS_IO in mbedtls library.  Prefer to use
+	 * crypto_mbedtls_readfile(), which wraps os_readfile() */
+	u8 *data;
+	size_t len;
+	if (crypto_mbedtls_readfile(file, &data, &len) != 0)
+		return NULL;
+
+	mbedtls_pk_context *ctx = os_malloc(sizeof(*ctx));
+	if (ctx == NULL) {
+		bin_clear_free(data, len);
+		return NULL;
+	}
+	mbedtls_pk_init(ctx);
+
+	int rc;
+	rc = (private_key
+	      ? mbedtls_pk_parse_key(ctx, data, len, NULL, 0
+	  #if MBEDTLS_VERSION_NUMBER >= 0x03000000 /* mbedtls 3.0.0 */
+	                            ,mbedtls_ctr_drbg_random,
+	                             crypto_mbedtls_ctr_drbg()
+	  #endif
+	                            )
+	      : mbedtls_pk_parse_public_key(ctx, data, len)) == 0
+	    && mbedtls_pk_can_do(ctx, MBEDTLS_PK_RSA);
+
+	bin_clear_free(data, len);
+
+	if (rc) {
+		/* use MBEDTLS_RSA_PKCS_V21 padding for RSAES-OAEP */
+		/* use MBEDTLS_MD_SHA256 for these hostap interfaces */
+	  #if MBEDTLS_VERSION_NUMBER < 0x03000000 /* mbedtls 3.0.0 */
+		/*(no return value in mbedtls 2.x)*/
+		mbedtls_rsa_set_padding(mbedtls_pk_rsa(*ctx),
+		                        MBEDTLS_RSA_PKCS_V21,
+		                        MBEDTLS_MD_SHA256);
+	  #else
+		if (mbedtls_rsa_set_padding(mbedtls_pk_rsa(*ctx),
+		                            MBEDTLS_RSA_PKCS_V21,
+		                            MBEDTLS_MD_SHA256) == 0)
+	  #endif
+			return (struct crypto_rsa_key *)ctx;
+	}
+
+	mbedtls_pk_free(ctx);
+	os_free(ctx);
+	return NULL;
+}
+
+struct wpabuf * crypto_rsa_oaep_sha256_encrypt(struct crypto_rsa_key *key,
+					       const struct wpabuf *in)
+{
+	mbedtls_rsa_context *pk_rsa = mbedtls_pk_rsa(*(mbedtls_pk_context*)key);
+	size_t olen = mbedtls_rsa_get_len(pk_rsa);
+	struct wpabuf *buf = wpabuf_alloc(olen);
+	if (buf == NULL)
+		return NULL;
+
+	/* mbedtls_pk_encrypt() takes a few more hops to get to same func */
+	if (mbedtls_rsa_rsaes_oaep_encrypt(pk_rsa,
+	                                   mbedtls_ctr_drbg_random,
+	                                   crypto_mbedtls_ctr_drbg(),
+	  #if MBEDTLS_VERSION_NUMBER < 0x03000000 /* mbedtls 3.0.0 */
+	                                   MBEDTLS_RSA_PRIVATE,
+	  #endif
+	                                   NULL, 0,
+	                                   wpabuf_len(in), wpabuf_head(in),
+	                                   wpabuf_put(buf, olen)) == 0) {
+		return buf;
+	}
+
+	wpabuf_clear_free(buf);
+	return NULL;
+}
+
+struct wpabuf * crypto_rsa_oaep_sha256_decrypt(struct crypto_rsa_key *key,
+					       const struct wpabuf *in)
+{
+	mbedtls_rsa_context *pk_rsa = mbedtls_pk_rsa(*(mbedtls_pk_context*)key);
+	size_t olen = mbedtls_rsa_get_len(pk_rsa);
+	struct wpabuf *buf = wpabuf_alloc(olen);
+	if (buf == NULL)
+		return NULL;
+
+	/* mbedtls_pk_decrypt() takes a few more hops to get to same func */
+	if (mbedtls_rsa_rsaes_oaep_decrypt(pk_rsa,
+	                                   mbedtls_ctr_drbg_random,
+	                                   crypto_mbedtls_ctr_drbg(),
+	  #if MBEDTLS_VERSION_NUMBER < 0x03000000 /* mbedtls 3.0.0 */
+	                                   MBEDTLS_RSA_PUBLIC,
+	  #endif
+	                                   NULL, 0, &olen, wpabuf_head(in),
+	                                   wpabuf_mhead(buf), olen) == 0) {
+		wpabuf_put(buf, olen);
+		return buf;
+	}
+
+	wpabuf_clear_free(buf);
+	return NULL;
+}
+
+void crypto_rsa_key_free(struct crypto_rsa_key *key)
+{
+	mbedtls_pk_free((mbedtls_pk_context *)key);
+	os_free(key);
+}
+
+#endif /* MBEDTLS_RSA_C */
+#endif /* CRYPTO_MBEDTLS_CRYPTO_RSA */
+
+#ifdef CRYPTO_MBEDTLS_CRYPTO_HPKE
+
+struct wpabuf * hpke_base_seal(enum hpke_kem_id kem_id,
+			       enum hpke_kdf_id kdf_id,
+			       enum hpke_aead_id aead_id,
+			       struct crypto_ec_key *peer_pub,
+			       const u8 *info, size_t info_len,
+			       const u8 *aad, size_t aad_len,
+			       const u8 *pt, size_t pt_len)
+{
+	/* not yet implemented */
+	return NULL;
+}
+
+struct wpabuf * hpke_base_open(enum hpke_kem_id kem_id,
+			       enum hpke_kdf_id kdf_id,
+			       enum hpke_aead_id aead_id,
+			       struct crypto_ec_key *own_priv,
+			       const u8 *info, size_t info_len,
+			       const u8 *aad, size_t aad_len,
+			       const u8 *enc_ct, size_t enc_ct_len)
+{
+	/* not yet implemented */
+	return NULL;
+}
+
+#endif
diff --git a/src/crypto/crypto_module_tests.c b/src/crypto/crypto_module_tests.c
index ffeddba..07c36d8 100644
--- a/src/crypto/crypto_module_tests.c
+++ b/src/crypto/crypto_module_tests.c
@@ -2470,6 +2470,139 @@ static int test_hpke(void)
 }
 
 
+static int test_ecc(void)
+{
+#ifdef CONFIG_ECC
+#ifndef CONFIG_TLS_INTERNAL
+#ifndef CONFIG_TLS_GNUTLS
+#if defined(CONFIG_TLS_MBEDTLS) \
+ || defined(CONFIG_TLS_OPENSSL) \
+ || defined(CONFIG_TLS_WOLFSSL)
+	wpa_printf(MSG_INFO, "Testing ECC");
+	/* Note: some tests below are valid on supported Short Weierstrass
+	 * curves, but not on Montgomery curves (e.g. IKE groups 31 and 32)
+	 * (e.g. deriving and comparing y^2 test below not valid on Montgomery)
+	 */
+#ifdef CONFIG_TLS_MBEDTLS
+	const int grps[] = {19, 20, 21, 25, 26, 28};
+#endif
+#ifdef CONFIG_TLS_OPENSSL
+	const int grps[] = {19, 20, 21, 26};
+#endif
+#ifdef CONFIG_TLS_WOLFSSL
+	const int grps[] = {19, 20, 21, 26};
+#endif
+	uint32_t i;
+	struct crypto_ec *e = NULL;
+	struct crypto_ec_point *p = NULL, *q = NULL;
+	struct crypto_bignum *x = NULL, *y = NULL;
+#ifdef CONFIG_DPP
+	u8 bin[4096];
+#endif
+	for (i = 0; i < ARRAY_SIZE(grps); ++i) {
+		e = crypto_ec_init(grps[i]);
+		if (e == NULL
+		    || crypto_ec_prime_len(e) == 0
+		    || crypto_ec_prime_len_bits(e) == 0
+		    || crypto_ec_order_len(e) == 0
+		    || crypto_ec_get_prime(e) == NULL
+		    || crypto_ec_get_order(e) == NULL
+		    || crypto_ec_get_a(e) == NULL
+		    || crypto_ec_get_b(e) == NULL
+		    || crypto_ec_get_generator(e) == NULL) {
+			break;
+		}
+#ifdef CONFIG_DPP
+		struct crypto_ec_key *key = crypto_ec_key_gen(grps[i]);
+		if (key == NULL)
+			break;
+		p = crypto_ec_key_get_public_key(key);
+		q = crypto_ec_key_get_public_key(key);
+		crypto_ec_key_deinit(key);
+		if (p == NULL || q == NULL)
+			break;
+		if (!crypto_ec_point_is_on_curve(e, p))
+			break;
+
+		/* inverted point should not match original;
+		 * double-invert should match */
+		if (crypto_ec_point_invert(e, q) != 0
+		    || crypto_ec_point_cmp(e, p, q) == 0
+		    || crypto_ec_point_invert(e, q) != 0
+		    || crypto_ec_point_cmp(e, p, q) != 0) {
+			break;
+		}
+
+		/* crypto_ec_point_to_bin() and crypto_ec_point_from_bin()
+		 * imbalanced interfaces? */
+		size_t prime_len = crypto_ec_prime_len(e);
+		if (prime_len * 2 > sizeof(bin))
+			break;
+		if (crypto_ec_point_to_bin(e, p, bin, bin+prime_len) != 0)
+			break;
+		struct crypto_ec_point *tmp = crypto_ec_point_from_bin(e, bin);
+		if (tmp == NULL)
+			break;
+		if (crypto_ec_point_cmp(e, p, tmp) != 0) {
+			crypto_ec_point_deinit(tmp, 0);
+			break;
+		}
+		crypto_ec_point_deinit(tmp, 0);
+
+		x = crypto_bignum_init();
+		y = crypto_bignum_init_set(bin+prime_len, prime_len);
+		if (x == NULL || y == NULL || crypto_ec_point_x(e, p, x) != 0)
+			break;
+		struct crypto_bignum *y2 = crypto_ec_point_compute_y_sqr(e, x);
+		if (y2 == NULL)
+			break;
+		if (crypto_bignum_sqrmod(y, crypto_ec_get_prime(e), y) != 0
+		    || crypto_bignum_cmp(y, y2) != 0) {
+			crypto_bignum_deinit(y2, 0);
+			break;
+		}
+		crypto_bignum_deinit(y2, 0);
+		crypto_bignum_deinit(x, 0);
+		crypto_bignum_deinit(y, 0);
+		x = NULL;
+		y = NULL;
+
+		x = crypto_bignum_init();
+		if (x == NULL)
+			break;
+		if (crypto_bignum_rand(x, crypto_ec_get_prime(e)) != 0)
+			break;
+		crypto_bignum_deinit(x, 0);
+		x = NULL;
+
+		crypto_ec_point_deinit(p, 0);
+		p = NULL;
+		crypto_ec_point_deinit(q, 0);
+		q = NULL;
+#endif /* CONFIG_DPP */
+		crypto_ec_deinit(e);
+		e = NULL;
+	}
+	if (i != ARRAY_SIZE(grps)) {
+		crypto_bignum_deinit(x, 0);
+		crypto_bignum_deinit(y, 0);
+		crypto_ec_point_deinit(p, 0);
+		crypto_ec_point_deinit(q, 0);
+		crypto_ec_deinit(e);
+		wpa_printf(MSG_INFO,
+		           "ECC test case failed tls_id:%d", grps[i]);
+		return -1;
+	}
+
+	wpa_printf(MSG_INFO, "ECC test cases passed");
+#endif
+#endif /* !CONFIG_TLS_GNUTLS */
+#endif /* !CONFIG_TLS_INTERNAL */
+#endif /* CONFIG_ECC */
+	return 0;
+}
+
+
 static int test_ms_funcs(void)
 {
 #ifndef CONFIG_FIPS
@@ -2591,6 +2724,7 @@ int crypto_module_tests(void)
 	    test_fips186_2_prf() ||
 	    test_extract_expand_hkdf() ||
 	    test_hpke() ||
+	    test_ecc() ||
 	    test_ms_funcs())
 		ret = -1;
 
diff --git a/src/crypto/tls_mbedtls.c b/src/crypto/tls_mbedtls.c
new file mode 100644
index 0000000..d83a3db
--- /dev/null
+++ b/src/crypto/tls_mbedtls.c
@@ -0,0 +1,3313 @@
+/*
+ * SSL/TLS interface functions for mbed TLS
+ *
+ * SPDX-FileCopyrightText: 2022 Glenn Strauss <gstrauss@gluelogic.com>
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * This software may be distributed under the terms of the BSD license.
+ * See README for more details.
+ *
+ * template:  src/crypto/tls_none.c
+ * reference: src/crypto/tls_*.c
+ *
+ * Known Limitations:
+ * - no TLSv1.3 (not available in mbedtls 2.x; experimental in mbedtls 3.x)
+ * - no OCSP (not yet available in mbedtls)
+ * - mbedtls does not support all certificate encodings used by hwsim tests
+ *   PCKS#5 v1.5
+ *   PCKS#12
+ *   DH DSA
+ * - EAP-FAST, EAP-TEAP session ticket support not implemented in tls_mbedtls.c
+ * - mbedtls does not currently provide way to set an attribute in a CSR
+ *     https://github.com/Mbed-TLS/mbedtls/issues/4886
+ *   so tests/hwsim dpp_enterprise tests fail
+ * - DPP2 not supported
+ *   PKCS#7 parsing is not supported in mbedtls
+ *   See crypto_mbedtls.c:crypto_pkcs7_get_certificates() comments
+ * - DPP3 not supported
+ *   hpke_base_seal() and hpke_base_seal() not implemented in crypto_mbedtls.c
+ *
+ * Status:
+ * - code written to be compatible with mbedtls 2.x and mbedtls 3.x
+ *   (currently requires mbedtls >= 2.27.0 for mbedtls_mpi_random())
+ *   (currently requires mbedtls >= 2.18.0 for mbedtls_ssl_tls_prf())
+ * - builds with tests/build/build-wpa_supplicant-mbedtls.config
+ * - passes all tests/ crypto module tests (incomplete coverage)
+ *   ($ cd tests; make clean; make -j 4 run-tests CONFIG_TLS=mbedtls)
+ * - passes almost all tests/hwsim tests
+ *   (hwsim tests skipped for missing features)
+ *
+ * RFE:
+ * - EAP-FAST, EAP-TEAP session ticket support not implemented in tls_mbedtls.c
+ * - client/server session resumption, and/or save client session ticket
+ */
+
+#include "includes.h"
+#include "common.h"
+
+#include <mbedtls/version.h>
+#include <mbedtls/ctr_drbg.h>
+#include <mbedtls/error.h>
+#include <mbedtls/oid.h>
+#include <mbedtls/pem.h>
+#include <mbedtls/platform.h> /* mbedtls_calloc() mbedtls_free() */
+#include <mbedtls/platform_util.h> /* mbedtls_platform_zeroize() */
+#include <mbedtls/ssl.h>
+#include <mbedtls/ssl_ticket.h>
+#include <mbedtls/x509.h>
+#include <mbedtls/x509_crt.h>
+
+#if MBEDTLS_VERSION_NUMBER >= 0x02040000 /* mbedtls 2.4.0 */
+#include <mbedtls/net_sockets.h>
+#else
+#include <mbedtls/net.h>
+#endif
+
+#ifndef MBEDTLS_PRIVATE
+#define MBEDTLS_PRIVATE(x) x
+#endif
+
+#if MBEDTLS_VERSION_NUMBER < 0x03020000 /* mbedtls 3.2.0 */
+#define mbedtls_ssl_get_ciphersuite_id_from_ssl(ssl) \
+        ((ssl)->MBEDTLS_PRIVATE(session) \
+        ?(ssl)->MBEDTLS_PRIVATE(session)->MBEDTLS_PRIVATE(ciphersuite) \
+        : 0)
+#define mbedtls_ssl_ciphersuite_get_name(info) \
+        (info)->MBEDTLS_PRIVATE(name)
+#endif
+
+#include "crypto.h"     /* sha256_vector() */
+#include "tls.h"
+
+#ifndef SHA256_DIGEST_LENGTH
+#define SHA256_DIGEST_LENGTH 32
+#endif
+
+#ifndef MBEDTLS_EXPKEY_FIXED_SECRET_LEN
+#define MBEDTLS_EXPKEY_FIXED_SECRET_LEN 48
+#endif
+
+#ifndef MBEDTLS_EXPKEY_RAND_LEN
+#define MBEDTLS_EXPKEY_RAND_LEN 32
+#endif
+
+#if MBEDTLS_VERSION_NUMBER >= 0x03000000 /* mbedtls 3.0.0 */
+static mbedtls_ssl_export_keys_t tls_connection_export_keys_cb;
+#elif MBEDTLS_VERSION_NUMBER >= 0x02120000 /* mbedtls 2.18.0 */
+static mbedtls_ssl_export_keys_ext_t tls_connection_export_keys_cb;
+#else /*(not implemented; return error)*/
+#define mbedtls_ssl_tls_prf(a,b,c,d,e,f,g,h) (-1)
+typedef mbedtls_tls_prf_types int;
+#endif
+
+
+/* hostapd/wpa_supplicant provides forced_memzero(),
+ * but prefer mbedtls_platform_zeroize() */
+#define forced_memzero(ptr,sz) mbedtls_platform_zeroize(ptr,sz)
+
+
+#if defined(EAP_FAST) || defined(EAP_FAST_DYNAMIC) || defined(EAP_SERVER_FAST) \
+ || defined(EAP_TEAP) || defined(EAP_SERVER_TEAP)
+#ifdef MBEDTLS_SSL_SESSION_TICKETS
+#ifdef MBEDTLS_SSL_TICKET_C
+#define TLS_MBEDTLS_SESSION_TICKETS
+#if defined(EAP_TEAP) || defined(EAP_SERVER_TEAP)
+#define TLS_MBEDTLS_EAP_TEAP
+#endif
+#if !defined(CONFIG_FIPS) /* EAP-FAST keys cannot be exported in FIPS mode */
+#if defined(EAP_FAST) || defined(EAP_FAST_DYNAMIC) || defined(EAP_SERVER_FAST)
+#define TLS_MBEDTLS_EAP_FAST
+#endif
+#endif
+#endif
+#endif
+#endif
+
+
+struct tls_conf {
+	mbedtls_ssl_config conf;
+
+	unsigned int verify_peer:1;
+	unsigned int verify_depth0_only:1;
+	unsigned int check_crl:2;           /*(needs :2 bits for 0, 1, 2)*/
+	unsigned int check_crl_strict:1;    /*(needs :1 bit  for 0, 1)*/
+	unsigned int ca_cert_probe:1;
+	unsigned int has_ca_cert:1;
+	unsigned int has_client_cert:1;
+	unsigned int has_private_key:1;
+	unsigned int suiteb128:1;
+	unsigned int suiteb192:1;
+	mbedtls_x509_crl *crl;
+	mbedtls_x509_crt ca_cert;
+	mbedtls_x509_crt client_cert;
+	mbedtls_pk_context private_key;
+
+	uint32_t refcnt;
+
+	unsigned int flags;
+	char *subject_match;
+	char *altsubject_match;
+	char *suffix_match;
+	char *domain_match;
+	char *check_cert_subject;
+	u8 ca_cert_hash[SHA256_DIGEST_LENGTH];
+
+	int *ciphersuites;  /* list of ciphersuite ids for mbedtls_ssl_config */
+#if MBEDTLS_VERSION_NUMBER < 0x03010000 /* mbedtls 3.1.0 */
+	mbedtls_ecp_group_id *curves;
+#else
+	uint16_t *curves;   /* list of curve ids for mbedtls_ssl_config */
+#endif
+};
+
+
+struct tls_global {
+	struct tls_conf *tls_conf;
+	char *ocsp_stapling_response;
+	mbedtls_ctr_drbg_context *ctr_drbg; /*(see crypto_mbedtls.c)*/
+  #ifdef MBEDTLS_SSL_SESSION_TICKETS
+	mbedtls_ssl_ticket_context ticket_ctx;
+  #endif
+	char *ca_cert_file;
+	struct os_reltime crl_reload_previous;
+	unsigned int crl_reload_interval;
+	uint32_t refcnt;
+	struct tls_config init_conf;
+};
+
+static struct tls_global tls_ctx_global;
+
+
+struct tls_connection {
+	struct tls_conf *tls_conf;
+	struct wpabuf *push_buf;
+	struct wpabuf *pull_buf;
+	size_t pull_buf_offset;
+
+	unsigned int established:1;
+	unsigned int resumed:1;
+	unsigned int verify_peer:1;
+	unsigned int is_server:1;
+
+	mbedtls_ssl_context ssl;
+
+	mbedtls_tls_prf_types tls_prf_type;
+	size_t expkey_keyblock_size;
+	size_t expkey_secret_len;
+  #if MBEDTLS_VERSION_NUMBER < 0x03000000 /* mbedtls 3.0.0 */
+	unsigned char expkey_secret[MBEDTLS_EXPKEY_FIXED_SECRET_LEN];
+  #else
+	unsigned char expkey_secret[MBEDTLS_MD_MAX_SIZE];
+  #endif
+	unsigned char expkey_randbytes[MBEDTLS_EXPKEY_RAND_LEN*2];
+
+	int read_alerts, write_alerts, failed;
+
+  #ifdef TLS_MBEDTLS_SESSION_TICKETS
+	tls_session_ticket_cb session_ticket_cb;
+	void *session_ticket_cb_ctx;
+	unsigned char *clienthello_session_ticket;
+	size_t clienthello_session_ticket_len;
+  #endif
+	char *peer_subject; /* peer subject info for authenticated peer */
+	struct wpabuf *success_data;
+};
+
+
+#ifndef __has_attribute
+#define __has_attribute(x) 0
+#endif
+
+#ifndef __GNUC_PREREQ
+#define __GNUC_PREREQ(maj,min) 0
+#endif
+
+#ifndef __attribute_cold__
+#if __has_attribute(cold) \
+ || __GNUC_PREREQ(4,3)
+#define __attribute_cold__  __attribute__((__cold__))
+#else
+#define __attribute_cold__
+#endif
+#endif
+
+#ifndef __attribute_noinline__
+#if __has_attribute(noinline) \
+ || __GNUC_PREREQ(3,1)
+#define __attribute_noinline__  __attribute__((__noinline__))
+#else
+#define __attribute_noinline__
+#endif
+#endif
+
+
+__attribute_cold__
+__attribute_noinline__
+static void emsg(int level, const char * const msg)
+{
+	wpa_printf(level, "MTLS: %s", msg);
+}
+
+
+__attribute_cold__
+__attribute_noinline__
+static void emsgrc(int level, const char * const msg, int rc)
+{
+  #ifdef MBEDTLS_ERROR_C
+	/* error logging convenience function that decodes mbedtls result codes */
+	char buf[256];
+	mbedtls_strerror(rc, buf, sizeof(buf));
+	wpa_printf(level, "MTLS: %s: %s (-0x%04x)", msg, buf, -rc);
+  #else
+	wpa_printf(level, "MTLS: %s: (-0x%04x)", msg, -rc);
+  #endif
+}
+
+
+#define elog(rc, msg) emsgrc(MSG_ERROR, (msg), (rc))
+#define ilog(rc, msg) emsgrc(MSG_INFO,  (msg), (rc))
+
+
+struct tls_conf * tls_conf_init(void *tls_ctx)
+{
+	struct tls_conf *tls_conf = os_zalloc(sizeof(*tls_conf));
+	if (tls_conf == NULL)
+		return NULL;
+	tls_conf->refcnt = 1;
+
+	mbedtls_ssl_config_init(&tls_conf->conf);
+	mbedtls_ssl_conf_rng(&tls_conf->conf,
+			     mbedtls_ctr_drbg_random, tls_ctx_global.ctr_drbg);
+	mbedtls_x509_crt_init(&tls_conf->ca_cert);
+	mbedtls_x509_crt_init(&tls_conf->client_cert);
+	mbedtls_pk_init(&tls_conf->private_key);
+
+	return tls_conf;
+}
+
+
+void tls_conf_deinit(struct tls_conf *tls_conf)
+{
+	if (tls_conf == NULL || --tls_conf->refcnt != 0)
+		return;
+
+	mbedtls_x509_crt_free(&tls_conf->ca_cert);
+	mbedtls_x509_crt_free(&tls_conf->client_cert);
+	if (tls_conf->crl) {
+		mbedtls_x509_crl_free(tls_conf->crl);
+		os_free(tls_conf->crl);
+	}
+	mbedtls_pk_free(&tls_conf->private_key);
+	mbedtls_ssl_config_free(&tls_conf->conf);
+	os_free(tls_conf->curves);
+	os_free(tls_conf->ciphersuites);
+	os_free(tls_conf->subject_match);
+	os_free(tls_conf->altsubject_match);
+	os_free(tls_conf->suffix_match);
+	os_free(tls_conf->domain_match);
+	os_free(tls_conf->check_cert_subject);
+	os_free(tls_conf);
+}
+
+
+mbedtls_ctr_drbg_context * crypto_mbedtls_ctr_drbg(void); /*(not in header)*/
+
+__attribute_cold__
+void * tls_init(const struct tls_config *conf)
+{
+	/* RFE: review struct tls_config *conf (different from tls_conf) */
+
+	if (++tls_ctx_global.refcnt > 1)
+		return &tls_ctx_global;
+
+	tls_ctx_global.ctr_drbg = crypto_mbedtls_ctr_drbg();
+  #ifdef MBEDTLS_SSL_SESSION_TICKETS
+	mbedtls_ssl_ticket_init(&tls_ctx_global.ticket_ctx);
+	mbedtls_ssl_ticket_setup(&tls_ctx_global.ticket_ctx,
+	                         mbedtls_ctr_drbg_random,
+	                         tls_ctx_global.ctr_drbg,
+	                         MBEDTLS_CIPHER_AES_256_GCM,
+	                         43200); /* ticket timeout: 12 hours */
+  #endif
+	/* copy struct for future use */
+	tls_ctx_global.init_conf = *conf;
+	if (conf->openssl_ciphers)
+		tls_ctx_global.init_conf.openssl_ciphers =
+		  os_strdup(conf->openssl_ciphers);
+
+	tls_ctx_global.crl_reload_interval = conf->crl_reload_interval;
+	os_get_reltime(&tls_ctx_global.crl_reload_previous);
+
+	return &tls_ctx_global;
+}
+
+
+__attribute_cold__
+void tls_deinit(void *tls_ctx)
+{
+	if (tls_ctx == NULL || --tls_ctx_global.refcnt != 0)
+		return;
+
+	tls_conf_deinit(tls_ctx_global.tls_conf);
+	os_free(tls_ctx_global.ca_cert_file);
+	os_free(tls_ctx_global.ocsp_stapling_response);
+	char *openssl_ciphers; /*(allocated in tls_init())*/
+	*(const char **)&openssl_ciphers =
+	  tls_ctx_global.init_conf.openssl_ciphers;
+	os_free(openssl_ciphers);
+  #ifdef MBEDTLS_SSL_SESSION_TICKETS
+	mbedtls_ssl_ticket_free(&tls_ctx_global.ticket_ctx);
+  #endif
+	os_memset(&tls_ctx_global, 0, sizeof(tls_ctx_global));
+}
+
+
+int tls_get_errors(void *tls_ctx)
+{
+	return 0;
+}
+
+
+static void tls_connection_deinit_expkey(struct tls_connection *conn)
+{
+	conn->tls_prf_type = 0; /* MBEDTLS_SSL_TLS_PRF_NONE; */
+	conn->expkey_keyblock_size = 0;
+	conn->expkey_secret_len = 0;
+	forced_memzero(conn->expkey_secret, sizeof(conn->expkey_secret));
+	forced_memzero(conn->expkey_randbytes, sizeof(conn->expkey_randbytes));
+}
+
+
+#ifdef TLS_MBEDTLS_SESSION_TICKETS
+void tls_connection_deinit_clienthello_session_ticket(struct tls_connection *conn)
+{
+	if (conn->clienthello_session_ticket) {
+		mbedtls_platform_zeroize(conn->clienthello_session_ticket,
+		                         conn->clienthello_session_ticket_len);
+		mbedtls_free(conn->clienthello_session_ticket);
+		conn->clienthello_session_ticket = NULL;
+		conn->clienthello_session_ticket_len = 0;
+	}
+}
+#endif
+
+
+void tls_connection_deinit(void *tls_ctx, struct tls_connection *conn)
+{
+	if (conn == NULL)
+		return;
+
+  #if 0 /*(good intention, but never sent since we destroy self below)*/
+	if (conn->established)
+		mbedtls_ssl_close_notify(&conn->ssl);
+  #endif
+
+	if (conn->tls_prf_type)
+		tls_connection_deinit_expkey(conn);
+
+  #ifdef TLS_MBEDTLS_SESSION_TICKETS
+	if (conn->clienthello_session_ticket)
+		tls_connection_deinit_clienthello_session_ticket(conn);
+  #endif
+
+	os_free(conn->peer_subject);
+	wpabuf_free(conn->success_data);
+	wpabuf_free(conn->push_buf);
+	wpabuf_free(conn->pull_buf);
+	mbedtls_ssl_free(&conn->ssl);
+	tls_conf_deinit(conn->tls_conf);
+	os_free(conn);
+}
+
+
+static void tls_mbedtls_refresh_crl(void);
+static int tls_mbedtls_ssl_setup(struct tls_connection *conn);
+
+struct tls_connection * tls_connection_init(void *tls_ctx)
+{
+	struct tls_connection *conn = os_zalloc(sizeof(*conn));
+	if (conn == NULL)
+		return NULL;
+
+	mbedtls_ssl_init(&conn->ssl);
+
+	conn->tls_conf = tls_ctx_global.tls_conf; /*(inherit global conf, if set)*/
+	if (conn->tls_conf) {
+		++conn->tls_conf->refcnt;
+		/* check for CRL refresh if inheriting from global config */
+		tls_mbedtls_refresh_crl();
+
+		conn->verify_peer = conn->tls_conf->verify_peer;
+		if (tls_mbedtls_ssl_setup(conn) != 0) {
+			tls_connection_deinit(&tls_ctx_global, conn);
+			return NULL;
+		}
+	}
+
+	return conn;
+}
+
+
+int tls_connection_established(void *tls_ctx, struct tls_connection *conn)
+{
+	return conn ? conn->established : 0;
+}
+
+
+__attribute_noinline__
+char * tls_mbedtls_peer_serial_num(const mbedtls_x509_crt *crt, char *serial_num, size_t len)
+{
+	/* mbedtls_x509_serial_gets() inefficiently formats to hex separated by
+	 * colons, so generate the hex serial number here.  The func
+	 * wpa_snprintf_hex_uppercase() is similarly inefficient. */
+	size_t i = 0; /* skip leading 0's per Distinguished Encoding Rules (DER) */
+	while (i < crt->serial.len && crt->serial.p[i] == 0) ++i;
+	if (i == crt->serial.len) --i;
+
+	const unsigned char *s = crt->serial.p + i;
+	const size_t e = (crt->serial.len - i) * 2;
+	if (e >= len)
+		return NULL;
+  #if 0
+	wpa_snprintf_hex_uppercase(serial_num, len, s, crt->serial.len-i);
+  #else
+	for (i = 0; i < e; i+=2, ++s) {
+		serial_num[i+0] = "0123456789ABCDEF"[(*s >>  4)];
+		serial_num[i+1] = "0123456789ABCDEF"[(*s & 0xF)];
+	}
+	serial_num[e] = '\0';
+  #endif
+	return serial_num;
+}
+
+
+char * tls_connection_peer_serial_num(void *tls_ctx,
+				      struct tls_connection *conn)
+{
+	const mbedtls_x509_crt *crt = mbedtls_ssl_get_peer_cert(&conn->ssl);
+	if (crt == NULL)
+		return NULL;
+	size_t len = crt->serial.len * 2 + 1;
+	char *serial_num = os_malloc(len);
+	if (!serial_num)
+		return NULL;
+	return tls_mbedtls_peer_serial_num(crt, serial_num, len);
+}
+
+
+static void tls_pull_buf_reset(struct tls_connection *conn);
+
+int tls_connection_shutdown(void *tls_ctx, struct tls_connection *conn)
+{
+	/* Note: this function called from eap_peer_tls_reauth_init()
+	 * for session resumption, not for connection shutdown */
+
+	if (conn == NULL)
+		return -1;
+
+	tls_pull_buf_reset(conn);
+	wpabuf_free(conn->push_buf);
+	conn->push_buf = NULL;
+	conn->established = 0;
+	conn->resumed = 0;
+	if (conn->tls_prf_type)
+		tls_connection_deinit_expkey(conn);
+
+	/* RFE: prepare for session resumption? (see doc in crypto/tls.h) */
+
+	return mbedtls_ssl_session_reset(&conn->ssl);
+}
+
+
+static int tls_wpabuf_resize_put_data(struct wpabuf **buf,
+                                      const unsigned char *data, size_t dlen)
+{
+	if (wpabuf_resize(buf, dlen) < 0)
+		return 0;
+	wpabuf_put_data(*buf, data, dlen);
+	return 1;
+}
+
+
+static int tls_pull_buf_append(struct tls_connection *conn,
+                               const struct wpabuf *in_data)
+{
+	/*(interface does not lend itself to move semantics)*/
+	return tls_wpabuf_resize_put_data(&conn->pull_buf,
+	                                  wpabuf_head(in_data),
+	                                  wpabuf_len(in_data));
+}
+
+
+static void tls_pull_buf_reset(struct tls_connection *conn)
+{
+	/*(future: might consider reusing conn->pull_buf)*/
+	wpabuf_free(conn->pull_buf);
+	conn->pull_buf = NULL;
+	conn->pull_buf_offset = 0;
+}
+
+
+__attribute_cold__
+static void tls_pull_buf_discard(struct tls_connection *conn, const char *func)
+{
+	size_t discard = wpabuf_len(conn->pull_buf) - conn->pull_buf_offset;
+	if (discard)
+		wpa_printf(MSG_DEBUG,
+			   "%s - %zu bytes remaining in pull_buf; discarding",
+			   func, discard);
+	tls_pull_buf_reset(conn);
+}
+
+
+static int tls_pull_func(void *ptr, unsigned char *buf, size_t len)
+{
+	struct tls_connection *conn = (struct tls_connection *) ptr;
+	if (conn->pull_buf == NULL)
+		return MBEDTLS_ERR_SSL_WANT_READ;
+	const size_t dlen = wpabuf_len(conn->pull_buf) - conn->pull_buf_offset;
+	if (dlen == 0)
+		return MBEDTLS_ERR_SSL_WANT_READ;
+
+	if (len > dlen)
+		len = dlen;
+	os_memcpy(buf, wpabuf_head(conn->pull_buf)+conn->pull_buf_offset, len);
+
+	if (len == dlen) {
+		tls_pull_buf_reset(conn);
+		/*wpa_printf(MSG_DEBUG, "%s - emptied pull_buf", __func__);*/
+	}
+	else {
+		conn->pull_buf_offset += len;
+		/*wpa_printf(MSG_DEBUG, "%s - %zu bytes remaining in pull_buf",
+			   __func__, dlen - len);*/
+	}
+	return (int)len;
+}
+
+
+static int tls_push_func(void *ptr, const unsigned char *buf, size_t len)
+{
+	struct tls_connection *conn = (struct tls_connection *) ptr;
+	return tls_wpabuf_resize_put_data(&conn->push_buf, buf, len)
+	  ? (int)len
+	  : MBEDTLS_ERR_SSL_ALLOC_FAILED;
+}
+
+
+static int
+tls_mbedtls_verify_cb (void *arg, mbedtls_x509_crt *crt, int depth, uint32_t *flags);
+
+
+static int tls_mbedtls_ssl_setup(struct tls_connection *conn)
+{
+  #if 0
+	/* mbedtls_ssl_setup() must be called only once */
+	/* If this func might be called multiple times (e.g. via set_params),
+	 * then we should set a flag in conn that ssl was initialized */
+	if (conn->ssl_is_init) {
+		mbedtls_ssl_free(&conn->ssl);
+		mbedtls_ssl_init(&conn->ssl);
+	}
+  #endif
+
+	int ret = mbedtls_ssl_setup(&conn->ssl, &conn->tls_conf->conf);
+	if (ret != 0) {
+		elog(ret, "mbedtls_ssl_setup");
+		return -1;
+	}
+
+	mbedtls_ssl_set_bio(&conn->ssl, conn, tls_push_func, tls_pull_func, NULL);
+  #if MBEDTLS_VERSION_NUMBER >= 0x03000000 /* mbedtls 3.0.0 */
+	mbedtls_ssl_set_export_keys_cb(
+	    &conn->ssl, tls_connection_export_keys_cb, conn);
+  #elif MBEDTLS_VERSION_NUMBER >= 0x02120000 /* mbedtls 2.18.0 */
+	mbedtls_ssl_conf_export_keys_ext_cb(
+	    &conn->tls_conf->conf, tls_connection_export_keys_cb, conn);
+  #endif
+	if (conn->verify_peer)
+		mbedtls_ssl_set_verify(&conn->ssl, tls_mbedtls_verify_cb, conn);
+
+	return 0;
+}
+
+
+static int tls_mbedtls_data_is_pem(const u8 *data)
+{
+    return (NULL != os_strstr((char *)data, "-----"));
+}
+
+
+static void tls_mbedtls_set_allowed_tls_vers(struct tls_conf *tls_conf,
+                                             mbedtls_ssl_config *conf)
+{
+  #if !defined(MBEDTLS_SSL_PROTO_TLS1_3)
+	tls_conf->flags |= TLS_CONN_DISABLE_TLSv1_3;
+  #endif
+
+	/* unconditionally require TLSv1.2+ for TLS_CONN_SUITEB */
+	if (tls_conf->flags & TLS_CONN_SUITEB) {
+		tls_conf->flags |= TLS_CONN_DISABLE_TLSv1_0;
+		tls_conf->flags |= TLS_CONN_DISABLE_TLSv1_1;
+	}
+
+	const unsigned int flags = tls_conf->flags;
+
+	/* attempt to map flags to min and max TLS protocol version */
+
+	int min = (flags & TLS_CONN_DISABLE_TLSv1_0)
+		? (flags & TLS_CONN_DISABLE_TLSv1_1)
+		? (flags & TLS_CONN_DISABLE_TLSv1_2)
+		? (flags & TLS_CONN_DISABLE_TLSv1_3)
+		? 4
+		: 3
+		: 2
+		: 1
+		: 0;
+
+	int max = (flags & TLS_CONN_DISABLE_TLSv1_3)
+		? (flags & TLS_CONN_DISABLE_TLSv1_2)
+		? (flags & TLS_CONN_DISABLE_TLSv1_1)
+		? (flags & TLS_CONN_DISABLE_TLSv1_0)
+		? -1
+		: 0
+		: 1
+		: 2
+		: 3;
+
+	if ((flags & TLS_CONN_ENABLE_TLSv1_2) && min > 2) min = 2;
+	if ((flags & TLS_CONN_ENABLE_TLSv1_1) && min > 1) min = 1;
+	if ((flags & TLS_CONN_ENABLE_TLSv1_0) && min > 0) min = 0;
+	if (max < min) {
+		emsg(MSG_ERROR, "invalid tls_disable_tlsv* params; ignoring");
+		return;
+	}
+  #if MBEDTLS_VERSION_NUMBER >= 0x03000000 /* mbedtls 3.0.0 */
+	/* mbed TLS 3.0.0 removes support for protocols < TLSv1.2 */
+	if (min < 2 || max < 2) {
+		emsg(MSG_ERROR, "invalid tls_disable_tlsv* params; ignoring");
+		if (min < 2) min = 2;
+		if (max < 2) max = 2;
+	}
+  #endif
+
+  #if MBEDTLS_VERSION_NUMBER >= 0x03020000 /* mbedtls 3.2.0 */
+	/* MBEDTLS_SSL_VERSION_TLS1_2 = 0x0303 *//*!< (D)TLS 1.2 */
+	/* MBEDTLS_SSL_VERSION_TLS1_3 = 0x0304 *//*!< (D)TLS 1.3 */
+	min = (min == 2) ? MBEDTLS_SSL_VERSION_TLS1_2 : MBEDTLS_SSL_VERSION_TLS1_3;
+	max = (max == 2) ? MBEDTLS_SSL_VERSION_TLS1_2 : MBEDTLS_SSL_VERSION_TLS1_3;
+	mbedtls_ssl_conf_min_tls_version(conf, min);
+	mbedtls_ssl_conf_max_tls_version(conf, max);
+  #else
+   #ifndef MBEDTLS_SSL_MINOR_VERSION_4
+	if (min == 3) min = 2;
+	if (max == 3) max = 2;
+   #endif
+	/* MBEDTLS_SSL_MINOR_VERSION_0  0 *//*!< SSL v3.0 */
+	/* MBEDTLS_SSL_MINOR_VERSION_1  1 *//*!< TLS v1.0 */
+	/* MBEDTLS_SSL_MINOR_VERSION_2  2 *//*!< TLS v1.1 */
+	/* MBEDTLS_SSL_MINOR_VERSION_3  3 *//*!< TLS v1.2 */
+	/* MBEDTLS_SSL_MINOR_VERSION_4  4 *//*!< TLS v1.3 */
+	mbedtls_ssl_conf_min_version(conf, MBEDTLS_SSL_MAJOR_VERSION_3, min+1);
+	mbedtls_ssl_conf_max_version(conf, MBEDTLS_SSL_MAJOR_VERSION_3, max+1);
+  #endif
+}
+
+
+__attribute_noinline__
+static int tls_mbedtls_readfile(const char *path, u8 **buf, size_t *n);
+
+
+static int
+tls_mbedtls_set_dhparams(struct tls_conf *tls_conf, const char *dh_file)
+{
+    size_t len;
+    u8 *data;
+    if (tls_mbedtls_readfile(dh_file, &data, &len))
+        return 0;
+
+    /* parse only if DH parameters if in PEM format */
+    if (tls_mbedtls_data_is_pem(data)
+        && NULL == os_strstr((char *)data, "-----BEGIN DH PARAMETERS-----")) {
+        if (os_strstr((char *)data, "-----BEGIN DSA PARAMETERS-----"))
+            wpa_printf(MSG_WARNING, "DSA parameters not handled (%s)", dh_file);
+        else
+            wpa_printf(MSG_WARNING, "unexpected DH param content (%s)",dh_file);
+        forced_memzero(data, len);
+        os_free(data);
+        return 0;
+    }
+
+    /* mbedtls_dhm_parse_dhm() expects "-----BEGIN DH PARAMETERS-----" if PEM */
+    mbedtls_dhm_context dhm;
+    mbedtls_dhm_init(&dhm);
+    int rc = mbedtls_dhm_parse_dhm(&dhm, data, len);
+    if (0 == rc)
+        rc = mbedtls_ssl_conf_dh_param_ctx(&tls_conf->conf, &dhm);
+    if (0 != rc)
+        elog(rc, dh_file);
+    mbedtls_dhm_free(&dhm);
+
+    forced_memzero(data, len);
+    os_free(data);
+    return (0 == rc);
+}
+
+
+/* reference: lighttpd src/mod_mbedtls.c:mod_mbedtls_ssl_append_curve()
+ * (same author: gstrauss@gluelogic.com; same license: BSD-3-Clause) */
+#if MBEDTLS_VERSION_NUMBER < 0x03010000 /* mbedtls 3.1.0 */
+static int
+tls_mbedtls_append_curve (mbedtls_ecp_group_id *ids, int nids, int idsz, const mbedtls_ecp_group_id id)
+{
+    if (1 >= idsz - (nids + 1)) {
+        emsg(MSG_ERROR, "error: too many curves during list expand");
+        return -1;
+    }
+    ids[++nids] = id;
+    return nids;
+}
+
+
+static int
+tls_mbedtls_set_curves(struct tls_conf *tls_conf, const char *curvelist)
+{
+    mbedtls_ecp_group_id ids[512];
+    int nids = -1;
+    const int idsz = (int)(sizeof(ids)/sizeof(*ids)-1);
+    const mbedtls_ecp_curve_info * const curve_info = mbedtls_ecp_curve_list();
+
+    for (const char *e = curvelist-1; e; ) {
+        const char * const n = e+1;
+        e = os_strchr(n, ':');
+        size_t len = e ? (size_t)(e - n) : os_strlen(n);
+        mbedtls_ecp_group_id grp_id = MBEDTLS_ECP_DP_NONE;
+        switch (len) {
+          case 5:
+            if (0 == os_memcmp("P-521", n, 5))
+                grp_id = MBEDTLS_ECP_DP_SECP521R1;
+            else if (0 == os_memcmp("P-384", n, 5))
+                grp_id = MBEDTLS_ECP_DP_SECP384R1;
+            else if (0 == os_memcmp("P-256", n, 5))
+                grp_id = MBEDTLS_ECP_DP_SECP256R1;
+            break;
+          case 6:
+            if (0 == os_memcmp("BP-521", n, 6))
+                grp_id = MBEDTLS_ECP_DP_BP512R1;
+            else if (0 == os_memcmp("BP-384", n, 6))
+                grp_id = MBEDTLS_ECP_DP_BP384R1;
+            else if (0 == os_memcmp("BP-256", n, 6))
+                grp_id = MBEDTLS_ECP_DP_BP256R1;
+            break;
+          default:
+            break;
+        }
+        if (grp_id != MBEDTLS_ECP_DP_NONE) {
+            nids = tls_mbedtls_append_curve(ids, nids, idsz, grp_id);
+            if (-1 == nids) return 0;
+            continue;
+        }
+        /* similar to mbedtls_ecp_curve_info_from_name() */
+        const mbedtls_ecp_curve_info *info;
+        for (info = curve_info; info->grp_id != MBEDTLS_ECP_DP_NONE; ++info) {
+            if (0 == os_strncmp(info->name, n, len) && info->name[len] == '\0')
+                break;
+        }
+        if (info->grp_id == MBEDTLS_ECP_DP_NONE) {
+            wpa_printf(MSG_ERROR, "MTLS: unrecognized curve: %.*s",(int)len,n);
+            return 0;
+        }
+
+        nids = tls_mbedtls_append_curve(ids, nids, idsz, info->grp_id);
+        if (-1 == nids) return 0;
+    }
+
+    /* mod_openssl configures "prime256v1" if curve list not specified,
+     * but mbedtls provides a list of supported curves if not explicitly set */
+    if (-1 == nids) return 1; /* empty list; no-op */
+
+    ids[++nids] = MBEDTLS_ECP_DP_NONE; /* terminate list */
+    ++nids;
+
+    /* curves list must be persistent for lifetime of mbedtls_ssl_config */
+    tls_conf->curves = os_malloc(nids * sizeof(mbedtls_ecp_group_id));
+    if (tls_conf->curves == NULL)
+        return 0;
+    os_memcpy(tls_conf->curves, ids, nids * sizeof(mbedtls_ecp_group_id));
+
+    mbedtls_ssl_conf_curves(&tls_conf->conf, tls_conf->curves);
+    return 1;
+}
+#else
+static int
+tls_mbedtls_append_curve (uint16_t *ids, int nids, int idsz, const uint16_t id)
+{
+    if (1 >= idsz - (nids + 1)) {
+        emsg(MSG_ERROR, "error: too many curves during list expand");
+        return -1;
+    }
+    ids[++nids] = id;
+    return nids;
+}
+
+
+static int
+tls_mbedtls_set_curves(struct tls_conf *tls_conf, const char *curvelist)
+{
+    /* TLS Supported Groups (renamed from "EC Named Curve Registry")
+     * https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-8
+     */
+    uint16_t ids[512];
+    int nids = -1;
+    const int idsz = (int)(sizeof(ids)/sizeof(*ids)-1);
+    const mbedtls_ecp_curve_info * const curve_info = mbedtls_ecp_curve_list();
+
+    for (const char *e = curvelist-1; e; ) {
+        const char * const n = e+1;
+        e = os_strchr(n, ':');
+        size_t len = e ? (size_t)(e - n) : os_strlen(n);
+        uint16_t tls_id = 0;
+        switch (len) {
+          case 5:
+            if (0 == os_memcmp("P-521", n, 5))
+                tls_id = 25; /* mbedtls_ecp_group_id MBEDTLS_ECP_DP_SECP521R1 */
+            else if (0 == os_memcmp("P-384", n, 5))
+                tls_id = 24; /* mbedtls_ecp_group_id MBEDTLS_ECP_DP_SECP384R1 */
+            else if (0 == os_memcmp("P-256", n, 5))
+                tls_id = 23; /* mbedtls_ecp_group_id MBEDTLS_ECP_DP_SECP256R1 */
+            break;
+          case 6:
+            if (0 == os_memcmp("BP-521", n, 6))
+                tls_id = 28; /* mbedtls_ecp_group_id MBEDTLS_ECP_DP_BP512R1 */
+            else if (0 == os_memcmp("BP-384", n, 6))
+                tls_id = 27; /* mbedtls_ecp_group_id MBEDTLS_ECP_DP_BP384R1 */
+            else if (0 == os_memcmp("BP-256", n, 6))
+                tls_id = 26; /* mbedtls_ecp_group_id MBEDTLS_ECP_DP_BP256R1 */
+            break;
+          default:
+            break;
+        }
+        if (tls_id != 0) {
+            nids = tls_mbedtls_append_curve(ids, nids, idsz, tls_id);
+            if (-1 == nids) return 0;
+            continue;
+        }
+        /* similar to mbedtls_ecp_curve_info_from_name() */
+        const mbedtls_ecp_curve_info *info;
+        for (info = curve_info; info->tls_id != 0; ++info) {
+            if (0 == os_strncmp(info->name, n, len) && info->name[len] == '\0')
+                break;
+        }
+        if (info->tls_id == 0) {
+            wpa_printf(MSG_ERROR, "MTLS: unrecognized curve: %.*s",(int)len,n);
+            return 0;
+        }
+
+        nids = tls_mbedtls_append_curve(ids, nids, idsz, info->tls_id);
+        if (-1 == nids) return 0;
+    }
+
+    /* mod_openssl configures "prime256v1" if curve list not specified,
+     * but mbedtls provides a list of supported curves if not explicitly set */
+    if (-1 == nids) return 1; /* empty list; no-op */
+
+    ids[++nids] = 0; /* terminate list */
+    ++nids;
+
+    /* curves list must be persistent for lifetime of mbedtls_ssl_config */
+    tls_conf->curves = os_malloc(nids * sizeof(uint16_t));
+    if (tls_conf->curves == NULL)
+        return 0;
+    os_memcpy(tls_conf->curves, ids, nids * sizeof(uint16_t));
+
+    mbedtls_ssl_conf_groups(&tls_conf->conf, tls_conf->curves);
+    return 1;
+}
+#endif /* MBEDTLS_VERSION_NUMBER >= 0x03010000 */ /* mbedtls 3.1.0 */
+
+
+/* data copied from lighttpd src/mod_mbedtls.c (BSD-3-Clause) */
+static const int suite_AES_256_ephemeral[] = {
+    /* All AES-256 ephemeral suites */
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CCM,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CCM,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CCM_8
+};
+
+/* data copied from lighttpd src/mod_mbedtls.c (BSD-3-Clause) */
+static const int suite_AES_128_ephemeral[] = {
+    /* All AES-128 ephemeral suites */
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CCM,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CCM,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CCM_8
+};
+
+/* data copied from lighttpd src/mod_mbedtls.c (BSD-3-Clause) */
+/* HIGH cipher list (mapped from openssl list to mbedtls) */
+static const int suite_HIGH[] = {
+    MBEDTLS_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
+    MBEDTLS_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CCM,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CCM,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CCM_8,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384,
+    MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256,
+    MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384,
+    MBEDTLS_TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CCM,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CCM,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8,
+    MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CCM_8,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256,
+    MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256,
+    MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA,
+    MBEDTLS_TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256,
+    MBEDTLS_TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256,
+    MBEDTLS_TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256,
+    MBEDTLS_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256,
+    MBEDTLS_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256,
+    MBEDTLS_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384,
+    MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CCM,
+    MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384,
+    MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384,
+    MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA,
+    MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA,
+    MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384,
+    MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384,
+    MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CCM_8,
+    MBEDTLS_TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384,
+    MBEDTLS_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256,
+    MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CCM,
+    MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256,
+    MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256,
+    MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA,
+    MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA,
+    MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256,
+    MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256,
+    MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CCM_8,
+    MBEDTLS_TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256,
+    MBEDTLS_TLS_RSA_WITH_AES_256_GCM_SHA384,
+    MBEDTLS_TLS_RSA_WITH_AES_256_CCM,
+    MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA256,
+    MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA,
+    MBEDTLS_TLS_RSA_WITH_AES_256_CCM_8,
+    MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256,
+    MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA,
+    MBEDTLS_TLS_RSA_WITH_ARIA_256_GCM_SHA384,
+    MBEDTLS_TLS_RSA_WITH_AES_128_GCM_SHA256,
+    MBEDTLS_TLS_RSA_WITH_AES_128_CCM,
+    MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA256,
+    MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA,
+    MBEDTLS_TLS_RSA_WITH_AES_128_CCM_8,
+    MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256,
+    MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA,
+    MBEDTLS_TLS_RSA_WITH_ARIA_128_GCM_SHA256,
+    MBEDTLS_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256,
+    MBEDTLS_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384,
+    MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384,
+    MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA,
+    MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384,
+    MBEDTLS_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384,
+    MBEDTLS_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256,
+    MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256,
+    MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA,
+    MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256,
+    MBEDTLS_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256,
+    MBEDTLS_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256,
+    MBEDTLS_TLS_PSK_WITH_AES_256_GCM_SHA384,
+    MBEDTLS_TLS_PSK_WITH_AES_256_CCM,
+    MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA384,
+    MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA,
+    MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384,
+    MBEDTLS_TLS_PSK_WITH_AES_256_CCM_8,
+    MBEDTLS_TLS_PSK_WITH_ARIA_256_GCM_SHA384,
+    MBEDTLS_TLS_PSK_WITH_AES_128_GCM_SHA256,
+    MBEDTLS_TLS_PSK_WITH_AES_128_CCM,
+    MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA256,
+    MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA,
+    MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256,
+    MBEDTLS_TLS_PSK_WITH_AES_128_CCM_8,
+    MBEDTLS_TLS_PSK_WITH_ARIA_128_GCM_SHA256
+};
+
+
+__attribute_noinline__
+static int
+tls_mbedtls_append_ciphersuite (int *ids, int nids, int idsz, const int *x, int xsz)
+{
+    if (xsz >= idsz - (nids + 1)) {
+        emsg(MSG_ERROR, "error: too many ciphers during list expand");
+        return -1;
+    }
+
+    for (int i = 0; i < xsz; ++i)
+        ids[++nids] = x[i];
+
+    return nids;
+}
+
+
+static int
+tls_mbedtls_translate_ciphername(int id, char *buf, size_t buflen)
+{
+    const mbedtls_ssl_ciphersuite_t *info =
+      mbedtls_ssl_ciphersuite_from_id(id);
+    if (info == NULL)
+        return 0;
+    const char *name = mbedtls_ssl_ciphersuite_get_name(info);
+    const size_t len = os_strlen(name);
+    if (len == 7 && 0 == os_memcmp(name, "unknown", 7))
+        return 0;
+    if (len >= buflen)
+        return 0;
+    os_strlcpy(buf, name, buflen);
+
+    /* attempt to translate mbedtls string to openssl string
+     * (some heuristics; incomplete) */
+    size_t i = 0, j = 0;
+    if (buf[0] == 'T') {
+        if (os_strncmp(buf, "TLS1-3-", 7) == 0) {
+            buf[3] = '-';
+            j = 4; /* remove "1-3" from "TLS1-3-" prefix */
+            i = 7;
+        }
+        else if (os_strncmp(buf, "TLS-", 4) == 0)
+            i = 4; /* remove "TLS-" prefix */
+    }
+    for (; buf[i]; ++i) {
+        if (buf[i] == '-') {
+            if (i >= 3) {
+                if (0 == os_memcmp(buf+i-3, "AES", 3))
+                    continue; /* "AES-" -> "AES" */
+            }
+            if (i >= 4) {
+                if (0 == os_memcmp(buf+i-4, "WITH", 4)) {
+                    j -= 4;   /* remove "WITH-" */
+                    continue;
+                }
+            }
+        }
+        buf[j++] = buf[i];
+    }
+    buf[j] = '\0';
+
+    return j;
+}
+
+
+__attribute_noinline__
+static int
+tls_mbedtls_set_ciphersuites(struct tls_conf *tls_conf, int *ids, int nids)
+{
+    /* ciphersuites list must be persistent for lifetime of mbedtls_ssl_config*/
+    os_free(tls_conf->ciphersuites);
+    tls_conf->ciphersuites = os_malloc(nids * sizeof(int));
+    if (tls_conf->ciphersuites == NULL)
+        return 0;
+    os_memcpy(tls_conf->ciphersuites, ids, nids * sizeof(int));
+    mbedtls_ssl_conf_ciphersuites(&tls_conf->conf, tls_conf->ciphersuites);
+    return 1;
+}
+
+
+static int
+tls_mbedtls_set_ciphers(struct tls_conf *tls_conf, const char *ciphers)
+{
+    char buf[64];
+    int ids[512];
+    int nids = -1;
+    const int idsz = (int)(sizeof(ids)/sizeof(*ids)-1);
+    const char *next;
+    size_t blen, clen;
+    do {
+        next = os_strchr(ciphers, ':');
+        clen = next ? (size_t)(next - ciphers) : os_strlen(ciphers);
+        if (!clen)
+            continue;
+
+        /* special-case a select set of openssl group names for hwsim tests */
+	/* (review; remove excess code if tests are not run for non-OpenSSL?) */
+        if (clen == 9 && os_memcmp(ciphers, "SUITEB192", 9) == 0) {
+            static int ssl_preset_suiteb192_ciphersuites[] = {
+                MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+                0
+            };
+            return tls_mbedtls_set_ciphersuites(tls_conf,
+                                                ssl_preset_suiteb192_ciphersuites,
+                                                2);
+        }
+        if (clen == 9 && os_memcmp(ciphers, "SUITEB128", 9) == 0) {
+            static int ssl_preset_suiteb128_ciphersuites[] = {
+                MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+                0
+            };
+            return tls_mbedtls_set_ciphersuites(tls_conf,
+                                                ssl_preset_suiteb128_ciphersuites,
+                                                2);
+        }
+        if (clen == 7 && os_memcmp(ciphers, "DEFAULT", 7) == 0)
+            continue;
+        if (clen == 6 && os_memcmp(ciphers, "AES128", 6) == 0) {
+            nids = tls_mbedtls_append_ciphersuite(ids, nids, idsz,
+                     suite_AES_128_ephemeral,
+                     (int)ARRAY_SIZE(suite_AES_128_ephemeral));
+            if (nids == -1)
+                return 0;
+            continue;
+        }
+        if (clen == 6 && os_memcmp(ciphers, "AES256", 6) == 0) {
+            nids = tls_mbedtls_append_ciphersuite(ids, nids, idsz,
+                     suite_AES_256_ephemeral,
+                     (int)ARRAY_SIZE(suite_AES_256_ephemeral));
+            if (nids == -1)
+                return 0;
+            continue;
+        }
+        if (clen == 4 && os_memcmp(ciphers, "HIGH", 4) == 0) {
+            nids = tls_mbedtls_append_ciphersuite(ids, nids, idsz, suite_HIGH,
+                                                  (int)ARRAY_SIZE(suite_HIGH));
+            if (nids == -1)
+                return 0;
+            continue;
+        }
+        /* ignore anonymous cipher group names (?not supported by mbedtls?) */
+        if (clen == 4 && os_memcmp(ciphers, "!ADH", 4) == 0)
+            continue;
+        if (clen == 6 && os_memcmp(ciphers, "-aECDH", 6) == 0)
+            continue;
+        if (clen == 7 && os_memcmp(ciphers, "-aECDSA", 7) == 0)
+            continue;
+
+        /* attempt to match mbedtls cipher names
+         * nb: does not support openssl group names or list manipulation syntax
+         *   (alt: could copy almost 1200 lines (!!!) of lighttpd mod_mbedtls.c
+         *    mod_mbedtls_ssl_conf_ciphersuites() to translate strings)
+         * note: not efficient to rewrite list for each ciphers entry,
+         *       but this code is expected to run only at startup
+         */
+        const int *list = mbedtls_ssl_list_ciphersuites();
+        for (; *list; ++list) {
+            blen = tls_mbedtls_translate_ciphername(*list,buf,sizeof(buf));
+            if (!blen)
+                continue;
+
+            /* matching heuristics additional to translate_ciphername above */
+            if (blen == clen+4) {
+                char *cbc = os_strstr(buf, "CBC-");
+                if (cbc) {
+                    os_memmove(cbc, cbc+4, blen-(cbc+4-buf)+1); /*(w/ '\0')*/
+                    blen -= 4;
+                }
+            }
+            if (blen >= clen && os_memcmp(ciphers, buf, clen) == 0
+                && (blen == clen
+                    || (blen == clen+7 && os_memcmp(buf+clen, "-SHA256", 7)))) {
+                if (1 >= idsz - (nids + 1)) {
+                    emsg(MSG_ERROR,
+                         "error: too many ciphers during list expand");
+                    return 0;
+                }
+                ids[++nids] = *list;
+                break;
+            }
+        }
+        if (*list == 0) {
+            wpa_printf(MSG_ERROR,
+                       "MTLS: unrecognized cipher: %.*s", (int)clen, ciphers);
+            return 0;
+        }
+    } while ((ciphers = next ? next+1 : NULL));
+
+    if (-1 == nids) return 1; /* empty list; no-op */
+
+    ids[++nids] = 0; /* terminate list */
+    ++nids;
+
+    return tls_mbedtls_set_ciphersuites(tls_conf, ids, nids);
+}
+
+
+__attribute_noinline__
+static int tls_mbedtls_set_item(char **config_item, const char *item)
+{
+	os_free(*config_item);
+	*config_item = NULL;
+	return item ? (*config_item = os_strdup(item)) != NULL : 1;
+}
+
+
+static int tls_connection_set_subject_match(struct tls_conf *tls_conf,
+                                            const struct tls_connection_params *params)
+{
+	int rc = 1;
+	rc &= tls_mbedtls_set_item(&tls_conf->subject_match,
+	                              params->subject_match);
+	rc &= tls_mbedtls_set_item(&tls_conf->altsubject_match,
+	                              params->altsubject_match);
+	rc &= tls_mbedtls_set_item(&tls_conf->suffix_match,
+	                              params->suffix_match);
+	rc &= tls_mbedtls_set_item(&tls_conf->domain_match,
+	                              params->domain_match);
+	rc &= tls_mbedtls_set_item(&tls_conf->check_cert_subject,
+	                              params->check_cert_subject);
+	return rc;
+}
+
+
+/* duplicated in crypto_mbedtls.c:crypto_mbedtls_readfile()*/
+__attribute_noinline__
+static int tls_mbedtls_readfile(const char *path, u8 **buf, size_t *n)
+{
+  #if 0 /* #ifdef MBEDTLS_FS_IO */
+	/*(includes +1 for '\0' needed by mbedtls PEM parsing funcs)*/
+	if (mbedtls_pk_load_file(path, (unsigned char **)buf, n) != 0) {
+		wpa_printf(MSG_ERROR, "error: mbedtls_pk_load_file %s", path);
+		return -1;
+	}
+  #else
+	/*(use os_readfile() so that we can use os_free()
+	 *(if we use mbedtls_pk_load_file() above, macros prevent calling free()
+	 * directly #if defined(OS_REJECT_C_LIB_FUNCTIONS) and calling os_free()
+	 * on buf aborts in tests if buf not allocated via os_malloc())*/
+	*buf = (u8 *)os_readfile(path, n);
+	if (!*buf) {
+		wpa_printf(MSG_ERROR, "error: os_readfile %s", path);
+		return -1;
+	}
+	u8 *buf0 = os_realloc(*buf, *n+1);
+	if (!buf0) {
+		bin_clear_free(*buf, *n);
+		*buf = NULL;
+		return -1;
+	}
+	buf0[(*n)++] = '\0';
+	*buf = buf0;
+  #endif
+	return 0;
+}
+
+
+static int tls_mbedtls_set_crl(struct tls_conf *tls_conf, const u8 *data, size_t len)
+{
+	/* do not use mbedtls_x509_crl_parse() on PEM unless it contains CRL */
+	if (len && data[len-1] == '\0'
+	    && NULL == os_strstr((const char *)data,"-----BEGIN X509 CRL-----")
+	    && tls_mbedtls_data_is_pem(data))
+		return 0;
+
+	mbedtls_x509_crl crl;
+	mbedtls_x509_crl_init(&crl);
+	int rc = mbedtls_x509_crl_parse(&crl, data, len);
+	if (rc < 0) {
+		mbedtls_x509_crl_free(&crl);
+		return rc == MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT ? 0 : rc;
+	}
+
+	mbedtls_x509_crl *crl_new = os_malloc(sizeof(crl));
+	if (crl_new == NULL) {
+		mbedtls_x509_crl_free(&crl);
+		return MBEDTLS_ERR_X509_ALLOC_FAILED;
+	}
+	os_memcpy(crl_new, &crl, sizeof(crl));
+
+	mbedtls_x509_crl *crl_old = tls_conf->crl;
+	tls_conf->crl = crl_new;
+	if (crl_old) {
+		mbedtls_x509_crl_free(crl_old);
+		os_free(crl_old);
+	}
+	return 0;
+}
+
+
+static int tls_mbedtls_set_ca(struct tls_conf *tls_conf, u8 *data, size_t len)
+{
+	/* load crt struct onto stack and then copy into tls_conf in
+	 * order to preserve existing tls_conf value if error occurs
+	 *
+	 * hostapd is not threaded, or else should allocate memory and swap in
+	 * pointer reduce race condition.  (If threaded, would also need to
+	 * keep reference count of use to avoid freeing while still in use.) */
+
+	mbedtls_x509_crt crt;
+	mbedtls_x509_crt_init(&crt);
+	int rc = mbedtls_x509_crt_parse(&crt, data, len);
+	if (rc < 0) {
+		mbedtls_x509_crt_free(&crt);
+		return rc;
+	}
+
+	mbedtls_x509_crt_free(&tls_conf->ca_cert);
+	os_memcpy(&tls_conf->ca_cert, &crt, sizeof(crt));
+	return 0;
+}
+
+
+static int tls_mbedtls_set_ca_and_crl(struct tls_conf *tls_conf, const char *ca_cert_file)
+{
+	size_t len;
+	u8 *data;
+	if (tls_mbedtls_readfile(ca_cert_file, &data, &len))
+		return -1;
+
+	int rc;
+	if (0 == (rc = tls_mbedtls_set_ca(tls_conf, data, len))
+	    && (!tls_mbedtls_data_is_pem(data) /*skip parse for CRL if not PEM*/
+	        || 0 == (rc = tls_mbedtls_set_crl(tls_conf, data, len)))) {
+		mbedtls_ssl_conf_ca_chain(&tls_conf->conf,
+		                          &tls_conf->ca_cert,
+		                          tls_conf->crl);
+	}
+	else {
+		elog(rc, __func__);
+		emsg(MSG_ERROR, ca_cert_file);
+	}
+
+	forced_memzero(data, len);
+	os_free(data);
+	return rc;
+}
+
+
+static void tls_mbedtls_refresh_crl(void)
+{
+	/* check for CRL refresh
+	 * continue even if error occurs; continue with previous cert, CRL */
+	unsigned int crl_reload_interval = tls_ctx_global.crl_reload_interval;
+	const char *ca_cert_file = tls_ctx_global.ca_cert_file;
+	if (!crl_reload_interval || !ca_cert_file)
+		return;
+
+	struct os_reltime *previous = &tls_ctx_global.crl_reload_previous;
+	struct os_reltime now;
+	if (os_get_reltime(&now) != 0
+	    || !os_reltime_expired(&now, previous, crl_reload_interval))
+		return;
+
+	/* Note: modifying global state is not thread-safe
+	 *       if in use by existing connections
+	 *
+	 * src/utils/os.h does not provide a portable stat()
+	 * or else it would be a good idea to check mtime and size,
+	 * and avoid reloading if file has not changed */
+
+	if (tls_mbedtls_set_ca_and_crl(tls_ctx_global.tls_conf, ca_cert_file) == 0)
+		*previous = now;
+}
+
+
+static int tls_mbedtls_set_ca_cert(struct tls_conf *tls_conf,
+				   const struct tls_connection_params *params)
+{
+	if (params->ca_cert) {
+		if (os_strncmp(params->ca_cert, "probe://", 8) == 0) {
+			tls_conf->ca_cert_probe = 1;
+			tls_conf->has_ca_cert = 1;
+			return 0;
+		}
+
+		if (os_strncmp(params->ca_cert, "hash://", 7) == 0) {
+			const char *pos = params->ca_cert + 7;
+			if (os_strncmp(pos, "server/sha256/", 14) != 0) {
+				emsg(MSG_ERROR, "unsupported ca_cert hash value");
+				return -1;
+			}
+			pos += 14;
+			if (os_strlen(pos) != SHA256_DIGEST_LENGTH*2) {
+				emsg(MSG_ERROR, "unexpected ca_cert hash length");
+				return -1;
+			}
+			if (hexstr2bin(pos, tls_conf->ca_cert_hash,
+			               SHA256_DIGEST_LENGTH) < 0) {
+				emsg(MSG_ERROR, "invalid ca_cert hash value");
+				return -1;
+			}
+			emsg(MSG_DEBUG, "checking only server certificate match");
+			tls_conf->verify_depth0_only = 1;
+			tls_conf->has_ca_cert = 1;
+			return 0;
+		}
+
+		if (tls_mbedtls_set_ca_and_crl(tls_conf, params->ca_cert) != 0)
+			return -1;
+	}
+	if (params->ca_cert_blob) {
+		size_t len = params->ca_cert_blob_len;
+		int is_pem = tls_mbedtls_data_is_pem(params->ca_cert_blob);
+		if (len && params->ca_cert_blob[len-1] != '\0' && is_pem)
+			++len; /*(include '\0' in len for PEM)*/
+		int ret = mbedtls_x509_crt_parse(&tls_conf->ca_cert,
+		                                 params->ca_cert_blob, len);
+		if (ret != 0) {
+			elog(ret, "mbedtls_x509_crt_parse");
+			return -1;
+		}
+		if (is_pem) { /*(ca_cert_blob in DER format contains ca cert only)*/
+			ret = tls_mbedtls_set_crl(tls_conf, params->ca_cert_blob, len);
+			if (ret != 0) {
+				elog(ret, "mbedtls_x509_crl_parse");
+				return -1;
+			}
+		}
+	}
+
+	if (mbedtls_x509_time_is_future(&tls_conf->ca_cert.valid_from)
+	    || mbedtls_x509_time_is_past(&tls_conf->ca_cert.valid_to)) {
+		emsg(MSG_WARNING, "ca_cert expired or not yet valid");
+		if (params->ca_cert)
+			emsg(MSG_WARNING, params->ca_cert);
+	}
+
+	tls_conf->has_ca_cert = 1;
+	return 0;
+}
+
+
+static int tls_mbedtls_set_certs(struct tls_conf *tls_conf,
+				 const struct tls_connection_params *params)
+{
+	int ret;
+
+	if (params->ca_cert || params->ca_cert_blob) {
+		if (tls_mbedtls_set_ca_cert(tls_conf, params) != 0)
+			return -1;
+	}
+	else if (params->ca_path) {
+		emsg(MSG_INFO, "ca_path support not implemented");
+		return -1;
+	}
+
+	if (!tls_conf->has_ca_cert)
+		mbedtls_ssl_conf_authmode(&tls_conf->conf, MBEDTLS_SSL_VERIFY_NONE);
+	else {
+		/* Initial setting: REQUIRED for client, OPTIONAL for server
+		 *   (see also tls_connection_set_verify()) */
+		tls_conf->verify_peer = (tls_ctx_global.tls_conf == NULL);
+		int authmode = tls_conf->verify_peer
+		  ? MBEDTLS_SSL_VERIFY_REQUIRED
+		  : MBEDTLS_SSL_VERIFY_OPTIONAL;
+		mbedtls_ssl_conf_authmode(&tls_conf->conf, authmode);
+		mbedtls_ssl_conf_ca_chain(&tls_conf->conf,
+		                          &tls_conf->ca_cert,
+		                          tls_conf->crl);
+
+		if (!tls_connection_set_subject_match(tls_conf, params))
+			return -1;
+	}
+
+	if (params->client_cert2) /*(yes, server_cert2 in msg below)*/
+		emsg(MSG_INFO, "server_cert2 support not implemented");
+
+	if (params->client_cert) {
+		size_t len;
+		u8 *data;
+		if (tls_mbedtls_readfile(params->client_cert, &data, &len))
+			return -1;
+		ret = mbedtls_x509_crt_parse(&tls_conf->client_cert, data, len);
+		forced_memzero(data, len);
+		os_free(data);
+	}
+	if (params->client_cert_blob) {
+		size_t len = params->client_cert_blob_len;
+		if (len && params->client_cert_blob[len-1] != '\0'
+		    && tls_mbedtls_data_is_pem(params->client_cert_blob))
+			++len; /*(include '\0' in len for PEM)*/
+		ret = mbedtls_x509_crt_parse(&tls_conf->client_cert,
+		                             params->client_cert_blob, len);
+	}
+	if (params->client_cert || params->client_cert_blob) {
+		if (ret < 0) {
+			elog(ret, "mbedtls_x509_crt_parse");
+			if (params->client_cert)
+				emsg(MSG_ERROR, params->client_cert);
+			return -1;
+		}
+		if (mbedtls_x509_time_is_future(&tls_conf->client_cert.valid_from)
+		    || mbedtls_x509_time_is_past(&tls_conf->client_cert.valid_to)) {
+			emsg(MSG_WARNING, "cert expired or not yet valid");
+			if (params->client_cert)
+				emsg(MSG_WARNING, params->client_cert);
+		}
+		tls_conf->has_client_cert = 1;
+	}
+
+	if (params->private_key || params->private_key_blob) {
+		size_t len = params->private_key_blob_len;
+		u8 *data;
+		*(const u8 **)&data = params->private_key_blob;
+		if (len && data[len-1] != '\0' && tls_mbedtls_data_is_pem(data))
+			++len; /*(include '\0' in len for PEM)*/
+		if (params->private_key
+		    && tls_mbedtls_readfile(params->private_key, &data, &len)) {
+			return -1;
+		}
+		const char *pwd = params->private_key_passwd;
+	  #if MBEDTLS_VERSION_NUMBER >= 0x03000000 /* mbedtls 3.0.0 */
+		ret = mbedtls_pk_parse_key(&tls_conf->private_key,
+			data, len,
+			(const unsigned char *)pwd,
+			pwd ? os_strlen(pwd) : 0,
+			mbedtls_ctr_drbg_random,
+			tls_ctx_global.ctr_drbg);
+	  #else
+		ret = mbedtls_pk_parse_key(&tls_conf->private_key,
+			data, len,
+			(const unsigned char *)pwd,
+			pwd ? os_strlen(pwd) : 0);
+	  #endif
+		if (params->private_key) {
+			forced_memzero(data, len);
+			os_free(data);
+		}
+		if (ret < 0) {
+			elog(ret, "mbedtls_pk_parse_key");
+			return -1;
+		}
+		tls_conf->has_private_key = 1;
+	}
+
+	if (tls_conf->has_client_cert && tls_conf->has_private_key) {
+		ret = mbedtls_ssl_conf_own_cert(
+		    &tls_conf->conf, &tls_conf->client_cert, &tls_conf->private_key);
+		if (ret < 0) {
+			elog(ret, "mbedtls_ssl_conf_own_cert");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+
+/* mbedtls_x509_crt_profile_suiteb plus rsa_min_bitlen 2048 */
+/* (reference: see also mbedtls_x509_crt_profile_next) */
+/* ??? should permit SHA-512, too, and additional curves ??? */
+static const mbedtls_x509_crt_profile tls_mbedtls_crt_profile_suiteb128 =
+{
+    /* Only SHA-256 and 384 */
+    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA256 ) |
+    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA384 ),
+    /* Only ECDSA */
+    MBEDTLS_X509_ID_FLAG( MBEDTLS_PK_ECDSA ) |
+    MBEDTLS_X509_ID_FLAG( MBEDTLS_PK_ECKEY ),
+#if defined(MBEDTLS_ECP_C)
+    /* Only NIST P-256 and P-384 */
+    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP256R1 ) |
+    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP384R1 ),
+#else
+    0,
+#endif
+    2048,
+};
+
+
+/* stricter than mbedtls_x509_crt_profile_suiteb */
+/* (reference: see also mbedtls_x509_crt_profile_next) */
+/* ??? should permit SHA-512, too, and additional curves ??? */
+static const mbedtls_x509_crt_profile tls_mbedtls_crt_profile_suiteb192 =
+{
+    /* Only SHA-384 */
+    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA384 ),
+    /* Only ECDSA */
+    MBEDTLS_X509_ID_FLAG( MBEDTLS_PK_ECDSA ) |
+    MBEDTLS_X509_ID_FLAG( MBEDTLS_PK_ECKEY ),
+#if defined(MBEDTLS_ECP_C)
+    /* Only NIST P-384 */
+    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP384R1 ),
+#else
+    0,
+#endif
+    3072,
+};
+
+
+/* stricter than mbedtls_x509_crt_profile_suiteb except allow any PK alg */
+/* (reference: see also mbedtls_x509_crt_profile_next) */
+/* ??? should permit SHA-512, too, and additional curves ??? */
+static const mbedtls_x509_crt_profile tls_mbedtls_crt_profile_suiteb192_anypk =
+{
+    /* Only SHA-384 */
+    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA384 ),
+    0xFFFFFFF, /* Any PK alg    */
+#if defined(MBEDTLS_ECP_C)
+    /* Only NIST P-384 */
+    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP384R1 ),
+#else
+    0,
+#endif
+    3072,
+};
+
+
+static int tls_mbedtls_set_params(struct tls_conf *tls_conf,
+				  const struct tls_connection_params *params)
+{
+	tls_conf->flags = params->flags;
+
+	if (tls_conf->flags & TLS_CONN_REQUIRE_OCSP_ALL) {
+		emsg(MSG_INFO, "ocsp=3 not supported");
+		return -1;
+	}
+
+	if (tls_conf->flags & TLS_CONN_REQUIRE_OCSP) {
+		emsg(MSG_INFO, "ocsp not supported");
+		return -1;
+	}
+
+	int suiteb128 = 0;
+	int suiteb192 = 0;
+	if (params->openssl_ciphers) {
+		if (os_strcmp(params->openssl_ciphers, "SUITEB192") == 0) {
+			suiteb192 = 1;
+			tls_conf->flags |= TLS_CONN_SUITEB;
+		}
+		if (os_strcmp(params->openssl_ciphers, "SUITEB128") == 0) {
+			suiteb128 = 1;
+			tls_conf->flags |= TLS_CONN_SUITEB;
+		}
+	}
+
+	int ret = mbedtls_ssl_config_defaults(
+	    &tls_conf->conf, tls_ctx_global.tls_conf ? MBEDTLS_SSL_IS_SERVER
+	                                             : MBEDTLS_SSL_IS_CLIENT,
+	    MBEDTLS_SSL_TRANSPORT_STREAM,
+	    (tls_conf->flags & TLS_CONN_SUITEB) ? MBEDTLS_SSL_PRESET_SUITEB
+	                                        : MBEDTLS_SSL_PRESET_DEFAULT);
+	if (ret != 0) {
+		elog(ret, "mbedtls_ssl_config_defaults");
+		return -1;
+	}
+
+	if (suiteb128) {
+		mbedtls_ssl_conf_cert_profile(&tls_conf->conf,
+		                              &tls_mbedtls_crt_profile_suiteb128);
+		mbedtls_ssl_conf_dhm_min_bitlen(&tls_conf->conf, 2048);
+	}
+	else if (suiteb192) {
+		mbedtls_ssl_conf_cert_profile(&tls_conf->conf,
+		                              &tls_mbedtls_crt_profile_suiteb192);
+		mbedtls_ssl_conf_dhm_min_bitlen(&tls_conf->conf, 3072);
+	}
+	else if (tls_conf->flags & TLS_CONN_SUITEB) {
+		/* treat as suiteb192 while allowing any PK algorithm */
+		mbedtls_ssl_conf_cert_profile(&tls_conf->conf,
+		                              &tls_mbedtls_crt_profile_suiteb192_anypk);
+		mbedtls_ssl_conf_dhm_min_bitlen(&tls_conf->conf, 3072);
+	}
+
+	tls_mbedtls_set_allowed_tls_vers(tls_conf, &tls_conf->conf);
+	ret = tls_mbedtls_set_certs(tls_conf, params);
+	if (ret != 0)
+		return -1;
+
+	if (params->dh_file
+	    && !tls_mbedtls_set_dhparams(tls_conf, params->dh_file)) {
+		return -1;
+	}
+
+	if (params->openssl_ecdh_curves
+	    && !tls_mbedtls_set_curves(tls_conf, params->openssl_ecdh_curves)) {
+		return -1;
+	}
+
+	if (params->openssl_ciphers) {
+		if (!tls_mbedtls_set_ciphers(tls_conf, params->openssl_ciphers))
+			return -1;
+	}
+	else if (tls_conf->flags & TLS_CONN_SUITEB) {
+		/* special-case a select set of ciphers for hwsim tests */
+		if (!tls_mbedtls_set_ciphers(tls_conf,
+		        (tls_conf->flags & TLS_CONN_SUITEB_NO_ECDH)
+		          ? "DHE-RSA-AES256-GCM-SHA384"
+		          : "ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384"))
+			return -1;
+	}
+
+	return 0;
+}
+
+
+int tls_connection_set_params(void *tls_ctx, struct tls_connection *conn,
+			      const struct tls_connection_params *params)
+{
+	if (conn == NULL || params == NULL)
+		return -1;
+
+	tls_conf_deinit(conn->tls_conf);
+	struct tls_conf *tls_conf = conn->tls_conf = tls_conf_init(tls_ctx);
+	if (tls_conf == NULL)
+		return -1;
+
+	if (tls_ctx_global.tls_conf) {
+		tls_conf->check_crl = tls_ctx_global.tls_conf->check_crl;
+		tls_conf->check_crl_strict = tls_ctx_global.tls_conf->check_crl_strict;
+		/*(tls_openssl.c inherits check_cert_subject from global conf)*/
+		if (tls_ctx_global.tls_conf->check_cert_subject) {
+			tls_conf->check_cert_subject =
+			  os_strdup(tls_ctx_global.tls_conf->check_cert_subject);
+			if (tls_conf->check_cert_subject == NULL)
+				return -1;
+		}
+	}
+
+	if (tls_mbedtls_set_params(tls_conf, params) != 0)
+		return -1;
+	conn->verify_peer = tls_conf->verify_peer;
+
+	return tls_mbedtls_ssl_setup(conn);
+}
+
+
+#ifdef TLS_MBEDTLS_SESSION_TICKETS
+
+static int tls_mbedtls_clienthello_session_ticket_prep (struct tls_connection *conn,
+                                                        const u8 *data, size_t len)
+{
+	if (conn->tls_conf->flags & TLS_CONN_DISABLE_SESSION_TICKET)
+		return -1;
+	if (conn->clienthello_session_ticket)
+		tls_connection_deinit_clienthello_session_ticket(conn);
+	if (len) {
+		conn->clienthello_session_ticket = mbedtls_calloc(1, len);
+		if (conn->clienthello_session_ticket == NULL)
+			return -1;
+		conn->clienthello_session_ticket_len = len;
+		os_memcpy(conn->clienthello_session_ticket, data, len);
+	}
+	return 0;
+}
+
+
+static void tls_mbedtls_clienthello_session_ticket_set (struct tls_connection *conn)
+{
+	mbedtls_ssl_session *sess = conn->ssl.MBEDTLS_PRIVATE(session_negotiate);
+	if (sess->MBEDTLS_PRIVATE(ticket)) {
+		mbedtls_platform_zeroize(sess->MBEDTLS_PRIVATE(ticket),
+		                         sess->MBEDTLS_PRIVATE(ticket_len));
+		mbedtls_free(sess->MBEDTLS_PRIVATE(ticket));
+	}
+	sess->MBEDTLS_PRIVATE(ticket) = conn->clienthello_session_ticket;
+	sess->MBEDTLS_PRIVATE(ticket_len) = conn->clienthello_session_ticket_len;
+	sess->MBEDTLS_PRIVATE(ticket_lifetime) = 86400;/* XXX: can hint be 0? */
+
+	conn->clienthello_session_ticket = NULL;
+	conn->clienthello_session_ticket_len = 0;
+}
+
+
+static int tls_mbedtls_ssl_ticket_write(void *p_ticket,
+                                        const mbedtls_ssl_session *session,
+                                        unsigned char *start,
+                                        const unsigned char *end,
+                                        size_t *tlen,
+                                        uint32_t *lifetime)
+{
+	struct tls_connection *conn = p_ticket;
+	if (conn && conn->session_ticket_cb) {
+		/* see tls_mbedtls_clienthello_session_ticket_prep() */
+		/* see tls_mbedtls_clienthello_session_ticket_set() */
+		return 0;
+	}
+
+	return mbedtls_ssl_ticket_write(&tls_ctx_global.ticket_ctx,
+	                                session, start, end, tlen, lifetime);
+}
+
+
+static int tls_mbedtls_ssl_ticket_parse(void *p_ticket,
+                                        mbedtls_ssl_session *session,
+                                        unsigned char *buf,
+                                        size_t len)
+{
+	/* XXX: TODO: not implemented in client;
+	 * mbedtls_ssl_conf_session_tickets_cb() callbacks only for TLS server*/
+
+	if (len == 0)
+		return MBEDTLS_ERR_SSL_BAD_INPUT_DATA;
+
+	struct tls_connection *conn = p_ticket;
+	if (conn && conn->session_ticket_cb) {
+		/* XXX: have random and secret been initialized yet?
+		 *      or must keys first be exported?
+		 *      EAP-FAST uses all args, EAP-TEAP only uses secret */
+		struct tls_random data;
+		if (tls_connection_get_random(NULL, conn, &data) != 0)
+			return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
+		int ret =
+		  conn->session_ticket_cb(conn->session_ticket_cb_ctx,
+		                          buf, len,
+		                          data.client_random,
+		                          data.server_random,
+		                          conn->expkey_secret);
+		if (ret == 1) {
+			conn->resumed = 1;
+			return 0;
+		}
+		emsg(MSG_ERROR, "EAP session ticket ext not implemented");
+		return MBEDTLS_ERR_SSL_INVALID_MAC;
+		/*(non-zero return used for mbedtls debug logging)*/
+	}
+
+	/* XXX: TODO always use tls_mbedtls_ssl_ticket_parse() for callback? */
+	int rc = mbedtls_ssl_ticket_parse(&tls_ctx_global.ticket_ctx,
+	                                  session, buf, len);
+	if (conn)
+		conn->resumed = (rc == 0);
+	return rc;
+}
+
+#endif /* TLS_MBEDTLS_SESSION_TICKETS */
+
+
+__attribute_cold__
+int tls_global_set_params(void *tls_ctx,
+			  const struct tls_connection_params *params)
+{
+	/* XXX: why might global_set_params be called more than once? */
+	if (tls_ctx_global.tls_conf)
+		tls_conf_deinit(tls_ctx_global.tls_conf);
+	tls_ctx_global.tls_conf = tls_conf_init(tls_ctx);
+	if (tls_ctx_global.tls_conf == NULL)
+		return -1;
+
+  #ifdef MBEDTLS_SSL_SESSION_TICKETS
+  #ifdef MBEDTLS_SSL_TICKET_C
+	if (!(params->flags & TLS_CONN_DISABLE_SESSION_TICKET))
+	  #ifdef TLS_MBEDTLS_SESSION_TICKETS
+		mbedtls_ssl_conf_session_tickets_cb(&tls_ctx_global.tls_conf->conf,
+		                                    tls_mbedtls_ssl_ticket_write,
+		                                    tls_mbedtls_ssl_ticket_parse,
+		                                    NULL);
+	  #else
+		mbedtls_ssl_conf_session_tickets_cb(&tls_ctx_global.tls_conf->conf,
+		                                    mbedtls_ssl_ticket_write,
+		                                    mbedtls_ssl_ticket_parse,
+		                                    &tls_ctx_global.ticket_ctx);
+	  #endif
+  #endif
+  #endif
+
+	os_free(tls_ctx_global.ocsp_stapling_response);
+	tls_ctx_global.ocsp_stapling_response = NULL;
+	if (params->ocsp_stapling_response)
+		tls_ctx_global.ocsp_stapling_response =
+			os_strdup(params->ocsp_stapling_response);
+
+	os_free(tls_ctx_global.ca_cert_file);
+	tls_ctx_global.ca_cert_file = NULL;
+	if (params->ca_cert)
+		tls_ctx_global.ca_cert_file = os_strdup(params->ca_cert);
+	return tls_mbedtls_set_params(tls_ctx_global.tls_conf, params);
+}
+
+
+int tls_global_set_verify(void *tls_ctx, int check_crl, int strict)
+{
+	tls_ctx_global.tls_conf->check_crl = check_crl;
+	tls_ctx_global.tls_conf->check_crl_strict = strict; /*(time checks)*/
+	return 0;
+}
+
+
+int tls_connection_set_verify(void *tls_ctx, struct tls_connection *conn,
+			      int verify_peer, unsigned int flags,
+			      const u8 *session_ctx, size_t session_ctx_len)
+{
+	/*(EAP server-side calls this from eap_server_tls_ssl_init())*/
+	if (conn == NULL)
+		return -1;
+
+	conn->tls_conf->flags |= flags;/* TODO: reprocess flags, if necessary */
+
+	int authmode;
+	switch (verify_peer) {
+	case 2:  authmode = MBEDTLS_SSL_VERIFY_OPTIONAL; break;/*(eap_teap_init())*/
+	case 1:  authmode = MBEDTLS_SSL_VERIFY_REQUIRED; break;
+	default: authmode = MBEDTLS_SSL_VERIFY_NONE;     break;
+	}
+	mbedtls_ssl_set_hs_authmode(&conn->ssl, authmode);
+
+	if ((conn->verify_peer = (authmode != MBEDTLS_SSL_VERIFY_NONE)))
+		mbedtls_ssl_set_verify(&conn->ssl, tls_mbedtls_verify_cb, conn);
+	else
+		mbedtls_ssl_set_verify(&conn->ssl, NULL, NULL);
+
+	return 0;
+}
+
+
+#if MBEDTLS_VERSION_NUMBER >= 0x03000000 /* mbedtls 3.0.0 */
+static void tls_connection_export_keys_cb(
+    void *p_expkey, mbedtls_ssl_key_export_type secret_type,
+    const unsigned char *secret, size_t secret_len,
+    const unsigned char client_random[MBEDTLS_EXPKEY_RAND_LEN],
+    const unsigned char server_random[MBEDTLS_EXPKEY_RAND_LEN],
+    mbedtls_tls_prf_types tls_prf_type)
+{
+	struct tls_connection *conn = p_expkey;
+	conn->tls_prf_type = tls_prf_type;
+	if (!tls_prf_type)
+		return;
+	if (secret_len > sizeof(conn->expkey_secret)) {
+		emsg(MSG_ERROR, "tls_connection_export_keys_cb secret too long");
+		conn->tls_prf_type = MBEDTLS_SSL_TLS_PRF_NONE; /* 0 */
+		return;
+	}
+	conn->expkey_secret_len = secret_len;
+	os_memcpy(conn->expkey_secret, secret, secret_len);
+	os_memcpy(conn->expkey_randbytes,
+	          client_random, MBEDTLS_EXPKEY_RAND_LEN);
+	os_memcpy(conn->expkey_randbytes + MBEDTLS_EXPKEY_RAND_LEN,
+	          server_random, MBEDTLS_EXPKEY_RAND_LEN);
+}
+#elif MBEDTLS_VERSION_NUMBER >= 0x02120000 /* mbedtls 2.18.0 */
+static int tls_connection_export_keys_cb(
+    void *p_expkey,
+    const unsigned char *ms,
+    const unsigned char *kb,
+    size_t maclen,
+    size_t keylen,
+    size_t ivlen,
+    const unsigned char client_random[MBEDTLS_EXPKEY_RAND_LEN],
+    const unsigned char server_random[MBEDTLS_EXPKEY_RAND_LEN],
+    mbedtls_tls_prf_types tls_prf_type )
+{
+	struct tls_connection *conn = p_expkey;
+	conn->tls_prf_type = tls_prf_type;
+	if (!tls_prf_type)
+		return -1; /*(return value ignored by mbedtls)*/
+	conn->expkey_keyblock_size = maclen + keylen + ivlen;
+	conn->expkey_secret_len = MBEDTLS_EXPKEY_FIXED_SECRET_LEN;
+	os_memcpy(conn->expkey_secret, ms, MBEDTLS_EXPKEY_FIXED_SECRET_LEN);
+	os_memcpy(conn->expkey_randbytes,
+	          client_random, MBEDTLS_EXPKEY_RAND_LEN);
+	os_memcpy(conn->expkey_randbytes + MBEDTLS_EXPKEY_RAND_LEN,
+	          server_random, MBEDTLS_EXPKEY_RAND_LEN);
+	return 0;
+}
+#endif
+
+
+int tls_connection_get_random(void *tls_ctx, struct tls_connection *conn,
+			      struct tls_random *data)
+{
+	if (!conn || !conn->tls_prf_type)
+		return -1;
+	data->client_random = conn->expkey_randbytes;
+	data->client_random_len = MBEDTLS_EXPKEY_RAND_LEN;
+	data->server_random = conn->expkey_randbytes + MBEDTLS_EXPKEY_RAND_LEN;
+	data->server_random_len = MBEDTLS_EXPKEY_RAND_LEN;
+	return 0;
+}
+
+
+int tls_connection_export_key(void *tls_ctx, struct tls_connection *conn,
+			      const char *label, const u8 *context,
+			      size_t context_len, u8 *out, size_t out_len)
+{
+	/* (EAP-PEAP EAP-TLS EAP-TTLS) */
+  #if MBEDTLS_VERSION_NUMBER >= 0x02120000 /* mbedtls 2.18.0 */
+	return (conn && conn->established && conn->tls_prf_type)
+	  ? mbedtls_ssl_tls_prf(conn->tls_prf_type,
+				conn->expkey_secret, conn->expkey_secret_len, label,
+				conn->expkey_randbytes,
+				sizeof(conn->expkey_randbytes), out, out_len)
+	  : -1;
+  #else
+	/* not implemented here for mbedtls < 2.18.0 */
+	return -1;
+  #endif
+}
+
+
+#ifdef TLS_MBEDTLS_EAP_FAST
+
+#if MBEDTLS_VERSION_NUMBER >= 0x03000000 /* mbedtls 3.0.0 */
+/* keyblock size info is not exposed in mbed TLS 3.0.0 */
+/* extracted from mbedtls library/ssl_tls.c:ssl_tls12_populate_transform() */
+#include <mbedtls/ssl_ciphersuites.h>
+#include <mbedtls/cipher.h>
+static size_t tls_mbedtls_ssl_keyblock_size (mbedtls_ssl_context *ssl)
+{
+  #if !defined(MBEDTLS_USE_PSA_CRYPTO) /* XXX: (not extracted for PSA crypto) */
+  #if defined(MBEDTLS_SSL_PROTO_TLS1_3)
+    if (mbedtls_ssl_get_version_number(ssl) == MBEDTLS_SSL_VERSION_TLS1_3)
+        return 0; /* (calculation not extracted) */
+  #endif /* MBEDTLS_SSL_PROTO_TLS1_3 */
+
+    int ciphersuite = mbedtls_ssl_get_ciphersuite_id_from_ssl(ssl);
+    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
+      mbedtls_ssl_ciphersuite_from_id(ciphersuite);
+    if (ciphersuite_info == NULL)
+        return 0;
+
+    const mbedtls_cipher_info_t *cipher_info =
+      mbedtls_cipher_info_from_type(ciphersuite_info->MBEDTLS_PRIVATE(cipher));
+    if (cipher_info == NULL)
+        return 0;
+
+  #if MBEDTLS_VERSION_NUMBER >= 0x03010000 /* mbedtls 3.1.0 */
+    size_t keylen = mbedtls_cipher_info_get_key_bitlen(cipher_info) / 8;
+    mbedtls_cipher_mode_t mode = mbedtls_cipher_info_get_mode(cipher_info);
+  #else
+    size_t keylen = cipher_info->MBEDTLS_PRIVATE(key_bitlen) / 8;
+    mbedtls_cipher_mode_t mode = cipher_info->MBEDTLS_PRIVATE(mode);
+  #endif
+  #if defined(MBEDTLS_GCM_C) || \
+      defined(MBEDTLS_CCM_C) || \
+      defined(MBEDTLS_CHACHAPOLY_C)
+    if (mode == MBEDTLS_MODE_GCM || mode == MBEDTLS_MODE_CCM)
+        return keylen + 4;
+    else if (mode == MBEDTLS_MODE_CHACHAPOLY)
+        return keylen + 12;
+    else
+  #endif /* MBEDTLS_GCM_C || MBEDTLS_CCM_C || MBEDTLS_CHACHAPOLY_C */
+  #if defined(MBEDTLS_SSL_SOME_SUITES_USE_MAC)
+    {
+        const mbedtls_md_info_t *md_info =
+          mbedtls_md_info_from_type(ciphersuite_info->MBEDTLS_PRIVATE(mac));
+        if (md_info == NULL)
+            return 0;
+        size_t mac_key_len = mbedtls_md_get_size(md_info);
+        size_t ivlen = mbedtls_cipher_info_get_iv_size(cipher_info);
+        return keylen + mac_key_len + ivlen;
+    }
+  #endif /* MBEDTLS_SSL_SOME_SUITES_USE_MAC */
+  #endif /* !MBEDTLS_USE_PSA_CRYPTO *//* (not extracted for PSA crypto) */
+    return 0;
+}
+#endif /* MBEDTLS_VERSION_NUMBER >= 0x03000000 *//* mbedtls 3.0.0 */
+
+
+int tls_connection_get_eap_fast_key(void *tls_ctx, struct tls_connection *conn,
+				    u8 *out, size_t out_len)
+{
+	/* XXX: has export keys callback been run? */
+	if (!conn || !conn->tls_prf_type)
+		return -1;
+
+  #if MBEDTLS_VERSION_NUMBER >= 0x03000000 /* mbedtls 3.0.0 */
+	conn->expkey_keyblock_size = tls_mbedtls_ssl_keyblock_size(&conn->ssl);
+	if (conn->expkey_keyblock_size == 0)
+		return -1;
+  #endif
+	size_t skip = conn->expkey_keyblock_size * 2;
+	unsigned char *tmp_out = os_malloc(skip + out_len);
+	if (!tmp_out)
+		return -1;
+
+	/* server_random and then client_random */
+	unsigned char seed[MBEDTLS_EXPKEY_RAND_LEN*2];
+	os_memcpy(seed, conn->expkey_randbytes + MBEDTLS_EXPKEY_RAND_LEN,
+	          MBEDTLS_EXPKEY_RAND_LEN);
+	os_memcpy(seed + MBEDTLS_EXPKEY_RAND_LEN, conn->expkey_randbytes,
+	          MBEDTLS_EXPKEY_RAND_LEN);
+
+  #if MBEDTLS_VERSION_NUMBER >= 0x02120000 /* mbedtls 2.18.0 */
+	int ret = mbedtls_ssl_tls_prf(conn->tls_prf_type,
+				      conn->expkey_secret, conn->expkey_secret_len,
+				      "key expansion", seed, sizeof(seed),
+				      tmp_out, skip + out_len);
+	if (ret == 0)
+		os_memcpy(out, tmp_out + skip, out_len);
+  #else
+	int ret = -1; /*(not reached if not impl; return -1 at top of func)*/
+  #endif
+
+	bin_clear_free(tmp_out, skip + out_len);
+	forced_memzero(seed, sizeof(seed));
+	return ret;
+}
+
+#endif /* TLS_MBEDTLS_EAP_FAST */
+
+
+__attribute_cold__
+static void tls_mbedtls_suiteb_handshake_alert (struct tls_connection *conn)
+{
+	/* tests/hwsim/test_suite_b.py test_suite_b_192_rsa_insufficient_dh */
+	if (!(conn->tls_conf->flags & TLS_CONN_SUITEB))
+		return;
+	if (tls_ctx_global.tls_conf) /*(is server; want issue event on client)*/
+		return;
+  #if 0
+	/*(info not available on client;
+         * mbed TLS library enforces dhm min bitlen in ServerKeyExchange)*/
+	if (MBEDTLS_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 ==
+	  #if MBEDTLS_VERSION_NUMBER < 0x03020000 /* mbedtls 3.2.0 */
+	          mbedtls_ssl_get_ciphersuite_id_from_ssl(&conn->ssl)
+	  #else
+	          mbedtls_ssl_get_ciphersuite_id(
+	            mbedtls_ssl_get_ciphersuite(&conn->ssl))
+	  #endif
+	    && mbedtls_mpi_size(&conn->tls_conf->conf.MBEDTLS_PRIVATE(dhm_P))
+	         < 384 /*(3072/8)*/)
+  #endif
+	{
+		struct tls_config *init_conf = &tls_ctx_global.init_conf;
+		if (init_conf->event_cb) {
+			union tls_event_data ev;
+			os_memset(&ev, 0, sizeof(ev));
+			ev.alert.is_local = 1;
+			ev.alert.type = "fatal";
+			/*"internal error" string for tests/hwsim/test_suiteb.py */
+			ev.alert.description = "internal error: handshake failure";
+			/*ev.alert.description = "insufficient security";*/
+			init_conf->event_cb(init_conf->cb_ctx, TLS_ALERT, &ev);
+		}
+	}
+}
+
+
+struct wpabuf * tls_connection_handshake(void *tls_ctx,
+					 struct tls_connection *conn,
+					 const struct wpabuf *in_data,
+					 struct wpabuf **appl_data)
+{
+	if (appl_data)
+		*appl_data = NULL;
+
+	if (in_data && wpabuf_len(in_data)) {
+		/*(unsure why tls_gnutls.c discards buffer contents; skip here)*/
+		if (conn->pull_buf && 0) /* disable; appears unwise */
+			tls_pull_buf_discard(conn, __func__);
+		if (!tls_pull_buf_append(conn, in_data))
+			return NULL;
+	}
+
+	if (conn->tls_conf == NULL) {
+		struct tls_connection_params params;
+		os_memset(&params, 0, sizeof(params));
+		params.openssl_ciphers =
+		  tls_ctx_global.init_conf.openssl_ciphers;
+		params.flags = tls_ctx_global.tls_conf->flags;
+		if (tls_connection_set_params(tls_ctx, conn, &params) != 0)
+			return NULL;
+	}
+
+	if (conn->verify_peer) /*(call here might be redundant; nbd)*/
+		mbedtls_ssl_set_verify(&conn->ssl, tls_mbedtls_verify_cb, conn);
+
+  #ifdef TLS_MBEDTLS_SESSION_TICKETS
+	if (conn->clienthello_session_ticket)
+		/*(starting handshake for EAP-FAST and EAP-TEAP)*/
+		tls_mbedtls_clienthello_session_ticket_set(conn);
+
+	/* (not thread-safe due to need to set userdata 'conn' for callback) */
+	/* (unable to use mbedtls_ssl_set_user_data_p() with mbedtls 3.2.0+
+	 *  since ticket write and parse callbacks take (mbedtls_ssl_session *)
+	 *  param instead of (mbedtls_ssl_context *) param) */
+	if (conn->tls_conf->flags & TLS_CONN_DISABLE_SESSION_TICKET)
+		mbedtls_ssl_conf_session_tickets_cb(&conn->tls_conf->conf,
+		                                    NULL, NULL, NULL);
+	else
+		mbedtls_ssl_conf_session_tickets_cb(&conn->tls_conf->conf,
+		                                    tls_mbedtls_ssl_ticket_write,
+		                                    tls_mbedtls_ssl_ticket_parse,
+		                                    conn);
+  #endif
+
+  #if MBEDTLS_VERSION_NUMBER >= 0x03020000 /* mbedtls 3.2.0 */
+	int ret = mbedtls_ssl_handshake(&conn->ssl);
+  #else
+	int ret = 0;
+	while (conn->ssl.MBEDTLS_PRIVATE(state) != MBEDTLS_SSL_HANDSHAKE_OVER) {
+		ret = mbedtls_ssl_handshake_step(&conn->ssl);
+		if (ret != 0)
+			break;
+	}
+  #endif
+
+  #ifdef TLS_MBEDTLS_SESSION_TICKETS
+	mbedtls_ssl_conf_session_tickets_cb(&conn->tls_conf->conf,
+	                                    tls_mbedtls_ssl_ticket_write,
+	                                    tls_mbedtls_ssl_ticket_parse,
+	                                    NULL);
+  #endif
+
+	switch (ret) {
+	case 0:
+		conn->established = 1;
+		if (conn->push_buf == NULL)
+			/* Need to return something to get final TLS ACK. */
+			conn->push_buf = wpabuf_alloc(0);
+
+		if (appl_data /*&& conn->pull_buf && wpabuf_len(conn->pull_buf)*/)
+			*appl_data = NULL; /* RFE: check for application data */
+		break;
+	case MBEDTLS_ERR_SSL_WANT_WRITE:
+	case MBEDTLS_ERR_SSL_WANT_READ:
+	case MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS:
+	case MBEDTLS_ERR_SSL_ASYNC_IN_PROGRESS:
+		if (tls_ctx_global.tls_conf /*(is server)*/
+		    && conn->established && conn->push_buf == NULL)
+			/* Need to return something to trigger completion of EAP-TLS. */
+			conn->push_buf = wpabuf_alloc(0);
+		break;
+	default:
+		++conn->failed;
+		switch (ret) {
+		case MBEDTLS_ERR_SSL_CLIENT_RECONNECT:
+		case MBEDTLS_ERR_NET_CONN_RESET:
+		case MBEDTLS_ERR_NET_SEND_FAILED:
+			++conn->write_alerts;
+			break;
+	      #if MBEDTLS_VERSION_NUMBER >= 0x03000000 /* mbedtls 3.0.0 */
+		case MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE:
+	      #else
+		case MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE:
+	      #endif
+			tls_mbedtls_suiteb_handshake_alert(conn);
+			/* fall through */
+		case MBEDTLS_ERR_NET_RECV_FAILED:
+		case MBEDTLS_ERR_SSL_CONN_EOF:
+		case MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY:
+		case MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE:
+			++conn->read_alerts;
+			break;
+		default:
+			break;
+		}
+
+		ilog(ret, "mbedtls_ssl_handshake");
+		break;
+	}
+
+	struct wpabuf *out_data = conn->push_buf;
+	conn->push_buf = NULL;
+	return out_data;
+}
+
+
+struct wpabuf * tls_connection_server_handshake(void *tls_ctx,
+						struct tls_connection *conn,
+						const struct wpabuf *in_data,
+						struct wpabuf **appl_data)
+{
+	conn->is_server = 1;
+	return tls_connection_handshake(tls_ctx, conn, in_data, appl_data);
+}
+
+
+struct wpabuf * tls_connection_encrypt(void *tls_ctx,
+				       struct tls_connection *conn,
+				       const struct wpabuf *in_data)
+{
+	int res = mbedtls_ssl_write(&conn->ssl,
+	                            wpabuf_head_u8(in_data), wpabuf_len(in_data));
+	if (res < 0) {
+		elog(res, "mbedtls_ssl_write");
+		return NULL;
+	}
+
+	struct wpabuf *buf = conn->push_buf;
+	conn->push_buf = NULL;
+	return buf;
+}
+
+
+struct wpabuf * tls_connection_decrypt(void *tls_ctx,
+				       struct tls_connection *conn,
+				       const struct wpabuf *in_data)
+{
+	int res;
+	struct wpabuf *out;
+
+	/*assert(in_data != NULL);*/
+	if (!tls_pull_buf_append(conn, in_data))
+		return NULL;
+
+  #if defined(MBEDTLS_ZLIB_SUPPORT) /* removed in mbedtls 3.x */
+	/* Add extra buffer space to handle the possibility of decrypted
+	 * data being longer than input data due to TLS compression. */
+	out = wpabuf_alloc((wpabuf_len(in_data) + 500) * 3);
+  #else /* TLS compression is disabled in mbedtls 3.x */
+	out = wpabuf_alloc(wpabuf_len(in_data));
+  #endif
+	if (out == NULL)
+		return NULL;
+
+	res = mbedtls_ssl_read(&conn->ssl, wpabuf_mhead(out), wpabuf_size(out));
+	if (res < 0) {
+	  #if 1 /*(seems like a different error if wpabuf_len(in_data) == 0)*/
+		if (res == MBEDTLS_ERR_SSL_WANT_READ)
+			return out;
+	  #endif
+		elog(res, "mbedtls_ssl_read");
+		wpabuf_free(out);
+		return NULL;
+	}
+	wpabuf_put(out, res);
+
+	return out;
+}
+
+
+int tls_connection_resumed(void *tls_ctx, struct tls_connection *conn)
+{
+	/* XXX: might need to detect if session resumed from TLS session ticket
+	 * even if not special session ticket handling for EAP-FAST, EAP-TEAP */
+	/* (?ssl->handshake->resume during session ticket validation?) */
+	return conn && conn->resumed;
+}
+
+
+#ifdef TLS_MBEDTLS_EAP_FAST
+int tls_connection_set_cipher_list(void *tls_ctx, struct tls_connection *conn,
+				   u8 *ciphers)
+{
+	/* ciphers is list of TLS_CIPHER_* from hostap/src/crypto/tls.h */
+	int ids[7];
+	const int idsz = (int)sizeof(ids);
+	int nids = -1, id;
+	for ( ; *ciphers != TLS_CIPHER_NONE; ++ciphers) {
+		switch (*ciphers) {
+		case TLS_CIPHER_RC4_SHA:
+		  #ifdef MBEDTLS_TLS_RSA_WITH_RC4_128_SHA
+			id = MBEDTLS_TLS_RSA_WITH_RC4_128_SHA;
+			break;
+		  #else
+			continue; /*(not supported in mbedtls 3.x; ignore)*/
+		  #endif
+		case TLS_CIPHER_AES128_SHA:
+			id = MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA;
+			break;
+		case TLS_CIPHER_RSA_DHE_AES128_SHA:
+			id = MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA;
+			break;
+		case TLS_CIPHER_ANON_DH_AES128_SHA:
+			continue; /*(not supported in mbedtls; ignore)*/
+		case TLS_CIPHER_RSA_DHE_AES256_SHA:
+			id = MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA;
+			break;
+		case TLS_CIPHER_AES256_SHA:
+			id = MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA;
+			break;
+		default:
+			return -1; /* should not happen */
+		}
+		if (++nids == idsz)
+			return -1; /* should not happen */
+		ids[nids] = id;
+	}
+	if (nids < 0)
+		return 0; /* nothing to do */
+	if (++nids == idsz)
+		return -1; /* should not happen */
+	ids[nids] = 0; /* terminate list */
+	++nids;
+
+	return tls_mbedtls_set_ciphersuites(conn->tls_conf, ids, nids) ? 0 : -1;
+}
+#endif
+
+
+int tls_get_version(void *ssl_ctx, struct tls_connection *conn,
+		    char *buf, size_t buflen)
+{
+	if (conn == NULL)
+		return -1;
+	os_strlcpy(buf, mbedtls_ssl_get_version(&conn->ssl), buflen);
+	return buf[0] != 'u' ? 0 : -1; /*(-1 if "unknown")*/
+}
+
+
+#ifdef TLS_MBEDTLS_EAP_TEAP
+u16 tls_connection_get_cipher_suite(struct tls_connection *conn)
+{
+	if (conn == NULL)
+		return 0;
+	return (u16)mbedtls_ssl_get_ciphersuite_id_from_ssl(&conn->ssl);
+}
+#endif
+
+
+int tls_get_cipher(void *tls_ctx, struct tls_connection *conn,
+		   char *buf, size_t buflen)
+{
+	if (conn == NULL)
+		return -1;
+	const int id = mbedtls_ssl_get_ciphersuite_id_from_ssl(&conn->ssl);
+	return tls_mbedtls_translate_ciphername(id, buf, buflen) ? 0 : -1;
+}
+
+
+#ifdef TLS_MBEDTLS_SESSION_TICKETS
+
+int tls_connection_enable_workaround(void *tls_ctx,
+				     struct tls_connection *conn)
+{
+	/* (see comment in src/eap_peer/eap_fast.c:eap_fast_init()) */
+	/* XXX: is there a relevant setting for this in mbed TLS? */
+	/* (do we even care that much about older CBC ciphers?) */
+	return 0;
+}
+
+
+int tls_connection_client_hello_ext(void *tls_ctx, struct tls_connection *conn,
+				    int ext_type, const u8 *data,
+				    size_t data_len)
+{
+	/* (EAP-FAST and EAP-TEAP) */
+	if (ext_type == MBEDTLS_TLS_EXT_SESSION_TICKET) /*(ext_type == 35)*/
+		return tls_mbedtls_clienthello_session_ticket_prep(conn, data,
+		                                                   data_len);
+
+	return -1;
+}
+
+#endif /* TLS_MBEDTLS_SESSION_TICKETS */
+
+
+int tls_connection_get_failed(void *tls_ctx, struct tls_connection *conn)
+{
+	return conn ? conn->failed : -1;
+}
+
+
+int tls_connection_get_read_alerts(void *tls_ctx, struct tls_connection *conn)
+{
+	return conn ? conn->read_alerts : -1;
+}
+
+
+int tls_connection_get_write_alerts(void *tls_ctx,
+				    struct tls_connection *conn)
+{
+	return conn ? conn->write_alerts : -1;
+}
+
+
+#ifdef TLS_MBEDTLS_SESSION_TICKETS
+int tls_connection_set_session_ticket_cb(
+	void *tls_ctx, struct tls_connection *conn,
+	tls_session_ticket_cb cb, void *ctx)
+{
+	if (!(conn->tls_conf->flags & TLS_CONN_DISABLE_SESSION_TICKET)) {
+		/* (EAP-FAST and EAP-TEAP) */
+		conn->session_ticket_cb = cb;
+		conn->session_ticket_cb_ctx = ctx;
+		return 0;
+	}
+	return -1;
+}
+#endif
+
+
+int tls_get_library_version(char *buf, size_t buf_len)
+{
+  #ifndef MBEDTLS_VERSION_C
+	const char * const ver = "n/a";
+  #else
+	char ver[9];
+	mbedtls_version_get_string(ver);
+  #endif
+	return os_snprintf(buf, buf_len,
+	                   "mbed TLS build=" MBEDTLS_VERSION_STRING " run=%s", ver);
+}
+
+
+void tls_connection_set_success_data(struct tls_connection *conn,
+				     struct wpabuf *data)
+{
+	wpabuf_free(conn->success_data);
+	conn->success_data = data;
+}
+
+
+void tls_connection_set_success_data_resumed(struct tls_connection *conn)
+{
+}
+
+
+const struct wpabuf *
+tls_connection_get_success_data(struct tls_connection *conn)
+{
+	return conn->success_data;
+}
+
+
+void tls_connection_remove_session(struct tls_connection *conn)
+{
+}
+
+
+#ifdef TLS_MBEDTLS_EAP_TEAP
+int tls_get_tls_unique(struct tls_connection *conn, u8 *buf, size_t max_len)
+{
+  #if defined(MBEDTLS_SSL_RENEGOTIATION) /* XXX: renegotiation or resumption? */
+	/* data from TLS handshake Finished message */
+	size_t verify_len = conn->ssl.MBEDTLS_PRIVATE(verify_data_len);
+	char *verify_data = (conn->is_server ^ conn->resumed)
+	  ? conn->ssl.MBEDTLS_PRIVATE(peer_verify_data)
+	  : conn->ssl.MBEDTLS_PRIVATE(own_verify_data);
+	if (verify_len && verify_len <= max_len) {
+		os_memcpy(buf, verify_data, verify_len);
+		return (int)verify_len;
+	}
+  #endif
+	return -1;
+}
+#endif
+
+
+__attribute_noinline__
+static void tls_mbedtls_set_peer_subject(struct tls_connection *conn, const mbedtls_x509_crt *crt)
+{
+	if (conn->peer_subject)
+		return;
+	char buf[MBEDTLS_X509_MAX_DN_NAME_SIZE*2];
+	int buflen = mbedtls_x509_dn_gets(buf, sizeof(buf), &crt->subject);
+	if (buflen >= 0 && (conn->peer_subject = os_malloc((size_t)buflen+1)))
+		os_memcpy(conn->peer_subject, buf, (size_t)buflen+1);
+}
+
+
+#ifdef TLS_MBEDTLS_EAP_TEAP
+const char * tls_connection_get_peer_subject(struct tls_connection *conn)
+{
+	if (!conn)
+		return NULL;
+	if (!conn->peer_subject) { /*(if not set during cert verify)*/
+		const mbedtls_x509_crt *peer_cert =
+		  mbedtls_ssl_get_peer_cert(&conn->ssl);
+		if (peer_cert)
+			tls_mbedtls_set_peer_subject(conn, peer_cert);
+	}
+	return conn->peer_subject;
+}
+#endif
+
+
+#ifdef TLS_MBEDTLS_EAP_TEAP
+bool tls_connection_get_own_cert_used(struct tls_connection *conn)
+{
+	/* XXX: availability of cert does not necessary mean that client
+	 * received certificate request from server and then sent cert.
+	 * ? step handshake in tls_connection_handshake() looking for
+	 *   MBEDTLS_SSL_CERTIFICATE_REQUEST ? */
+	const struct tls_conf * const tls_conf = conn->tls_conf;
+	return (tls_conf->has_client_cert && tls_conf->has_private_key);
+}
+#endif
+
+
+#if defined(CONFIG_FIPS)
+#define TLS_MBEDTLS_CONFIG_FIPS
+#endif
+
+#if defined(CONFIG_SHA256)
+#define TLS_MBEDTLS_TLS_PRF_SHA256
+#endif
+
+#if defined(CONFIG_SHA384)
+#define TLS_MBEDTLS_TLS_PRF_SHA384
+#endif
+
+
+#ifndef TLS_MBEDTLS_CONFIG_FIPS
+#if defined(CONFIG_MODULE_TESTS)
+/* unused with CONFIG_TLS=mbedtls except in crypto_module_tests.c */
+#if MBEDTLS_VERSION_NUMBER >= 0x02120000 /* mbedtls 2.18.0 */ \
+ && MBEDTLS_VERSION_NUMBER <  0x03000000 /* mbedtls 3.0.0 */
+/* sha1-tlsprf.c */
+#include "sha1.h"
+int tls_prf_sha1_md5(const u8 *secret, size_t secret_len, const char *label,
+		     const u8 *seed, size_t seed_len, u8 *out, size_t outlen)
+{
+	return mbedtls_ssl_tls_prf(MBEDTLS_SSL_TLS_PRF_TLS1,
+				   secret, secret_len, label,
+				   seed, seed_len, out, outlen) ? -1 : 0;
+}
+#else
+#include "sha1-tlsprf.c" /* pull in hostap local implementation */
+#endif
+#endif
+#endif
+
+#ifdef TLS_MBEDTLS_TLS_PRF_SHA256
+/* sha256-tlsprf.c */
+#if MBEDTLS_VERSION_NUMBER >= 0x02120000 /* mbedtls 2.18.0 */
+#include "sha256.h"
+int tls_prf_sha256(const u8 *secret, size_t secret_len, const char *label,
+		   const u8 *seed, size_t seed_len, u8 *out, size_t outlen)
+{
+	return mbedtls_ssl_tls_prf(MBEDTLS_SSL_TLS_PRF_SHA256,
+				   secret, secret_len, label,
+				   seed, seed_len, out, outlen) ? -1 : 0;
+}
+#else
+#include "sha256-tlsprf.c" /* pull in hostap local implementation */
+#endif
+#endif
+
+#ifdef TLS_MBEDTLS_TLS_PRF_SHA384
+/* sha384-tlsprf.c */
+#if MBEDTLS_VERSION_NUMBER >= 0x02120000 /* mbedtls 2.18.0 */
+#include "sha384.h"
+int tls_prf_sha384(const u8 *secret, size_t secret_len, const char *label,
+		   const u8 *seed, size_t seed_len, u8 *out, size_t outlen)
+{
+	return mbedtls_ssl_tls_prf(MBEDTLS_SSL_TLS_PRF_SHA384,
+				   secret, secret_len, label,
+				   seed, seed_len, out, outlen) ? -1 : 0;
+}
+#else
+#include "sha384-tlsprf.c" /* pull in hostap local implementation */
+#endif
+#endif
+
+
+#if MBEDTLS_VERSION_NUMBER < 0x03020000 /* mbedtls 3.2.0 */
+#define mbedtls_x509_crt_has_ext_type(crt, ext_type) \
+        ((crt)->MBEDTLS_PRIVATE(ext_types) & (ext_type))
+#endif
+
+struct mlist { const char *p; size_t n; };
+
+
+static int
+tls_mbedtls_match_altsubject(mbedtls_x509_crt *crt, const char *match)
+{
+	/* RFE: this could be pre-parsed into structured data at config time */
+	struct mlist list[256]; /*(much larger than expected)*/
+	int nlist = 0;
+	if (   os_strncmp(match, "EMAIL:", 6) != 0
+	    && os_strncmp(match, "DNS:",   4) != 0
+	    && os_strncmp(match, "URI:",   4) != 0   ) {
+		wpa_printf(MSG_INFO, "MTLS: Invalid altSubjectName match '%s'", match);
+		return 0;
+	}
+	for (const char *s = match, *tok; *s; s = tok ? tok+1 : "") {
+		do { } while ((tok = os_strchr(s, ';'))
+		              && os_strncmp(tok+1, "EMAIL:", 6) != 0
+		              && os_strncmp(tok+1, "DNS:",   4) != 0
+		              && os_strncmp(tok+1, "URI:",   4) != 0);
+		list[nlist].p = s;
+		list[nlist].n = tok ? (size_t)(tok - s) : os_strlen(s);
+		if (list[nlist].n && ++nlist == sizeof(list)/sizeof(*list)) {
+			wpa_printf(MSG_INFO, "MTLS: excessive altSubjectName match '%s'",
+			           match);
+			break; /* truncate huge list and continue */
+		}
+	}
+
+	if (!mbedtls_x509_crt_has_ext_type(crt, MBEDTLS_X509_EXT_SUBJECT_ALT_NAME))
+		return 0;
+
+	const mbedtls_x509_sequence *cur = &crt->subject_alt_names;
+	for (; cur != NULL; cur = cur->next) {
+		const unsigned char san_type = (unsigned char)cur->buf.tag
+		                             & MBEDTLS_ASN1_TAG_VALUE_MASK;
+		char t;
+		size_t step = 4;
+		switch (san_type) {             /* "EMAIL:" or "DNS:" or "URI:" */
+		case MBEDTLS_X509_SAN_RFC822_NAME:       step = 6; t = 'E'; break;
+		case MBEDTLS_X509_SAN_DNS_NAME:                    t = 'D'; break;
+		case MBEDTLS_X509_SAN_UNIFORM_RESOURCE_IDENTIFIER: t = 'U'; break;
+		default: continue;
+		}
+
+		for (int i = 0; i < nlist; ++i) {
+			/* step over "EMAIL:" or "DNS:" or "URI:" in list[i].p */
+			/* Note: v is not '\0'-terminated, but is a known length vlen,
+			 * so okay to pass to os_strncasecmp() even though not z-string */
+			if (cur->buf.len == list[i].n - step && t == *list[i].p
+			    && 0 == os_strncasecmp((char *)cur->buf.p,
+			                           list[i].p+step, cur->buf.len)) {
+				return 1; /* match */
+			}
+		}
+	}
+	return 0; /* no match */
+}
+
+
+static int
+tls_mbedtls_match_suffix(const char *v, size_t vlen,
+                         const struct mlist *list, int nlist, int full)
+{
+	/* Note: v is not '\0'-terminated, but is a known length vlen,
+	 * so okay to pass to os_strncasecmp() even though not z-string */
+	for (int i = 0; i < nlist; ++i) {
+		size_t n = list[i].n;
+		if ((n == vlen || (n < vlen && v[vlen-n-1] == '.' && !full))
+		    && 0 == os_strncasecmp(v+vlen-n, list[i].p, n))
+			return 1; /* match */
+	}
+	return 0; /* no match */
+}
+
+
+static int
+tls_mbedtls_match_suffixes(mbedtls_x509_crt *crt, const char *match, int full)
+{
+	/* RFE: this could be pre-parsed into structured data at config time */
+	struct mlist list[256]; /*(much larger than expected)*/
+	int nlist = 0;
+	for (const char *s = match, *tok; *s; s = tok ? tok+1 : "") {
+		tok = os_strchr(s, ';');
+		list[nlist].p = s;
+		list[nlist].n = tok ? (size_t)(tok - s) : os_strlen(s);
+		if (list[nlist].n && ++nlist == sizeof(list)/sizeof(*list)) {
+			wpa_printf(MSG_INFO, "MTLS: excessive suffix match '%s'", match);
+			break; /* truncate huge list and continue */
+		}
+	}
+
+	/* check subjectAltNames */
+	if (mbedtls_x509_crt_has_ext_type(crt, MBEDTLS_X509_EXT_SUBJECT_ALT_NAME)) {
+		const mbedtls_x509_sequence *cur = &crt->subject_alt_names;
+		for (; cur != NULL; cur = cur->next) {
+			const unsigned char san_type = (unsigned char)cur->buf.tag
+			                             & MBEDTLS_ASN1_TAG_VALUE_MASK;
+			if (san_type == MBEDTLS_X509_SAN_DNS_NAME
+			    && tls_mbedtls_match_suffix((char *)cur->buf.p,
+			                                cur->buf.len,
+			                                list, nlist, full)) {
+				return 1; /* match */
+			}
+		}
+	}
+
+	/* check subject CN */
+	const mbedtls_x509_name *name = &crt->subject;
+	for (; name != NULL; name = name->next) {
+		if (name->oid.p && MBEDTLS_OID_CMP(MBEDTLS_OID_AT_CN, &name->oid) == 0)
+			break;
+	}
+	if (name && tls_mbedtls_match_suffix((char *)name->val.p, name->val.len,
+	                                     list, nlist, full)) {
+		return 1; /* match */
+	}
+
+	return 0; /* no match */
+}
+
+
+static int
+tls_mbedtls_match_dn_field(mbedtls_x509_crt *crt, const char *match)
+{
+	/* RFE: this could be pre-parsed into structured data at config time */
+	struct mlistoid { const char *p; size_t n;
+	                  const char *oid; size_t olen;
+	                  int prefix; };
+	struct mlistoid list[32]; /*(much larger than expected)*/
+	int nlist = 0;
+	for (const char *s = match, *tok, *e; *s; s = tok ? tok+1 : "") {
+		tok = os_strchr(s, '/');
+		list[nlist].oid = NULL;
+		list[nlist].olen = 0;
+		list[nlist].n = tok ? (size_t)(tok - s) : os_strlen(s);
+		e = memchr(s, '=', list[nlist].n);
+		if (e == NULL) {
+			if (list[nlist].n == 0)
+				continue; /* skip consecutive, repeated '/' */
+			if (list[nlist].n == 1 && *s == '*') {
+				/* special-case "*" to match any OID and value */
+				s = e = "=*";
+				list[nlist].n = 2;
+				list[nlist].oid = "";
+			}
+			else {
+				wpa_printf(MSG_INFO,
+				           "MTLS: invalid check_cert_subject '%s' missing '='",
+				           match);
+				return 0;
+			}
+		}
+		switch (e - s) {
+		case 1:
+			if (*s == 'C') {
+				list[nlist].oid  = MBEDTLS_OID_AT_COUNTRY;
+				list[nlist].olen = sizeof(MBEDTLS_OID_AT_COUNTRY)-1;
+			}
+			else if (*s == 'L') {
+				list[nlist].oid  = MBEDTLS_OID_AT_LOCALITY;
+				list[nlist].olen = sizeof(MBEDTLS_OID_AT_LOCALITY)-1;
+			}
+			else if (*s == 'O') {
+				list[nlist].oid  = MBEDTLS_OID_AT_ORGANIZATION;
+				list[nlist].olen = sizeof(MBEDTLS_OID_AT_ORGANIZATION)-1;
+			}
+			break;
+		case 2:
+			if (s[0] == 'C' && s[1] == 'N') {
+				list[nlist].oid  = MBEDTLS_OID_AT_CN;
+				list[nlist].olen = sizeof(MBEDTLS_OID_AT_CN)-1;
+			}
+			else if (s[0] == 'S' && s[1] == 'T') {
+				list[nlist].oid  = MBEDTLS_OID_AT_STATE;
+				list[nlist].olen = sizeof(MBEDTLS_OID_AT_STATE)-1;
+			}
+			else if (s[0] == 'O' && s[1] == 'U') {
+				list[nlist].oid  = MBEDTLS_OID_AT_ORG_UNIT;
+				list[nlist].olen = sizeof(MBEDTLS_OID_AT_ORG_UNIT)-1;
+			}
+			break;
+		case 12:
+			if (os_memcmp(s, "emailAddress", 12) == 0) {
+				list[nlist].oid  = MBEDTLS_OID_PKCS9_EMAIL;
+				list[nlist].olen = sizeof(MBEDTLS_OID_PKCS9_EMAIL)-1;
+			}
+			break;
+		default:
+			break;
+		}
+		if (list[nlist].oid == NULL) {
+			wpa_printf(MSG_INFO,
+			           "MTLS: Unknown field in check_cert_subject '%s'",
+			           match);
+			return 0;
+		}
+		list[nlist].n -= (size_t)(++e - s);
+		list[nlist].p = e;
+		if (list[nlist].n && e[list[nlist].n-1] == '*') {
+			--list[nlist].n;
+			list[nlist].prefix = 1;
+		}
+		/*(could easily add support for suffix matches if value begins with '*',
+		 * but suffix match is not currently supported by other TLS modules)*/
+
+		if (list[nlist].n && ++nlist == sizeof(list)/sizeof(*list)) {
+			wpa_printf(MSG_INFO,
+			           "MTLS: excessive check_cert_subject match '%s'",
+			           match);
+			break; /* truncate huge list and continue */
+		}
+	}
+
+	/* each component in match string must match cert Subject in order listed
+	 * The behavior below preserves ordering but is slightly different than
+	 * the grossly inefficient contortions implemented in tls_openssl.c */
+	const mbedtls_x509_name *name = &crt->subject;
+	for (int i = 0; i < nlist; ++i) {
+		int found = 0;
+		for (; name != NULL && !found; name = name->next) {
+			if (!name->oid.p)
+				continue;
+			/* special-case "*" to match any OID and value */
+			if (list[i].olen == 0) {
+				found = 1;
+				continue;
+			}
+			/* perform equalent of !MBEDTLS_OID_CMP() with oid ptr and len */
+			if (list[i].olen != name->oid.len
+			    || os_memcmp(list[i].oid, name->oid.p, name->oid.len) != 0)
+				continue;
+			/* Note: v is not '\0'-terminated, but is a known length vlen,
+			 * so okay to pass to os_strncasecmp() even though not z-string */
+			if ((list[i].prefix
+			      ? list[i].n <= name->val.len  /* prefix match */
+			      : list[i].n == name->val.len) /* full match */
+			    && 0 == os_strncasecmp((char *)name->val.p,
+			                           list[i].p, list[i].n)) {
+				found = 1;
+				continue;
+			}
+		}
+		if (!found)
+			return 0; /* no match */
+	}
+	return 1; /* match */
+}
+
+
+__attribute_cold__
+static void
+tls_mbedtls_verify_fail_event (mbedtls_x509_crt *crt, int depth,
+                               const char *errmsg, enum tls_fail_reason reason)
+{
+	struct tls_config *init_conf = &tls_ctx_global.init_conf;
+	if (init_conf->event_cb == NULL)
+		return;
+
+	struct wpabuf *certbuf = wpabuf_alloc_copy(crt->raw.p, crt->raw.len);
+	char subject[MBEDTLS_X509_MAX_DN_NAME_SIZE*2];
+	if (mbedtls_x509_dn_gets(subject, sizeof(subject), &crt->subject) < 0)
+		subject[0] = '\0';
+	union tls_event_data ev;
+	os_memset(&ev, 0, sizeof(ev));
+	ev.cert_fail.reason = reason;
+	ev.cert_fail.depth = depth;
+	ev.cert_fail.subject = subject;
+	ev.cert_fail.reason_txt = errmsg;
+	ev.cert_fail.cert = certbuf;
+
+	init_conf->event_cb(init_conf->cb_ctx, TLS_CERT_CHAIN_FAILURE, &ev);
+
+	wpabuf_free(certbuf);
+}
+
+
+__attribute_noinline__
+static void
+tls_mbedtls_verify_cert_event (struct tls_connection *conn,
+                               mbedtls_x509_crt *crt, int depth)
+{
+	struct tls_config *init_conf = &tls_ctx_global.init_conf;
+	if (init_conf->event_cb == NULL)
+		return;
+
+	struct wpabuf *certbuf = NULL;
+	union tls_event_data ev;
+	os_memset(&ev, 0, sizeof(ev));
+
+  #ifdef MBEDTLS_SHA256_C
+	u8 hash[SHA256_DIGEST_LENGTH];
+	const u8 *addr[] = { (u8 *)crt->raw.p };
+	if (sha256_vector(1, addr, &crt->raw.len, hash) == 0) {
+		ev.peer_cert.hash = hash;
+		ev.peer_cert.hash_len = sizeof(hash);
+	}
+  #endif
+	ev.peer_cert.depth = depth;
+	char subject[MBEDTLS_X509_MAX_DN_NAME_SIZE*2];
+	if (depth == 0)
+		ev.peer_cert.subject = conn->peer_subject;
+	if (ev.peer_cert.subject == NULL) {
+		ev.peer_cert.subject = subject;
+		if (mbedtls_x509_dn_gets(subject, sizeof(subject), &crt->subject) < 0)
+			subject[0] = '\0';
+	}
+
+	char serial_num[128+1];
+	ev.peer_cert.serial_num =
+	  tls_mbedtls_peer_serial_num(crt, serial_num, sizeof(serial_num));
+
+	const mbedtls_x509_sequence *cur;
+
+	cur = NULL;
+	if (mbedtls_x509_crt_has_ext_type(crt, MBEDTLS_X509_EXT_SUBJECT_ALT_NAME))
+		cur = &crt->subject_alt_names;
+	for (; cur != NULL; cur = cur->next) {
+		const unsigned char san_type = (unsigned char)cur->buf.tag
+		                             & MBEDTLS_ASN1_TAG_VALUE_MASK;
+		size_t prelen = 4;
+		const char *pre;
+		switch (san_type) {
+		case MBEDTLS_X509_SAN_RFC822_NAME:     prelen = 6; pre = "EMAIL:";break;
+		case MBEDTLS_X509_SAN_DNS_NAME:                    pre = "DNS:";  break;
+		case MBEDTLS_X509_SAN_UNIFORM_RESOURCE_IDENTIFIER: pre = "URI:";  break;
+		default: continue;
+		}
+
+		char *pos = os_malloc(prelen + cur->buf.len + 1);
+		if (pos == NULL)
+			break;
+		ev.peer_cert.altsubject[ev.peer_cert.num_altsubject] = pos;
+		os_memcpy(pos, pre, prelen);
+		/* data should be properly backslash-escaped if needed,
+		 * so code below does not re-escape, but does replace CTLs */
+		/*os_memcpy(pos+prelen, cur->buf.p, cur->buf.len);*/
+		/*pos[prelen+cur->buf.len] = '\0';*/
+		pos += prelen;
+		for (size_t i = 0; i < cur->buf.len; ++i) {
+			unsigned char c = cur->buf.p[i];
+			*pos++ = (c >= 32 && c != 127) ? c : '?';
+		}
+		*pos = '\0';
+
+		if (++ev.peer_cert.num_altsubject == TLS_MAX_ALT_SUBJECT)
+			break;
+	}
+
+	cur = NULL;
+	if (mbedtls_x509_crt_has_ext_type(crt, MBEDTLS_X509_EXT_CERTIFICATE_POLICIES))
+		cur = &crt->certificate_policies;
+	for (; cur != NULL; cur = cur->next) {
+		if (cur->buf.len != 11) /* len of OID_TOD_STRICT or OID_TOD_TOFU */
+			continue;
+		/* TOD-STRICT "1.3.6.1.4.1.40808.1.3.1" */
+		/* TOD-TOFU   "1.3.6.1.4.1.40808.1.3.2" */
+		#define OID_TOD_STRICT "\x2b\x06\x01\x04\x01\x82\xbe\x68\x01\x03\x01"
+		#define OID_TOD_TOFU   "\x2b\x06\x01\x04\x01\x82\xbe\x68\x01\x03\x02"
+		if (os_memcmp(cur->buf.p,
+		              OID_TOD_STRICT, sizeof(OID_TOD_STRICT)-1) == 0) {
+			ev.peer_cert.tod = 1; /* TOD-STRICT */
+			break;
+		}
+		if (os_memcmp(cur->buf.p,
+		              OID_TOD_TOFU, sizeof(OID_TOD_TOFU)-1) == 0) {
+			ev.peer_cert.tod = 2; /* TOD-TOFU */
+			break;
+		}
+	}
+
+	struct tls_conf *tls_conf = conn->tls_conf;
+	if (tls_conf->ca_cert_probe || (tls_conf->flags & TLS_CONN_EXT_CERT_CHECK)
+	    || init_conf->cert_in_cb) {
+		certbuf = wpabuf_alloc_copy(crt->raw.p, crt->raw.len);
+		ev.peer_cert.cert = certbuf;
+	}
+
+	init_conf->event_cb(init_conf->cb_ctx, TLS_PEER_CERTIFICATE, &ev);
+
+	wpabuf_free(certbuf);
+	char **altsubject;
+	*(const char ***)&altsubject = ev.peer_cert.altsubject;
+	for (size_t i = 0; i < ev.peer_cert.num_altsubject; ++i)
+		os_free(altsubject[i]);
+}
+
+
+static int
+tls_mbedtls_verify_cb (void *arg, mbedtls_x509_crt *crt, int depth, uint32_t *flags)
+{
+	/* XXX: N.B. verify code not carefully tested besides hwsim tests
+	 *
+	 * RFE: mbedtls_x509_crt_verify_info() and enhance log trace messages
+	 * RFE: review and add support for additional TLS_CONN_* flags
+	 * not handling OCSP (not available in mbedtls)
+	 * ... */
+
+	struct tls_connection *conn = (struct tls_connection *)arg;
+	struct tls_conf *tls_conf = conn->tls_conf;
+	uint32_t flags_in = *flags;
+
+	if (depth > 8) { /*(depth 8 picked as arbitrary limit)*/
+		emsg(MSG_WARNING, "client cert chain too long");
+		*flags |= MBEDTLS_X509_BADCERT_OTHER; /* cert chain too long */
+		tls_mbedtls_verify_fail_event(crt, depth,
+			                      "client cert chain too long",
+		                              TLS_FAIL_BAD_CERTIFICATE);
+	}
+	else if (tls_conf->verify_depth0_only) {
+		if (depth > 0)
+			*flags = 0;
+		else {
+		  #ifdef MBEDTLS_SHA256_C
+			u8 hash[SHA256_DIGEST_LENGTH];
+			const u8 *addr[] = { (u8 *)crt->raw.p };
+			if (sha256_vector(1, addr, &crt->raw.len, hash) < 0
+			    || os_memcmp(tls_conf->ca_cert_hash, hash, sizeof(hash)) != 0) {
+				*flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
+				tls_mbedtls_verify_fail_event(crt, depth,
+			                                      "cert hash mismatch",
+				                              TLS_FAIL_UNTRUSTED);
+			}
+			else /* hash matches; ignore other issues *except* if revoked)*/
+				*flags &= MBEDTLS_X509_BADCERT_REVOKED;
+		  #endif
+		}
+	}
+	else if (depth == 0) {
+		if (!conn->peer_subject)
+			tls_mbedtls_set_peer_subject(conn, crt);
+		/*(use same labels to tls_mbedtls_verify_fail_event() as used in
+		 * other TLS modules so that hwsim tests find exact string match)*/
+		if (!conn->peer_subject) { /* error copying subject string */
+			*flags |= MBEDTLS_X509_BADCERT_OTHER;
+			tls_mbedtls_verify_fail_event(crt, depth,
+			                              "internal error",
+			                              TLS_FAIL_UNSPECIFIED);
+		}
+		/*(use os_strstr() for subject match as is done in tls_mbedtls.c
+		 * to follow the same behavior, even though a suffix match would
+		 * make more sense.  Also, note that strstr match does not
+		 * normalize whitespace (between components) for comparison)*/
+		else if (tls_conf->subject_match
+		         && os_strstr(conn->peer_subject,
+		                      tls_conf->subject_match) == NULL) {
+			wpa_printf(MSG_WARNING,
+			           "MTLS: Subject '%s' did not match with '%s'",
+			           conn->peer_subject, tls_conf->subject_match);
+			*flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
+			tls_mbedtls_verify_fail_event(crt, depth,
+			                              "Subject mismatch",
+			                              TLS_FAIL_SUBJECT_MISMATCH);
+		}
+		if (tls_conf->altsubject_match
+		    && !tls_mbedtls_match_altsubject(crt, tls_conf->altsubject_match)) {
+			wpa_printf(MSG_WARNING,
+				   "MTLS: altSubjectName match '%s' not found",
+			           tls_conf->altsubject_match);
+			*flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
+			tls_mbedtls_verify_fail_event(crt, depth,
+			                              "AltSubject mismatch",
+			                              TLS_FAIL_ALTSUBJECT_MISMATCH);
+		}
+		if (tls_conf->suffix_match
+		    && !tls_mbedtls_match_suffixes(crt, tls_conf->suffix_match, 0)) {
+			wpa_printf(MSG_WARNING,
+			           "MTLS: Domain suffix match '%s' not found",
+				   tls_conf->suffix_match);
+			*flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
+			tls_mbedtls_verify_fail_event(crt, depth,
+			                              "Domain suffix mismatch",
+			                              TLS_FAIL_DOMAIN_SUFFIX_MISMATCH);
+		}
+		if (tls_conf->domain_match
+		    && !tls_mbedtls_match_suffixes(crt, tls_conf->domain_match, 1)) {
+			wpa_printf(MSG_WARNING,
+			           "MTLS: Domain match '%s' not found",
+				   tls_conf->domain_match);
+			*flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
+			tls_mbedtls_verify_fail_event(crt, depth,
+			                              "Domain mismatch",
+			                              TLS_FAIL_DOMAIN_MISMATCH);
+		}
+		if (tls_conf->check_cert_subject
+		    && !tls_mbedtls_match_dn_field(crt, tls_conf->check_cert_subject)) {
+			*flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
+			tls_mbedtls_verify_fail_event(crt, depth,
+			                              "Distinguished Name",
+			                              TLS_FAIL_DN_MISMATCH);
+		}
+		if (tls_conf->flags & TLS_CONN_SUITEB) {
+			/* check RSA modulus size (public key bitlen) */
+			const mbedtls_pk_type_t pk_alg = mbedtls_pk_get_type(&crt->pk);
+			if ((pk_alg == MBEDTLS_PK_RSA || pk_alg == MBEDTLS_PK_RSASSA_PSS)
+			    && mbedtls_pk_get_bitlen(&crt->pk) < 3072) {
+				/* hwsim suite_b RSA tests expect 3072
+				 *   suite_b_192_rsa_ecdhe_radius_rsa2048_client
+				 *   suite_b_192_rsa_dhe_radius_rsa2048_client */
+				*flags |= MBEDTLS_X509_BADCERT_BAD_KEY;
+				tls_mbedtls_verify_fail_event(crt, depth,
+				                              "Insufficient RSA modulus size",
+				                              TLS_FAIL_INSUFFICIENT_KEY_LEN);
+			}
+		}
+		if (tls_conf->check_crl && tls_conf->crl == NULL) {
+			/* see tests/hwsim test_ap_eap.py ap_wpa2_eap_tls_check_crl */
+			emsg(MSG_WARNING, "check_crl set but no CRL loaded; reject all?");
+			*flags |= MBEDTLS_X509_BADCERT_OTHER;
+			tls_mbedtls_verify_fail_event(crt, depth,
+				                      "check_crl set but no CRL loaded; "
+			                              "reject all?",
+			                              TLS_FAIL_BAD_CERTIFICATE);
+		}
+	}
+	else {
+		if (tls_conf->check_crl != 2) /* 2 == verify CRLs for all certs */
+			*flags &= ~MBEDTLS_X509_BADCERT_REVOKED;
+	}
+
+	if (!tls_conf->check_crl_strict) {
+		*flags &= ~MBEDTLS_X509_BADCRL_EXPIRED;
+		*flags &= ~MBEDTLS_X509_BADCRL_FUTURE;
+	}
+
+	if (tls_conf->flags & TLS_CONN_DISABLE_TIME_CHECKS) {
+		*flags &= ~MBEDTLS_X509_BADCERT_EXPIRED;
+		*flags &= ~MBEDTLS_X509_BADCERT_FUTURE;
+	}
+
+	tls_mbedtls_verify_cert_event(conn, crt, depth);
+
+	if (*flags) {
+		if (*flags & (MBEDTLS_X509_BADCERT_NOT_TRUSTED
+		             |MBEDTLS_X509_BADCERT_CN_MISMATCH
+		             |MBEDTLS_X509_BADCERT_REVOKED)) {
+			emsg(MSG_WARNING, "client cert not trusted");
+		}
+		/* report event if flags set but no additional flags set above */
+		/* (could translate flags to more detailed TLS_FAIL_* if needed) */
+		if (!(*flags & ~flags_in)) {
+			enum tls_fail_reason reason = TLS_FAIL_UNSPECIFIED;
+			const char *errmsg = "cert verify fail unspecified";
+			if (*flags & MBEDTLS_X509_BADCERT_NOT_TRUSTED) {
+				reason = TLS_FAIL_UNTRUSTED;
+				errmsg = "certificate not trusted";
+			}
+			if (*flags & MBEDTLS_X509_BADCERT_REVOKED) {
+				reason = TLS_FAIL_REVOKED;
+				errmsg = "certificate has been revoked";
+			}
+			if (*flags & MBEDTLS_X509_BADCERT_FUTURE) {
+				reason = TLS_FAIL_NOT_YET_VALID;
+				errmsg = "certificate not yet valid";
+			}
+			if (*flags & MBEDTLS_X509_BADCERT_EXPIRED) {
+				reason = TLS_FAIL_EXPIRED;
+				errmsg = "certificate has expired";
+			}
+			if (*flags & MBEDTLS_X509_BADCERT_BAD_MD) {
+				reason = TLS_FAIL_BAD_CERTIFICATE;
+				errmsg = "certificate uses insecure algorithm";
+			}
+			tls_mbedtls_verify_fail_event(crt, depth, errmsg, reason);
+		}
+	  #if 0
+		/* ??? send (again) cert events for all certs in chain ???
+		 * (should already have been called for greater depths) */
+		/* tls_openssl.c:tls_verify_cb() sends cert events for all certs
+		 * in chain if certificate validation fails, but sends all events
+		 * with depth set to 0 (might be a bug) */
+		if (depth > 0) {
+			int pdepth = depth + 1;
+			for (mbedtls_x509_crt *pcrt; (pcrt = crt->next); ++pdepth) {
+				tls_mbedtls_verify_cert_event(conn, pcrt, pdepth);
+			}
+		}
+	  #endif
+		/*(do not preserve subject if verification failed but was optional)*/
+		if (depth == 0 && conn->peer_subject) {
+			os_free(conn->peer_subject);
+			conn->peer_subject = NULL;
+		}
+	}
+	else if (depth == 0) {
+		struct tls_config *init_conf = &tls_ctx_global.init_conf;
+		if (tls_conf->ca_cert_probe) {
+			/* reject server certificate on probe-only run */
+			*flags |= MBEDTLS_X509_BADCERT_OTHER;
+			tls_mbedtls_verify_fail_event(crt, depth,
+			                              "server chain probe",
+			                              TLS_FAIL_SERVER_CHAIN_PROBE);
+		}
+		else if (init_conf->event_cb) {
+			/* ??? send event as soon as depth == 0 is verified ???
+			 * What about rest of chain?
+			 * Follows tls_mbedtls.c behavior: */
+			init_conf->event_cb(init_conf->cb_ctx,
+			                    TLS_CERT_CHAIN_SUCCESS, NULL);
+		}
+	}
+
+	return 0;
+}
diff --git a/src/drivers/driver.h b/src/drivers/driver.h
index 3f650c5..91134a7 100644
--- a/src/drivers/driver.h
+++ b/src/drivers/driver.h
@@ -74,6 +74,25 @@ enum hostapd_chan_width_attr {
 #define HOSTAPD_DFS_REGION_ETSI	2
 #define HOSTAPD_DFS_REGION_JP	3
 
+/**
+ * struct hostapd_scs_desc_info - SCS Req information
+ * @id: SCSID of each SCS stream
+ * @req_type: request type in SCS Descriptor element
+ * @dir: Direction in the control info of QoS Characteristics element
+ * @peer_addr: the mac addr of SCS requester station
+ * @qos_ie: QoS Characteristics IE in SCS Descriptor element
+ * @qos_ie_len: the length of QoS Characteristics element
+ */
+#define EID_EXT_QOS_CHAR_MAX_SIZE 44
+struct hostapd_scs_desc_info {
+	u8 id;
+	u8 req_type;
+	u8 dir;
+	u8 peer_addr[ETH_ALEN];
+	u8 qos_ie[EID_EXT_QOS_CHAR_MAX_SIZE];
+	u8 qos_ie_len;
+};
+
 /**
  * enum reg_change_initiator - Regulatory change initiator
  */
@@ -180,6 +199,16 @@ struct hostapd_channel_data {
 	 * punct_bitmap - RU puncturing bitmap
 	 */
 	u16 punct_bitmap;
+
+	/**
+	 * mu onoff=<val> (bitmap- UL MU-MIMO(bit3), DL MU-MIMO(bit2), UL OFDMA(bit1), DL OFDMA(bit0))
+	 */
+	u8 mu_onoff;
+
+	/**
+	 * ibf_enable=<val>
+	 */
+	u8 ibf_enable;
 };
 
 #define HE_MAC_CAPAB_0		0
@@ -891,10 +920,23 @@ struct hostapd_freq_params {
 	 */
 	bool eht_enabled;
 
+	/**
+	 * punct_bitmap - puncturing bitmap
+	 * Each bit corresponds to a 20 MHz subchannel, lowest bit for the
+	 * channel with the lowest frequency. Bit set to 1 indicates that the
+	 * subchannel is punctured, otherwise active.
+	 */
+	u16 punct_bitmap;
+
 	/**
 	 * link_id: If >=0 indicates the link of the AP MLD to configure
 	 */
 	int link_id;
+
+	/**
+	 * op_class: Operating class of the channel
+	 */
+	u8 op_class;
 };
 
 /**
@@ -1004,6 +1046,9 @@ struct wpa_driver_associate_params {
 	 * responsible for selecting with which BSS to associate. */
 	const u8 *bssid;
 
+	unsigned char rates[WLAN_SUPP_RATES_MAX];
+	int mcast_rate;
+
 	/**
 	 * bssid_hint - BSSID of a proposed AP
 	 *
@@ -1917,6 +1962,7 @@ struct wpa_driver_mesh_join_params {
 #define WPA_DRIVER_MESH_FLAG_AMPE	0x00000008
 	unsigned int flags;
 	bool handle_dfs;
+	int mcast_rate;
 };
 
 struct wpa_driver_set_key_params {
@@ -2390,6 +2436,9 @@ struct wpa_driver_capa {
 	/** Maximum number of iterations in a single scan plan */
 	u32 max_sched_scan_plan_iterations;
 
+	/** Maximum number of extra IE bytes for scans */
+	u16 max_scan_ie_len;
+
 	/** Whether sched_scan (offloaded scanning) is supported */
 	int sched_scan_supported;
 
@@ -2591,6 +2640,7 @@ struct hostapd_sta_add_params {
 	bool mld_link_sta;
 	s8 mld_link_id;
 	const u8 *mld_link_addr;
+	u16 eml_capa;
 };
 
 struct mac_address {
@@ -2722,6 +2772,7 @@ struct wpa_channel_info {
 	int sec_channel;
 	int center_frq1;
 	int center_frq2;
+	u16 punct_bitmap;
 	u8 seg1_idx;
 };
 
@@ -2765,7 +2816,6 @@ struct beacon_data {
  * @beacon_after: Next beacon/probe resp/asooc resp info
  * @counter_offset_beacon: Offset to the count field in beacon's tail
  * @counter_offset_presp: Offset to the count field in probe resp.
- * @punct_bitmap - Preamble puncturing bitmap
  * @link_id: Link ID to determine the link for MLD; -1 for non-MLD
  * @ubpr: Unsolicited broadcast Probe Response frame data
  */
@@ -2779,8 +2829,8 @@ struct csa_settings {
 
 	u16 counter_offset_beacon[2];
 	u16 counter_offset_presp[2];
+	u16 counter_offset_sta_prof[MAX_NUM_MLD_LINKS][2];
 
-	u16 punct_bitmap;
 	int link_id;
 
 	struct unsol_bcast_probe_resp ubpr;
@@ -2813,6 +2863,29 @@ struct cca_settings {
 	int link_id;
 };
 
+#ifdef CONFIG_IEEE80211BE
+/**
+ * struct attlm_settings - Setting for Advertised Tid-to-Link Mapping
+ * @valid: whether this A-TTLM is still valid
+ * @direction: direction of this A-TTLM
+ * @disabled_links: disabled link ID bitmap
+ * @switch_time: duration in ms to establish the A-TTLM
+ * @switch_time_tsf_tu: time in TUs that the A-TTLM is established. It should be
+ * the bits 10 to 25 of the TSF
+ * @duration_tu: duration in ms that the A-TTLM lasts
+ * @start_time: the relative time that this A-TTLM is entablished
+ */
+struct attlm_settings {
+	bool valid;
+	u8 direction;
+	u16 disabled_links;
+	u16 switch_time;
+	u16 switch_time_tsf_tu;
+	u32 duration;
+	struct os_reltime start_time;
+};
+#endif /* CONFIG_IEEE80211BE */
+
 /* TDLS peer capabilities for send_tdls_mgmt() */
 enum tdls_peer_capability {
 	TDLS_PEER_HT = BIT(0),
@@ -3072,8 +3145,10 @@ struct driver_sta_mlo_info {
 	struct {
 		u8 addr[ETH_ALEN];
 		u8 bssid[ETH_ALEN];
-		unsigned int freq;
+		unsigned int freq, center_freq1, center_freq2;
+		u16 punct_bitmap;
 		struct t2lm_mapping t2lmap;
+		enum chan_width width;
 	} links[MAX_NUM_MLD_LINKS];
 };
 
@@ -3586,6 +3661,8 @@ struct wpa_driver_ops {
 	 */
 	void (*hapd_deinit)(void *priv);
 
+	int (*move_bss_to_first)(void *priv, const char *ifname);
+
 	/**
 	 * set_ieee8021x - Enable/disable IEEE 802.1X support (AP only)
 	 * @priv: Private driver interface data
@@ -3908,7 +3985,7 @@ struct wpa_driver_ops {
 	int (*if_add)(void *priv, enum wpa_driver_if_type type,
 		      const char *ifname, const u8 *addr, void *bss_ctx,
 		      void **drv_priv, char *force_ifname, u8 *if_addr,
-		      const char *bridge, int use_existing, int setup_ap);
+		      const char *bridge, int use_existing, int setup_ap, int freq, u32 radio_mask);
 
 	/**
 	 * if_remove - Remove a virtual interface
@@ -3920,6 +3997,25 @@ struct wpa_driver_ops {
 	int (*if_remove)(void *priv, enum wpa_driver_if_type type,
 			 const char *ifname);
 
+	/**
+	 * if_rename - Rename a virtual interface
+	 * @priv: Private driver interface data
+	 * @type: Interface type
+	 * @ifname: Interface name of the virtual interface to be renamed
+	 *	    (NULL when renaming the AP BSS interface)
+	 * @new_name: New interface name of the virtual interface
+	 * Returns: 0 on success, -1 on failure
+	 */
+	int (*if_rename)(void *priv, enum wpa_driver_if_type type,
+			 const char *ifname, const char *new_name);
+
+	/**
+	 * set_first_bss - Make a virtual interface the first (primary) bss
+	 * @priv: Private driver interface data
+	 * Returns: 0 on success, -1 on failure
+	 */
+	int (*set_first_bss)(void *priv);
+
 	/**
 	 * set_sta_vlan - Bind a station into a specific interface (AP only)
 	 * @priv: Private driver interface data
@@ -4022,7 +4118,7 @@ struct wpa_driver_ops {
 	 * Returns: 0 on success, -1 on failure
 	 */
 	int (*set_wds_sta)(void *priv, const u8 *addr, int aid, int val,
-			   const char *bridge_ifname, char *ifname_wds);
+			   const char *bridge_ifname, const char *ifname_wds);
 
 	/**
 	 * send_action - Transmit an Action frame
@@ -4328,7 +4424,7 @@ struct wpa_driver_ops {
 	 * Returns: 0 on success, negative (<0) on failure
 	 */
 	int (*br_set_net_param)(void *priv, enum drv_br_net_param param,
-				unsigned int val);
+				const char *ifname, unsigned int val);
 
 	/**
 	 * get_wowlan - Get wake-on-wireless status
@@ -4640,6 +4736,7 @@ struct wpa_driver_ops {
 	 * @priv: Private driver interface data
 	 * @freq: If set, survey data for the specified frequency is only
 	 *	being requested. If not set, all survey data is requested.
+	 * @link_id: The link ID that requests the get_survey.
 	 * Returns: 0 on success, -1 on failure
 	 *
 	 * Use this to retrieve:
@@ -4658,7 +4755,7 @@ struct wpa_driver_ops {
 	 * for each survey. The min_nf of the channel is updated for each
 	 * survey.
 	 */
-	int (*get_survey)(void *priv, unsigned int freq);
+	int (*get_survey)(void *priv, unsigned int freq, int link_id);
 
 	/**
 	 * status - Get driver interface status information
@@ -5230,6 +5327,14 @@ struct wpa_driver_ops {
 	int (*link_remove)(void *priv, enum wpa_driver_if_type type,
 			   const char *ifname, u8 link_id);
 
+	/**
+	 * set_attlm - Set AP MLD advertised Tid-to-Link Mapping
+	 * @priv: Private driver interface data
+	 * @attlm: setting of Tid-to-Link Mapping
+	 * Returns: 0 on success, negative value on failure
+	 */
+	int (*set_attlm)(void *priv, struct attlm_settings *attlm);
+
 	/**
 	 * is_drv_shared - Check whether the driver interface is shared
 	 * @priv: Private driver interface data from init()
@@ -5344,6 +5449,172 @@ struct wpa_driver_ops {
 	 */
 	struct hostapd_multi_hw_info *
 	(*get_multi_hw_info)(void *priv, unsigned int *num_multi_hws);
+
+	int (*configure_edcca_enable)(void *priv, const u8 edcca_enable,
+				  const s8 edcca_compensation);
+	int (*configure_edcca_threshold)(void *priv, const int *threshold);
+	int (*get_edcca)(void *priv, const u8 mode, u8 *value);
+
+	/**
+	 * mu_ctrl - ctrl for UL/DL MURU
+	 * @priv: Private driver interface data
+	 *
+	 */
+	 int (*mu_ctrl)(void *priv, u8 mode, s8 link_id);
+	 int (*mu_dump)(void *priv, u8 *mu_onoff, s8 link_id);
+
+	/**
+	 * beacon_ctrl - ctrl on off for beacon
+	 * @priv: Private driver interface data
+	 *
+	 */
+	int (*beacon_ctrl)(void *priv, u8 beacon_mode);
+
+	/**
+	 * set eml omn - Send the EML Operating Mode
+	 * 		 Notification content to driver
+	 * @priv: Private driver interface data
+	 * @link_id: MLD link id
+	 * @addr: MLD STA address
+	 * @omn_ie: EML OMN content sent by the MLD STA
+	 */
+	int (*set_eml_omn)(void *priv, u8 link_id,
+			   u8 *addr, struct eml_omn_element *omn_ie);
+
+	/**
+	 * three_wire_ctrl - set three_wire_ctrl mode
+	 * @priv: Private driver interface data
+	 * @three_wire_enable: three_wire_ctrl mode
+	 *
+	 */
+	 int (*three_wire_ctrl)(void *priv, u8 three_wire_enable);
+
+	/**
+	 * ibf_ctrl - ctrl disable/enable for ibf
+	 * @priv: Private driver interface data
+	 *
+	 */
+	int (*ibf_ctrl)(void *priv, u8 ibf_enable);
+
+	/**
+	 * ibf_dump - dump ibf
+	 * @priv: Private driver interface data
+	 *
+	 */
+	int (*ibf_dump)(void *priv, u8 *ibf_enable);
+
+	/**
+	 * amsdu_ctrl - enable/disable amsdu
+	 * amsdu_dump - get current amsdu status
+	 * @priv: Private driver interface data
+	 *
+	 */
+	int (*amsdu_ctrl)(void *priv, u8 amsdu);
+	int (*amsdu_dump)(void *priv, u8 *amsdu);
+
+	/**
+	 * get_aval_color_bmp - get available BSS color bitmap
+	 * @priv: Private driver interface data
+	 * @aval_color_bmp: available bss color bitmap
+	 *
+	 */
+	int (*get_aval_color_bmp)(void *priv, u64 *aval_color_bmp);
+
+	/**
+	* ap_wireless - set wireless command
+	* @priv: Private driver interface data
+	* @value: value
+	* @link_id: MLD link id. -1 if this is an non-MLD AP.
+	*/
+	int (*ap_wireless)(void *priv, u8 mode, int value, s8 link_id);
+
+	/**
+	* ap_rfeatures - set ap rf features command
+	* @priv: Private driver interface data
+	* @value: value
+	* @link_id: MLD link id. -1 if this is an non-MLD AP.
+	*/
+	int (*ap_rfeatures)(void *priv, u8 mode, int value, s8 link_id);
+
+	/**
+	* ap_trigtype - set trigger type
+	* @priv: Private driver interface data
+	* @enable: enable or disable
+	* @type: trigger type
+	* @link_id: MLD link id. -1 if this is an non-MLD AP.
+	*/
+	int (*ap_trigtype)(void *priv, u8 enable, u8 type, s8 link_id);
+
+	/**
+	* amnt_set - add/delete station from monitoring
+	* @priv: Private driver interface data
+	* @amnt_idx: Monitor Index
+	* @amnt_sta_mac: station mac address
+	*/
+	int (*amnt_set)(void *priv, u8 amnt_idx, u8 *amnt_sta_mac, s8 link_id);
+
+	/**
+	* amnt_dump - Dump particular/ all station
+	* @priv: Private driver interface data
+	* @amnt_idx: Monitor Index
+	* @amnt_dump_buf: Buffer to print
+	*/
+	int (*amnt_dump)(void *priv, u8 amnt_idx, u8 *amnt_dump_buf, s8 link_id);
+
+	/**
+	 * background_radar_mode - set background radar mode
+	 * @priv: Private driver interface data
+	 * @background_radar_mode: background radar mode
+	 */
+	int (*background_radar_mode)(void *priv, u8 background_radar_mode);
+	/**
+	 * pp_mode_set - Set preamble puncture operation mode
+	 * @priv: Private driver interface data
+	 * @pp_mode: Value is defined in enum pp_mode
+	 * @link_id: MLD link id. -1 if this is an non-MLD AP
+	 * @punct_bitmap: current puncture bitmap
+	 */
+	int (*pp_mode_set)(void *priv, const u8 pp_mode, s8 link_id, u16 punct_bitmap);
+#ifdef CONFIG_IEEE80211BE
+	int (*get_mld_addr)(void *priv, u8 *addr);
+	/**
+	 * set_scs - Configure Stream Classification Service
+	 * @priv: Private driver interface data
+	 * @info: Stream classidication service configuration
+	 * @link_id: MLD link id
+	 */
+	int (*set_scs)(void *priv, struct hostapd_scs_desc_info *info, u8 link_id);
+#endif
+	/**
+	 * csi_set - Set csi related mode and parameter
+	 * @priv: Private driver interface data
+	 * @link_id: MLD link id. -1 if this is an non-MLD AP
+	 * @mode: Csi mode parameter
+	 * @cfg: Csi config parameter
+	 * @v1: Value1
+	 * @v2: Value2
+	 * @mac: Station mac for station filter
+	 */
+	int (*csi_set)(void *priv, s8 link_id, u8 mode, u8 cfg, u8 v1, u32 v2, u8 *mac);
+	/**
+	* csi_dump - Dump csi data to json file
+	* @priv: Private driver interface data
+	* @link_id: MLD link id. -1 if this is an non-MLD AP
+	* @dump_buf: Dump_struct that store csi data and related info
+	*/
+	int (*csi_dump)(void *priv, s8 link_id, void *dump_buf);
+	/**
+	* txpower_ctrl - ctrl txpower operation
+	* @priv: Private driver interface data
+	* @lpi_psd: 1 to enable lpi psd compensate, 0 to disable
+	* @lpi_bcn_enhance: 1 to enable beacon duplicate enhancement in 6G lpi mode, 0 to disable enhancement
+	* @sku_idx: index used to indicate which sku table should be used
+	* @link_id: MLD link id. -1 if this is an non-MLD AP
+	* @power_table: power table generated from AFC response
+	* @lpi_mode: specify the current mode is whether lpi
+	*/
+	int (*txpower_ctrl)(void *priv, u8 lpi_psd, u8 sku_idx, u8 lpi_bcn_enhance,
+			    u8 link_id, s8 **power_table, u8 lpi_mode);
 };
 
 /**
@@ -5957,6 +6228,21 @@ enum wpa_event_type {
 	 */
 	EVENT_LINK_CH_SWITCH_STARTED,
 
+	/**
+	 * EVENT_ATTLM - MLD AP Advertised Tid-to-Link Mapping event
+	 *
+	 * This event is used by the driver to indicate the state transition of
+	 * A-TTLM.
+	 *
+	 * Described in wpa_event_data.attlm_event
+	 */
+	EVENT_ATTLM,
+
+	/**
+	 * EVENT_TSF_OFFSET - TSF OFFSET VALUE FROM DRIVER
+	 */
+	EVENT_TSF_OFFSET,
+
 	/**
 	 * EVENT_TID_LINK_MAP - MLD event to set TID-to-link mapping
 	 *
@@ -5976,6 +6262,43 @@ enum wpa_event_type {
 	 * EVENT_MLD_INTERFACE_FREED - Notification of AP MLD interface removal
 	 */
 	EVENT_MLD_INTERFACE_FREED,
+
+	/**
+	 * EVENT_DFS_STA_CAC_SKIPPED - Notification that CAC has been skipped
+	 *
+	 * The channel in the notification is now marked as available.
+	 */
+	EVENT_DFS_STA_CAC_SKIPPED,
+
+	/**
+	 * EVENT_DFS_STA_CAC_EXPIRED - Notification that CAC has expired
+	 *
+	 * The channel in the notification is now marked as usable.
+	 */
+	EVENT_DFS_STA_CAC_EXPIRED,
+
+	/**
+	 * EVENT_DFS_BACKGROUND_CHAN_UPDATE - Notification that background
+	 * channel has been updated.
+	 */
+	EVENT_DFS_BACKGROUND_CHAN_UPDATE,
+
+	/**
+	 * EVENT_DFS_BACKGROUND_CHAN_EXPAND - Notification that background
+	 * channel has been updated and operating channel should expand its width.
+	 */
+	EVENT_DFS_BACKGROUND_CHAN_EXPAND,
+
+	/**
+	 * EVENT_PP_BITMAP_UPDATE - Notification that the new puncture bitmap
+	 * has been applied and a channel switch should be triggered.
+	 */
+	EVENT_PP_BITMAP_UPDATE,
+
+	/**
+	 * EVENT_CRIT_UPDATE - Notification of the status of a critical update event
+	 */
+	EVENT_CRIT_UPDATE,
 };
 
 
@@ -6717,6 +7040,7 @@ union wpa_event_data {
 
 	/**
 	 * struct ch_switch
+	 * @count: Count until channel switch activates
 	 * @freq: Frequency of new channel in MHz
 	 * @ht_enabled: Whether this is an HT channel
 	 * @ch_offset: Secondary channel offset
@@ -6727,6 +7051,7 @@ union wpa_event_data {
 	 * @punct_bitmap: Puncturing bitmap
 	 */
 	struct ch_switch {
+		int count;
 		int freq;
 		int ht_enabled;
 		int ch_offset;
@@ -6737,6 +7062,26 @@ union wpa_event_data {
 		u16 punct_bitmap;
 	} ch_switch;
 
+	/**
+	 * struct attlm_event
+	 * @switch_time_tsf_tu: the TSF of switch time in unit of TUs
+	 * @started: the ATTLM is started or has been done.
+	 * @switch_time_expired: the switch time has expired
+	 */
+	struct attlm_event {
+		enum {
+			EVENT_ATTLM_STARTED,
+			EVENT_ATTLM_SWITCH_TIME_EXPIRED,
+			EVENT_ATTLM_END
+		} event;
+		u16 switch_time_tsf_tu;
+	} attlm_event;
+
+	struct tsf_event {
+		s64 tsf_offset[MAX_NUM_MLD_LINKS];
+		u8 link_id;
+	} tsf_event;
+
 	/**
 	 * struct connect_failed - Data for EVENT_CONNECT_FAILED_REASON
 	 * @addr: Remote client address
@@ -6770,10 +7115,12 @@ union wpa_event_data {
 	 * @freq_filter: Requested frequency survey filter, 0 if request
 	 *	was for all survey data
 	 * @survey_list: Linked list of survey data (struct freq_survey)
+	 * @link_id: Link ID of the MLO link
 	 */
 	struct survey_results {
 		unsigned int freq_filter;
 		struct dl_list survey_list; /* struct freq_survey */
+		int link_id;
 	} survey_results;
 
 	/**
@@ -6963,6 +7310,26 @@ union wpa_event_data {
 		u8 valid_links;
 		struct t2lm_mapping t2lmap[MAX_NUM_MLD_LINKS];
 	} t2l_map_info;
+
+	/**
+	 * struct reconfig_info - Data for EVENT_LINK_RECONFIG
+	 */
+	struct reconfig_info {
+		u16 removed_links;
+	} reconfig_info;
+
+	/**
+	 * struct crit_update_info - Data for EVENT_CRIT_UPDATE
+	 */
+	struct crit_update_info {
+		int link_id;
+		enum {
+			CRIT_UPDATE_NONE,
+			CRIT_UPDATE_SINGLE,
+			CRIT_UPDATE_ALL,
+			CRIT_UPDATE_FLAG,
+		} flag;
+	} crit_update_info;
 };
 
 /**
@@ -6975,8 +7342,8 @@ union wpa_event_data {
  * Driver wrapper code should call this function whenever an event is received
  * from the driver.
  */
-void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
-			  union wpa_event_data *data);
+extern void (*wpa_supplicant_event)(void *ctx, enum wpa_event_type event,
+				    union wpa_event_data *data);
 
 /**
  * wpa_supplicant_event_global - Report a driver event for wpa_supplicant
@@ -6988,7 +7355,7 @@ void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
  * Same as wpa_supplicant_event(), but we search for the interface in
  * wpa_global.
  */
-void wpa_supplicant_event_global(void *ctx, enum wpa_event_type event,
+extern void (*wpa_supplicant_event_global)(void *ctx, enum wpa_event_type event,
 				 union wpa_event_data *data);
 
 /*
diff --git a/src/drivers/driver_nl80211.c b/src/drivers/driver_nl80211.c
index 4141bc5..7120fc8 100644
--- a/src/drivers/driver_nl80211.c
+++ b/src/drivers/driver_nl80211.c
@@ -41,6 +41,13 @@
 #include "radiotap_iter.h"
 #include "rfkill.h"
 #include "driver_nl80211.h"
+#include "common/mtk_vendor.h"
+#include "ap/ap_config.h"
+#include "ap/hostapd.h"
+
+#ifdef CONFIG_IEEE80211BE
+#include "ap/scs.h"
+#endif
 
 
 #ifndef NETLINK_CAP_ACK
@@ -77,6 +84,134 @@ enum nlmsgerr_attrs {
 
 #endif /* ANDROID */
 
+static void handle_nl_debug_hook(struct nl_msg *msg, int tx)
+{
+	const struct nlmsghdr *nlh;
+
+	if (!wpa_netlink_hook)
+		return;
+
+	nlh = nlmsg_hdr(msg);
+	wpa_netlink_hook(tx, nlh, nlh->nlmsg_len);
+}
+
+static struct nla_policy
+ibf_ctrl_policy[NUM_MTK_VENDOR_ATTRS_IBF_CTRL] = {
+	[MTK_VENDOR_ATTR_IBF_CTRL_ENABLE] = { .type = NLA_U8 },
+};
+
+static struct nla_policy
+ibf_dump_policy[NUM_MTK_VENDOR_ATTRS_IBF_DUMP] = {
+	[MTK_VENDOR_ATTR_IBF_DUMP_ENABLE] = { .type = NLA_U8 },
+};
+
+static struct nla_policy three_wire_ctrl_policy[NUM_MTK_VENDOR_ATTRS_3WIRE_CTRL] = {
+	[MTK_VENDOR_ATTR_3WIRE_CTRL_MODE] = {.type = NLA_U8 },
+};
+
+static struct nla_policy edcca_ctrl_policy[NUM_MTK_VENDOR_ATTRS_EDCCA_CTRL] = {
+	[MTK_VENDOR_ATTR_EDCCA_CTRL_MODE] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_CTRL_PRI20_VAL] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_CTRL_SEC20_VAL] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_CTRL_SEC40_VAL] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_CTRL_SEC80_VAL] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_CTRL_COMPENSATE] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_EDCCA_CTRL_SEC160_VAL] = { .type = NLA_U8 },
+};
+
+static const struct nla_policy
+wireless_dump_policy[NUM_MTK_VENDOR_ATTRS_WIRELESS_DUMP] = {
+	[MTK_VENDOR_ATTR_WIRELESS_DUMP_AMSDU] = { .type = NLA_U8 },
+};
+
+static const struct nla_policy
+rfeature_ctrl_policy[NUM_MTK_VENDOR_ATTRS_RFEATURE_CTRL] = {
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_HE_GI] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_HE_LTF] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE_CFG] = { .type = NLA_NESTED },
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE_EN] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_ACK_PLCY] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TXBF] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_VARIANT_TYPE] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_CODING_TYPE] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_RFEATURE_CTRL_LINK_ID] = { .type = NLA_U8 },
+};
+
+static const struct nla_policy
+wireless_ctrl_policy[NUM_MTK_VENDOR_ATTRS_WIRELESS_CTRL] = {
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_FIXED_MCS] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_FIXED_OFDMA] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_PPDU_TX_TYPE] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_NUSERS_OFDMA] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_MIMO] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_BA_BUFFER_SIZE] = {.type = NLA_U16 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_AMSDU] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_CERT] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_WIRELESS_CTRL_LINK_ID] = {.type = NLA_U8 },
+};
+
+static struct nla_policy
+amnt_ctrl_policy[NUM_MTK_VENDOR_ATTRS_AMNT_CTRL] = {
+	[MTK_VENDOR_ATTR_AMNT_CTRL_SET] = {.type = NLA_NESTED },
+	[MTK_VENDOR_ATTR_AMNT_CTRL_DUMP] = { .type = NLA_NESTED },
+	[MTK_VENDOR_ATTR_AMNT_CTRL_LINK_ID] = { .type = NLA_U8 },
+};
+
+static struct nla_policy
+amnt_dump_policy[NUM_MTK_VENDOR_ATTRS_AMNT_DUMP] = {
+	[MTK_VENDOR_ATTR_AMNT_DUMP_INDEX] = {.type = NLA_U8 },
+	[MTK_VENDOR_ATTR_AMNT_DUMP_LEN] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_AMNT_DUMP_RESULT] = { .type = NLA_NESTED },
+};
+
+static struct nla_policy
+pp_ctrl_policy[NUM_MTK_VENDOR_ATTRS_PP_CTRL] = {
+	[MTK_VENDOR_ATTR_PP_MODE] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_PP_LINK_ID] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_PP_BITMAP] = { .type = NLA_U16 },
+	[MTK_VENDOR_ATTR_PP_CURR_FREQ] = { .type = NLA_U32 },
+};
+
+static struct nla_policy csi_ctrl_policy[NUM_MTK_VENDOR_ATTRS_CSI_CTRL] = {
+	[MTK_VENDOR_ATTR_CSI_CTRL_RADIO_IDX] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_CSI_CTRL_CFG] = { .type = NLA_NESTED },
+	[MTK_VENDOR_ATTR_CSI_CTRL_CFG_MODE] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_CSI_CTRL_CFG_TYPE] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_CSI_CTRL_CFG_VAL1] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_CSI_CTRL_CFG_VAL2] = { .type = NLA_U32 },
+	[MTK_VENDOR_ATTR_CSI_CTRL_MAC_ADDR] = { .type = NLA_NESTED },
+	[MTK_VENDOR_ATTR_CSI_CTRL_DUMP_NUM] = { .type = NLA_U16 },
+	[MTK_VENDOR_ATTR_CSI_CTRL_DATA] = { .type = NLA_NESTED },
+};
+
+static struct nla_policy csi_data_policy[NUM_MTK_VENDOR_ATTRS_CSI_DATA] = {
+	[MTK_VENDOR_ATTR_CSI_DATA_VER] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_CSI_DATA_TS] = { .type = NLA_U32 },
+	[MTK_VENDOR_ATTR_CSI_DATA_RSSI] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_CSI_DATA_SNR] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_CSI_DATA_BW] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_CSI_DATA_CH_IDX] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_CSI_DATA_TA] = { .type = NLA_NESTED },
+	[MTK_VENDOR_ATTR_CSI_DATA_NUM] = { .type = NLA_U32 },
+	[MTK_VENDOR_ATTR_CSI_DATA_I] = { .type = NLA_NESTED },
+	[MTK_VENDOR_ATTR_CSI_DATA_Q] = { .type = NLA_NESTED },
+	[MTK_VENDOR_ATTR_CSI_DATA_INFO] = { .type = NLA_U32 },
+	[MTK_VENDOR_ATTR_CSI_DATA_TX_ANT] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_CSI_DATA_RX_ANT] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_CSI_DATA_MODE] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_CSI_DATA_CHAIN_INFO] = { .type = NLA_U32 },
+};
+
+static struct nla_policy
+txpower_ctrl_policy[NUM_MTK_VENDOR_ATTRS_TXPOWER_CTRL] = {
+	[MTK_VENDOR_ATTR_TXPOWER_CTRL_LPI_PSD] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_TXPOWER_CTRL_SKU_IDX] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_TXPOWER_CTRL_LPI_BCN_ENHANCE] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_TXPOWER_CTRL_LINK_ID] = { .type = NLA_U8 },
+	[MTK_VENDOR_ATTR_TXPOWER_CTRL_AFC_TABLE] = { .type = NLA_BINARY },
+	[MTK_VENDOR_ATTR_TXPOWER_CTRL_AFC_LPI] = { .type = NLA_U8 },
+};
 
 static struct nl_sock * nl_create_handle(struct nl_cb *cb, const char *dbg)
 {
@@ -431,6 +566,11 @@ static int no_seq_check(struct nl_msg *msg, void *arg)
 	return NL_OK;
 }
 
+static int debug_handler(struct nl_msg *msg, void *arg)
+{
+	handle_nl_debug_hook(msg, 0);
+	return NL_OK;
+}
 
 static void nl80211_nlmsg_clear(struct nl_msg *msg)
 {
@@ -504,6 +644,8 @@ int send_and_recv(struct nl80211_global *global,
 	if (!msg)
 		return -ENOMEM;
 
+	handle_nl_debug_hook(msg, 1);
+
 	err.err = -ENOMEM;
 
 	s_nl_cb = nl_socket_get_cb(nl_handle);
@@ -538,6 +680,7 @@ int send_and_recv(struct nl80211_global *global,
 	err.orig_msg = msg;
 	err.err_info = err_info;
 
+	nl_cb_set(cb, NL_CB_MSG_IN, NL_CB_CUSTOM, debug_handler, NULL);
 	nl_cb_err(cb, NL_CB_CUSTOM, error_handler, &err);
 	nl_cb_set(cb, NL_CB_FINISH, NL_CB_CUSTOM, finish_handler, &err.err);
 	if (ack_handler_custom) {
@@ -941,6 +1084,7 @@ nl80211_get_wiphy_data_ap(struct i802_bss *bss)
 			os_free(w);
 			return NULL;
 		}
+		nl_cb_set(w->nl_cb, NL_CB_MSG_IN, NL_CB_CUSTOM, debug_handler, NULL);
 		nl_cb_set(w->nl_cb, NL_CB_SEQ_CHECK, NL_CB_CUSTOM,
 			  no_seq_check, NULL);
 		nl_cb_set(w->nl_cb, NL_CB_VALID, NL_CB_CUSTOM,
@@ -991,6 +1135,11 @@ static void nl80211_put_wiphy_data_ap(struct i802_bss *bss)
 
 	if (w == NULL)
 		return;
+
+	/* do not clear wiphy data if there are still more than one links */
+	if (bss->valid_links && (bss->valid_links & (bss->valid_links - 1)))
+		return;
+
 	bss->wiphy_data = NULL;
 	dl_list_del(&bss->wiphy_list);
 
@@ -1048,6 +1197,31 @@ static int wpa_driver_nl80211_get_ssid(void *priv, u8 *ssid)
 }
 
 
+static void get_link_channel_info(struct nlattr **link_data, u8 link_id,
+				  struct driver_sta_mlo_info *info)
+{
+	info->links[link_id].freq =
+		nla_get_u32(link_data[NL80211_ATTR_WIPHY_FREQ]);
+
+	if (link_data[NL80211_ATTR_CHANNEL_WIDTH]) {
+		info->links[link_id].width =
+	       convert2width(nla_get_u32(link_data[NL80211_ATTR_CHANNEL_WIDTH]));
+
+		if (link_data[NL80211_ATTR_CENTER_FREQ1])
+			info->links[link_id].center_freq1 =
+			      nla_get_u32(link_data[NL80211_ATTR_CENTER_FREQ1]);
+
+		if (link_data[NL80211_ATTR_CENTER_FREQ2])
+			info->links[link_id].center_freq2 =
+			      nla_get_u32(link_data[NL80211_ATTR_CENTER_FREQ2]);
+
+		if (link_data[NL80211_ATTR_PUNCT_BITMAP])
+			info->links[link_id].punct_bitmap =
+			      nla_get_u32(link_data[NL80211_ATTR_PUNCT_BITMAP]);
+	}
+}
+
+
 static int get_mlo_info(struct nl_msg *msg, void *arg)
 {
 	struct nlattr *tb[NL80211_ATTR_MAX + 1];
@@ -1085,8 +1259,7 @@ static int get_mlo_info(struct nl_msg *msg, void *arg)
 		os_memcpy(info->links[link_id].addr,
 			  nla_data(link_data[NL80211_ATTR_MAC]), ETH_ALEN);
 		if (link_data[NL80211_ATTR_WIPHY_FREQ])
-			info->links[link_id].freq =
-				nla_get_u32(link_data[NL80211_ATTR_WIPHY_FREQ]);
+			get_link_channel_info(link_data, link_id, info);
 	}
 
 	return NL_SKIP;
@@ -1355,7 +1528,7 @@ static void wpa_driver_nl80211_event_rtm_newlink(void *ctx,
 		}
 		wpa_printf(MSG_DEBUG, "nl80211: Interface down (%s/%s)",
 			   namebuf, ifname);
-		if (os_strcmp(drv->first_bss->ifname, ifname) != 0) {
+		if (drv->first_bss->ifindex != ifi->ifi_index) {
 			wpa_printf(MSG_DEBUG,
 				   "nl80211: Not the main interface (%s) - do not indicate interface down",
 				   drv->first_bss->ifname);
@@ -1391,7 +1564,7 @@ static void wpa_driver_nl80211_event_rtm_newlink(void *ctx,
 		}
 		wpa_printf(MSG_DEBUG, "nl80211: Interface up (%s/%s)",
 			   namebuf, ifname);
-		if (os_strcmp(drv->first_bss->ifname, ifname) != 0) {
+		if (drv->first_bss->ifindex != ifi->ifi_index) {
 			wpa_printf(MSG_DEBUG,
 				   "nl80211: Not the main interface (%s) - do not indicate interface up",
 				   drv->first_bss->ifname);
@@ -1816,6 +1989,9 @@ static int get_channel_info(struct nl_msg *msg, void *arg)
 	if (tb[NL80211_ATTR_CENTER_FREQ2])
 		chan_info->center_frq2 =
 			nla_get_u32(tb[NL80211_ATTR_CENTER_FREQ2]);
+	if (tb[NL80211_ATTR_PUNCT_BITMAP])
+		chan_info->punct_bitmap =
+			nla_get_u32(tb[NL80211_ATTR_PUNCT_BITMAP]);
 
 	if (chan_info->center_frq2) {
 		u8 seg1_idx = 0;
@@ -2037,6 +2213,7 @@ static int wpa_driver_nl80211_init_nl_global(struct nl80211_global *global)
 	genl_family_put(family);
 	nl_cache_free(cache);
 
+	nl_cb_set(global->nl_cb, NL_CB_MSG_IN, NL_CB_CUSTOM, debug_handler, NULL);
 	nl_cb_set(global->nl_cb, NL_CB_SEQ_CHECK, NL_CB_CUSTOM,
 		  no_seq_check, NULL);
 	nl_cb_set(global->nl_cb, NL_CB_VALID, NL_CB_CUSTOM,
@@ -2207,6 +2384,7 @@ static int nl80211_init_bss(struct i802_bss *bss)
 	if (!bss->nl_cb)
 		return -1;
 
+	nl_cb_set(bss->nl_cb, NL_CB_MSG_IN, NL_CB_CUSTOM, debug_handler, NULL);
 	nl_cb_set(bss->nl_cb, NL_CB_SEQ_CHECK, NL_CB_CUSTOM,
 		  no_seq_check, NULL);
 	nl_cb_set(bss->nl_cb, NL_CB_VALID, NL_CB_CUSTOM,
@@ -2768,6 +2946,12 @@ static int nl80211_action_subscribe_ap(struct i802_bss *bss)
 	if (nl80211_register_action_frame(bss, (u8 *) "\x12", 1) < 0)
 		ret = -1;
 #endif /* CONFIG_FST */
+	/* Protected EHT */
+	if (nl80211_register_action_frame(bss, (u8 *) "\x25", 1) < 0)
+		ret = -1;
+	/* Robust AV SCS Request */
+	if (nl80211_register_action_frame(bss, (u8 *) "\x13\x00", 2) < 0)
+		ret = -1;
 	/* Vendor-specific */
 	if (nl80211_register_action_frame(bss, (u8 *) "\x7f", 1) < 0)
 		ret = -1;
@@ -4407,7 +4591,7 @@ send_frame_cmd:
 	res = nl80211_send_frame_cmd(bss, freq, wait_time, data, data_len,
 				     use_cookie, no_cck, noack, offchanok,
 				     csa_offs, csa_offs_len, link_id);
-	if (!res)
+	if (!res && !noack)
 		drv->send_frame_link_id = link_id;
 
 	return res;
@@ -4787,7 +4971,6 @@ static int nl80211_fils_discovery(struct i802_bss *bss, struct nl_msg *msg,
 	     nla_put(msg, NL80211_FILS_DISCOVERY_ATTR_TMPL,
 		     params->fd_frame_tmpl_len, params->fd_frame_tmpl)))
 		return -1;
-
 	nla_nest_end(msg, attr);
 	return 0;
 }
@@ -5114,6 +5297,17 @@ static int wpa_driver_nl80211_set_ap(void *priv,
 	wpa_printf(MSG_DEBUG, "nl80211: dtim_period=%d", params->dtim_period);
 	wpa_printf(MSG_DEBUG, "nl80211: ssid=%s",
 		   wpa_ssid_txt(params->ssid, params->ssid_len));
+
+	if (!beacon_set) {
+		/* update wdev->preset_chandef in MAC80211 */
+		ret = nl80211_set_channel(bss, params->freq, 1);
+		if (ret) {
+			wpa_printf(MSG_ERROR,
+				   "nl80211: Frequency set failed: %d (%s)",
+				   ret, strerror(-ret));
+		}
+	}
+
 	if (!(msg = nl80211_bss_msg(bss, 0, cmd)) ||
 	    nla_put(msg, NL80211_ATTR_BEACON_HEAD, params->head_len,
 		    params->head) ||
@@ -5419,7 +5613,10 @@ static int wpa_driver_nl80211_set_ap(void *priv,
 #endif /* CONFIG_SAE */
 
 #ifdef CONFIG_FILS
-	if (params->fd_max_int && nl80211_fils_discovery(bss, msg, params) < 0)
+	if ((params->fd_max_int ||
+	    ((params->freq->freq > 5950 && params->freq->freq <= 7115) &&
+	      !(params->ubpr.unsol_bcast_probe_resp_interval))) &&
+	     nl80211_fils_discovery(bss, msg, params) < 0)
 		goto fail;
 #endif /* CONFIG_FILS */
 
@@ -5512,7 +5709,7 @@ static int nl80211_set_channel(struct i802_bss *bss,
 		   freq->he_enabled, freq->eht_enabled, freq->bandwidth,
 		   freq->center_freq1, freq->center_freq2);
 
-	msg = nl80211_drv_msg(drv, 0, set_chan ? NL80211_CMD_SET_CHANNEL :
+	msg = nl80211_bss_msg(bss, 0, set_chan ? NL80211_CMD_SET_CHANNEL :
 			      NL80211_CMD_SET_WIPHY);
 	if (!msg || nl80211_put_freq_params(msg, freq) < 0) {
 		nlmsg_free(msg);
@@ -5870,6 +6067,14 @@ static int wpa_driver_nl80211_sta_add(void *priv,
 			goto fail;
 	}
 
+	if (params->eml_capa) {
+		wpa_printf(MSG_DEBUG, "  * eml_capa=%u",
+			   params->eml_capa);
+		if (nla_put_u16(msg, NL80211_ATTR_EML_CAPABILITY,
+				params->eml_capa))
+			goto fail;
+	}
+
 	ret = send_and_recv_cmd(drv, msg);
 	msg = NULL;
 	if (ret)
@@ -6066,7 +6271,7 @@ static int nl80211_create_iface_once(struct wpa_driver_nl80211_data *drv,
 				     enum nl80211_iftype iftype,
 				     const u8 *addr, int wds,
 				     int (*handler)(struct nl_msg *, void *),
-				     void *arg)
+				     void *arg, u32 radio_mask)
 {
 	struct nl_msg *msg;
 	int ifidx;
@@ -6078,7 +6283,8 @@ static int nl80211_create_iface_once(struct wpa_driver_nl80211_data *drv,
 	msg = nl80211_cmd_msg(drv->first_bss, 0, NL80211_CMD_NEW_INTERFACE);
 	if (!msg ||
 	    nla_put_string(msg, NL80211_ATTR_IFNAME, ifname) ||
-	    nla_put_u32(msg, NL80211_ATTR_IFTYPE, iftype))
+	    nla_put_u32(msg, NL80211_ATTR_IFTYPE, iftype) ||
+	    nla_put_u32(msg, NL80211_ATTR_VIF_RADIO_MASK, radio_mask))
 		goto fail;
 
 	if (iftype == NL80211_IFTYPE_MONITOR) {
@@ -6152,12 +6358,12 @@ int nl80211_create_iface(struct wpa_driver_nl80211_data *drv,
 			 const char *ifname, enum nl80211_iftype iftype,
 			 const u8 *addr, int wds,
 			 int (*handler)(struct nl_msg *, void *),
-			 void *arg, int use_existing)
+			 void *arg, int use_existing, u32 radio_mask)
 {
 	int ret;
 
 	ret = nl80211_create_iface_once(drv, ifname, iftype, addr, wds, handler,
-					arg);
+					arg, radio_mask);
 
 	/* if error occurred and interface exists already */
 	if (ret == -ENFILE && if_nametoindex(ifname)) {
@@ -6183,7 +6389,7 @@ int nl80211_create_iface(struct wpa_driver_nl80211_data *drv,
 
 		/* Try to create the interface again */
 		ret = nl80211_create_iface_once(drv, ifname, iftype, addr,
-						wds, handler, arg);
+						wds, handler, arg, radio_mask);
 	}
 
 	if (ret >= 0 && is_p2p_net_interface(iftype)) {
@@ -6253,8 +6459,7 @@ static void nl80211_teardown_ap(struct i802_bss *bss)
 		nl80211_mgmt_unsubscribe(bss, "AP teardown");
 
 	nl80211_put_wiphy_data_ap(bss);
-	if (bss->flink)
-		bss->flink->beacon_set = 0;
+	wpa_driver_nl80211_del_beacon_all(bss);
 }
 
 
@@ -8539,24 +8744,17 @@ static int have_ifidx(struct wpa_driver_nl80211_data *drv, int ifidx,
 
 
 static int i802_set_wds_sta(void *priv, const u8 *addr, int aid, int val,
-			    const char *bridge_ifname, char *ifname_wds)
+			    const char *bridge_ifname, const char *ifname_wds)
 {
 	struct i802_bss *bss = priv;
 	struct wpa_driver_nl80211_data *drv = bss->drv;
-	char name[IFNAMSIZ + 1];
+	char name[IFNAMSIZ + 1] = {0};
 	union wpa_event_data event;
 	bool add_br = false;
 	int ret;
 
-	ret = os_snprintf(name, sizeof(name), "%s.sta%d", bss->ifname, aid);
-	if (ret >= (int) sizeof(name))
-		wpa_printf(MSG_WARNING,
-			   "nl80211: WDS interface name was truncated");
-	else if (ret < 0)
-		return ret;
-
 	if (ifname_wds)
-		os_strlcpy(ifname_wds, name, IFNAMSIZ + 1);
+		os_strlcpy(name, ifname_wds, IFNAMSIZ + 1);
 
 	wpa_printf(MSG_DEBUG, "nl80211: Set WDS STA addr=" MACSTR
 		   " aid=%d val=%d name=%s", MAC2STR(addr), aid, val, name);
@@ -8564,7 +8762,7 @@ static int i802_set_wds_sta(void *priv, const u8 *addr, int aid, int val,
 		if (!if_nametoindex(name)) {
 			if (nl80211_create_iface(drv, name,
 						 NL80211_IFTYPE_AP_VLAN,
-						 bss->addr, 1, NULL, NULL, 0) <
+						 bss->addr, 1, NULL, NULL, 0, 0) <
 			    0)
 				return -1;
 
@@ -8705,6 +8903,7 @@ static void *i802_init(struct hostapd_data *hapd,
 	char master_ifname[IFNAMSIZ];
 	int ifindex, br_ifindex = 0;
 	int br_added = 0;
+	int err;
 
 	bss = wpa_driver_nl80211_drv_init(hapd, params->ifname,
 					  params->global_priv, 1,
@@ -8764,21 +8963,17 @@ static void *i802_init(struct hostapd_data *hapd,
 	    (params->num_bridge == 0 || !params->bridge[0]))
 		add_ifidx(drv, br_ifindex, drv->ifindex);
 
-	if (bss->added_if_into_bridge || bss->already_in_bridge) {
-		int err;
-
-		drv->rtnl_sk = nl_socket_alloc();
-		if (drv->rtnl_sk == NULL) {
-			wpa_printf(MSG_ERROR, "nl80211: Failed to allocate nl_sock");
-			goto failed;
-		}
+	drv->rtnl_sk = nl_socket_alloc();
+	if (drv->rtnl_sk == NULL) {
+		wpa_printf(MSG_ERROR, "nl80211: Failed to allocate nl_sock");
+		goto failed;
+	}
 
-		err = nl_connect(drv->rtnl_sk, NETLINK_ROUTE);
-		if (err) {
-			wpa_printf(MSG_ERROR, "nl80211: Failed to connect nl_sock to NETLINK_ROUTE: %s",
-				   nl_geterror(err));
-			goto failed;
-		}
+	err = nl_connect(drv->rtnl_sk, NETLINK_ROUTE);
+	if (err) {
+		wpa_printf(MSG_ERROR, "nl80211: Failed to connect nl_sock to NETLINK_ROUTE: %s",
+			   nl_geterror(err));
+		goto failed;
 	}
 
 	if (drv->capa.flags2 & WPA_DRIVER_FLAGS2_CONTROL_PORT_RX) {
@@ -8822,6 +9017,48 @@ static void i802_deinit(void *priv)
 	wpa_driver_nl80211_deinit(bss);
 }
 
+static int i802_move_bss_to_first(void *priv, const char *ifname)
+{
+	struct i802_bss *bss = priv;
+	struct i802_bss *first_bss, *target_bss, *prev_bss, *tmp_bss;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+
+	if (!os_strcmp(drv->first_bss->ifname, ifname)) {
+		wpa_printf(MSG_ERROR, "nl80211: BSS is already the first one");
+		return 0;
+	}
+
+	prev_bss = drv->first_bss;
+	target_bss = drv->first_bss->next;
+	while (target_bss) {
+		if (!os_strcmp(target_bss->ifname, ifname))
+			break;
+
+		prev_bss = target_bss;
+		target_bss = target_bss->next;
+	}
+
+	if (!target_bss) {
+		wpa_printf(MSG_ERROR, "nl80211: Failed to find the target BSS");
+		return -1;
+	}
+
+	first_bss = drv->first_bss;
+	drv->first_bss = target_bss;
+	prev_bss->next = first_bss;
+
+	tmp_bss = first_bss->next;
+	first_bss->next = target_bss->next;
+	target_bss->next = tmp_bss;
+
+	memcpy(drv->perm_addr, drv->first_bss->addr, ETH_ALEN);
+	drv->ifindex = if_nametoindex(drv->first_bss->ifname);
+	drv->ctx = drv->first_bss->ctx;
+
+	first_bss->added_if = 1;
+	target_bss->added_if = 0;
+	return 0;
+}
 
 static enum nl80211_iftype wpa_driver_nl80211_if_type(
 	enum wpa_driver_if_type type)
@@ -8916,7 +9153,7 @@ static int wpa_driver_nl80211_if_add(void *priv, enum wpa_driver_if_type type,
 				     void *bss_ctx, void **drv_priv,
 				     char *force_ifname, u8 *if_addr,
 				     const char *bridge, int use_existing,
-				     int setup_ap)
+				     int setup_ap, int freq, u32 radio_mask)
 {
 	enum nl80211_iftype nlmode;
 	struct i802_bss *bss = priv;
@@ -8933,7 +9170,7 @@ static int wpa_driver_nl80211_if_add(void *priv, enum wpa_driver_if_type type,
 		os_memset(&p2pdev_info, 0, sizeof(p2pdev_info));
 		ifidx = nl80211_create_iface(drv, ifname, nlmode, addr,
 					     0, nl80211_wdev_handler,
-					     &p2pdev_info, use_existing);
+					     &p2pdev_info, use_existing, radio_mask);
 		if (!p2pdev_info.wdev_id_set || ifidx != 0) {
 			wpa_printf(MSG_ERROR, "nl80211: Failed to create a P2P Device interface %s",
 				   ifname);
@@ -8949,7 +9186,7 @@ static int wpa_driver_nl80211_if_add(void *priv, enum wpa_driver_if_type type,
 			   (long long unsigned int) p2pdev_info.wdev_id);
 	} else {
 		ifidx = nl80211_create_iface(drv, ifname, nlmode, addr,
-					     0, NULL, NULL, use_existing);
+					     0, NULL, NULL, use_existing, radio_mask);
 		if (use_existing && ifidx == -ENFILE) {
 			added = 0;
 			ifidx = if_nametoindex(ifname);
@@ -9036,7 +9273,7 @@ static int wpa_driver_nl80211_if_add(void *priv, enum wpa_driver_if_type type,
 		new_bss->valid_links = 0;
 		os_memcpy(new_bss->flink->addr, new_bss->addr, ETH_ALEN);
 
-		new_bss->flink->freq = drv->first_bss->flink->freq;
+		new_bss->flink->freq = (freq == -1) ? drv->first_bss->flink->freq : freq;
 		new_bss->ctx = bss_ctx;
 		new_bss->added_if = added;
 		drv->first_bss->next = new_bss;
@@ -9147,6 +9384,50 @@ static int wpa_driver_nl80211_if_remove(struct i802_bss *bss,
 	return 0;
 }
 
+static int wpa_driver_nl80211_if_rename(struct i802_bss *bss,
+					enum wpa_driver_if_type type,
+					const char *ifname, const char *new_name)
+{
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct ifinfomsg ifi = {
+		.ifi_family = AF_UNSPEC,
+		.ifi_index = bss->ifindex,
+	};
+	struct nl_msg *msg;
+	int res = -ENOMEM;
+
+	if (ifname)
+		ifi.ifi_index = if_nametoindex(ifname);
+
+	msg = nlmsg_alloc_simple(RTM_SETLINK, 0);
+	if (!msg)
+		return res;
+
+	if (nlmsg_append(msg, &ifi, sizeof(ifi), NLMSG_ALIGNTO) < 0)
+		goto out;
+
+	if (nla_put_string(msg, IFLA_IFNAME, new_name))
+		goto out;
+
+	res = nl_send_auto_complete(drv->rtnl_sk, msg);
+	if (res < 0)
+		goto out;
+
+	res = nl_wait_for_ack(drv->rtnl_sk);
+	if (res) {
+		wpa_printf(MSG_INFO,
+			   "nl80211: Renaming device %s to %s failed: %s",
+			   ifname ? ifname : bss->ifname, new_name, nl_geterror(res));
+		goto out;
+	}
+
+	if (type == WPA_IF_AP_BSS && !ifname)
+		os_strlcpy(bss->ifname, new_name, sizeof(bss->ifname));
+
+out:
+	nlmsg_free(msg);
+	return res;
+}
 
 static int cookie_handler(struct nl_msg *msg, void *arg)
 {
@@ -9205,8 +9486,8 @@ static int nl80211_send_frame_cmd(struct i802_bss *bss,
 			   "cookie 0x%llx", no_ack ? " (no ACK)" : "",
 			   (long long unsigned int) cookie);
 
-		if (save_cookie)
-			drv->send_frame_cookie = no_ack ? (u64) -1 : cookie;
+		if (save_cookie && !no_ack)
+			drv->send_frame_cookie = cookie;
 
 		if (!wait) {
 			 /* There is no need to store this cookie since there
@@ -10380,7 +10661,8 @@ static int survey_handler(struct nl_msg *msg, void *arg)
 }
 
 
-static int wpa_driver_nl80211_get_survey(void *priv, unsigned int freq)
+static int wpa_driver_nl80211_get_survey(void *priv, unsigned int freq,
+					 int link_id)
 {
 	struct i802_bss *bss = priv;
 	struct wpa_driver_nl80211_data *drv = bss->drv;
@@ -10400,6 +10682,7 @@ static int wpa_driver_nl80211_get_survey(void *priv, unsigned int freq)
 	if (!msg)
 		return -ENOBUFS;
 
+	data.survey_results.link_id = link_id;
 	if (freq)
 		data.survey_results.freq_filter = freq;
 
@@ -10415,6 +10698,7 @@ static int wpa_driver_nl80211_get_survey(void *priv, unsigned int freq)
 		wpa_supplicant_event(ctx, EVENT_SURVEY, &data);
 
 	clean_survey_results(survey_results);
+	bss->scan_link = NULL;
 	return err;
 }
 
@@ -10608,6 +10892,14 @@ static int nl80211_start_radar_detection(void *priv,
 			nlmsg_free(msg);
 			return -1;
 		}
+
+		if (freq->radar_background) {
+			struct i802_link *link = nl80211_get_link(bss, freq->link_id);
+
+			link->background_freq = freq->freq;
+		} else {
+			nl80211_link_set_freq(bss, freq->link_id, freq->freq);
+		}
 	}
 
 	ret = send_and_recv_cmd(drv, msg);
@@ -10974,9 +11266,72 @@ static bool nl80211_is_drv_shared(void *priv, int link_id)
 	return true;
 }
 
+
+static int nl80211_set_attlm(void *priv, struct attlm_settings *attlm)
+{
+	struct nl_msg *msg;
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	int ret = -ENOBUFS;
+
+	wpa_printf(MSG_DEBUG, "nl80211: Set A-TTLM");
+
+	if (!(msg = nl80211_bss_msg(bss, 0, NL80211_CMD_SET_ATTLM)) ||
+	    nla_put_u16(msg, NL80211_ATTR_MLO_LINK_DISABLED_BMP,
+			attlm->disabled_links) ||
+	    nla_put_u16(msg, NL80211_ATTR_MLO_ATTLM_SWITCH_TIME,
+			attlm->switch_time) ||
+	    nla_put_u32(msg, NL80211_ATTR_MLO_ATTLM_DURATION,
+			attlm->duration))
+		goto error;
+
+	ret = send_and_recv_cmd(drv, msg);
+	if (ret) {
+		wpa_printf(MSG_DEBUG,
+			   "nl80211: disable link failed err=%d (%s)",
+			   ret, strerror(-ret));
+	}
+
+	return ret;
+error:
+	nlmsg_free(msg);
+	wpa_printf(MSG_DEBUG, "nl80211: Could not build link disabling request");
+	return ret;
+}
 #endif /* CONFIG_IEEE80211BE */
 
 
+static int driver_nl80211_if_rename(void *priv, enum wpa_driver_if_type type,
+				    const char *ifname, const char *new_name)
+{
+	struct i802_bss *bss = priv;
+	return wpa_driver_nl80211_if_rename(bss, type, ifname, new_name);
+}
+
+
+static int driver_nl80211_set_first_bss(void *priv)
+{
+	struct i802_bss *bss = priv, *tbss;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+
+	if (drv->first_bss == bss)
+		return 0;
+
+	for (tbss = drv->first_bss; tbss; tbss = tbss->next) {
+		if (tbss->next != bss)
+			continue;
+
+		tbss->next = bss->next;
+		bss->next = drv->first_bss;
+		drv->first_bss = bss;
+		drv->ctx = bss->ctx;
+		return 0;
+	}
+
+	return -1;
+}
+
+
 static int driver_nl80211_send_mlme(void *priv, const u8 *data,
 				    size_t data_len, int noack,
 				    unsigned int freq,
@@ -11382,9 +11737,10 @@ static int nl80211_switch_channel(void *priv, struct csa_settings *settings)
 	struct i802_bss *bss = priv;
 	struct wpa_driver_nl80211_data *drv = bss->drv;
 	struct nlattr *beacon_csa;
-	int ret = -ENOBUFS;
-	int csa_off_len = 0;
-	int i;
+	int i, csa_off_len = 0, ret = -ENOBUFS;
+	unsigned int cs_link_id = settings->link_id;
+	u16 *counter_offset_beacon = settings->counter_offset_beacon;
+	u16 *counter_offset_presp = settings->counter_offset_presp;
 
 	wpa_printf(MSG_DEBUG,
 		   "nl80211: Channel switch request (cs_count=%u block_tx=%u freq=%d channel=%d sec_channel_offset=%d width=%d cf1=%d cf2=%d puncturing_bitmap=0x%04x link_id=%d%s%s%s)",
@@ -11395,8 +11751,8 @@ static int nl80211_switch_channel(void *priv, struct csa_settings *settings)
 		   settings->freq_params.bandwidth,
 		   settings->freq_params.center_freq1,
 		   settings->freq_params.center_freq2,
-		   settings->punct_bitmap,
-		   settings->link_id,
+		   settings->freq_params.punct_bitmap,
+		   settings->freq_params.link_id,
 		   settings->freq_params.ht_enabled ? " ht" : "",
 		   settings->freq_params.vht_enabled ? " vht" : "",
 		   settings->freq_params.he_enabled ? " he" : "");
@@ -11416,18 +11772,19 @@ static int nl80211_switch_channel(void *priv, struct csa_settings *settings)
 	 * counters match. This implementation assumes that there are only two
 	 * counters.
 	 */
-	if (settings->counter_offset_beacon[0] &&
-	    !settings->counter_offset_beacon[1]) {
+	if (cs_link_id != settings->freq_params.link_id) {
+		counter_offset_beacon = settings->counter_offset_sta_prof[cs_link_id];
+		counter_offset_presp = NULL;
+	}
+
+	if (counter_offset_beacon[0] && !counter_offset_beacon[1]) {
 		csa_off_len = 1;
-	} else if (settings->counter_offset_beacon[1] &&
-		   !settings->counter_offset_beacon[0]) {
+	} else if (counter_offset_beacon[1] && !counter_offset_beacon[0]) {
 		csa_off_len = 1;
-		settings->counter_offset_beacon[0] =
-			settings->counter_offset_beacon[1];
-		settings->counter_offset_presp[0] =
-			settings->counter_offset_presp[1];
-	} else if (settings->counter_offset_beacon[1] &&
-		   settings->counter_offset_beacon[0]) {
+		counter_offset_beacon[0] = counter_offset_beacon[1];
+		if (counter_offset_presp)
+			counter_offset_presp[0] = counter_offset_presp[1];
+	} else if (counter_offset_beacon[1] && counter_offset_beacon[0]) {
 		csa_off_len = 2;
 	} else {
 		wpa_printf(MSG_ERROR, "nl80211: No CSA counters provided");
@@ -11446,14 +11803,18 @@ static int nl80211_switch_channel(void *priv, struct csa_settings *settings)
 		return -EINVAL;
 
 	for (i = 0; i < csa_off_len; i++) {
-		u16 csa_c_off_bcn = settings->counter_offset_beacon[i];
-		u16 csa_c_off_presp = settings->counter_offset_presp[i];
+		u16 csa_c_off_bcn = counter_offset_beacon[i];
+		u16 csa_c_off_presp;
 
 		if ((settings->beacon_csa.tail_len <= csa_c_off_bcn) ||
 		    (settings->beacon_csa.tail[csa_c_off_bcn] !=
 		     settings->cs_count))
 			return -EINVAL;
 
+		if (!counter_offset_presp)
+			continue;
+
+		csa_c_off_presp = counter_offset_presp[i];
 		if (settings->beacon_csa.probe_resp &&
 		    ((settings->beacon_csa.probe_resp_len <=
 		      csa_c_off_presp) ||
@@ -11468,11 +11829,11 @@ static int nl80211_switch_channel(void *priv, struct csa_settings *settings)
 	    (ret = nl80211_put_freq_params(msg, &settings->freq_params)) ||
 	    (settings->block_tx &&
 	     nla_put_flag(msg, NL80211_ATTR_CH_SWITCH_BLOCK_TX)) ||
-	    (settings->punct_bitmap &&
+	    (settings->freq_params.punct_bitmap &&
 	     nla_put_u32(msg, NL80211_ATTR_PUNCT_BITMAP,
-			 settings->punct_bitmap)) ||
-	    (settings->link_id != NL80211_DRV_LINK_ID_NA &&
-	     nla_put_u8(msg, NL80211_ATTR_MLO_LINK_ID, settings->link_id)))
+			 settings->freq_params.punct_bitmap)) ||
+	    (settings->freq_params.link_id != NL80211_DRV_LINK_ID_NA &&
+	     nla_put_u8(msg, NL80211_ATTR_MLO_LINK_ID, settings->freq_params.link_id)))
 		goto error;
 
 	/* beacon_after params */
@@ -11480,6 +11841,10 @@ static int nl80211_switch_channel(void *priv, struct csa_settings *settings)
 	if (ret)
 		goto error;
 
+	if (drv->nlmode == NL80211_IFTYPE_MESH_POINT) {
+		nla_put_flag(msg, NL80211_ATTR_HANDLE_DFS);
+	}
+
 	/* beacon_csa params */
 	beacon_csa = nla_nest_start(msg, NL80211_ATTR_CSA_IES);
 	if (!beacon_csa)
@@ -11489,9 +11854,14 @@ static int nl80211_switch_channel(void *priv, struct csa_settings *settings)
 	if (ret)
 		goto error;
 
-	if (nla_put(msg, NL80211_ATTR_CSA_C_OFF_BEACON,
-		    csa_off_len * sizeof(u16),
-		    settings->counter_offset_beacon) ||
+	if ((cs_link_id == settings->freq_params.link_id &&
+	     nla_put(msg, NL80211_ATTR_CSA_C_OFF_BEACON,
+		     csa_off_len * sizeof(u16),
+		     settings->counter_offset_beacon)) ||
+	    (cs_link_id != settings->freq_params.link_id &&
+	     nla_put(msg, NL80211_ATTR_CSA_C_OFF_STA_PROF,
+		     csa_off_len * sizeof(u16),
+		     settings->counter_offset_sta_prof[cs_link_id])) ||
 	    (settings->beacon_csa.probe_resp &&
 	     nla_put(msg, NL80211_ATTR_CSA_C_OFF_PRESP,
 		     csa_off_len * sizeof(u16),
@@ -12154,6 +12524,18 @@ static int nl80211_put_mesh_id(struct nl_msg *msg, const u8 *mesh_id,
 }
 
 
+static int nl80211_put_mcast_rate(struct nl_msg *msg, int mcast_rate)
+{
+	if (mcast_rate > 0) {
+		wpa_printf(MSG_DEBUG, "  * mcast_rate=%.1f",
+			   (double)mcast_rate / 10);
+		return nla_put_u32(msg, NL80211_ATTR_MCAST_RATE, mcast_rate);
+	}
+
+	return 0;
+}
+
+
 static int nl80211_put_mesh_config(struct nl_msg *msg,
 				   struct wpa_driver_mesh_bss_params *params)
 {
@@ -12215,6 +12597,7 @@ static int nl80211_join_mesh(struct i802_bss *bss,
 	    nl80211_put_basic_rates(msg, params->basic_rates) ||
 	    nl80211_put_mesh_id(msg, params->meshid, params->meshid_len) ||
 	    nl80211_put_beacon_int(msg, params->beacon_int) ||
+	    nl80211_put_mcast_rate(msg, params->mcast_rate) ||
 	    nl80211_put_dtim_period(msg, params->dtim_period))
 		goto fail;
 
@@ -12568,7 +12951,7 @@ static const char * drv_br_net_param_str(enum drv_br_net_param param)
 
 
 static int wpa_driver_br_set_net_param(void *priv, enum drv_br_net_param param,
-				       unsigned int val)
+				       const char *ifname, unsigned int val)
 {
 	struct i802_bss *bss = priv;
 	char path[128];
@@ -12594,8 +12977,11 @@ static int wpa_driver_br_set_net_param(void *priv, enum drv_br_net_param param,
 			return -EINVAL;
 	}
 
+	if (!ifname)
+		ifname = bss->brname;
+
 	os_snprintf(path, sizeof(path), "/proc/sys/net/ipv%d/conf/%s/%s",
-		    ip_version, bss->brname, param_txt);
+		    ip_version, ifname, param_txt);
 
 set_val:
 	if (linux_write_system_file(path, val))
@@ -13242,7 +13628,6 @@ static void nl80211_parse_btm_candidate_info(struct candidate_list *candidate,
 		   num, MAC2STR(candidate->bssid), buf);
 }
 
-
 static int
 nl80211_get_bss_transition_status_handler(struct nl_msg *msg, void *arg)
 {
@@ -14304,183 +14689,1621 @@ fail:
 }
 
 
-#ifdef CONFIG_DPP
-static int nl80211_dpp_listen(void *priv, bool enable)
+#ifdef CONFIG_IEEE80211AX
+static int nl80211_mu_ctrl(void *priv, u8 mode, s8 link_id)
 {
 	struct i802_bss *bss = priv;
 	struct wpa_driver_nl80211_data *drv = bss->drv;
-	u16 type = (WLAN_FC_TYPE_MGMT << 2) | (WLAN_FC_STYPE_ACTION << 4);
-	struct nl_sock *handle;
+	struct i802_link *link = nl80211_get_link(bss, link_id);
+	struct hostapd_data *hapd = bss->ctx;
+	struct hostapd_config *cfg;
+	struct nl_msg *msg;
+	struct nlattr *data;
+	int ret = -ENOBUFS;
+	u8 radio_idx = 0;
 
-	if (!drv->multicast_registrations || !bss->nl_mgmt)
-		return 0; /* cannot do more than hope broadcast RX works */
+	if (!drv->mtk_mu_vendor_cmd_avail) {
+		wpa_printf(MSG_INFO,
+			   "nl80211: Driver does not support setting mu control");
+		return 0;
+	}
 
-	wpa_printf(MSG_DEBUG,
-		   "nl80211: Update DPP Public Action frame registration (%s multicast RX)",
-		   enable ? "enable" : "disable");
-	handle = (void *) (((intptr_t) bss->nl_mgmt) ^ ELOOP_SOCKET_INVALID);
-	return nl80211_register_frame(bss, handle, type,
-				      (u8 *) "\x04\x09\x50\x6f\x9a\x1a", 6,
-				      enable);
-}
-#endif /* CONFIG_DPP */
+	if (link && link->ctx)
+		hapd = link->ctx;
 
+	cfg = hapd->iconf;
 
-static int nl80211_link_add(void *priv, u8 link_id, const u8 *addr,
-			    void *bss_ctx)
-{
-	struct i802_bss *bss = priv;
-	struct wpa_driver_nl80211_data *drv = bss->drv;
-	struct nl_msg *msg;
-	int ret;
+	if (!(msg = nl80211_bss_msg(bss, 0, NL80211_CMD_VENDOR)) ||
+		nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+		nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD, MTK_NL80211_VENDOR_SUBCMD_MU_CTRL) ||
+		!(data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA)))
+		goto fail;
 
-	wpa_printf(MSG_DEBUG, "nl80211: MLD: add link_id=%u, addr=" MACSTR,
-		   link_id, MAC2STR(addr));
+	switch (mode) {
+	case MU_CTRL_ONOFF:
+		if (hapd->iface->current_hw_info)
+			radio_idx = hapd->iface->current_hw_info->hw_idx;
 
-	if (drv->nlmode != NL80211_IFTYPE_AP) {
-		wpa_printf(MSG_DEBUG,
-			   "nl80211: MLD: cannot add link to iftype=%u",
-			   drv->nlmode);
-		return -EINVAL;
+		if (nla_put_u8(msg, MTK_VENDOR_ATTR_MU_CTRL_ONOFF, cfg->mu_onoff) ||
+		    nla_put_u8(msg, MTK_VENDOR_ATTR_MU_CTRL_RADIO_IDX, radio_idx))
+			goto fail;
+		break;
+	case MU_CTRL_UPDATE:
+		if (nla_put(msg, MTK_VENDOR_ATTR_MU_CTRL_STRUCT,
+			    sizeof(struct connac3_muru), cfg->muru_config))
+			goto fail;
+		break;
+	default:
+		wpa_printf(MSG_ERROR, "nl80211: Wrong mu mode %u!", mode);
+		ret = -EINVAL;
+		goto fail;
 	}
 
-	if (link_id >= MAX_NUM_MLD_LINKS) {
-		wpa_printf(MSG_DEBUG,
-			   "nl80211: invalid link_id=%u", link_id);
-		return -EINVAL;
-	}
+	nla_nest_end(msg, data);
 
-	if (bss->valid_links & BIT(link_id)) {
-		wpa_printf(MSG_DEBUG,
-			   "nl80211: MLD: Link %u already set", link_id);
-		return -EINVAL;
-	}
+	ret = send_and_recv_cmd(drv, msg);
+	if (ret)
+		wpa_printf(MSG_ERROR, "Failed to set mu_ctrl. ret=%d (%s)", ret, strerror(-ret));
+	return ret;
 
-	if (!bss->valid_links) {
-		/* Becoming MLD, verify we were not beaconing */
-		if (bss->flink->beacon_set) {
-			wpa_printf(MSG_DEBUG, "nl80211: BSS already beaconing");
-			return -EINVAL;
-		}
+fail:
+	nl80211_nlmsg_clear(msg);
+	nlmsg_free(msg);
+	return ret;
+}
+
+
+static int mu_dump_handler(struct nl_msg *msg, void *arg)
+{
+	u8 *mu_onoff = (u8 *) arg;
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct nlattr *tb_vendor[MTK_VENDOR_ATTR_MU_CTRL_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *nl_vend, *attr;
+
+	static const struct nla_policy
+	mu_ctrl_policy[NUM_MTK_VENDOR_ATTRS_MU_CTRL + 1] = {
+		[MTK_VENDOR_ATTR_MU_CTRL_ONOFF] = {.type = NLA_U8 },
+		[MTK_VENDOR_ATTR_MU_CTRL_DUMP] = {.type = NLA_U8 },
+	};
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+			genlmsg_attrlen(gnlh, 0), NULL);
+
+	nl_vend = tb[NL80211_ATTR_VENDOR_DATA];
+	if (!nl_vend)
+		return NL_SKIP;
+
+	nla_parse(tb_vendor, MTK_VENDOR_ATTR_MU_CTRL_MAX,
+		  nla_data(nl_vend), nla_len(nl_vend), NULL);
+
+	attr = tb_vendor[MTK_VENDOR_ATTR_MU_CTRL_DUMP];
+	if (!attr) {
+		wpa_printf(MSG_ERROR, "nl80211: cannot find MTK_VENDOR_ATTR_MU_CTRL_DUMP");
+		return NL_SKIP;
+	}
+
+	*mu_onoff = nla_get_u8(attr);
+	wpa_printf(MSG_DEBUG, "nla_get mu_onoff: %d\n", *mu_onoff);
+
+	return 0;
+}
+
+static int nl80211_mu_dump(void *priv, u8 *mu_onoff, s8 link_id)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct i802_link *link = nl80211_get_link(bss, link_id);
+	struct hostapd_data *hapd = bss->ctx;
+	struct nl_msg *msg;
+	struct nlattr *attr;
+	int ret;
+	u8 radio_idx = 0;
+
+	if (!drv->mtk_mu_vendor_cmd_avail) {
+		wpa_printf(MSG_INFO,
+			   "nl80211: Driver does not support setting mu control");
+		return 0;
+	}
+
+	if (link && link->ctx)
+		hapd = link->ctx;
+
+	if (hapd->iface->current_hw_info)
+		radio_idx = hapd->iface->current_hw_info->hw_idx;
+
+	if (!(msg = nl80211_bss_msg(bss, NLM_F_DUMP, NL80211_CMD_VENDOR)) ||
+		nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+		nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD, MTK_NL80211_VENDOR_SUBCMD_MU_CTRL) ||
+		!(attr = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA)) ||
+		nla_put_u8(msg, MTK_VENDOR_ATTR_MU_CTRL_RADIO_IDX, radio_idx)) {
+		nlmsg_free(msg);
+		return -ENOBUFS;
+	}
+
+	nla_nest_end(msg, attr);
+
+	ret = send_and_recv_resp(drv, msg, mu_dump_handler, mu_onoff);
+
+	if(ret){
+		wpa_printf(MSG_ERROR, "Failed to get mu_onoff. ret=%d (%s)", ret, strerror(-ret));
+	}
+
+	return ret;
+}
+static int nl80211_beacon_ctrl(void *priv, u8 beacon_mode)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct nlattr *data;
+	int ret;
+
+	if (!drv->mtk_beacon_ctrl_vendor_cmd_avail) {
+		wpa_printf(MSG_ERROR,
+			   "nl80211: Driver does not support setting beacon control");
+		return 0;
+	}
+
+	if (!(msg = nl80211_drv_msg(drv, 0, NL80211_CMD_VENDOR)) ||
+		nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+		nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD, MTK_NL80211_VENDOR_SUBCMD_BEACON_CTRL) ||
+		!(data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA)) ||
+		nla_put_u8(msg, MTK_VENDOR_ATTR_BEACON_CTRL_MODE, beacon_mode)) {
+		nlmsg_free(msg);
+		return -ENOBUFS;
+	}
+
+	nla_nest_end(msg, data);
+
+	ret = send_and_recv_cmd(drv, msg);
+
+	if (ret)
+		wpa_printf(MSG_ERROR, "Failed to set beacon_ctrl. ret=%d (%s)", ret, strerror(-ret));
+
+	return ret;
+}
+
+#endif /* CONFIG_IEEE80211AX */
+
+
+#ifdef CONFIG_DPP
+static int nl80211_dpp_listen(void *priv, bool enable)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	u16 type = (WLAN_FC_TYPE_MGMT << 2) | (WLAN_FC_STYPE_ACTION << 4);
+	struct nl_sock *handle;
+
+	if (!drv->multicast_registrations || !bss->nl_mgmt)
+		return 0; /* cannot do more than hope broadcast RX works */
+
+	wpa_printf(MSG_DEBUG,
+		   "nl80211: Update DPP Public Action frame registration (%s multicast RX)",
+		   enable ? "enable" : "disable");
+	handle = (void *) (((intptr_t) bss->nl_mgmt) ^ ELOOP_SOCKET_INVALID);
+	return nl80211_register_frame(bss, handle, type,
+				      (u8 *) "\x04\x09\x50\x6f\x9a\x1a", 6,
+				      enable);
+}
+#endif /* CONFIG_DPP */
+
+
+static int nl80211_link_add(void *priv, u8 link_id, const u8 *addr,
+			    void *bss_ctx)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	int ret;
+
+	wpa_printf(MSG_DEBUG, "nl80211: MLD: add link_id=%u, addr=" MACSTR,
+		   link_id, MAC2STR(addr));
+
+	if (drv->nlmode != NL80211_IFTYPE_AP) {
+		wpa_printf(MSG_DEBUG,
+			   "nl80211: MLD: cannot add link to iftype=%u",
+			   drv->nlmode);
+		return -EINVAL;
+	}
+
+	if (link_id >= MAX_NUM_MLD_LINKS) {
+		wpa_printf(MSG_DEBUG,
+			   "nl80211: invalid link_id=%u", link_id);
+		return -EINVAL;
+	}
+
+	if (bss->valid_links & BIT(link_id)) {
+		wpa_printf(MSG_DEBUG,
+			   "nl80211: MLD: Link %u already set", link_id);
+		return -EINVAL;
+	}
+
+	if (!bss->valid_links) {
+		/* Becoming MLD, verify we were not beaconing */
+		if (bss->flink->beacon_set) {
+			wpa_printf(MSG_DEBUG, "nl80211: BSS already beaconing");
+			return -EINVAL;
+		}
+	}
+
+	msg = nl80211_bss_msg(bss, 0, NL80211_CMD_ADD_LINK);
+	if (!msg ||
+	    nla_put_u8(msg, NL80211_ATTR_MLO_LINK_ID, link_id) ||
+	    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr)) {
+		nlmsg_free(msg);
+		return -ENOBUFS;
+	}
+
+	ret = send_and_recv_cmd(drv, msg);
+	if (ret) {
+		wpa_printf(MSG_DEBUG, "nl80211: add link failed. ret=%d (%s)",
+			   ret, strerror(-ret));
+		return ret;
+	}
+
+	os_memcpy(bss->links[link_id].addr, addr, ETH_ALEN);
+
+	/* The new link is the first one, make it the default */
+	if (!bss->valid_links)
+		bss->flink = &bss->links[link_id];
+
+	bss->valid_links |= BIT(link_id);
+	bss->links[link_id].ctx = bss_ctx;
+
+	wpa_printf(MSG_DEBUG, "nl80211: MLD: valid_links=0x%04x on %s",
+		   bss->valid_links, bss->ifname);
+
+	if (drv->rtnl_sk)
+		rtnl_neigh_add_fdb_entry(bss, addr, true);
+
+	return 0;
+}
+
+
+#ifdef CONFIG_IEEE80211BE
+static int wpa_driver_nl80211_link_sta_remove(void *priv, u8 link_id,
+					      const u8 *addr)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	int ret;
+
+	if (!(bss->valid_links & BIT(link_id)))
+		return -ENOLINK;
+
+	if (!(msg = nl80211_bss_msg(bss, 0, NL80211_CMD_REMOVE_LINK_STA)) ||
+	    nla_put(msg, NL80211_ATTR_MLD_ADDR, ETH_ALEN, addr) ||
+	    nla_put_u8(msg, NL80211_ATTR_MLO_LINK_ID, link_id)) {
+		nlmsg_free(msg);
+		return -ENOBUFS;
+	}
+
+	ret = send_and_recv_cmd(drv, msg);
+	wpa_printf(MSG_DEBUG,
+		   "nl80211: link_sta_remove -> REMOVE_LINK_STA on link_id %u from MLD STA "
+		   MACSTR ", from %s --> %d (%s)",
+		   link_id, MAC2STR(addr), bss->ifname, ret, strerror(-ret));
+
+	return ret;
+}
+#endif /* CONFIG_IEEE80211BE */
+
+
+#ifdef CONFIG_TESTING_OPTIONS
+
+static int testing_nl80211_register_frame(void *priv, u16 type,
+					  const u8 *match, size_t match_len,
+					  bool multicast)
+{
+	struct i802_bss *bss = priv;
+	struct nl_sock *handle;
+
+	if (!bss->nl_mgmt)
+		return -1;
+	handle = (void *) (((intptr_t) bss->nl_mgmt) ^ ELOOP_SOCKET_INVALID);
+	return nl80211_register_frame(bss, handle, type, match, match_len,
+				      multicast);
+}
+
+
+static int testing_nl80211_radio_disable(void *priv, int disabled)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+
+	/* For now, this is supported only partially in station mode with
+	 * SME-in-wpa_supplicant case where the NL80211_ATTR_LOCAL_STATE_CHANGE
+	 * attribute can be used to avoid sending out the Deauthentication frame
+	 * to the currently associated AP. */
+
+	if (!disabled)
+		return 0;
+
+	if (!(drv->capa.flags & WPA_DRIVER_FLAGS_SME))
+		return -1;
+
+	if (!drv->associated)
+		return 0;
+
+	return wpa_driver_nl80211_mlme(drv, drv->bssid,
+				       NL80211_CMD_DEAUTHENTICATE,
+				       WLAN_REASON_PREV_AUTH_NOT_VALID, 1,
+				       drv->first_bss);
+}
+
+#endif /* CONFIG_TESTING_OPTIONS */
+
+static int nl80211_configure_edcca_enable(void *priv,
+					  const u8 edcca_enable,
+					  const s8 edcca_compensation)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct nlattr *data;
+	int ret;
+
+	if (!drv->mtk_edcca_vendor_cmd_avail) {
+		wpa_printf(MSG_INFO,
+			   "nl80211: Driver does not support setting EDCCA enable");
+		return 0;
+	}
+
+	if (!(msg = nl80211_drv_msg(drv, 0, NL80211_CMD_VENDOR)) ||
+	    nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+	    nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD,
+			MTK_NL80211_VENDOR_SUBCMD_EDCCA_CTRL) ||
+	    !(data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA)) ||
+	    nla_put_u8(msg, MTK_VENDOR_ATTR_EDCCA_CTRL_MODE, EDCCA_CTRL_SET_EN) ||
+	    nla_put_u8(msg, MTK_VENDOR_ATTR_EDCCA_CTRL_PRI20_VAL, edcca_enable) ||
+	    nla_put_u8(msg, MTK_VENDOR_ATTR_EDCCA_CTRL_COMPENSATE,
+		edcca_compensation)) {
+		wpa_printf (MSG_ERROR, "Prepare nl80211 msg fail");
+		nlmsg_free(msg);
+		return -ENOBUFS;
+	}
+	nla_nest_end(msg, data);
+	ret = send_and_recv_cmd(drv, msg);
+	if (ret) {
+		wpa_printf(MSG_ERROR, "Failed to configure EDCCA enable. ret=%d (%s) ",
+			   ret, strerror(-ret));
+	}
+	return ret;
+}
+
+static int nl80211_configure_edcca_threshold(void *priv, const int *threshold)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct nlattr *data;
+	int ret;
+
+	if (!drv->mtk_edcca_vendor_cmd_avail) {
+		wpa_printf(MSG_INFO,
+			   "nl80211: Driver does not support setting EDCCA threshold");
+		return 0;
+	}
+
+	if (!threshold) {
+		wpa_printf(MSG_INFO,
+			   "nl80211: Input EDCCA threshold is empty!");
+		return 0;
+	}
+
+	if (!(msg = nl80211_drv_msg(drv, 0, NL80211_CMD_VENDOR)) ||
+	    nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+	    nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD,
+			MTK_NL80211_VENDOR_SUBCMD_EDCCA_CTRL) ||
+	    !(data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA)) ||
+	    nla_put_u8(msg, MTK_VENDOR_ATTR_EDCCA_CTRL_MODE, EDCCA_CTRL_SET_THRES) ||
+	    nla_put_u8(msg, MTK_VENDOR_ATTR_EDCCA_CTRL_PRI20_VAL, threshold[0] & 0xff) ||
+	    nla_put_u8(msg, MTK_VENDOR_ATTR_EDCCA_CTRL_SEC40_VAL, threshold[1] & 0xff) ||
+	    nla_put_u8(msg, MTK_VENDOR_ATTR_EDCCA_CTRL_SEC80_VAL, threshold[2] & 0xff) ||
+	    nla_put_u8(msg, MTK_VENDOR_ATTR_EDCCA_CTRL_SEC160_VAL, threshold[3] & 0xff)) {
+		wpa_printf (MSG_ERROR, "Prepare nl80211 msg fail");
+		nlmsg_free(msg);
+		return -ENOBUFS;
+	}
+	nla_nest_end(msg, data);
+	ret = send_and_recv_cmd(drv, msg);
+	if (ret) {
+		wpa_printf(MSG_ERROR, "Failed to configure EDCCA threshold. ret=%d (%s) ",
+			   ret, strerror(-ret));
+	}
+	return ret;
+}
+
+
+static int edcca_info_handler(struct nl_msg *msg, void *arg)
+{
+	u8 *info = (u8 *) arg;
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct nlattr *tb_vendor[MTK_VENDOR_ATTR_EDCCA_DUMP_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *nl_vend, *attr;
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	nl_vend = tb[NL80211_ATTR_VENDOR_DATA];
+	if (!nl_vend)
+		return NL_SKIP;
+
+	nla_parse(tb_vendor, MTK_VENDOR_ATTR_EDCCA_DUMP_MAX,
+		  nla_data(nl_vend), nla_len(nl_vend), NULL);
+
+	attr = tb_vendor[MTK_VENDOR_ATTR_EDCCA_DUMP_PRI20_VAL];
+	if (!attr) {
+		wpa_printf(MSG_ERROR, "nl80211: MTK_VENDOR_ATTR_EDCCA_DUMP_PRI20_VAL");
+		return NL_SKIP;
+	}
+
+	*info++ = nla_get_u8(attr);
+
+	attr = tb_vendor[MTK_VENDOR_ATTR_EDCCA_DUMP_SEC40_VAL];
+	if (!attr) {
+		wpa_printf(MSG_ERROR, "nl80211: MTK_VENDOR_ATTR_EDCCA_DUMP_SEC40_VAL");
+		return NL_SKIP;
+	}
+
+	*info++ = nla_get_u8(attr);
+
+	attr = tb_vendor[MTK_VENDOR_ATTR_EDCCA_DUMP_SEC80_VAL];
+	if (!attr) {
+		wpa_printf(MSG_ERROR, "nl80211: MTK_VENDOR_ATTR_EDCCA_DUMP_SEC80_VAL");
+		return NL_SKIP;
+	}
+
+	*info++ = nla_get_u8(attr);
+
+	attr = tb_vendor[MTK_VENDOR_ATTR_EDCCA_DUMP_SEC160_VAL];
+	if (!attr) {
+		wpa_printf(MSG_ERROR, "nl80211: MTK_VENDOR_ATTR_EDCCA_DUMP_SEC160_VAL");
+		return NL_SKIP;
+	}
+
+	*info = nla_get_u8(attr);
+	return NL_SKIP;
+}
+
+
+static int nl80211_get_edcca(void *priv, const u8 mode, u8 *value)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct nlattr *data;
+	int ret;
+
+	if (!drv->mtk_edcca_vendor_cmd_avail) {
+		wpa_printf(MSG_INFO,
+			   "nl80211: Driver does not support setting EDCCA threshold");
+		return 0;
+	}
+
+	if (!(msg = nl80211_drv_msg(drv, NLM_F_DUMP, NL80211_CMD_VENDOR)) ||
+	    nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+	    nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD,
+			MTK_NL80211_VENDOR_SUBCMD_EDCCA_CTRL) ||
+	    !(data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA | NLA_F_NESTED)) ||
+	    nla_put_u8(msg, MTK_VENDOR_ATTR_EDCCA_CTRL_MODE, mode)) {
+		wpa_printf (MSG_ERROR, "Prepare nl80211 msg fail");
+		nlmsg_free(msg);
+		return -ENOBUFS;
+	}
+	nla_nest_end(msg, data);
+	ret = send_and_recv_resp(drv, msg, edcca_info_handler, value);
+	if (ret) {
+		wpa_printf(MSG_ERROR, "Failed to get EDCCA configuration. ret=%d (%s)",
+			   ret, strerror(-ret));
+	}
+	return ret;
+}
+
+static int nl80211_enable_three_wire(void *priv, const u8 three_wire_enable)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	/* Prepare nl80211 cmd */
+	struct nl_msg *msg;
+	struct nlattr *data;
+	int ret;
+
+	if (!drv->mtk_3wire_vendor_cmd_avail) {
+		wpa_printf(MSG_INFO,
+			   "nl80211: Driver does not support setting three wire control");
+		return 0;
+	}
+
+	if (!(msg = nl80211_drv_msg(drv, 0, NL80211_CMD_VENDOR)) ||
+	    nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+	    nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD,
+			MTK_NL80211_VENDOR_SUBCMD_3WIRE_CTRL) ||
+	    !(data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA)) ||
+	    nla_put_u8(msg, MTK_VENDOR_ATTR_3WIRE_CTRL_MODE, three_wire_enable)) {
+		nlmsg_free(msg);
+		return -ENOBUFS;
+	}
+	nla_nest_end(msg, data);
+	ret = send_and_recv_cmd(drv, msg);
+	if (ret) {
+		wpa_printf(MSG_ERROR, "Failed to enable three wire. ret=%d (%s) ",
+			   ret, strerror(-ret));
+	}
+	return ret;
+}
+
+static struct hostapd_multi_hw_info *
+wpa_driver_get_multi_hw_info(void *priv, unsigned int *num_multi_hws)
+{
+	struct i802_bss *bss = priv;
+
+	return nl80211_get_multi_hw_info(bss, num_multi_hws);
+}
+
+static int nl80211_ibf_enable(void *priv, u8 ibf_enable)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct nlattr *data;
+	int ret;
+
+	if (!drv->mtk_ibf_vendor_cmd_avail) {
+		wpa_printf(MSG_INFO,
+			   "nl80211: Driver does not support setting ibf control");
+		return 0;
+	}
+
+	msg = nl80211_drv_msg(drv, 0, NL80211_CMD_VENDOR);
+	if (!msg)
+		goto fail;
+
+	if (nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+		nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD, MTK_NL80211_VENDOR_SUBCMD_IBF_CTRL))
+		goto fail;
+
+	data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA);
+	if (!data)
+		goto fail;
+
+	nla_put_u8(msg, MTK_VENDOR_ATTR_IBF_CTRL_ENABLE, ibf_enable);
+
+	nla_nest_end(msg, data);
+	ret = send_and_recv_cmd(drv, msg);
+	if (ret) {
+		wpa_printf(MSG_ERROR, "Failed to set ibf_enable. ret=%d (%s)", ret, strerror(-ret));
+	}
+
+	return ret;
+
+fail:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+static int ibf_dump_handler(struct nl_msg *msg, void *arg)
+{
+	u8 *ibf_enable = (u8 *) arg;
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct nlattr *tb_vendor[MTK_VENDOR_ATTR_IBF_DUMP_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *nl_vend, *attr;
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+			genlmsg_attrlen(gnlh, 0), NULL);
+
+	nl_vend = tb[NL80211_ATTR_VENDOR_DATA];
+	if (!nl_vend)
+		return NL_SKIP;
+
+	nla_parse(tb_vendor, MTK_VENDOR_ATTR_IBF_DUMP_MAX,
+			nla_data(nl_vend), nla_len(nl_vend), NULL);
+
+	attr = tb_vendor[MTK_VENDOR_ATTR_IBF_DUMP_ENABLE];
+	if (!attr) {
+		wpa_printf(MSG_ERROR, "nl80211: cannot find MTK_VENDOR_ATTR_IBF_DUMP_ENABLE");
+		return NL_SKIP;
+	}
+
+	*ibf_enable = nla_get_u8(attr);
+
+	return NL_SKIP;
+}
+
+static int
+nl80211_ibf_dump(void *priv, u8 *ibf_enable)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct nlattr *data;
+	int ret;
+
+	msg = nl80211_drv_msg(drv, NLM_F_DUMP, NL80211_CMD_VENDOR);
+	if (!msg)
+		goto fail;
+
+	if (nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+		nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD, MTK_NL80211_VENDOR_SUBCMD_IBF_CTRL))
+		goto fail;
+
+	data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA | NLA_F_NESTED);
+	if (!data)
+		goto fail;
+
+	nla_nest_end(msg, data);
+
+	ret = send_and_recv_resp(drv, msg, ibf_dump_handler, ibf_enable);
+
+	if (ret) {
+		wpa_printf(MSG_ERROR, "Failed to dump ibf_enable. ret=%d (%s)", ret, strerror(-ret));
+	}
+
+	return ret;
+
+fail:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+static int nl80211_enable_amsdu(void *priv, u8 amsdu)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct nlattr *data;
+	int ret;
+
+	if (!drv->mtk_wireless_vendor_cmd_avail) {
+		wpa_printf(MSG_INFO,
+			   "nl80211: Driver does not support setting ap wireless control");
+		return 0;
+	}
+
+	msg = nl80211_bss_msg(bss, 0, NL80211_CMD_VENDOR);
+	if (!msg)
+		goto fail;
+
+	if (nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+		nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD, MTK_NL80211_VENDOR_SUBCMD_WIRELESS_CTRL))
+		goto fail;
+
+	data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA);
+	if (!data)
+		goto fail;
+
+	nla_put_u8(msg, MTK_VENDOR_ATTR_WIRELESS_CTRL_AMSDU, amsdu);
+
+	nla_nest_end(msg, data);
+	ret = send_and_recv_cmd(drv, msg);
+	if (ret) {
+		wpa_printf(MSG_ERROR, "Failed to set amsdu. ret=%d (%s)", ret, strerror(-ret));
+	}
+
+	return ret;
+
+fail:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+static int dump_amsdu_handler(struct nl_msg *msg, void *arg)
+{
+	u8 *amsdu = (u8 *) arg;
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct nlattr *tb_vendor[MTK_VENDOR_ATTR_WIRELESS_DUMP_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *nl_vend, *attr_amsdu;
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+			genlmsg_attrlen(gnlh, 0), NULL);
+
+	nl_vend = tb[NL80211_ATTR_VENDOR_DATA];
+	if (!nl_vend)
+		return NL_SKIP;
+
+	nla_parse(tb_vendor, MTK_VENDOR_ATTR_WIRELESS_DUMP_MAX,
+			nla_data(nl_vend), nla_len(nl_vend), NULL);
+
+	attr_amsdu = tb_vendor[MTK_VENDOR_ATTR_WIRELESS_DUMP_AMSDU];
+	if (!attr_amsdu ){
+		wpa_printf(MSG_ERROR, "nl80211: cannot find vendor attributes");
+		return NL_SKIP;
+	}
+
+	*amsdu = nla_get_u8(attr_amsdu);
+
+	return NL_SKIP;
+}
+
+static int
+nl80211_dump_amsdu(void *priv, u8 *amsdu)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct nlattr *data;
+	int ret;
+
+	if (!drv->mtk_wireless_vendor_cmd_avail) {
+		wpa_printf(MSG_INFO,
+				 "nl80211: Driver does not support ap_wireless control");
+		return 0;
+	}
+
+	msg = nl80211_bss_msg(bss, NLM_F_DUMP, NL80211_CMD_VENDOR);
+	if (!msg)
+		goto fail;
+
+	if (nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+		nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD, MTK_NL80211_VENDOR_SUBCMD_WIRELESS_CTRL))
+		goto fail;
+
+	data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA);
+	if (!data)
+		goto fail;
+
+	nla_nest_end(msg, data);
+
+	ret = send_and_recv_resp(drv, msg, dump_amsdu_handler, amsdu);
+
+	if (ret) {
+		wpa_printf(MSG_ERROR, "Failed to dump amsdu. ret=%d (%s)", ret, strerror(-ret));
+	}
+
+	return ret;
+
+fail:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+static int nl80211_get_aval_color_bmp_handler(struct nl_msg *msg, void *arg)
+{
+	u64 *aval_color_bmp = arg;
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct nlattr *tb_vendor[MTK_VENDOR_ATTR_BSS_COLOR_CTRL_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *nl_vend, *attr;
+
+	static const struct nla_policy
+	bss_color_ctrl_policy[NUM_MTK_VENDOR_ATTRS_BSS_COLOR_CTRL + 1] = {
+		[MTK_VENDOR_ATTR_AVAL_BSS_COLOR_BMP] = { .type = NLA_U64 },
+	};
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+			genlmsg_attrlen(gnlh, 0), NULL);
+
+	nl_vend = tb[NL80211_ATTR_VENDOR_DATA];
+	if (!nl_vend)
+		return NL_SKIP;
+
+	nla_parse(tb_vendor, MTK_VENDOR_ATTR_BSS_COLOR_CTRL_MAX,
+			nla_data(nl_vend), nla_len(nl_vend), NULL);
+
+	*aval_color_bmp = nla_get_u64(tb_vendor[MTK_VENDOR_ATTR_AVAL_BSS_COLOR_BMP]);
+
+	return 0;
+}
+
+static int nl80211_get_aval_color_bmp(void *priv, u64 *aval_color_bmp)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct nlattr *attr;
+	int ret;
+
+	if (!drv->mtk_bss_color_vendor_cmd_avail) {
+		wpa_printf(MSG_INFO,
+			   "nl80211: Driver does not support BSS COLOR vendor cmd");
+		return 0;
+	}
+
+	if (!(msg = nl80211_drv_msg(drv, NLM_F_DUMP, NL80211_CMD_VENDOR)) ||
+	    nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+	    nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD,
+			MTK_NL80211_VENDOR_SUBCMD_BSS_COLOR_CTRL))
+		return -ENOBUFS;
+
+	attr = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA);
+	if (!attr) {
+		nlmsg_free(msg);
+		return -1;
+	}
+
+	nla_nest_end(msg, attr);
+
+	ret = send_and_recv_resp(drv, msg, nl80211_get_aval_color_bmp_handler, aval_color_bmp);
+
+	if (ret) {
+		wpa_printf(MSG_ERROR, "Failed to send BSS COLOR vendor cmd. ret=%d (%s) ",
+			   ret, strerror(-ret));
+	}
+	return ret;
+}
+
+static int nl80211_ap_wireless(void *priv, u8 sub_vendor_id, int value, s8 link_id)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct nlattr *data;
+	int ret;
+
+	if (!drv->mtk_wireless_vendor_cmd_avail) {
+		wpa_printf(MSG_INFO,
+			   "nl80211: Driver does not support setting ap wireless control");
+		return 0;
+	}
+
+	msg = nl80211_bss_msg(bss, 0, NL80211_CMD_VENDOR);
+	if (!msg)
+		goto fail;
+
+	if (nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+		nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD, MTK_NL80211_VENDOR_SUBCMD_WIRELESS_CTRL))
+		goto fail;
+
+	data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA);
+	if (!data)
+		goto fail;
+
+	if (sub_vendor_id == MTK_VENDOR_ATTR_WIRELESS_CTRL_BA_BUFFER_SIZE)
+		nla_put_u16(msg, sub_vendor_id, (u16) value);
+	else
+		nla_put_u8(msg, sub_vendor_id, (u8) value);
+
+	if (link_id > -1)
+		nla_put_u8(msg, MTK_VENDOR_ATTR_WIRELESS_CTRL_LINK_ID, link_id);
+
+	nla_nest_end(msg, data);
+	ret = send_and_recv_cmd(drv, msg);
+	if (ret)
+		wpa_printf(MSG_ERROR, "Failed to set ap_wireless. ret=%d (%s)", ret, strerror(-ret));
+
+	return ret;
+
+fail:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+static int nl80211_ap_rfeatures(void *priv, u8 sub_vendor_id, int value, s8 link_id)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct nlattr *data;
+	int ret;
+
+	if (!drv->mtk_rfeatures_vendor_cmd_avail) {
+		wpa_printf(MSG_INFO,
+			   "nl80211: Driver does not support setting ap rfeatures control");
+		return 0;
+	}
+
+	msg = nl80211_bss_msg(bss, 0, NL80211_CMD_VENDOR);
+	if (!msg)
+		goto fail;
+
+	if (nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+		nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD, MTK_NL80211_VENDOR_SUBCMD_RFEATURE_CTRL))
+		goto fail;
+
+	data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA);
+	if (!data)
+		goto fail;
+
+	nla_put_u8(msg, sub_vendor_id, (u8) value);
+
+	if (link_id > -1)
+		nla_put_u8(msg, MTK_VENDOR_ATTR_RFEATURE_CTRL_LINK_ID, link_id);
+
+	nla_nest_end(msg, data);
+
+	ret = send_and_recv_cmd(drv, msg);
+	if (ret)
+		wpa_printf(MSG_ERROR, "Failed to set rf_features. ret=%d (%s)", ret, strerror(-ret));
+
+	return ret;
+
+fail:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+static int nl80211_ap_trigtype(void *priv, u8 enable, u8 type, s8 link_id)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct nlattr *data, *data2;
+	int ret;
+
+	if (!drv->mtk_rfeatures_vendor_cmd_avail) {
+		wpa_printf(MSG_INFO,
+			   "nl80211: Driver does not support setting ap rfeatures control");
+		return 0;
+	}
+
+	msg = nl80211_bss_msg(bss, 0, NL80211_CMD_VENDOR);
+	if (!msg)
+		goto fail;
+
+	if (nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+		nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD, MTK_NL80211_VENDOR_SUBCMD_RFEATURE_CTRL))
+		goto fail;
+
+	data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA);
+	if (!data)
+		goto fail;
+
+	if (link_id > -1)
+		nla_put_u8(msg, MTK_VENDOR_ATTR_RFEATURE_CTRL_LINK_ID, link_id);
+
+	data2 = nla_nest_start(msg, MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE_CFG);
+	if (!data2)
+		goto fail;
+
+	nla_put_u8(msg, MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE_EN, enable);
+	nla_put_u8(msg, MTK_VENDOR_ATTR_RFEATURE_CTRL_TRIG_TYPE, type);
+
+	nla_nest_end(msg, data2);
+	nla_nest_end(msg, data);
+
+	ret = send_and_recv_cmd(drv, msg);
+	if (ret)
+		wpa_printf(MSG_ERROR, "Failed to set trig_type. ret=%d (%s)", ret, strerror(-ret));
+
+	return ret;
+
+fail:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+static int
+nl80211_amnt_set(void *priv, u8 amnt_idx, u8 *amnt_sta_mac, s8 link_id)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct nlattr *data;
+	void *tb1;
+	int ret;
+
+	if (!drv->mtk_amnt_vendor_cmd_avail) {
+		wpa_printf(MSG_ERROR,
+			"nl80211: Driver does not support air monitor");
+		return 0;
+	}
+
+	msg = nl80211_drv_msg(drv, 0, NL80211_CMD_VENDOR);
+	if (!msg)
+		goto fail;
+
+	if (nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+			nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD,
+			MTK_NL80211_VENDOR_SUBCMD_AMNT_CTRL))
+		goto fail;
+
+	data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA | NLA_F_NESTED);
+	if (!data)
+		goto fail;
+
+	nla_put_u8(msg, MTK_VENDOR_ATTR_AMNT_CTRL_LINK_ID, link_id);
+	tb1 = nla_nest_start(msg, MTK_VENDOR_ATTR_AMNT_CTRL_SET);
+	if (!tb1)
+		goto fail;
+
+	nla_put_u8(msg, MTK_VENDOR_ATTR_AMNT_SET_INDEX, amnt_idx);
+
+	nla_put(msg, MTK_VENDOR_ATTR_AMNT_SET_MACADDR, ETH_ALEN, amnt_sta_mac);
+
+	nla_nest_end(msg, tb1);
+	nla_nest_end(msg, data);
+
+	ret = send_and_recv_cmd(drv, msg);
+
+	if (ret)
+		wpa_printf(MSG_ERROR, "Failed to set air monitor. ret=%d (%s)",
+			ret, strerror(-ret));
+
+	return ret;
+
+fail:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+
+}
+
+static int
+mt76_amnt_dump_cb(struct nl_msg *msg, void *arg)
+{
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct nlattr *tb1[NUM_MTK_VENDOR_ATTRS_AMNT_CTRL];
+	struct nlattr *tb2[NUM_MTK_VENDOR_ATTRS_AMNT_DUMP];
+	struct nlattr *attr, *cur, *data;
+	struct amnt_data *res;
+	int len = 0, rem;
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct amnt_resp_data *amnt_dump = (struct amnt_resp_data *)arg;
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		genlmsg_attrlen(gnlh, 0), NULL);
+
+	attr = tb[NL80211_ATTR_VENDOR_DATA];
+	if (!attr)
+		return NL_SKIP;
+
+	nla_parse_nested(tb1, MTK_VENDOR_ATTR_AMNT_CTRL_MAX,
+			attr, amnt_ctrl_policy);
+
+	if (!tb1[MTK_VENDOR_ATTR_AMNT_CTRL_DUMP])
+		return NL_SKIP;
+
+	nla_parse_nested(tb2, NUM_MTK_VENDOR_ATTRS_AMNT_DUMP,
+			tb1[MTK_VENDOR_ATTR_AMNT_CTRL_DUMP], amnt_dump_policy);
+
+	if (!tb2[MTK_VENDOR_ATTR_AMNT_DUMP_LEN])
+		return NL_SKIP;
+
+	len = nla_get_u8(tb2[MTK_VENDOR_ATTR_AMNT_DUMP_LEN]);
+	if (!len)
+		return 0;
+
+	if (!tb2[MTK_VENDOR_ATTR_AMNT_DUMP_RESULT])
+		return NL_SKIP;
+
+	data = tb2[MTK_VENDOR_ATTR_AMNT_DUMP_RESULT];
+
+	nla_for_each_nested(cur, data, rem) {
+		if (amnt_dump->sta_num >= AIR_MONITOR_MAX_ENTRY)
+			return NL_SKIP;
+		res = (struct amnt_data *) nla_data(cur);
+		wpa_printf(MSG_ERROR, "[vendor] amnt_idx: %d, "
+			"addr="MACSTR", "
+			"rssi=%d/%d/%d/%d, last_seen=%u\n",
+			res->idx,
+			MAC2STR(res->addr),
+			res->rssi[0], res->rssi[1], res->rssi[2],
+			res->rssi[3], res->last_seen);
+		os_memcpy(&amnt_dump->resp_data[amnt_dump->sta_num], res,
+			sizeof(struct amnt_data));
+		amnt_dump->sta_num++;
+	}
+	return 0;
+}
+
+static int
+nl80211_amnt_dump(void *priv, u8 amnt_idx, u8 *dump_buf, s8 link_id)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct nlattr *data;
+	void *tb1;
+	int ret;
+
+	if (!drv->mtk_amnt_vendor_cmd_avail) {
+		wpa_printf(MSG_INFO,
+			"nl80211: Driver does not support air monitor");
+		return 0;
+	}
+
+	msg = nl80211_bss_msg(bss, NLM_F_DUMP, NL80211_CMD_VENDOR);
+	if (!msg)
+		goto fail;
+
+	if (nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+			nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD,
+			MTK_NL80211_VENDOR_SUBCMD_AMNT_CTRL))
+		goto fail;
+
+	data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA | NLA_F_NESTED);
+	if (!data)
+		goto fail;
+
+	nla_put_u8(msg, MTK_VENDOR_ATTR_AMNT_CTRL_LINK_ID, link_id);
+	tb1 = nla_nest_start(msg, MTK_VENDOR_ATTR_AMNT_CTRL_DUMP | NLA_F_NESTED);
+	if (!tb1)
+		goto fail;
+
+	nla_put_u8(msg, MTK_VENDOR_ATTR_AMNT_DUMP_INDEX, amnt_idx);
+
+	nla_nest_end(msg, tb1);
+	nla_nest_end(msg, data);
+
+	ret = send_and_recv_resp(drv, msg, mt76_amnt_dump_cb, dump_buf);
+
+	if (ret)
+		wpa_printf(MSG_ERROR, "Failed to Dump air monitor. ret=%d (%s)",
+			   ret, strerror(-ret));
+
+	return ret;
+
+fail:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+static int nl80211_background_radar_mode(void *priv, const u8 background_radar_mode)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	/* Prepare nl80211 cmd */
+	struct nl_msg *msg;
+	struct nlattr *data;
+	int ret;
+
+	if (!drv->mtk_background_radar_vendor_cmd_avail) {
+		wpa_printf(MSG_INFO,
+			   "nl80211: Driver does not support setting background radar mode");
+		return 0;
+	}
+
+	if (!(msg = nl80211_drv_msg(drv, 0, NL80211_CMD_VENDOR)) ||
+	    nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+	    nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD,
+			MTK_NL80211_VENDOR_SUBCMD_BACKGROUND_RADAR_CTRL) ||
+	    !(data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA)) ||
+	    nla_put_u8(msg, MTK_VENDOR_ATTR_BACKGROUND_RADAR_CTRL_MODE, background_radar_mode)) {
+		nlmsg_free(msg);
+		return -ENOBUFS;
+	}
+	nla_nest_end(msg, data);
+	ret = send_and_recv_cmd(drv, msg);
+	if (ret) {
+		wpa_printf(MSG_ERROR, "Failed to set background radar mode. ret=%d (%s) ",
+			   ret, strerror(-ret));
+	}
+	return ret;
+}
+
+static int nl80211_pp_mode_set(void *priv, const u8 pp_mode, s8 link_id, u16 punct_bitmap)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct nlattr *data;
+	int ret;
+
+	if (!drv->mtk_pp_vendor_cmd_avail) {
+		wpa_printf(MSG_DEBUG,
+			   "nl80211: Driver does not support setting preamble puncture");
+		return 0;
 	}
 
-	msg = nl80211_bss_msg(bss, 0, NL80211_CMD_ADD_LINK);
-	if (!msg ||
-	    nla_put_u8(msg, NL80211_ATTR_MLO_LINK_ID, link_id) ||
-	    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, addr)) {
-		nlmsg_free(msg);
-		return -ENOBUFS;
+	msg = nl80211_bss_msg(bss, 0, NL80211_CMD_VENDOR);
+	if (!msg)
+		goto fail;
+
+	if (nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+	    nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD,
+			MTK_NL80211_VENDOR_SUBCMD_PP_CTRL))
+		goto fail;
+
+	data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA);
+	if (!data)
+		goto fail;
+
+	if (link_id > -1)
+		nla_put_u8(msg, MTK_VENDOR_ATTR_PP_LINK_ID, link_id);
+	nla_put_u8(msg, MTK_VENDOR_ATTR_PP_MODE, pp_mode);
+	nla_put_u16(msg, MTK_VENDOR_ATTR_PP_BITMAP, punct_bitmap);
+
+	nla_nest_end(msg, data);
+	ret = send_and_recv_cmd(drv, msg);
+
+	if (ret)
+		wpa_printf(MSG_ERROR, "Failed to set pp_enable. ret=%d (%s)",
+			   ret, strerror(-ret));
+
+	return ret;
+
+fail:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+#ifdef CONFIG_IEEE80211BE
+static int nl80211_get_mld_addr(void *priv, u8 *addr)
+{
+	struct i802_bss *bss = priv;
+
+	os_memcpy(addr, bss->addr, ETH_ALEN);
+
+	return 0;
+}
+
+static int nl80211_set_eml_omn(void *priv, u8 link_id, u8 *addr,
+			       struct eml_omn_element *omn_ie)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct nlattr *data;
+	int ret = -ENOBUFS;
+
+	if (!drv->mtk_eml_vendor_cmd_avail) {
+		wpa_printf(MSG_ERROR,
+			   "nl80211: Driver does not support setting EML control");
+		return 0;
 	}
 
+	if (!(msg = nl80211_drv_msg(drv, 0, NL80211_CMD_VENDOR)) ||
+	    nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+	    nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD,
+			MTK_NL80211_VENDOR_SUBCMD_EML_CTRL) ||
+	    !(data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA)) ||
+	    nla_put_u8(msg, MTK_VENDOR_ATTR_EML_LINK_ID, link_id) ||
+	    nla_put(msg, MTK_VENDOR_ATTR_EML_STA_ADDR, ETH_ALEN, addr) ||
+	    nla_put(msg, MTK_VENDOR_ATTR_EML_CTRL_STRUCT,
+		    sizeof(struct eml_omn_element), omn_ie))
+		goto fail;
+
+
+	nla_nest_end(msg, data);
 	ret = send_and_recv_cmd(drv, msg);
-	if (ret) {
-		wpa_printf(MSG_DEBUG, "nl80211: add link failed. ret=%d (%s)",
+
+	if (ret)
+		wpa_printf(MSG_ERROR, "Failed to set EML OMN ctrl. ret = %d (%s)",
 			   ret, strerror(-ret));
-		return ret;
+
+	return ret;
+
+fail:
+	nlmsg_free(msg);
+	return ret;
+}
+
+static int
+nl80211_set_scs(void *priv, struct hostapd_scs_desc_info *info, u8 link_id)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct nlattr *data;
+	int ret;
+
+	if (!drv->mtk_scs_vendor_cmd_avail) {
+		wpa_printf(MSG_ERROR,
+			   "nl80211: Driver does not support scs");
+		return 0;
 	}
 
-	os_memcpy(bss->links[link_id].addr, addr, ETH_ALEN);
+	msg = nl80211_bss_msg(bss, 0, NL80211_CMD_VENDOR);
+	if (!msg)
+		goto fail;
 
-	/* The new link is the first one, make it the default */
-	if (!bss->valid_links)
-		bss->flink = &bss->links[link_id];
+	if (nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+	    nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD,
+			MTK_NL80211_VENDOR_SUBCMD_SCS_CTRL))
+		goto fail;
 
-	bss->valid_links |= BIT(link_id);
-	bss->links[link_id].ctx = bss_ctx;
+	data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA);
+	if (!data)
+		goto fail;
 
-	wpa_printf(MSG_DEBUG, "nl80211: MLD: valid_links=0x%04x on %s",
-		   bss->valid_links, bss->ifname);
+	if (nla_put_u8(msg, MTK_VENDOR_ATTR_SCS_ID, info->id) ||
+	    nla_put_u8(msg, MTK_VENDOR_ATTR_SCS_REQ_TYPE, info->req_type) ||
+	    nla_put(msg, MTK_VENDOR_ATTR_SCS_MAC_ADDR, ETH_ALEN, info->peer_addr) ||
+	    nla_put_u8(msg, MTK_VENDOR_ATTR_SCS_LINK_ID, link_id))
+		goto fail;
 
-	if (drv->rtnl_sk)
-		rtnl_neigh_add_fdb_entry(bss, addr, true);
+	if (info->req_type == SCS_REQ_TYPE_ADD ||
+	    info->req_type == SCS_REQ_TYPE_CHANGE)
+		if (nla_put_u8(msg, MTK_VENDOR_ATTR_SCS_DIR, info->dir) ||
+		    nla_put(msg, MTK_VENDOR_ATTR_SCS_QOS_IE, info->qos_ie_len,
+			    info->qos_ie))
+			goto fail;
 
-	return 0;
-}
+	nla_nest_end(msg, data);
+	ret = send_and_recv_cmd(drv, msg);
+	if (ret)
+		wpa_printf(MSG_ERROR, "Failed to set scs. ret = %d (%s)",
+			   ret, strerror(-ret));
 
+	return ret;
 
-#ifdef CONFIG_IEEE80211BE
-static int wpa_driver_nl80211_link_sta_remove(void *priv, u8 link_id,
-					      const u8 *addr)
+fail:
+	nlmsg_free(msg);
+	return ret;
+}
+#endif
+
+static int
+nl80211_csi_set(void *priv, s8 link_id, u8 mode, u8 cfg, u8 v1, u32 v2, u8 *mac)
 {
 	struct i802_bss *bss = priv;
 	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct i802_link *link = nl80211_get_link(bss, link_id);
+	struct hostapd_data *hapd = bss->ctx;
 	struct nl_msg *msg;
-	int ret;
+	struct nlattr *data;
+	void *tb1, *tb2;
+	int ret, i;
+	u8 radio_idx = 0;
 
-	if (!(bss->valid_links & BIT(link_id)))
-		return -ENOLINK;
+	if (!drv->mtk_csi_vendor_cmd_avail) {
+		wpa_printf(MSG_ERROR,
+			"nl80211: Driver does not support csi");
+		return 0;
+	}
 
-	if (!(msg = nl80211_bss_msg(bss, 0, NL80211_CMD_REMOVE_LINK_STA)) ||
-	    nla_put(msg, NL80211_ATTR_MLD_ADDR, ETH_ALEN, addr) ||
-	    nla_put_u8(msg, NL80211_ATTR_MLO_LINK_ID, link_id)) {
-		nlmsg_free(msg);
-		return -ENOBUFS;
+	if (link && link->ctx)
+		hapd = link->ctx;
+
+	if (hapd->iface->current_hw_info)
+		radio_idx = hapd->iface->current_hw_info->hw_idx;
+
+	msg = nl80211_bss_msg(bss, 0, NL80211_CMD_VENDOR);
+	if (!msg)
+		goto fail;
+
+	if (nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+			nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD,
+			MTK_NL80211_VENDOR_SUBCMD_CSI_CTRL))
+		goto fail;
+
+	data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA | NLA_F_NESTED);
+	if (!data)
+		goto fail;
+
+	nla_put_u8(msg, MTK_VENDOR_ATTR_CSI_CTRL_RADIO_IDX, radio_idx);
+
+	tb1 = nla_nest_start(msg, MTK_VENDOR_ATTR_CSI_CTRL_CFG | NLA_F_NESTED);
+	if (!tb1)
+		goto fail;
+
+	nla_put_u8(msg, MTK_VENDOR_ATTR_CSI_CTRL_CFG_MODE, mode);
+	nla_put_u8(msg, MTK_VENDOR_ATTR_CSI_CTRL_CFG_TYPE, cfg);
+	nla_put_u8(msg, MTK_VENDOR_ATTR_CSI_CTRL_CFG_VAL1, v1);
+	nla_put_u32(msg, MTK_VENDOR_ATTR_CSI_CTRL_CFG_VAL2, v2);
+
+	nla_nest_end(msg, tb1);
+
+	if (mac) {
+		tb2 = nla_nest_start(msg, MTK_VENDOR_ATTR_CSI_CTRL_MAC_ADDR | NLA_F_NESTED);
+		if (!tb2)
+			goto fail;
+
+		for (i = 0; i < ETH_ALEN; i++)
+			nla_put_u8(msg, i, mac[i]);
+
+		nla_nest_end(msg, tb2);
 	}
 
+	nla_nest_end(msg, data);
+
 	ret = send_and_recv_cmd(drv, msg);
-	wpa_printf(MSG_DEBUG,
-		   "nl80211: link_sta_remove -> REMOVE_LINK_STA on link_id %u from MLD STA "
-		   MACSTR ", from %s --> %d (%s)",
-		   link_id, MAC2STR(addr), bss->ifname, ret, strerror(-ret));
+
+	if (ret)
+		wpa_printf(MSG_ERROR, "Failed to set csi. ret=%d (%s)",
+			ret, strerror(-ret));
 
 	return ret;
-}
-#endif /* CONFIG_IEEE80211BE */
 
+fail:
+	nlmsg_free(msg);
+	return -ENOBUFS;
 
-#ifdef CONFIG_TESTING_OPTIONS
+}
 
-static int testing_nl80211_register_frame(void *priv, u16 type,
-					  const u8 *match, size_t match_len,
-					  bool multicast)
+static int
+mt76_csi_dump_cb(struct nl_msg *msg, void *arg)
 {
-	struct i802_bss *bss = priv;
-	struct nl_sock *handle;
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct nlattr *tb1[NUM_MTK_VENDOR_ATTRS_CSI_CTRL];
+	struct nlattr *tb2[NUM_MTK_VENDOR_ATTRS_CSI_DATA];
+	struct nlattr *attr, *cur, *data;
+	int len = 0, rem, idx;
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct csi_resp_data *csi_resp = (struct csi_resp_data *)arg;
+	struct csi_data *c = csi_resp->csi_buf;
 
-	if (!bss->nl_mgmt)
-		return -1;
-	handle = (void *) (((intptr_t) bss->nl_mgmt) ^ ELOOP_SOCKET_INVALID);
-	return nl80211_register_frame(bss, handle, type, match, match_len,
-				      multicast);
-}
+	c += csi_resp->buf_cnt;
 
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		genlmsg_attrlen(gnlh, 0), NULL);
 
-static int testing_nl80211_radio_disable(void *priv, int disabled)
+	attr = tb[NL80211_ATTR_VENDOR_DATA];
+	if (!attr)
+		return NL_SKIP;
+
+	nla_parse_nested(tb1, MTK_VENDOR_ATTR_CSI_CTRL_MAX,
+			attr, csi_ctrl_policy);
+
+	if (!tb1[MTK_VENDOR_ATTR_CSI_CTRL_DATA])
+		return NL_SKIP;
+
+	nla_parse_nested(tb2, MTK_VENDOR_ATTR_CSI_DATA_MAX,
+			tb1[MTK_VENDOR_ATTR_CSI_CTRL_DATA], csi_data_policy);
+
+	if (!(tb2[MTK_VENDOR_ATTR_CSI_DATA_VER] &&
+	      tb2[MTK_VENDOR_ATTR_CSI_DATA_TS] &&
+	      tb2[MTK_VENDOR_ATTR_CSI_DATA_RSSI] &&
+	      tb2[MTK_VENDOR_ATTR_CSI_DATA_SNR] &&
+	      tb2[MTK_VENDOR_ATTR_CSI_DATA_BW] &&
+	      tb2[MTK_VENDOR_ATTR_CSI_DATA_CH_IDX] &&
+	      tb2[MTK_VENDOR_ATTR_CSI_DATA_TA] &&
+	      tb2[MTK_VENDOR_ATTR_CSI_DATA_I] &&
+	      tb2[MTK_VENDOR_ATTR_CSI_DATA_Q] &&
+	      tb2[MTK_VENDOR_ATTR_CSI_DATA_INFO] &&
+	      tb2[MTK_VENDOR_ATTR_CSI_DATA_MODE] &&
+	      tb2[MTK_VENDOR_ATTR_CSI_DATA_CHAIN_INFO])) {
+		fprintf(stderr, "Attributes error for CSI data\n");
+		return NL_SKIP;
+	}
+
+	c->rssi = nla_get_u8(tb2[MTK_VENDOR_ATTR_CSI_DATA_RSSI]);
+	c->snr = nla_get_u8(tb2[MTK_VENDOR_ATTR_CSI_DATA_SNR]);
+	c->data_bw = nla_get_u8(tb2[MTK_VENDOR_ATTR_CSI_DATA_BW]);
+	c->pri_ch_idx = nla_get_u8(tb2[MTK_VENDOR_ATTR_CSI_DATA_CH_IDX]);
+	c->rx_mode = nla_get_u8(tb2[MTK_VENDOR_ATTR_CSI_DATA_MODE]);
+
+	c->tx_idx = nla_get_u16(tb2[MTK_VENDOR_ATTR_CSI_DATA_TX_ANT]);
+	c->rx_idx = nla_get_u16(tb2[MTK_VENDOR_ATTR_CSI_DATA_RX_ANT]);
+
+	c->ext_info = nla_get_u32(tb2[MTK_VENDOR_ATTR_CSI_DATA_INFO]);
+	c->chain_info = nla_get_u32(tb2[MTK_VENDOR_ATTR_CSI_DATA_CHAIN_INFO]);
+
+	c->ts = nla_get_u32(tb2[MTK_VENDOR_ATTR_CSI_DATA_TS]);
+
+	c->data_num = nla_get_u32(tb2[MTK_VENDOR_ATTR_CSI_DATA_NUM]);
+
+	idx = 0;
+	nla_for_each_nested(cur, tb2[MTK_VENDOR_ATTR_CSI_DATA_TA], rem) {
+		if (idx < ETH_ALEN)
+			c->ta[idx++] = nla_get_u8(cur);
+	}
+
+	idx = 0;
+	nla_for_each_nested(cur, tb2[MTK_VENDOR_ATTR_CSI_DATA_I], rem) {
+		if (idx < c->data_num)
+			c->data_i[idx++] = nla_get_u16(cur);
+	}
+
+	idx = 0;
+	nla_for_each_nested(cur, tb2[MTK_VENDOR_ATTR_CSI_DATA_Q], rem) {
+		if (idx < c->data_num)
+			c->data_q[idx++] = nla_get_u16(cur);
+	}
+
+	csi_resp->buf_cnt++;
+
+	return NL_SKIP;
+}
+
+static int
+nl80211_csi_dump(void *priv, s8 link_id, void *dump_buf)
 {
 	struct i802_bss *bss = priv;
 	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct i802_link *link = nl80211_get_link(bss, link_id);
+	struct hostapd_data *hapd = bss->ctx;
+	struct nl_msg *msg;
+	struct nlattr *data;
+	int ret;
+	struct csi_resp_data *csi_resp;
+	u16 pkt_num, i;
+	u8 radio_idx = 0;
 
-	/* For now, this is supported only partially in station mode with
-	 * SME-in-wpa_supplicant case where the NL80211_ATTR_LOCAL_STATE_CHANGE
-	 * attribute can be used to avoid sending out the Deauthentication frame
-	 * to the currently associated AP. */
-
-	if (!disabled)
+	if (!drv->mtk_csi_vendor_cmd_avail) {
+		wpa_printf(MSG_INFO,
+			"nl80211: Driver does not support csi");
 		return 0;
+	}
 
-	if (!(drv->capa.flags & WPA_DRIVER_FLAGS_SME))
-		return -1;
+	if (link && link->ctx)
+		hapd = link->ctx;
 
-	if (!drv->associated)
-		return 0;
+	if (hapd->iface->current_hw_info)
+		radio_idx = hapd->iface->current_hw_info->hw_idx;
 
-	return wpa_driver_nl80211_mlme(drv, drv->bssid,
-				       NL80211_CMD_DEAUTHENTICATE,
-				       WLAN_REASON_PREV_AUTH_NOT_VALID, 1,
-				       drv->first_bss);
-}
+	csi_resp = (struct csi_resp_data *)dump_buf;
+	pkt_num =  csi_resp->usr_need_cnt;
 
-#endif /* CONFIG_TESTING_OPTIONS */
+	if (pkt_num > 3000)
+		return -EINVAL;
+
+#define CSI_DUMP_PER_NUM	3
+	for (i = 0; i < pkt_num / CSI_DUMP_PER_NUM; i++) {
+		msg = nl80211_bss_msg(bss, NLM_F_DUMP, NL80211_CMD_VENDOR);
+		if (!msg)
+			goto fail;
 
+		if (nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+				nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD,
+				MTK_NL80211_VENDOR_SUBCMD_CSI_CTRL))
+			goto fail;
 
-static struct hostapd_multi_hw_info *
-wpa_driver_get_multi_hw_info(void *priv, unsigned int *num_multi_hws)
+		data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA | NLA_F_NESTED);
+		if (!data)
+			goto fail;
+
+		nla_put_u8(msg, MTK_VENDOR_ATTR_CSI_CTRL_RADIO_IDX, radio_idx);
+		nla_put_u16(msg, MTK_VENDOR_ATTR_CSI_CTRL_DUMP_NUM, CSI_DUMP_PER_NUM);
+
+		nla_nest_end(msg, data);
+
+		ret = send_and_recv_resp(drv, msg, mt76_csi_dump_cb, dump_buf);
+	}
+
+	return ret;
+
+fail:
+	nlmsg_free(msg);
+	return -ENOBUFS;
+}
+
+static int nl80211_txpower_ctrl(void *priv, u8 lpi_psd, u8 sku_idx, u8 lpi_bcn_enhance,
+				u8 link_id, s8 **power_table, u8 lpi_mode)
 {
 	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct nlattr *data;
+	struct nlattr *table_attr, *channel_list;
+	int ret = 0;
 
-	return nl80211_get_multi_hw_info(bss, num_multi_hws);
-}
+	if (!drv->mtk_txpower_vendor_cmd_avail) {
+		wpa_printf(MSG_INFO,
+			   "nl80211: Driver does not support setting txpower control");
+		goto fail;
+	}
+
+	msg = nl80211_bss_msg(bss, 0, NL80211_CMD_VENDOR);
+	if (!msg) {
+		ret = -ENOBUFS;
+		goto fail;
+	}
+
+	if (nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, OUI_MTK) ||
+		nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD,
+			    MTK_NL80211_VENDOR_SUBCMD_TXPOWER_CTRL)) {
+		ret = -ENOBUFS;
+		goto fail;
+	}
+
+	data = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA | NLA_F_NESTED);
+	if (!data) {
+		ret = -ENOBUFS;
+		goto fail;
+	}
+
+	nla_put_u8(msg, MTK_VENDOR_ATTR_TXPOWER_CTRL_LPI_PSD, lpi_psd);
+	nla_put_u8(msg, MTK_VENDOR_ATTR_TXPOWER_CTRL_SKU_IDX, sku_idx);
+	nla_put_u8(msg, MTK_VENDOR_ATTR_TXPOWER_CTRL_LPI_BCN_ENHANCE, lpi_bcn_enhance);
 
+	if (link_id > -1)
+		nla_put_u8(msg, MTK_VENDOR_ATTR_TXPOWER_CTRL_LINK_ID, link_id);
+
+#ifdef CONFIG_AFC
+	if (power_table && *power_table) {
+		nla_put(msg, MTK_VENDOR_ATTR_TXPOWER_CTRL_AFC_TABLE,
+		        MAX_CHANNEL_NUM_6G * afc_power_table_num, power_table);
+	}
+#endif /* CONFIG_AFC */
+
+	nla_put_u8(msg, MTK_VENDOR_ATTR_TXPOWER_CTRL_AFC_LPI, lpi_mode);
+	nla_nest_end(msg, data);
+	ret = send_and_recv_cmd(drv, msg);
+	if (ret)
+		wpa_printf(MSG_ERROR, "Failed to set power. ret=%d (%s)",
+			   ret, strerror(-ret));
+
+	return ret;
+
+fail:
+	nlmsg_free(msg);
+	return ret;
+}
 
 const struct wpa_driver_ops wpa_driver_nl80211_ops = {
 	.name = "nl80211",
@@ -14509,6 +16332,8 @@ const struct wpa_driver_ops wpa_driver_nl80211_ops = {
 	.set_acl = wpa_driver_nl80211_set_acl,
 	.if_add = wpa_driver_nl80211_if_add,
 	.if_remove = driver_nl80211_if_remove,
+	.if_rename = driver_nl80211_if_rename,
+	.set_first_bss = driver_nl80211_set_first_bss,
 	.send_mlme = driver_nl80211_send_mlme,
 	.get_hw_feature_data = nl80211_get_hw_feature_data,
 	.sta_add = wpa_driver_nl80211_sta_add,
@@ -14519,6 +16344,7 @@ const struct wpa_driver_ops wpa_driver_nl80211_ops = {
 	.sta_set_airtime_weight = driver_nl80211_sta_set_airtime_weight,
 	.hapd_init = i802_init,
 	.hapd_deinit = i802_deinit,
+	.move_bss_to_first = i802_move_bss_to_first,
 	.set_wds_sta = i802_set_wds_sta,
 	.get_seqnum = i802_get_seqnum,
 	.flush = i802_flush,
@@ -14634,6 +16460,10 @@ const struct wpa_driver_ops wpa_driver_nl80211_ops = {
 	.update_connect_params = nl80211_update_connection_params,
 	.send_external_auth_status = nl80211_send_external_auth_status,
 	.set_4addr_mode = nl80211_set_4addr_mode,
+	.mu_ctrl = nl80211_mu_ctrl,
+	.mu_dump = nl80211_mu_dump,
+	.beacon_ctrl = nl80211_beacon_ctrl,
+	.set_eml_omn = nl80211_set_eml_omn,
 #ifdef CONFIG_DPP
 	.dpp_listen = nl80211_dpp_listen,
 #endif /* CONFIG_DPP */
@@ -14641,6 +16471,7 @@ const struct wpa_driver_ops wpa_driver_nl80211_ops = {
 	.link_add = nl80211_link_add,
 #ifdef CONFIG_IEEE80211BE
 	.link_remove = driver_nl80211_link_remove,
+	.set_attlm = nl80211_set_attlm,
 	.is_drv_shared = nl80211_is_drv_shared,
 	.link_sta_remove = wpa_driver_nl80211_link_sta_remove,
 #endif /* CONFIG_IEEE80211BE */
@@ -14649,4 +16480,28 @@ const struct wpa_driver_ops wpa_driver_nl80211_ops = {
 	.radio_disable = testing_nl80211_radio_disable,
 #endif /* CONFIG_TESTING_OPTIONS */
 	.get_multi_hw_info = wpa_driver_get_multi_hw_info,
+/* Need ifdef CONFIG_DRIVER_NL80211_MTK */
+	.configure_edcca_enable = nl80211_configure_edcca_enable,
+	.configure_edcca_threshold = nl80211_configure_edcca_threshold,
+	.get_edcca = nl80211_get_edcca,
+	.three_wire_ctrl = nl80211_enable_three_wire,
+	.ibf_ctrl = nl80211_ibf_enable,
+	.ibf_dump = nl80211_ibf_dump,
+	.amsdu_ctrl = nl80211_enable_amsdu,
+	.amsdu_dump = nl80211_dump_amsdu,
+	.get_aval_color_bmp = nl80211_get_aval_color_bmp,
+	.ap_wireless = nl80211_ap_wireless,
+	.ap_rfeatures = nl80211_ap_rfeatures,
+	.ap_trigtype = nl80211_ap_trigtype,
+	.amnt_set = nl80211_amnt_set,
+	.amnt_dump = nl80211_amnt_dump,
+	.background_radar_mode = nl80211_background_radar_mode,
+	.pp_mode_set = nl80211_pp_mode_set,
+#ifdef CONFIG_IEEE80211BE
+	.get_mld_addr = nl80211_get_mld_addr,
+	.set_scs = nl80211_set_scs,
+#endif
+	.csi_set = nl80211_csi_set,
+	.csi_dump = nl80211_csi_dump,
+	.txpower_ctrl = nl80211_txpower_ctrl,
 };
diff --git a/src/drivers/driver_nl80211.h b/src/drivers/driver_nl80211.h
index 40941ea..f12139a 100644
--- a/src/drivers/driver_nl80211.h
+++ b/src/drivers/driver_nl80211.h
@@ -56,6 +56,7 @@ struct i802_link {
 	unsigned int beacon_set:1;
 
 	int freq;
+	int background_freq;
 	int bandwidth;
 	u8 addr[ETH_ALEN];
 	void *ctx;
@@ -201,6 +202,21 @@ struct wpa_driver_nl80211_data {
 	unsigned int puncturing:1;
 	unsigned int qca_ap_allowed_freqs:1;
 	unsigned int connect_ext_vendor_cmd_avail:1;
+	unsigned int mtk_edcca_vendor_cmd_avail:1;
+	unsigned int mtk_mu_vendor_cmd_avail:1;
+	unsigned int mtk_3wire_vendor_cmd_avail:1;
+	unsigned int mtk_ibf_vendor_cmd_avail:1;
+	unsigned int mtk_wireless_vendor_cmd_avail:1;
+	unsigned int mtk_bss_color_vendor_cmd_avail:1;
+	unsigned int mtk_rfeatures_vendor_cmd_avail:1;
+	unsigned int mtk_amnt_vendor_cmd_avail:1;
+	unsigned int mtk_background_radar_vendor_cmd_avail:1;
+	unsigned int mtk_pp_vendor_cmd_avail:1;
+	unsigned int mtk_beacon_ctrl_vendor_cmd_avail:1;
+	unsigned int mtk_csi_vendor_cmd_avail:1;
+	unsigned int mtk_eml_vendor_cmd_avail:1;
+	unsigned int mtk_txpower_vendor_cmd_avail:1;
+	unsigned int mtk_scs_vendor_cmd_avail:1;
 
 	u32 ignore_next_local_disconnect;
 	u32 ignore_next_local_deauth;
@@ -311,7 +327,7 @@ int nl80211_create_iface(struct wpa_driver_nl80211_data *drv,
 			 const char *ifname, enum nl80211_iftype iftype,
 			 const u8 *addr, int wds,
 			 int (*handler)(struct nl_msg *, void *),
-			 void *arg, int use_existing);
+			 void *arg, int use_existing, u32 radio_mask);
 void nl80211_remove_iface(struct wpa_driver_nl80211_data *drv, int ifidx);
 unsigned int nl80211_get_assoc_freq(struct wpa_driver_nl80211_data *drv);
 int nl80211_get_assoc_ssid(struct wpa_driver_nl80211_data *drv, u8 *ssid);
diff --git a/src/drivers/driver_nl80211_capa.c b/src/drivers/driver_nl80211_capa.c
index c4a23d5..e15202c 100644
--- a/src/drivers/driver_nl80211_capa.c
+++ b/src/drivers/driver_nl80211_capa.c
@@ -18,6 +18,7 @@
 #include "common/qca-vendor-attr.h"
 #include "common/brcm_vendor.h"
 #include "driver_nl80211.h"
+#include "common/mtk_vendor.h"
 
 
 static int protocol_feature_handler(struct nl_msg *msg, void *arg)
@@ -976,6 +977,10 @@ static int wiphy_info_handler(struct nl_msg *msg, void *arg)
 			nla_get_u32(tb[NL80211_ATTR_MAX_SCAN_PLAN_ITERATIONS]);
 	}
 
+	if (tb[NL80211_ATTR_MAX_SCAN_IE_LEN])
+		capa->max_scan_ie_len =
+			nla_get_u16(tb[NL80211_ATTR_MAX_SCAN_IE_LEN]);
+
 	if (tb[NL80211_ATTR_MAX_MATCH_SETS])
 		capa->max_match_sets =
 			nla_get_u8(tb[NL80211_ATTR_MAX_MATCH_SETS]);
@@ -1137,6 +1142,53 @@ static int wiphy_info_handler(struct nl_msg *msg, void *arg)
 					break;
 				}
 #endif /* CONFIG_DRIVER_NL80211_BRCM */
+			} else if (vinfo->vendor_id == OUI_MTK) {
+				switch (vinfo->subcmd) {
+				case MTK_NL80211_VENDOR_SUBCMD_EDCCA_CTRL:
+					drv->mtk_edcca_vendor_cmd_avail = 1;
+					break;
+				case MTK_NL80211_VENDOR_SUBCMD_MU_CTRL :
+					drv->mtk_mu_vendor_cmd_avail = 1;
+					break;
+				case MTK_NL80211_VENDOR_SUBCMD_3WIRE_CTRL :
+					drv->mtk_3wire_vendor_cmd_avail = 1;
+					break;
+				case MTK_NL80211_VENDOR_SUBCMD_IBF_CTRL:
+					drv->mtk_ibf_vendor_cmd_avail = 1;
+					break;
+				case MTK_NL80211_VENDOR_SUBCMD_WIRELESS_CTRL:
+					drv->mtk_wireless_vendor_cmd_avail = 1;
+					break;
+				case MTK_NL80211_VENDOR_SUBCMD_BSS_COLOR_CTRL :
+					drv->mtk_bss_color_vendor_cmd_avail = 1;
+				case MTK_NL80211_VENDOR_SUBCMD_AMNT_CTRL:
+					drv->mtk_amnt_vendor_cmd_avail = 1;
+					break;
+				case MTK_NL80211_VENDOR_SUBCMD_RFEATURE_CTRL:
+					drv->mtk_rfeatures_vendor_cmd_avail = 1;
+					break;
+				case MTK_NL80211_VENDOR_SUBCMD_BACKGROUND_RADAR_CTRL:
+					drv->mtk_background_radar_vendor_cmd_avail = 1;
+					break;
+				case MTK_NL80211_VENDOR_SUBCMD_PP_CTRL:
+					drv->mtk_pp_vendor_cmd_avail = 1;
+					break;
+				case MTK_NL80211_VENDOR_SUBCMD_BEACON_CTRL :
+					drv->mtk_beacon_ctrl_vendor_cmd_avail = 1;
+					break;
+				case MTK_NL80211_VENDOR_SUBCMD_CSI_CTRL:
+					drv->mtk_csi_vendor_cmd_avail = 1;
+					break;
+				case MTK_NL80211_VENDOR_SUBCMD_EML_CTRL:
+					drv->mtk_eml_vendor_cmd_avail = 1;
+					break;
+				case MTK_NL80211_VENDOR_SUBCMD_TXPOWER_CTRL:
+					drv->mtk_txpower_vendor_cmd_avail = 1;
+					break;
+				case MTK_NL80211_VENDOR_SUBCMD_SCS_CTRL:
+					drv->mtk_scs_vendor_cmd_avail = 1;
+					break;
+				}
 			}
 
 			wpa_printf(MSG_DEBUG, "nl80211: Supported vendor command: vendor_id=0x%x subcmd=%u",
diff --git a/src/drivers/driver_nl80211_event.c b/src/drivers/driver_nl80211_event.c
index e50a814..a57acef 100644
--- a/src/drivers/driver_nl80211_event.c
+++ b/src/drivers/driver_nl80211_event.c
@@ -19,6 +19,7 @@
 #include "common/ieee802_11_defs.h"
 #include "common/ieee802_11_common.h"
 #include "driver_nl80211.h"
+#include "common/mtk_vendor.h"
 
 
 static void
@@ -187,6 +188,10 @@ static const char * nl80211_command_to_string(enum nl80211_commands cmd)
 	C2S(NL80211_CMD_SET_HW_TIMESTAMP)
 	C2S(NL80211_CMD_LINKS_REMOVED)
 	C2S(NL80211_CMD_SET_TID_TO_LINK_MAPPING)
+	C2S(NL80211_CMD_ATTLM_EVENT)
+	C2S(NL80211_CMD_SET_ATTLM)
+	C2S(NL80211_CMD_TSF_OFFSET_EVENT)
+	C2S(NL80211_CMD_NOTIFY_CRIT_UPDATE)
 	C2S(__NL80211_CMD_AFTER_LAST)
 	}
 #undef C2S
@@ -329,6 +334,7 @@ static void mlme_event_assoc(struct wpa_driver_nl80211_data *drv,
 			   wpa_ssid_txt(drv->ssid, drv->ssid_len));
 	}
 
+	drv->assoc_freq = nl80211_get_assoc_freq(drv);
 	event.assoc_info.freq = drv->assoc_freq;
 	drv->first_bss->flink->freq = drv->assoc_freq;
 
@@ -1197,6 +1203,7 @@ static void mlme_event_ch_switch(struct wpa_driver_nl80211_data *drv,
 				 struct nlattr *bw, struct nlattr *cf1,
 				 struct nlattr *cf2,
 				 struct nlattr *punct_bitmap,
+				 struct nlattr *count,
 				 int finished)
 {
 	struct i802_bss *bss;
@@ -1260,6 +1267,8 @@ static void mlme_event_ch_switch(struct wpa_driver_nl80211_data *drv,
 		data.ch_switch.cf1 = nla_get_u32(cf1);
 	if (cf2)
 		data.ch_switch.cf2 = nla_get_u32(cf2);
+	if (count)
+		data.ch_switch.count = nla_get_u32(count);
 
 	if (link) {
 		data.ch_switch.link_id = nla_get_u8(link);
@@ -1319,6 +1328,67 @@ static void mlme_event_ch_switch(struct wpa_driver_nl80211_data *drv,
 }
 
 
+static void mlme_event_attlm(struct wpa_driver_nl80211_data *drv,
+			     struct nlattr *ifindex,
+			     struct nlattr *event,
+			     struct nlattr *switch_time_tsf_tu)
+{
+	enum nl80211_attlm_event event_type;
+	union wpa_event_data data;
+	struct i802_bss *bss;
+	int ifidx;
+
+	ifidx = nla_get_u32(ifindex);
+	bss = get_bss_ifindex(drv, ifidx);
+	if (bss == NULL) {
+		wpa_printf(MSG_WARNING,
+			   "nl80211: Unknown ifindex (%d) for A-TTLM, ignoring",
+			   ifidx);
+		return;
+	}
+
+	if (!event)
+		return;
+
+	wpa_printf(MSG_DEBUG, "nl80211: %s: A-TTLM event", bss->ifname);
+
+	data.attlm_event.switch_time_tsf_tu = switch_time_tsf_tu ?
+					nla_get_u16(switch_time_tsf_tu) : 0;
+	event_type = nla_get_u32(event);
+	switch (event_type) {
+		case NL80211_ATTLM_STARTED:
+			data.attlm_event.event = EVENT_ATTLM_STARTED;
+			break;
+		case NL80211_ATTLM_SWITCH_TIME_EXPIRED:
+			data.attlm_event.event = EVENT_ATTLM_SWITCH_TIME_EXPIRED;
+			break;
+		case NL80211_ATTLM_END:
+			data.attlm_event.event = EVENT_ATTLM_END;
+			break;
+		default:
+			wpa_printf(MSG_DEBUG,
+				   "nl80211: Unsupported A-TTLM event");
+			return;
+	}
+
+	wpa_supplicant_event(bss->ctx, EVENT_ATTLM, &data);
+}
+
+
+static void mlme_event_tsf_offset(struct wpa_driver_nl80211_data *drv,
+				  struct nlattr *link_id,
+				  struct nlattr *tsf_offset)
+{
+	union wpa_event_data event;
+
+	os_memset(&event, 0, sizeof(event));
+	event.tsf_event.link_id = nla_get_u8(link_id);
+	os_memcpy(event.tsf_event.tsf_offset, nla_data(tsf_offset), nla_len(tsf_offset));
+
+	wpa_supplicant_event(drv->ctx, EVENT_TSF_OFFSET, &event);
+}
+
+
 static void mlme_timeout_event(struct wpa_driver_nl80211_data *drv,
 			       enum nl80211_commands cmd, struct nlattr *addr)
 {
@@ -1388,7 +1458,7 @@ static void mlme_event_mgmt(struct i802_bss *bss,
 	event.rx_mgmt.ctx = bss->ctx;
 	event.rx_mgmt.link_id = link_id;
 
-	wpa_supplicant_event(drv->ctx, EVENT_RX_MGMT, &event);
+	wpa_supplicant_event(bss->ctx, EVENT_RX_MGMT, &event);
 }
 
 
@@ -1645,7 +1715,8 @@ nl80211_get_link_id_by_freq(struct i802_bss *bss, unsigned int freq)
 	unsigned int i;
 
 	for_each_link(bss->valid_links, i) {
-		if ((unsigned int) bss->links[i].freq == freq)
+		if ((unsigned int) bss->links[i].freq == freq ||
+		    (unsigned int) bss->links[i].background_freq == freq)
 			return i;
 	}
 
@@ -1667,6 +1738,7 @@ static void mlme_event(struct i802_bss *bss,
 	size_t len;
 	int link_id = -1;
 	struct i802_link *mld_link = NULL;
+	bool beacon_set;
 
 	if (timed_out && addr) {
 		mlme_timeout_event(drv, cmd, addr);
@@ -1690,6 +1762,13 @@ static void mlme_event(struct i802_bss *bss,
 	if (nl80211_link_valid(bss->valid_links, link_id))
 		mld_link = nl80211_get_link(bss, link_id);
 
+	beacon_set = mld_link ? mld_link->beacon_set : bss->flink->beacon_set;
+	if (is_ap_interface(drv->nlmode) && !beacon_set) {
+		wpa_printf(MSG_DEBUG,
+			   "nl80211: drop BSS Event due to disabled BSS");
+		return;
+	}
+
 	data = nla_data(frame);
 	len = nla_len(frame);
 	if (len < 4 + 2 * ETH_ALEN) {
@@ -2467,6 +2546,9 @@ static void nl80211_stop_ap(struct i802_bss *bss, struct nlattr **tb)
 		 * will return an error. Ignore that since nl80211_remove_link()
 		 * is called here only to update the bss->links[] state. */
 		nl80211_remove_link(bss, link_id);
+		bss->ctx = bss->flink->ctx;
+		if (bss->drv->first_bss == bss && bss->valid_links)
+			bss->drv->ctx = bss->ctx;
 	}
 
 	wpa_supplicant_event(ctx, EVENT_INTERFACE_UNAVAILABLE, NULL);
@@ -2541,6 +2623,18 @@ static void nl80211_process_radar_event(struct i802_bss *bss,
 	case NL80211_RADAR_CAC_STARTED:
 		wpa_supplicant_event(bss->ctx, EVENT_DFS_CAC_STARTED, data);
 		break;
+	case NL80211_RADAR_BACKGROUND_CHAN_UPDATE:
+		wpa_supplicant_event(bss->ctx, EVENT_DFS_BACKGROUND_CHAN_UPDATE, data);
+		break;
+	case NL80211_RADAR_BACKGROUND_CHAN_EXPAND:
+		wpa_supplicant_event(bss->ctx, EVENT_DFS_BACKGROUND_CHAN_EXPAND, data);
+		break;
+	case NL80211_RADAR_STA_CAC_SKIPPED:
+		wpa_supplicant_event(bss->ctx, EVENT_DFS_STA_CAC_SKIPPED, data);
+		break;
+	case NL80211_RADAR_STA_CAC_EXPIRED:
+		wpa_supplicant_event(bss->ctx, EVENT_DFS_STA_CAC_EXPIRED, data);
+		break;
 	default:
 		wpa_printf(MSG_DEBUG,
 			   "nl80211: Unknown radar event %d received",
@@ -2675,7 +2769,7 @@ static void nl80211_spurious_frame(struct i802_bss *bss, struct nlattr **tb,
 	event.rx_from_unknown.addr = nla_data(tb[NL80211_ATTR_MAC]);
 	event.rx_from_unknown.wds = wds;
 
-	wpa_supplicant_event(drv->ctx, EVENT_RX_FROM_UNKNOWN, &event);
+	wpa_supplicant_event(bss->ctx, EVENT_RX_FROM_UNKNOWN, &event);
 }
 
 
@@ -3420,6 +3514,50 @@ static void nl80211_vendor_event_brcm(struct wpa_driver_nl80211_data *drv,
 
 #endif /* CONFIG_DRIVER_NL80211_BRCM */
 
+static void mtk_nl80211_pp_bitmap_update(struct wpa_driver_nl80211_data *drv,
+					 const u8 *data, size_t len)
+{
+	struct nlattr *tb[MTK_VENDOR_ATTR_PP_CTRL_MAX + 1];
+	union wpa_event_data event;
+
+	wpa_printf(MSG_DEBUG,
+		   "nl80211: MTK pp bitmap update vendor event received");
+
+	if (nla_parse(tb, MTK_VENDOR_ATTR_PP_CTRL_MAX,
+		      (struct nlattr *) data, len, NULL) ||
+	    !tb[MTK_VENDOR_ATTR_PP_CURR_FREQ] ||
+	    !tb[MTK_VENDOR_ATTR_PP_BITMAP])
+		return;
+
+	os_memset(&event, 0, sizeof(event));
+	event.ch_switch.freq = nla_get_u32(tb[MTK_VENDOR_ATTR_PP_CURR_FREQ]);
+
+	event.ch_switch.link_id =
+		nl80211_get_link_id_by_freq(drv->first_bss, event.ch_switch.freq);
+	event.ch_switch.punct_bitmap =
+		nla_get_u16(tb[MTK_VENDOR_ATTR_PP_BITMAP]);
+
+	wpa_printf(MSG_DEBUG,
+		   "nl80211: puncture bitmap: 0x%04x, link_id: %d",
+		   event.ch_switch.punct_bitmap, event.ch_switch.link_id);
+	wpa_supplicant_event(drv->ctx, EVENT_PP_BITMAP_UPDATE, &event);
+}
+
+static void nl80211_vendor_event_mtk(struct wpa_driver_nl80211_data *drv,
+				      u32 subcmd, u8 *data, size_t len)
+{
+	wpa_printf(MSG_DEBUG, "nl80211: Got MTK vendor event %u", subcmd);
+	switch (subcmd) {
+	case MTK_NL80211_VENDOR_EVENT_PP_BMP_UPDATE:
+		mtk_nl80211_pp_bitmap_update(drv, data, len);
+		break;
+	default:
+		wpa_printf(MSG_DEBUG,
+			   "%s: Ignore unsupported MTK vendor event %u",
+			   __func__, subcmd);
+		break;
+	}
+}
 
 static void nl80211_vendor_event(struct wpa_driver_nl80211_data *drv,
 				 struct nlattr **tb)
@@ -3476,6 +3614,9 @@ static void nl80211_vendor_event(struct wpa_driver_nl80211_data *drv,
 		nl80211_vendor_event_brcm(drv, subcmd, data, len);
 		break;
 #endif /* CONFIG_DRIVER_NL80211_BRCM */
+	case OUI_MTK:
+		nl80211_vendor_event_mtk(drv, subcmd, data, len);
+		break;
 	default:
 		wpa_printf(MSG_DEBUG, "nl80211: Ignore unsupported vendor event");
 		break;
@@ -3970,6 +4111,83 @@ static void nl80211_obss_color_event(struct i802_bss *bss,
 
 #endif /* CONFIG_IEEE80211AX */
 
+static void nl80211_links_removed(struct wpa_driver_nl80211_data *drv,
+				  struct nlattr **tb)
+{
+	struct nlattr *link_attr, *link_data[NL80211_ATTR_MAX + 1];
+	static struct nla_policy link_policy[NL80211_ATTR_MAX + 1] = {
+		[NL80211_ATTR_MLO_LINK_ID] = { .type = NLA_U8 },
+	};
+	union wpa_event_data data = {};
+	int rem;
+
+	if (!tb[NL80211_ATTR_MLO_LINKS])
+		return;
+
+	nla_for_each_nested(link_attr, tb[NL80211_ATTR_MLO_LINKS], rem) {
+		u8 link_id;
+
+		if (nla_parse_nested(link_data, NL80211_ATTR_MAX,
+				     link_attr, link_policy) != 0)
+			continue;
+
+		if (!link_data[NL80211_ATTR_MLO_LINK_ID])
+			continue;
+
+		link_id = nla_get_u8(link_data[NL80211_ATTR_MLO_LINK_ID]);
+		if (link_id >= MAX_NUM_MLD_LINKS)
+			continue;
+		data.reconfig_info.removed_links |= BIT(link_id);
+	}
+
+	wpa_supplicant_event(drv->ctx, EVENT_LINK_RECONFIG, &data);
+}
+
+
+static void nl80211_notify_crit_update(struct wpa_driver_nl80211_data *drv,
+				       struct nlattr **tb)
+{
+	struct i802_bss *bss;
+	union wpa_event_data data;
+	enum nl80211_crit_update_event event_type;
+	int ifidx;
+
+	if (!tb[NL80211_ATTR_IFINDEX] || !tb[NL80211_ATTR_MLO_LINK_ID] ||
+	    !tb[NL80211_ATTR_CRTI_UPDATE_EVENT])
+		return;
+
+	ifidx = nla_get_u32(tb[NL80211_ATTR_IFINDEX]);
+	bss = get_bss_ifindex(drv, ifidx);
+	if (!bss) {
+		wpa_printf(MSG_ERROR,
+			   "nl80211: Unknown ifindex (%d) for critical update event, ignoring",
+			   ifidx);
+		return;
+	}
+
+	data.crit_update_info.link_id = nla_get_u8(tb[NL80211_ATTR_MLO_LINK_ID]);
+	event_type = nla_get_u8(tb[NL80211_ATTR_CRTI_UPDATE_EVENT]);
+	switch (event_type) {
+	case NL80211_CRIT_UPDATE_NONE:
+		data.crit_update_info.flag = CRIT_UPDATE_NONE;
+		break;
+	case NL80211_CRIT_UPDATE_SINGLE:
+		data.crit_update_info.flag = CRIT_UPDATE_SINGLE;
+		break;
+	case NL80211_CRIT_UPDATE_ALL:
+		data.crit_update_info.flag = CRIT_UPDATE_ALL;
+		break;
+	case NL80211_CRIT_UPDATE_FLAG:
+		data.crit_update_info.flag = CRIT_UPDATE_FLAG;
+		break;
+	default:
+		wpa_printf(MSG_DEBUG,
+			   "nl80211: Unknown critical update event");
+		return;
+	}
+	wpa_supplicant_event(bss->ctx, EVENT_CRIT_UPDATE, &data);
+}
+
 
 static void do_process_drv_event(struct i802_bss *bss, int cmd,
 				 struct nlattr **tb)
@@ -4117,6 +4335,7 @@ static void do_process_drv_event(struct i802_bss *bss, int cmd,
 				     tb[NL80211_ATTR_CENTER_FREQ1],
 				     tb[NL80211_ATTR_CENTER_FREQ2],
 				     tb[NL80211_ATTR_PUNCT_BITMAP],
+				     tb[NL80211_ATTR_CH_SWITCH_COUNT],
 				     0);
 		break;
 	case NL80211_CMD_CH_SWITCH_NOTIFY:
@@ -4129,8 +4348,19 @@ static void do_process_drv_event(struct i802_bss *bss, int cmd,
 				     tb[NL80211_ATTR_CENTER_FREQ1],
 				     tb[NL80211_ATTR_CENTER_FREQ2],
 				     tb[NL80211_ATTR_PUNCT_BITMAP],
+				     NULL,
 				     1);
 		break;
+	case NL80211_CMD_ATTLM_EVENT:
+		mlme_event_attlm(drv, tb[NL80211_ATTR_IFINDEX],
+				 tb[NL80211_ATTR_MLO_ATTLM_EVENT],
+				 tb[NL80211_ATTR_MLO_ATTLM_SWITCH_TIME_TSF_TU]);
+		break;
+	case NL80211_CMD_TSF_OFFSET_EVENT:
+		mlme_event_tsf_offset(drv,
+				      tb[NL80211_ATTR_MLO_LINK_ID],
+				      tb[NL80211_ATTR_MLO_TSF_OFFSET_VAL]);
+		break;
 	case NL80211_CMD_DISCONNECT:
 		mlme_event_disconnect(drv, tb[NL80211_ATTR_REASON_CODE],
 				      tb[NL80211_ATTR_MAC],
@@ -4233,7 +4463,10 @@ static void do_process_drv_event(struct i802_bss *bss, int cmd,
 		break;
 #endif /* CONFIG_IEEE80211AX */
 	case NL80211_CMD_LINKS_REMOVED:
-		wpa_supplicant_event(drv->ctx, EVENT_LINK_RECONFIG, NULL);
+		nl80211_links_removed(drv, tb);
+		break;
+	case NL80211_CMD_NOTIFY_CRIT_UPDATE:
+		nl80211_notify_crit_update(drv, tb);
 		break;
 	default:
 		wpa_dbg(drv->ctx, MSG_DEBUG, "nl80211: Ignored unknown event "
diff --git a/src/drivers/driver_nl80211_monitor.c b/src/drivers/driver_nl80211_monitor.c
index 7ff55f1..448adb2 100644
--- a/src/drivers/driver_nl80211_monitor.c
+++ b/src/drivers/driver_nl80211_monitor.c
@@ -381,7 +381,7 @@ int nl80211_create_monitor_interface(struct wpa_driver_nl80211_data *drv)
 
 	drv->monitor_ifidx =
 		nl80211_create_iface(drv, buf, NL80211_IFTYPE_MONITOR, NULL,
-				     0, NULL, NULL, 0);
+				     0, NULL, NULL, 0, 0);
 
 	if (drv->monitor_ifidx == -EOPNOTSUPP) {
 		/*
diff --git a/src/drivers/driver_nl80211_scan.c b/src/drivers/driver_nl80211_scan.c
index d0ed7ad..92b4c30 100644
--- a/src/drivers/driver_nl80211_scan.c
+++ b/src/drivers/driver_nl80211_scan.c
@@ -235,7 +235,7 @@ nl80211_scan_common(struct i802_bss *bss, u8 cmd,
 		wpa_printf(MSG_DEBUG, "nl80211: Passive scan requested");
 	}
 
-	if (params->extra_ies) {
+	if (params->extra_ies && drv->capa.max_scan_ie_len >= params->extra_ies_len) {
 		wpa_hexdump(MSG_MSGDUMP, "nl80211: Scan extra IEs",
 			    params->extra_ies, params->extra_ies_len);
 		if (nla_put(msg, NL80211_ATTR_IE, params->extra_ies_len,
diff --git a/src/drivers/drivers.c b/src/drivers/drivers.c
index e95df6d..9071da3 100644
--- a/src/drivers/drivers.c
+++ b/src/drivers/drivers.c
@@ -10,6 +10,10 @@
 #include "utils/common.h"
 #include "driver.h"
 
+void (*wpa_supplicant_event)(void *ctx, enum wpa_event_type event,
+			     union wpa_event_data *data);
+void (*wpa_supplicant_event_global)(void *ctx, enum wpa_event_type event,
+			     union wpa_event_data *data);
 
 const struct wpa_driver_ops *const wpa_drivers[] =
 {
diff --git a/src/drivers/drivers.mak b/src/drivers/drivers.mak
index a03d4a0..8da44d9 100644
--- a/src/drivers/drivers.mak
+++ b/src/drivers/drivers.mak
@@ -54,7 +54,6 @@ NEED_SME=y
 NEED_AP_MLME=y
 NEED_NETLINK=y
 NEED_LINUX_IOCTL=y
-NEED_RFKILL=y
 NEED_RADIOTAP=y
 NEED_LIBNL=y
 endif
@@ -111,7 +110,6 @@ DRV_WPA_CFLAGS += -DCONFIG_DRIVER_WEXT
 CONFIG_WIRELESS_EXTENSION=y
 NEED_NETLINK=y
 NEED_LINUX_IOCTL=y
-NEED_RFKILL=y
 endif
 
 ifdef CONFIG_DRIVER_NDIS
@@ -137,7 +135,6 @@ endif
 ifdef CONFIG_WIRELESS_EXTENSION
 DRV_WPA_CFLAGS += -DCONFIG_WIRELESS_EXTENSION
 DRV_WPA_OBJS += ../src/drivers/driver_wext.o
-NEED_RFKILL=y
 endif
 
 ifdef NEED_NETLINK
@@ -146,6 +143,7 @@ endif
 
 ifdef NEED_RFKILL
 DRV_OBJS += ../src/drivers/rfkill.o
+DRV_WPA_CFLAGS += -DCONFIG_RFKILL
 endif
 
 ifdef NEED_RADIOTAP
diff --git a/src/drivers/linux_ioctl.c b/src/drivers/linux_ioctl.c
index 29abc0c..73d2782 100644
--- a/src/drivers/linux_ioctl.c
+++ b/src/drivers/linux_ioctl.c
@@ -150,7 +150,8 @@ int linux_br_del(int sock, const char *brname)
 int linux_br_add_if(int sock, const char *brname, const char *ifname)
 {
 	struct ifreq ifr;
-	int ifindex;
+	int ifindex, ret;
+	char in_br[IFNAMSIZ];
 
 	ifindex = if_nametoindex(ifname);
 	if (ifindex == 0)
@@ -165,6 +166,17 @@ int linux_br_add_if(int sock, const char *brname, const char *ifname)
 
 		wpa_printf(MSG_DEBUG, "Could not add interface %s into bridge "
 			   "%s: %s", ifname, brname, strerror(errno));
+
+		/* If ioctl returns -EBUSY when adding interface into bridge,
+		 * the interface might already be added by netifd, so here we
+		 * check whether the interface is currently on the right
+		 * bridge. */
+		if(errno == EBUSY && linux_br_get(in_br, ifname) == 0 &&
+	           os_strcmp(in_br, brname) == 0)
+			ret = 0;
+		else
+			ret = -1;
+
 		errno = saved_errno;
 
 		/* If ioctl() returns EBUSY when adding an interface into the
@@ -175,6 +187,8 @@ int linux_br_add_if(int sock, const char *brname, const char *ifname)
 		if (errno != EBUSY || linux_br_get(in_br, ifname) != 0 ||
 		    os_strcmp(in_br, brname) != 0)
 			return -1;
+
+		return ret;
 	}
 
 	return 0;
diff --git a/src/drivers/nl80211_copy.h b/src/drivers/nl80211_copy.h
index f97f5ad..eecca41 100644
--- a/src/drivers/nl80211_copy.h
+++ b/src/drivers/nl80211_copy.h
@@ -1329,6 +1329,9 @@
  *      %NL80211_ATTR_MLO_TTLM_ULINK attributes are used to specify the
  *      TID to Link mapping for downlink/uplink traffic.
  *
+ * @NL80211_CMD_NOTIFY_CRIT_UPDATE: Notify the userspace that the status of a
+ *	critical update event was changed.
+ *
  * @NL80211_CMD_MAX: highest used command number
  * @__NL80211_CMD_AFTER_LAST: internal use
  */
@@ -1588,6 +1591,12 @@ enum nl80211_commands {
 
 	/* add new commands above here */
 
+	/* MTK internal */
+	NL80211_CMD_ATTLM_EVENT,
+	NL80211_CMD_SET_ATTLM,
+	NL80211_CMD_NOTIFY_CRIT_UPDATE,
+	NL80211_CMD_TSF_OFFSET_EVENT,
+
 	/* used to define NL80211_CMD_MAX below */
 	__NL80211_CMD_AFTER_LAST,
 	NL80211_CMD_MAX = __NL80211_CMD_AFTER_LAST - 1
@@ -2868,6 +2877,32 @@ enum nl80211_commands {
  *	nested item, it contains attributes defined in
  *	&enum nl80211_if_combination_attrs.
  *
+ * @NL80211_ATTR_VIF_RADIO_MASK: Bitmask of allowed radios (u32).
+ *	A value of 0 means all radios.
+ *
+ * @NL80211_ATTR_CNTDWN_OFFS_STA_PROF: An array of offsets (u16) to the channel
+ *	switch or color change counters in the per-STA profile corresponding to
+ *	the affected AP.
+ *
+ * @NL80211_ATTR_MLO_LINK_DISABLED_BMP: u16 bitmap of A-TTLM disabled links for
+ * 	the %NL80211_CMD_SET_ATTLM.
+ *
+ * @NL80211_ATTR_MLO_ATTLM_SWITCH_TIME: u16 attribute specifying the time for
+ * 	how long the Adv-TTLM is established.
+ *
+ * @NL80211_ATTR_MLO_ATTLM_DURATION: u32 attribute specifying the duration
+ * 	of the Adv-TTLM.
+ *
+ * @NL80211_ATTR_MLO_ATTLM_EVENT: Type of Adv-TTLM event for notification to
+ * 	userspace, contains a value of enum nl80211_attlm_event (u32).
+ *
+ * @NL80211_ATTR_MLO_ATTLM_SWITCH_TIME_TSF_TU: u16 attribute reported by the
+ * 	driver to speciffy the switch time in TU at which the Adv-TTLM is
+ * 	established.
+ *
+ * @NL80211_ATTR_CRTI_UPDATE_EVENT: Type of critical update event for notification
+ *	to userspace, contains a value of enum nl80211_crit_update_event (u8).
+ *
  * @NUM_NL80211_ATTR: total number of nl80211_attrs available
  * @NL80211_ATTR_MAX: highest attribute number currently defined
  * @__NL80211_ATTR_AFTER_LAST: internal use
@@ -3416,8 +3451,23 @@ enum nl80211_attrs {
 	NL80211_ATTR_WIPHY_RADIOS,
 	NL80211_ATTR_WIPHY_INTERFACE_COMBINATIONS,
 
+	NL80211_ATTR_VIF_RADIO_MASK,
+
 	/* add attributes here, update the policy in nl80211.c */
 
+	/* MTK internal */
+	NL80211_ATTR_CNTDWN_OFFS_STA_PROF,
+
+	NL80211_ATTR_MLO_LINK_DISABLED_BMP,
+	NL80211_ATTR_MLO_ATTLM_SWITCH_TIME,
+	NL80211_ATTR_MLO_ATTLM_DURATION,
+	NL80211_ATTR_MLO_ATTLM_EVENT,
+	NL80211_ATTR_MLO_ATTLM_SWITCH_TIME_TSF_TU,
+
+	NL80211_ATTR_CRTI_UPDATE_EVENT,
+
+	NL80211_ATTR_MLO_TSF_OFFSET_VAL,
+
 	__NL80211_ATTR_AFTER_LAST,
 	NUM_NL80211_ATTR = __NL80211_ATTR_AFTER_LAST,
 	NL80211_ATTR_MAX = __NL80211_ATTR_AFTER_LAST - 1
@@ -3430,6 +3480,7 @@ enum nl80211_attrs {
 #define NL80211_ATTR_SAE_DATA NL80211_ATTR_AUTH_DATA
 #define NL80211_ATTR_CSA_C_OFF_BEACON NL80211_ATTR_CNTDWN_OFFS_BEACON
 #define NL80211_ATTR_CSA_C_OFF_PRESP NL80211_ATTR_CNTDWN_OFFS_PRESP
+#define NL80211_ATTR_CSA_C_OFF_STA_PROF NL80211_ATTR_CNTDWN_OFFS_STA_PROF
 
 /*
  * Allow user space programs to use #ifdef on new attributes by defining them
@@ -4698,6 +4749,7 @@ enum nl80211_survey_info {
  *	overrides all other flags.
  * @NL80211_MNTR_FLAG_ACTIVE: use the configured MAC address
  *	and ACK incoming unicast packets.
+ * @NL80211_MNTR_FLAG_SKIP_TX: do not pass local tx packets
  *
  * @__NL80211_MNTR_FLAG_AFTER_LAST: internal use
  * @NL80211_MNTR_FLAG_MAX: highest possible monitor flag
@@ -4710,6 +4762,7 @@ enum nl80211_mntr_flags {
 	NL80211_MNTR_FLAG_OTHER_BSS,
 	NL80211_MNTR_FLAG_COOK_FRAMES,
 	NL80211_MNTR_FLAG_ACTIVE,
+	NL80211_MNTR_FLAG_SKIP_TX,
 
 	/* keep last */
 	__NL80211_MNTR_FLAG_AFTER_LAST,
@@ -6641,6 +6694,7 @@ enum nl80211_ext_feature_index {
 	NL80211_EXT_FEATURE_OWE_OFFLOAD_AP,
 	NL80211_EXT_FEATURE_DFS_CONCURRENT,
 	NL80211_EXT_FEATURE_SPP_AMSDU_SUPPORT,
+	NL80211_EXT_FEATURE_STAS_COUNT,
 
 	/* add new features before the definition below */
 	NUM_NL80211_EXT_FEATURES,
@@ -6843,6 +6897,14 @@ enum nl80211_smps_mode {
  *	applicable for ETSI dfs domain where pre-CAC is valid for ever.
  * @NL80211_RADAR_CAC_STARTED: Channel Availability Check has been started,
  *	should be generated by HW if NL80211_EXT_FEATURE_DFS_OFFLOAD is enabled.
+ * @NL80211_RADAR_BACKGROUND_CHAN_UPDATE: background channel is updated by the
+ *	driver.
+ * @NL80211_RADAR_BACKGROUND_CHAN_EXPAND: background channel is updated by the
+ *	driver and required to expand main operating channel.
+ * @NL80211_RADAR_STA_CAC_SKIPPED: STA set the DFS state to available
+ *	when receiving CSA/assoc resp
+ * @NL80211_RADAR_STA_CAC_EXPIRED: STA set the DFS state to usable
+ *	when STA is disconnected or leaving the channel
  */
 enum nl80211_radar_event {
 	NL80211_RADAR_DETECTED,
@@ -6851,6 +6913,10 @@ enum nl80211_radar_event {
 	NL80211_RADAR_NOP_FINISHED,
 	NL80211_RADAR_PRE_CAC_EXPIRED,
 	NL80211_RADAR_CAC_STARTED,
+	NL80211_RADAR_BACKGROUND_CHAN_UPDATE,
+	NL80211_RADAR_BACKGROUND_CHAN_EXPAND,
+	NL80211_RADAR_STA_CAC_SKIPPED,
+	NL80211_RADAR_STA_CAC_EXPIRED,
 };
 
 /**
@@ -8031,6 +8097,8 @@ enum nl80211_ap_settings_flags {
  * @NL80211_WIPHY_RADIO_ATTR_INTERFACE_COMBINATION: Supported interface
  *	combination for this radio. Attribute may be present multiple times
  *	and contains attributes defined in &enum nl80211_if_combination_attrs.
+ * @NL80211_WIPHY_RADIO_ATTR_ANTENNA_MASK: bitmask (u32) of antennas
+ *	connected to this radio.
  *
  * @__NL80211_WIPHY_RADIO_ATTR_LAST: Internal
  * @NL80211_WIPHY_RADIO_ATTR_MAX: Highest attribute
@@ -8041,6 +8109,7 @@ enum nl80211_wiphy_radio_attrs {
 	NL80211_WIPHY_RADIO_ATTR_INDEX,
 	NL80211_WIPHY_RADIO_ATTR_FREQ_RANGE,
 	NL80211_WIPHY_RADIO_ATTR_INTERFACE_COMBINATION,
+	NL80211_WIPHY_RADIO_ATTR_ANTENNA_MASK,
 
 	/* keep last */
 	__NL80211_WIPHY_RADIO_ATTR_LAST,
@@ -8070,4 +8139,39 @@ enum nl80211_wiphy_radio_freq_range {
 	NL80211_WIPHY_RADIO_FREQ_ATTR_MAX = __NL80211_WIPHY_RADIO_FREQ_ATTR_LAST - 1,
 };
 
+/**
+ * enum nl80211_attlm_event - type of events for Advertised Tid-to-Link
+ * Mapping operations
+ *
+ * @NL80211_ATTLM_STARTED: A A-TTLM request has been set and start to count down.
+ * @NL80211_ATTLM_SWITCH_TIME_EXPIRED: The switch time of A-TTLM has expired.
+ * @NL80211ATTLM_END: The A-TTLM has been done.
+ */
+enum nl80211_attlm_event {
+	NL80211_ATTLM_STARTED,
+	NL80211_ATTLM_SWITCH_TIME_EXPIRED,
+	NL80211_ATTLM_END,
+};
+
+/**
+ * enum nl80211_crit_update_event - type of critical update event
+ *
+ * Type of event to be used with NL80211_ATTR_CRTI_UPDATE_EVENT to inform userspace
+ * about the status of the current critical update flag.
+ *
+ * @NL80211_CRIT_UPDATE_NONE: clear the critical update flag.
+ * @NL80211_CRIT_UPDATE_SINGLE: update the BPCC of a single BSS and
+ *	set the critical update flag of the BSS.
+ * @NL80211_CRIT_UPDATE_ALL: update the BPCC of all the BSSes and
+ *	set the critical update flag of all the BSSes.
+ * @NL80211_CRIT_UPDATE_FLAG: set the critical update flag without updating BPCC.
+ */
+
+enum nl80211_crit_update_event {
+	NL80211_CRIT_UPDATE_NONE,
+	NL80211_CRIT_UPDATE_SINGLE,
+	NL80211_CRIT_UPDATE_ALL,
+	NL80211_CRIT_UPDATE_FLAG
+};
+
 #endif /* __LINUX_NL80211_H */
diff --git a/src/drivers/rfkill.h b/src/drivers/rfkill.h
index 0412ac3..e275653 100644
--- a/src/drivers/rfkill.h
+++ b/src/drivers/rfkill.h
@@ -18,8 +18,24 @@ struct rfkill_config {
 	void (*unblocked_cb)(void *ctx);
 };
 
+#ifdef CONFIG_RFKILL
 struct rfkill_data * rfkill_init(struct rfkill_config *cfg);
 void rfkill_deinit(struct rfkill_data *rfkill);
 int rfkill_is_blocked(struct rfkill_data *rfkill);
+#else
+static inline struct rfkill_data * rfkill_init(struct rfkill_config *cfg)
+{
+	return (void *) 1;
+}
+
+static inline void rfkill_deinit(struct rfkill_data *rfkill)
+{
+}
+
+static inline int rfkill_is_blocked(struct rfkill_data *rfkill)
+{
+	return 0;
+}
+#endif
 
 #endif /* RFKILL_H */
diff --git a/src/radius/radius_client.c b/src/radius/radius_client.c
index 2a7f361..8e89030 100644
--- a/src/radius/radius_client.c
+++ b/src/radius/radius_client.c
@@ -165,6 +165,8 @@ struct radius_client_data {
 	 */
 	void *ctx;
 
+	struct hostapd_ip_addr local_ip;
+
 	/**
 	 * conf - RADIUS client configuration (list of RADIUS servers to use)
 	 */
@@ -818,6 +820,30 @@ static void radius_close_acct_socket(struct radius_client_data *radius)
 }
 
 
+/**
+ * radius_client_send - Get local address for the RADIUS auth socket
+ * @radius: RADIUS client context from radius_client_init()
+ * @addr: pointer to store the address
+ *
+ * This function returns the local address for the connection to the RADIUS
+ * auth server. It also opens the socket if it's not available yet.
+ */
+int radius_client_get_local_addr(struct radius_client_data *radius,
+				 struct hostapd_ip_addr *addr)
+{
+	struct hostapd_radius_servers *conf = radius->conf;
+
+	if (conf->auth_server && radius->auth_sock < 0)
+		radius_client_init_auth(radius);
+
+	if (radius->auth_sock < 0)
+		return -1;
+
+	memcpy(addr, &radius->local_ip, sizeof(*addr));
+
+	return 0;
+}
+
 /**
  * radius_client_send - Send a RADIUS request
  * @radius: RADIUS client context from radius_client_init()
@@ -1711,6 +1737,10 @@ radius_change_server(struct radius_client_data *radius,
 			wpa_printf(MSG_DEBUG, "RADIUS local address: %s:%u",
 				   inet_ntoa(claddr.sin_addr),
 				   ntohs(claddr.sin_port));
+			if (auth) {
+				radius->local_ip.af = AF_INET;
+				radius->local_ip.u.v4 = claddr.sin_addr;
+			}
 		}
 		break;
 #ifdef CONFIG_IPV6
@@ -1722,6 +1752,10 @@ radius_change_server(struct radius_client_data *radius,
 				   inet_ntop(AF_INET6, &claddr6.sin6_addr,
 					     abuf, sizeof(abuf)),
 				   ntohs(claddr6.sin6_port));
+			if (auth) {
+				radius->local_ip.af = AF_INET6;
+				radius->local_ip.u.v6 = claddr6.sin6_addr;
+			}
 		}
 		break;
 	}
diff --git a/src/radius/radius_client.h b/src/radius/radius_client.h
index db40637..9a89b03 100644
--- a/src/radius/radius_client.h
+++ b/src/radius/radius_client.h
@@ -274,6 +274,8 @@ int radius_client_register(struct radius_client_data *radius,
 void radius_client_set_interim_error_cb(struct radius_client_data *radius,
 					void (*cb)(const u8 *addr, void *ctx),
 					void *ctx);
+int radius_client_get_local_addr(struct radius_client_data *radius,
+				 struct hostapd_ip_addr * addr);
 int radius_client_send(struct radius_client_data *radius,
 		       struct radius_msg *msg,
 		       RadiusType msg_type, const u8 *addr);
diff --git a/src/radius/radius_das.c b/src/radius/radius_das.c
index 8d7c9b4..01913b0 100644
--- a/src/radius/radius_das.c
+++ b/src/radius/radius_das.c
@@ -12,13 +12,26 @@
 #include "utils/common.h"
 #include "utils/eloop.h"
 #include "utils/ip_addr.h"
+#include "utils/list.h"
 #include "radius.h"
 #include "radius_das.h"
 
 
-struct radius_das_data {
+static struct dl_list das_ports = DL_LIST_HEAD_INIT(das_ports);
+
+struct radius_das_port {
+	struct dl_list list;
+	struct dl_list das_data;
+
+	int port;
 	int sock;
+};
+
+struct radius_das_data {
+	struct dl_list list;
+	struct radius_das_port *port;
 	u8 *shared_secret;
+	u8 *nas_identifier;
 	size_t shared_secret_len;
 	struct hostapd_ip_addr client_addr;
 	unsigned int time_window;
@@ -388,56 +401,17 @@ fail:
 }
 
 
-static void radius_das_receive(int sock, void *eloop_ctx, void *sock_ctx)
+static void
+radius_das_receive_msg(struct radius_das_data *das, struct radius_msg *msg,
+		       struct sockaddr *from, socklen_t fromlen,
+		       char *abuf, int from_port)
 {
-	struct radius_das_data *das = eloop_ctx;
-	u8 buf[1500];
-	union {
-		struct sockaddr_storage ss;
-		struct sockaddr_in sin;
-#ifdef CONFIG_IPV6
-		struct sockaddr_in6 sin6;
-#endif /* CONFIG_IPV6 */
-	} from;
-	char abuf[50];
-	int from_port = 0;
-	socklen_t fromlen;
-	int len;
-	struct radius_msg *msg, *reply = NULL;
+	struct radius_msg *reply = NULL;
 	struct radius_hdr *hdr;
 	struct wpabuf *rbuf;
+	struct os_time now;
 	u32 val;
 	int res;
-	struct os_time now;
-
-	fromlen = sizeof(from);
-	len = recvfrom(sock, buf, sizeof(buf), 0,
-		       (struct sockaddr *) &from.ss, &fromlen);
-	if (len < 0) {
-		wpa_printf(MSG_ERROR, "DAS: recvfrom: %s", strerror(errno));
-		return;
-	}
-
-	os_strlcpy(abuf, inet_ntoa(from.sin.sin_addr), sizeof(abuf));
-	from_port = ntohs(from.sin.sin_port);
-
-	wpa_printf(MSG_DEBUG, "DAS: Received %d bytes from %s:%d",
-		   len, abuf, from_port);
-	if (das->client_addr.u.v4.s_addr &&
-	    das->client_addr.u.v4.s_addr != from.sin.sin_addr.s_addr) {
-		wpa_printf(MSG_DEBUG, "DAS: Drop message from unknown client");
-		return;
-	}
-
-	msg = radius_msg_parse(buf, len);
-	if (msg == NULL) {
-		wpa_printf(MSG_DEBUG, "DAS: Parsing incoming RADIUS packet "
-			   "from %s:%d failed", abuf, from_port);
-		return;
-	}
-
-	if (wpa_debug_level <= MSG_MSGDUMP)
-		radius_msg_dump(msg);
 
 	if (radius_msg_verify_das_req(msg, das->shared_secret,
 				       das->shared_secret_len,
@@ -504,9 +478,8 @@ static void radius_das_receive(int sock, void *eloop_ctx, void *sock_ctx)
 			radius_msg_dump(reply);
 
 		rbuf = radius_msg_get_buf(reply);
-		res = sendto(das->sock, wpabuf_head(rbuf),
-			     wpabuf_len(rbuf), 0,
-			     (struct sockaddr *) &from.ss, fromlen);
+		res = sendto(das->port->sock, wpabuf_head(rbuf),
+			     wpabuf_len(rbuf), 0, from, fromlen);
 		if (res < 0) {
 			wpa_printf(MSG_ERROR, "DAS: sendto(to %s:%d): %s",
 				   abuf, from_port, strerror(errno));
@@ -518,6 +491,72 @@ fail:
 	radius_msg_free(reply);
 }
 
+static void radius_das_receive(int sock, void *eloop_ctx, void *sock_ctx)
+{
+	struct radius_das_port *p = eloop_ctx;
+	struct radius_das_data *das;
+	u8 buf[1500];
+	union {
+		struct sockaddr_storage ss;
+		struct sockaddr_in sin;
+#ifdef CONFIG_IPV6
+		struct sockaddr_in6 sin6;
+#endif /* CONFIG_IPV6 */
+	} from;
+	struct radius_msg *msg;
+	size_t nasid_len = 0;
+	u8 *nasid_buf = NULL;
+	char abuf[50];
+	int from_port = 0;
+	socklen_t fromlen;
+	int found = 0;
+	int len;
+
+	fromlen = sizeof(from);
+	len = recvfrom(sock, buf, sizeof(buf), 0,
+		       (struct sockaddr *) &from.ss, &fromlen);
+	if (len < 0) {
+		wpa_printf(MSG_ERROR, "DAS: recvfrom: %s", strerror(errno));
+		return;
+	}
+
+	os_strlcpy(abuf, inet_ntoa(from.sin.sin_addr), sizeof(abuf));
+	from_port = ntohs(from.sin.sin_port);
+
+	msg = radius_msg_parse(buf, len);
+	if (msg == NULL) {
+		wpa_printf(MSG_DEBUG, "DAS: Parsing incoming RADIUS packet "
+			   "from %s:%d failed", abuf, from_port);
+		return;
+	}
+
+	wpa_printf(MSG_DEBUG, "DAS: Received %d bytes from %s:%d",
+		   len, abuf, from_port);
+
+	if (wpa_debug_level <= MSG_MSGDUMP)
+		radius_msg_dump(msg);
+
+	radius_msg_get_attr_ptr(msg, RADIUS_ATTR_NAS_IDENTIFIER,
+				&nasid_buf, &nasid_len, NULL);
+	dl_list_for_each(das, &p->das_data, struct radius_das_data, list) {
+		if (das->client_addr.u.v4.s_addr &&
+		    das->client_addr.u.v4.s_addr != from.sin.sin_addr.s_addr)
+			continue;
+
+		if (das->nas_identifier && nasid_buf &&
+		    (nasid_len != os_strlen(das->nas_identifier) ||
+		     os_memcmp(das->nas_identifier, nasid_buf, nasid_len) != 0))
+			continue;
+
+		found = 1;
+		radius_das_receive_msg(das, msg, (struct sockaddr *)&from.ss,
+				       fromlen, abuf, from_port);
+	}
+
+	if (!found)
+		wpa_printf(MSG_DEBUG, "DAS: Drop message from unknown client");
+}
+
 
 static int radius_das_open_socket(int port)
 {
@@ -543,6 +582,49 @@ static int radius_das_open_socket(int port)
 }
 
 
+static struct radius_das_port *
+radius_das_open_port(int port)
+{
+	struct radius_das_port *p;
+
+	dl_list_for_each(p, &das_ports, struct radius_das_port, list) {
+		if (p->port == port)
+			return p;
+	}
+
+	p = os_zalloc(sizeof(*p));
+	if (p == NULL)
+		return NULL;
+
+	dl_list_init(&p->das_data);
+	p->port = port;
+	p->sock = radius_das_open_socket(port);
+	if (p->sock < 0)
+		goto free_port;
+
+	if (eloop_register_read_sock(p->sock, radius_das_receive, p, NULL))
+		goto close_port;
+
+	dl_list_add(&das_ports, &p->list);
+
+	return p;
+
+close_port:
+	close(p->sock);
+free_port:
+	os_free(p);
+
+	return NULL;
+}
+
+static void radius_das_close_port(struct radius_das_port *p)
+{
+	dl_list_del(&p->list);
+	eloop_unregister_read_sock(p->sock);
+	close(p->sock);
+	free(p);
+}
+
 struct radius_das_data *
 radius_das_init(struct radius_das_conf *conf)
 {
@@ -563,6 +645,8 @@ radius_das_init(struct radius_das_conf *conf)
 	das->ctx = conf->ctx;
 	das->disconnect = conf->disconnect;
 	das->coa = conf->coa;
+	if (conf->nas_identifier)
+		das->nas_identifier = os_strdup(conf->nas_identifier);
 
 	os_memcpy(&das->client_addr, conf->client_addr,
 		  sizeof(das->client_addr));
@@ -575,19 +659,15 @@ radius_das_init(struct radius_das_conf *conf)
 	}
 	das->shared_secret_len = conf->shared_secret_len;
 
-	das->sock = radius_das_open_socket(conf->port);
-	if (das->sock < 0) {
+	das->port = radius_das_open_port(conf->port);
+	if (!das->port) {
 		wpa_printf(MSG_ERROR, "Failed to open UDP socket for RADIUS "
 			   "DAS");
 		radius_das_deinit(das);
 		return NULL;
 	}
 
-	if (eloop_register_read_sock(das->sock, radius_das_receive, das, NULL))
-	{
-		radius_das_deinit(das);
-		return NULL;
-	}
+	dl_list_add(&das->port->das_data, &das->list);
 
 	return das;
 }
@@ -598,11 +678,14 @@ void radius_das_deinit(struct radius_das_data *das)
 	if (das == NULL)
 		return;
 
-	if (das->sock >= 0) {
-		eloop_unregister_read_sock(das->sock);
-		close(das->sock);
+	if (das->port) {
+		dl_list_del(&das->list);
+
+		if (dl_list_empty(&das->port->das_data))
+			radius_das_close_port(das->port);
 	}
 
+	os_free(das->nas_identifier);
 	os_free(das->shared_secret);
 	os_free(das);
 }
diff --git a/src/radius/radius_das.h b/src/radius/radius_das.h
index 233d662..80dc13f 100644
--- a/src/radius/radius_das.h
+++ b/src/radius/radius_das.h
@@ -44,6 +44,7 @@ struct radius_das_attrs {
 struct radius_das_conf {
 	int port;
 	const u8 *shared_secret;
+	const u8 *nas_identifier;
 	size_t shared_secret_len;
 	const struct hostapd_ip_addr *client_addr;
 	unsigned int time_window;
diff --git a/src/radius/radius_server.c b/src/radius/radius_server.c
index fa36915..95a1cb9 100644
--- a/src/radius/radius_server.c
+++ b/src/radius/radius_server.c
@@ -63,6 +63,12 @@ struct radius_server_counters {
 	u32 unknown_acct_types;
 };
 
+struct radius_accept_attr {
+	u8 type;
+	u16 len;
+	void *data;
+};
+
 /**
  * struct radius_session - Internal RADIUS server data for a session
  */
@@ -90,7 +96,7 @@ struct radius_session {
 	unsigned int macacl:1;
 	unsigned int t_c_filtering:1;
 
-	struct hostapd_radius_attr *accept_attr;
+	struct radius_accept_attr *accept_attr;
 
 	u32 t_c_timestamp; /* Last read T&C timestamp from user DB */
 };
@@ -394,6 +400,7 @@ static void radius_server_session_free(struct radius_server_data *data,
 	radius_msg_free(sess->last_reply);
 	os_free(sess->username);
 	os_free(sess->nas_ip);
+	os_free(sess->accept_attr);
 	os_free(sess);
 	data->num_sess--;
 }
@@ -554,6 +561,36 @@ radius_server_erp_find_key(struct radius_server_data *data, const char *keyname)
 }
 #endif /* CONFIG_ERP */
 
+static struct radius_accept_attr *
+radius_server_copy_attr(const struct hostapd_radius_attr *data)
+{
+	const struct hostapd_radius_attr *attr;
+	struct radius_accept_attr *attr_new;
+	size_t data_size = 0;
+	void *data_buf;
+	int n_attr = 1;
+
+	for (attr = data; attr; attr = attr->next) {
+		n_attr++;
+		data_size += wpabuf_len(attr->val);
+	}
+
+	attr_new = os_zalloc(n_attr * sizeof(*attr) + data_size);
+	if (!attr_new)
+		return NULL;
+
+	data_buf = &attr_new[n_attr];
+	for (n_attr = 0, attr = data; attr; attr = attr->next) {
+		struct radius_accept_attr *cur = &attr_new[n_attr++];
+
+		cur->type = attr->type;
+		cur->len = wpabuf_len(attr->val);
+		cur->data = memcpy(data_buf, wpabuf_head(attr->val), cur->len);
+		data_buf += cur->len;
+	}
+
+	return attr_new;
+}
 
 static struct radius_session *
 radius_server_get_new_session(struct radius_server_data *data,
@@ -607,7 +644,7 @@ radius_server_get_new_session(struct radius_server_data *data,
 		eap_user_free(tmp);
 		return NULL;
 	}
-	sess->accept_attr = tmp->accept_attr;
+	sess->accept_attr = radius_server_copy_attr(tmp->accept_attr);
 	sess->macacl = tmp->macacl;
 	eap_user_free(tmp);
 
@@ -1123,11 +1160,10 @@ radius_server_encapsulate_eap(struct radius_server_data *data,
 	}
 
 	if (code == RADIUS_CODE_ACCESS_ACCEPT) {
-		struct hostapd_radius_attr *attr;
-		for (attr = sess->accept_attr; attr; attr = attr->next) {
-			if (!radius_msg_add_attr(msg, attr->type,
-						 wpabuf_head(attr->val),
-						 wpabuf_len(attr->val))) {
+		struct radius_accept_attr *attr;
+		for (attr = sess->accept_attr; attr->data; attr++) {
+			if (!radius_msg_add_attr(msg, attr->type, attr->data,
+						 attr->len)) {
 				wpa_printf(MSG_ERROR, "Could not add RADIUS attribute");
 				radius_msg_free(msg);
 				return NULL;
@@ -1221,11 +1257,10 @@ radius_server_macacl(struct radius_server_data *data,
 	}
 
 	if (code == RADIUS_CODE_ACCESS_ACCEPT) {
-		struct hostapd_radius_attr *attr;
-		for (attr = sess->accept_attr; attr; attr = attr->next) {
-			if (!radius_msg_add_attr(msg, attr->type,
-						 wpabuf_head(attr->val),
-						 wpabuf_len(attr->val))) {
+		struct radius_accept_attr *attr;
+		for (attr = sess->accept_attr; attr->data; attr++) {
+			if (!radius_msg_add_attr(msg, attr->type, attr->data,
+						 attr->len)) {
 				wpa_printf(MSG_ERROR, "Could not add RADIUS attribute");
 				radius_msg_free(msg);
 				return NULL;
@@ -2527,7 +2562,7 @@ static int radius_server_get_eap_user(void *ctx, const u8 *identity,
 	ret = data->get_eap_user(data->conf_ctx, identity, identity_len,
 				 phase2, user);
 	if (ret == 0 && user) {
-		sess->accept_attr = user->accept_attr;
+		sess->accept_attr = radius_server_copy_attr(user->accept_attr);
 		sess->remediation = user->remediation;
 		sess->macacl = user->macacl;
 		sess->t_c_timestamp = user->t_c_timestamp;
diff --git a/src/rsn_supp/wpa.c b/src/rsn_supp/wpa.c
index e127093..716a1d5 100644
--- a/src/rsn_supp/wpa.c
+++ b/src/rsn_supp/wpa.c
@@ -4159,6 +4159,8 @@ static u32 wpa_key_mgmt_suite(struct wpa_sm *sm)
 }
 
 
+#ifdef CONFIG_CTRL_IFACE_MIB
+
 #define RSN_SUITE "%02x-%02x-%02x-%d"
 #define RSN_SUITE_ARG(s) \
 ((s) >> 24) & 0xff, ((s) >> 16) & 0xff, ((s) >> 8) & 0xff, (s) & 0xff
@@ -4240,6 +4242,7 @@ int wpa_sm_get_mib(struct wpa_sm *sm, char *buf, size_t buflen)
 
 	return (int) len;
 }
+#endif
 #endif /* CONFIG_CTRL_IFACE */
 
 
diff --git a/src/tls/Makefile b/src/tls/Makefile
index c84fbe8..e974a41 100644
--- a/src/tls/Makefile
+++ b/src/tls/Makefile
@@ -1,3 +1,10 @@
+LIB_OBJS= asn1.o
+
+ifneq ($(CONFIG_TLS),gnutls)
+ifneq ($(CONFIG_TLS),mbedtls)
+ifneq ($(CONFIG_TLS),openssl)
+ifneq ($(CONFIG_TLS),wolfssl)
+
 CFLAGS += -DCONFIG_INTERNAL_LIBTOMMATH
 CFLAGS += -DCONFIG_CRYPTO_INTERNAL
 CFLAGS += -DCONFIG_TLSV11
@@ -21,5 +28,9 @@ LIB_OBJS= \
 	tlsv1_server_read.o \
 	tlsv1_server_write.o \
 	x509v3.o
+endif
+endif
+endif
+endif
 
 include ../lib.rules
diff --git a/src/utils/build_features.h b/src/utils/build_features.h
new file mode 100644
index 0000000..cc88315
--- /dev/null
+++ b/src/utils/build_features.h
@@ -0,0 +1,69 @@
+#ifndef BUILD_FEATURES_H
+#define BUILD_FEATURES_H
+
+static inline int has_feature(const char *feat)
+{
+#if defined(IEEE8021X_EAPOL) || (defined(HOSTAPD) && !defined(CONFIG_NO_RADIUS))
+	if (!strcmp(feat, "eap"))
+		return 1;
+#endif
+#ifdef CONFIG_IEEE80211AC
+	if (!strcmp(feat, "11ac"))
+		return 1;
+#endif
+#ifdef CONFIG_IEEE80211AX
+	if (!strcmp(feat, "11ax"))
+		return 1;
+#endif
+#ifdef CONFIG_IEEE80211BE
+	if (!strcmp(feat, "11be"))
+		return 1;
+#endif
+#ifdef CONFIG_IEEE80211R
+	if (!strcmp(feat, "11r"))
+		return 1;
+#endif
+#ifdef CONFIG_ACS
+	if (!strcmp(feat, "acs"))
+		return 1;
+#endif
+#ifdef CONFIG_SAE
+	if (!strcmp(feat, "sae"))
+		return 1;
+#endif
+#ifdef CONFIG_OWE
+	if (!strcmp(feat, "owe"))
+		return 1;
+#endif
+#ifdef CONFIG_SUITEB192
+	if (!strcmp(feat, "suiteb192"))
+		return 1;
+#endif
+#ifdef CONFIG_WEP
+	if (!strcmp(feat, "wep"))
+		return 1;
+#endif
+#ifdef CONFIG_HS20
+	if (!strcmp(feat, "hs20"))
+		return 1;
+#endif
+#ifdef CONFIG_WPS
+	if (!strcmp(feat, "wps"))
+		return 1;
+#endif
+#ifdef CONFIG_FILS
+	if (!strcmp(feat, "fils"))
+		return 1;
+#endif
+#ifdef CONFIG_OCV
+	if (!strcmp(feat, "ocv"))
+		return 1;
+#endif
+#ifdef CONFIG_MESH
+	if (!strcmp(feat, "mesh"))
+		return 1;
+#endif
+	return 0;
+}
+
+#endif /* BUILD_FEATURES_H */
diff --git a/src/utils/eloop.c b/src/utils/eloop.c
index 00b0bef..50dd1be 100644
--- a/src/utils/eloop.c
+++ b/src/utils/eloop.c
@@ -77,6 +77,9 @@ struct eloop_sock_table {
 struct eloop_data {
 	int max_sock;
 
+	eloop_timeout_poll_handler timeout_poll_cb;
+	eloop_poll_handler poll_cb;
+
 	size_t count; /* sum of all table counts */
 #ifdef CONFIG_ELOOP_POLL
 	size_t max_pollfd_map; /* number of pollfds_map currently allocated */
@@ -1121,6 +1124,12 @@ void eloop_run(void)
 				os_reltime_sub(&timeout->time, &now, &tv);
 			else
 				tv.sec = tv.usec = 0;
+		}
+
+		if (eloop.timeout_poll_cb && eloop.timeout_poll_cb(&tv, !!timeout))
+			timeout = (void *)1;
+
+		if (timeout) {
 #if defined(CONFIG_ELOOP_POLL) || defined(CONFIG_ELOOP_EPOLL)
 			timeout_ms = tv.sec * 1000 + tv.usec / 1000;
 #endif /* defined(CONFIG_ELOOP_POLL) || defined(CONFIG_ELOOP_EPOLL) */
@@ -1190,7 +1199,8 @@ void eloop_run(void)
 		eloop.exceptions.changed = 0;
 
 		eloop_process_pending_signals();
-
+		if (eloop.poll_cb)
+			eloop.poll_cb();
 
 		/* check if some registered timeouts have occurred */
 		timeout = dl_list_first(&eloop.timeout, struct eloop_timeout,
@@ -1252,6 +1262,14 @@ out:
 	return;
 }
 
+int eloop_register_cb(eloop_poll_handler poll_cb,
+		      eloop_timeout_poll_handler timeout_cb)
+{
+	eloop.poll_cb = poll_cb;
+	eloop.timeout_poll_cb = timeout_cb;
+
+	return 0;
+}
 
 void eloop_terminate(void)
 {
diff --git a/src/utils/eloop.h b/src/utils/eloop.h
index 04ee6d1..5452ea5 100644
--- a/src/utils/eloop.h
+++ b/src/utils/eloop.h
@@ -65,6 +65,9 @@ typedef void (*eloop_timeout_handler)(void *eloop_ctx, void *user_ctx);
  */
 typedef void (*eloop_signal_handler)(int sig, void *signal_ctx);
 
+typedef bool (*eloop_timeout_poll_handler)(struct os_reltime *tv, bool tv_set);
+typedef void (*eloop_poll_handler)(void);
+
 /**
  * eloop_init() - Initialize global event loop data
  * Returns: 0 on success, -1 on failure
@@ -73,6 +76,9 @@ typedef void (*eloop_signal_handler)(int sig, void *signal_ctx);
  */
 int eloop_init(void);
 
+int eloop_register_cb(eloop_poll_handler poll_cb,
+		      eloop_timeout_poll_handler timeout_cb);
+
 /**
  * eloop_register_read_sock - Register handler for read events
  * @sock: File descriptor number for the socket
@@ -320,6 +326,8 @@ int eloop_register_signal_reconfig(eloop_signal_handler handler,
  */
 int eloop_sock_requeue(void);
 
+void eloop_add_uloop(void);
+
 /**
  * eloop_run - Start the event loop
  *
diff --git a/src/utils/ucode.c b/src/utils/ucode.c
new file mode 100644
index 0000000..187a9cb
--- /dev/null
+++ b/src/utils/ucode.c
@@ -0,0 +1,517 @@
+#include <unistd.h>
+#include "ucode.h"
+#include "utils/eloop.h"
+#include "crypto/crypto.h"
+#include "crypto/sha1.h"
+#include "common/ieee802_11_common.h"
+#include <linux/netlink.h>
+#include <linux/genetlink.h>
+#include <linux/nl80211.h>
+#include <libubox/uloop.h>
+#include <ucode/compiler.h>
+#include <udebug.h>
+
+static uc_value_t *registry;
+static uc_vm_t vm;
+static struct uloop_timeout gc_timer;
+static struct udebug ud;
+static struct udebug_buf ud_log, ud_nl[3];
+static const struct udebug_buf_meta meta_log = {
+	.name = "wpa_log",
+	.format = UDEBUG_FORMAT_STRING,
+};
+static const struct udebug_buf_meta meta_nl_ll = {
+	.name = "wpa_nl_ctrl",
+	.format = UDEBUG_FORMAT_PACKET,
+	.sub_format = UDEBUG_DLT_NETLINK,
+};
+static const struct udebug_buf_meta meta_nl_tx = {
+	.name = "wpa_nl_tx",
+	.format = UDEBUG_FORMAT_PACKET,
+	.sub_format = UDEBUG_DLT_NETLINK,
+};
+#define UDEBUG_FLAG_RX_FRAME	(1ULL << 0)
+static const struct udebug_buf_flag rx_flags[] = {
+	{  "rx_frame", UDEBUG_FLAG_RX_FRAME },
+};
+static const struct udebug_buf_meta meta_nl_rx = {
+	.name = "wpa_nl_rx",
+	.format = UDEBUG_FORMAT_PACKET,
+	.sub_format = UDEBUG_DLT_NETLINK,
+	.flags = rx_flags,
+	.n_flags = ARRAY_SIZE(rx_flags),
+};
+static struct udebug_ubus_ring udebug_rings[] = {
+	{
+		.buf = &ud_log,
+		.meta = &meta_log,
+		.default_entries = 1024,
+		.default_size = 64 * 1024
+	},
+	{
+		.buf = &ud_nl[0],
+		.meta = &meta_nl_rx,
+		.default_entries = 1024,
+		.default_size = 256 * 1024,
+	},
+	{
+		.buf = &ud_nl[1],
+		.meta = &meta_nl_tx,
+		.default_entries = 1024,
+		.default_size = 64 * 1024,
+	},
+	{
+		.buf = &ud_nl[2],
+		.meta = &meta_nl_ll,
+		.default_entries = 1024,
+		.default_size = 32 * 1024,
+	}
+};
+char *udebug_service;
+struct udebug_ubus ud_ubus;
+
+static void uc_gc_timer(struct uloop_timeout *timeout)
+{
+	ucv_gc(&vm);
+}
+
+uc_value_t *uc_wpa_printf(uc_vm_t *vm, size_t nargs)
+{
+	uc_value_t *level = uc_fn_arg(0);
+	uc_value_t *ret, **args;
+	uc_cfn_ptr_t _sprintf;
+	int l = MSG_INFO;
+	int i, start = 0;
+
+	_sprintf = uc_stdlib_function("sprintf");
+	if (!sprintf)
+		return NULL;
+
+	if (ucv_type(level) == UC_INTEGER) {
+		l = ucv_int64_get(level);
+		start++;
+	}
+
+	if (nargs <= start)
+		return NULL;
+
+	ret = _sprintf(vm, nargs - start);
+	if (ucv_type(ret) != UC_STRING)
+		return NULL;
+
+	wpa_printf(l, "%s", ucv_string_get(ret));
+	ucv_put(ret);
+
+	return NULL;
+}
+
+uc_value_t *uc_wpa_freq_info(uc_vm_t *vm, size_t nargs)
+{
+	uc_value_t *freq = uc_fn_arg(0);
+	uc_value_t *sec = uc_fn_arg(1);
+	int width = ucv_uint64_get(uc_fn_arg(2));
+	int punct_bitmap = ucv_uint64_get(uc_fn_arg(5));
+	int bw320_offset = 1, radio_idx;
+	int freq_val, center_idx, center_ofs;
+	enum oper_chan_width chanwidth;
+	enum hostapd_hw_mode hw_mode;
+	u8 op_class, channel, tmp_channel;
+	const char *modestr;
+	int sec_channel = 0;
+	uc_value_t *ret;
+
+	if (ucv_type(freq) != UC_INTEGER)
+		return NULL;
+
+	freq_val = ucv_int64_get(freq);
+	radio_idx = ucv_int64_get(uc_fn_arg(4));
+	if (ucv_type(sec) == UC_INTEGER)
+		sec_channel = ucv_int64_get(sec);
+	else if (sec)
+		return NULL;
+	else if (freq_val > 4000)
+		sec_channel = (freq_val / 20) & 1 ? 1 : -1;
+	else
+		sec_channel = freq_val < 2442 ? 1 : -1;
+
+	if (sec_channel != -1 && sec_channel != 1 && sec_channel != 0)
+		return NULL;
+
+	switch (width) {
+	case 0:
+		chanwidth = CONF_OPER_CHWIDTH_USE_HT;
+		break;
+	case 1:
+		chanwidth = CONF_OPER_CHWIDTH_80MHZ;
+		break;
+	case 2:
+		chanwidth = CONF_OPER_CHWIDTH_160MHZ;
+		break;
+	case 9:
+		width = 3;
+		chanwidth = CONF_OPER_CHWIDTH_320MHZ;
+
+		/* bw320_offset is 1 for 320 MHz-1, and 2 for 320 MHz-2 */
+		bw320_offset = ucv_uint64_get(uc_fn_arg(3));
+		break;
+	default:
+		return NULL;
+	}
+
+	hw_mode = ieee80211_freq_to_channel_ext(freq_val, sec_channel,
+						chanwidth, &op_class, &channel);
+	switch (hw_mode) {
+	case HOSTAPD_MODE_IEEE80211B:
+		modestr = "b";
+		break;
+	case HOSTAPD_MODE_IEEE80211G:
+		modestr = "g";
+		break;
+	case HOSTAPD_MODE_IEEE80211A:
+		modestr = "a";
+		break;
+	case HOSTAPD_MODE_IEEE80211AD:
+		modestr = "ad";
+		break;
+	default:
+		return NULL;
+	}
+
+	ret = ucv_object_new(vm);
+	ucv_object_add(ret, "op_class", ucv_int64_new(op_class));
+	ucv_object_add(ret, "channel", ucv_int64_new(channel));
+	ucv_object_add(ret, "hw_mode", ucv_int64_new(hw_mode));
+	ucv_object_add(ret, "hw_mode_str", ucv_get(ucv_string_new(modestr)));
+	ucv_object_add(ret, "sec_channel", ucv_int64_new(sec_channel));
+	ucv_object_add(ret, "frequency", ucv_int64_new(freq_val));
+	ucv_object_add(ret, "oper_chwidth", ucv_int64_new(chanwidth));
+	ucv_object_add(ret, "radio_idx", ucv_int64_new(radio_idx));
+	ucv_object_add(ret, "punct_bitmap", ucv_int64_new(punct_bitmap));
+
+	if (chanwidth == CONF_OPER_CHWIDTH_USE_HT) {
+		center_idx = freq_val < 3000 ? 0 : channel + 2 * sec_channel;
+		ucv_object_add(ret, "center_seg0_idx", ucv_int64_new(center_idx));
+		ucv_object_add(ret, "center_freq1",
+			       ucv_int64_new(freq_val + sec_channel * 10));
+		return ret;
+	}
+
+	if (freq_val >= 5900)
+		center_ofs = 32 * (1 - bw320_offset);
+	else if (freq_val >= 5745)
+		center_ofs = 20;
+	else
+		center_ofs = 35;
+	tmp_channel = channel - center_ofs;
+	tmp_channel &= ~((8 << width) - 1);
+	center_idx = tmp_channel + center_ofs + (4 << width) - 1;
+
+	ucv_object_add(ret, "center_seg0_idx", ucv_int64_new(center_idx));
+	center_idx = (center_idx - channel) * 5 + freq_val;
+	ucv_object_add(ret, "center_freq1", ucv_int64_new(center_idx));
+
+out:
+	return ret;
+}
+
+uc_value_t *uc_wpa_getpid(uc_vm_t *vm, size_t nargs)
+{
+	return ucv_int64_new(getpid());
+}
+
+uc_value_t *uc_wpa_sha1(uc_vm_t *vm, size_t nargs)
+{
+	u8 hash[SHA1_MAC_LEN];
+	char hash_hex[2 * ARRAY_SIZE(hash) + 1];
+	uc_value_t *val;
+	size_t *lens;
+	const u8 **args;
+	int i;
+
+	if (!nargs)
+		return NULL;
+
+	args = alloca(nargs * sizeof(*args));
+	lens = alloca(nargs * sizeof(*lens));
+	for (i = 0; i < nargs; i++) {
+		val = uc_fn_arg(i);
+		if (ucv_type(val) != UC_STRING)
+			return NULL;
+
+		args[i] = ucv_string_get(val);
+		lens[i] = ucv_string_length(val);
+	}
+
+	if (sha1_vector(nargs, args, lens, hash))
+		return NULL;
+
+	for (i = 0; i < ARRAY_SIZE(hash); i++)
+		sprintf(hash_hex + 2 * i, "%02x", hash[i]);
+
+	return ucv_string_new_length(hash_hex, 2 * ARRAY_SIZE(hash));
+}
+
+uc_vm_t *wpa_ucode_create_vm(void)
+{
+	static uc_parse_config_t config = {
+		.strict_declarations = true,
+		.lstrip_blocks = true,
+		.trim_blocks = true,
+		.raw_mode = true
+	};
+
+	uc_search_path_init(&config.module_search_path);
+	uc_search_path_add(&config.module_search_path, HOSTAPD_UC_PATH "*.so");
+	uc_search_path_add(&config.module_search_path, HOSTAPD_UC_PATH "*.uc");
+
+	uc_vm_init(&vm, &config);
+
+	uc_stdlib_load(uc_vm_scope_get(&vm));
+	eloop_add_uloop();
+	gc_timer.cb = uc_gc_timer;
+
+	return &vm;
+}
+
+int wpa_ucode_run(const char *script)
+{
+	uc_source_t *source;
+	uc_program_t *prog;
+	uc_value_t *ops;
+	char *err;
+	int ret;
+
+	source = uc_source_new_file(script);
+	if (!source)
+		return -1;
+
+	prog = uc_compile(vm.config, source, &err);
+	uc_source_put(source);
+	if (!prog) {
+		wpa_printf(MSG_ERROR, "Error loading ucode: %s\n", err);
+		return -1;
+	}
+
+	ret = uc_vm_execute(&vm, prog, &ops);
+	uc_program_put(prog);
+	if (ret || !ops)
+		return -1;
+
+	registry = ucv_array_new(&vm);
+	uc_vm_registry_set(&vm, "hostap.registry", registry);
+	ucv_array_set(registry, 0, ucv_get(ops));
+
+	return 0;
+}
+
+int wpa_ucode_call_prepare(const char *fname)
+{
+	uc_value_t *obj, *func;
+
+	if (!registry)
+		return -1;
+
+	obj = ucv_array_get(registry, 0);
+	if (!obj)
+		return -1;
+
+	func = ucv_object_get(obj, fname, NULL);
+	if (!ucv_is_callable(func))
+		return -1;
+
+	uc_vm_stack_push(&vm, ucv_get(obj));
+	uc_vm_stack_push(&vm, ucv_get(func));
+
+	return 0;
+}
+
+static void udebug_printf_hook(int level, const char *fmt, va_list ap)
+{
+	udebug_entry_init(&ud_log);
+	udebug_entry_vprintf(&ud_log, fmt, ap);
+	udebug_entry_add(&ud_log);
+}
+
+static void udebug_hexdump_hook(int level, const char *title,
+                const void *data, size_t len)
+{
+	char *buf;
+
+	udebug_entry_init(&ud_log);
+	udebug_entry_printf(&ud_log, "%s - hexdump:", title);
+	buf = udebug_entry_append(&ud_log, NULL, 3 * len);
+	for (size_t i = 0; i < len; i++)
+		buf += sprintf(buf, " %02x", *(uint8_t *)(data + i));
+	udebug_entry_add(&ud_log);
+}
+
+static void udebug_netlink_hook(int tx, const void *data, size_t len)
+{
+	struct {
+		uint16_t pkttype;
+		uint16_t arphdr;
+		uint16_t _pad[5];
+		uint16_t proto;
+	} hdr = {
+		.pkttype = host_to_be16(tx ? 7 : 6),
+		.arphdr = host_to_be16(824),
+		.proto = host_to_be16(16),
+	};
+	const struct nlmsghdr *nlh = data;
+	const struct genlmsghdr *gnlh = data + NLMSG_HDRLEN;
+	struct udebug_buf *buf = &ud_nl[!!tx];
+
+	if (nlh->nlmsg_type == 0x10)
+		buf = &ud_nl[2];
+	else if (!tx && gnlh->cmd == NL80211_CMD_FRAME &&
+	         !(udebug_buf_flags(buf) & UDEBUG_FLAG_RX_FRAME))
+		return;
+
+	if (!udebug_buf_valid(buf))
+		return;
+
+	udebug_entry_init(buf);
+	udebug_entry_append(buf, &hdr, sizeof(hdr));
+	udebug_entry_append(buf, data, len);
+	udebug_entry_add(buf);
+}
+
+static void
+wpa_udebug_config(struct udebug_ubus *ctx, struct blob_attr *data,
+		  bool enabled)
+{
+	udebug_ubus_apply_config(&ud, udebug_rings, ARRAY_SIZE(udebug_rings),
+				 data, enabled);
+
+	if (udebug_buf_valid(&ud_log)) {
+		wpa_printf_hook = udebug_printf_hook;
+		wpa_hexdump_hook = udebug_hexdump_hook;
+	} else {
+		wpa_printf_hook = NULL;
+		wpa_hexdump_hook = NULL;
+	}
+
+	if (udebug_buf_valid(&ud_nl[0]) ||
+	    udebug_buf_valid(&ud_nl[1]) ||
+	    udebug_buf_valid(&ud_nl[2]))
+		wpa_netlink_hook = udebug_netlink_hook;
+	else
+		wpa_netlink_hook = NULL;
+}
+
+uc_value_t *uc_wpa_udebug_set(uc_vm_t *vm, size_t nargs)
+{
+	uc_value_t *name = uc_fn_arg(0);
+	uc_value_t *ubus = uc_fn_arg(1);
+	static bool enabled = false;
+	struct ubus_context *ctx;
+	bool cur_en;
+
+	cur_en = ucv_type(name) == UC_STRING;
+	ctx = ucv_resource_data(ubus, "ubus.connection");
+	if (!ctx)
+		cur_en = false;
+
+	if (enabled == cur_en)
+		return ucv_boolean_new(true);
+
+	enabled = cur_en;
+	if (enabled) {
+		udebug_service = strdup(ucv_string_get(name));
+		udebug_init(&ud);
+		udebug_auto_connect(&ud, NULL);
+		udebug_ubus_init(&ud_ubus, ctx, udebug_service, wpa_udebug_config);
+	} else {
+		udebug_ubus_free(&ud_ubus);
+		for (size_t i = 0; i < ARRAY_SIZE(udebug_rings); i++)
+			if (udebug_buf_valid(udebug_rings[i].buf))
+				udebug_buf_free(udebug_rings[i].buf);
+		udebug_free(&ud);
+		free(udebug_service);
+	}
+
+	return ucv_boolean_new(true);
+}
+
+uc_value_t *wpa_ucode_global_init(const char *name, uc_resource_type_t *global_type)
+{
+	uc_value_t *global = uc_resource_new(global_type, NULL);
+	uc_value_t *proto;
+
+	uc_vm_registry_set(&vm, "hostap.global", global);
+	proto = ucv_prototype_get(global);
+	ucv_object_add(proto, "data", ucv_get(ucv_object_new(&vm)));
+
+#define ADD_CONST(x) ucv_object_add(proto, #x, ucv_int64_new(x))
+	ADD_CONST(MSG_EXCESSIVE);
+	ADD_CONST(MSG_MSGDUMP);
+	ADD_CONST(MSG_DEBUG);
+	ADD_CONST(MSG_INFO);
+	ADD_CONST(MSG_WARNING);
+	ADD_CONST(MSG_ERROR);
+#undef ADD_CONST
+
+	ucv_object_add(uc_vm_scope_get(&vm), name, ucv_get(global));
+
+	return global;
+}
+
+int wpa_ucode_registry_add(uc_value_t *reg, uc_value_t *val)
+{
+	uc_value_t *data;
+	int i = 0;
+
+	while (ucv_array_get(reg, i))
+		i++;
+
+	ucv_array_set(reg, i, ucv_get(val));
+
+	return i + 1;
+}
+
+uc_value_t *wpa_ucode_registry_get(uc_value_t *reg, int idx)
+{
+	if (!idx)
+		return NULL;
+
+	return ucv_array_get(reg, idx - 1);
+}
+
+uc_value_t *wpa_ucode_registry_remove(uc_value_t *reg, int idx)
+{
+	uc_value_t *val = wpa_ucode_registry_get(reg, idx);
+	void **dataptr;
+
+	if (!val)
+		return NULL;
+
+	ucv_array_set(reg, idx - 1, NULL);
+	dataptr = ucv_resource_dataptr(val, NULL);
+	if (dataptr)
+		*dataptr = NULL;
+
+	return val;
+}
+
+
+uc_value_t *wpa_ucode_call(size_t nargs)
+{
+	if (uc_vm_call(&vm, true, nargs) != EXCEPTION_NONE)
+		return NULL;
+
+	if (!gc_timer.pending)
+		uloop_timeout_set(&gc_timer, 10);
+
+	return uc_vm_stack_pop(&vm);
+}
+
+void wpa_ucode_free_vm(void)
+{
+	if (!vm.config)
+		return;
+
+	uc_search_path_free(&vm.config->module_search_path);
+	uc_vm_free(&vm);
+	registry = NULL;
+	vm = (uc_vm_t){};
+}
diff --git a/src/utils/ucode.h b/src/utils/ucode.h
new file mode 100644
index 0000000..c083241
--- /dev/null
+++ b/src/utils/ucode.h
@@ -0,0 +1,30 @@
+#ifndef __HOSTAPD_UTILS_UCODE_H
+#define __HOSTAPD_UTILS_UCODE_H
+
+#include "utils/includes.h"
+#include "utils/common.h"
+#include <ucode/lib.h>
+#include <ucode/vm.h>
+
+#define HOSTAPD_UC_PATH	"/usr/share/hostap/"
+
+extern uc_value_t *uc_registry;
+uc_vm_t *wpa_ucode_create_vm(void);
+int wpa_ucode_run(const char *script);
+int wpa_ucode_call_prepare(const char *fname);
+uc_value_t *wpa_ucode_call(size_t nargs);
+void wpa_ucode_free_vm(void);
+
+uc_value_t *wpa_ucode_global_init(const char *name, uc_resource_type_t *global_type);
+
+int wpa_ucode_registry_add(uc_value_t *reg, uc_value_t *val);
+uc_value_t *wpa_ucode_registry_get(uc_value_t *reg, int idx);
+uc_value_t *wpa_ucode_registry_remove(uc_value_t *reg, int idx);
+
+uc_value_t *uc_wpa_udebug_set(uc_vm_t *vm, size_t nargs);
+uc_value_t *uc_wpa_printf(uc_vm_t *vm, size_t nargs);
+uc_value_t *uc_wpa_getpid(uc_vm_t *vm, size_t nargs);
+uc_value_t *uc_wpa_sha1(uc_vm_t *vm, size_t nargs);
+uc_value_t *uc_wpa_freq_info(uc_vm_t *vm, size_t nargs);
+
+#endif
diff --git a/src/utils/uloop.c b/src/utils/uloop.c
new file mode 100644
index 0000000..c0d26db
--- /dev/null
+++ b/src/utils/uloop.c
@@ -0,0 +1,64 @@
+#include <libubox/uloop.h>
+#include "includes.h"
+#include "common.h"
+#include "eloop.h"
+
+static void eloop_uloop_event_cb(int sock, void *eloop_ctx, void *sock_ctx)
+{
+}
+
+static void eloop_uloop_fd_cb(struct uloop_fd *fd, unsigned int events)
+{
+	unsigned int changed = events ^ fd->flags;
+
+	if (changed & ULOOP_READ) {
+		if (events & ULOOP_READ)
+			eloop_register_sock(fd->fd, EVENT_TYPE_READ, eloop_uloop_event_cb, fd, fd);
+		else
+			eloop_unregister_sock(fd->fd, EVENT_TYPE_READ);
+	}
+
+	if (changed & ULOOP_WRITE) {
+		if (events & ULOOP_WRITE)
+			eloop_register_sock(fd->fd, EVENT_TYPE_WRITE, eloop_uloop_event_cb, fd, fd);
+		else
+			eloop_unregister_sock(fd->fd, EVENT_TYPE_WRITE);
+	}
+}
+
+static bool uloop_timeout_poll_handler(struct os_reltime *tv, bool tv_set)
+{
+	struct os_reltime tv_uloop;
+	int timeout_ms = uloop_get_next_timeout();
+
+	if (timeout_ms < 0)
+		return false;
+
+	tv_uloop.sec = timeout_ms / 1000;
+	tv_uloop.usec = (timeout_ms % 1000) * 1000;
+
+	if (!tv_set || os_reltime_before(&tv_uloop, tv)) {
+		*tv = tv_uloop;
+		return true;
+	}
+
+	return false;
+}
+
+static void uloop_poll_handler(void)
+{
+	uloop_run_timeout(0);
+}
+
+void eloop_add_uloop(void)
+{
+	static bool init_done = false;
+
+	if (!init_done) {
+		uloop_init();
+		uloop_fd_set_cb = eloop_uloop_fd_cb;
+		init_done = true;
+	}
+
+	eloop_register_cb(uloop_poll_handler, uloop_timeout_poll_handler);
+}
diff --git a/src/utils/wpa_debug.c b/src/utils/wpa_debug.c
index 7f3dd18..627575e 100644
--- a/src/utils/wpa_debug.c
+++ b/src/utils/wpa_debug.c
@@ -26,6 +26,10 @@ static FILE *wpa_debug_tracing_file = NULL;
 #define WPAS_TRACE_PFX "wpas <%d>: "
 #endif /* CONFIG_DEBUG_LINUX_TRACING */
 
+void (*wpa_printf_hook)(int level, const char *fmt, va_list ap);
+void (*wpa_hexdump_hook)(int level, const char *title, const void *buf,
+			 size_t len);
+void (*wpa_netlink_hook)(int tx, const void *data, size_t len);
 
 int wpa_debug_level = MSG_INFO;
 int wpa_debug_show_keys = 0;
@@ -206,10 +210,16 @@ void wpa_debug_close_linux_tracing(void)
  *
  * Note: New line '\n' is added to the end of the text when printing to stdout.
  */
-void wpa_printf(int level, const char *fmt, ...)
+void _wpa_printf(int level, const char *fmt, ...)
 {
 	va_list ap;
 
+	if (wpa_printf_hook) {
+		va_start(ap, fmt);
+		wpa_printf_hook(level, fmt, ap);
+		va_end(ap);
+	}
+
 	if (level >= wpa_debug_level) {
 #ifdef CONFIG_ANDROID_LOG
 		va_start(ap, fmt);
@@ -255,11 +265,14 @@ void wpa_printf(int level, const char *fmt, ...)
 }
 
 
-static void _wpa_hexdump(int level, const char *title, const u8 *buf,
+void _wpa_hexdump(int level, const char *title, const u8 *buf,
 			 size_t len, int show, int only_syslog)
 {
 	size_t i;
 
+	if (wpa_hexdump_hook)
+		wpa_hexdump_hook(level, title, buf, len);
+
 #ifdef CONFIG_DEBUG_LINUX_TRACING
 	if (wpa_debug_tracing_file != NULL) {
 		fprintf(wpa_debug_tracing_file,
@@ -382,19 +395,7 @@ static void _wpa_hexdump(int level, const char *title, const u8 *buf,
 #endif /* CONFIG_ANDROID_LOG */
 }
 
-void wpa_hexdump(int level, const char *title, const void *buf, size_t len)
-{
-	_wpa_hexdump(level, title, buf, len, 1, 0);
-}
-
-
-void wpa_hexdump_key(int level, const char *title, const void *buf, size_t len)
-{
-	_wpa_hexdump(level, title, buf, len, wpa_debug_show_keys, 0);
-}
-
-
-static void _wpa_hexdump_ascii(int level, const char *title, const void *buf,
+void _wpa_hexdump_ascii(int level, const char *title, const void *buf,
 			       size_t len, int show)
 {
 	size_t i, llen;
@@ -507,20 +508,6 @@ file_done:
 }
 
 
-void wpa_hexdump_ascii(int level, const char *title, const void *buf,
-		       size_t len)
-{
-	_wpa_hexdump_ascii(level, title, buf, len, 1);
-}
-
-
-void wpa_hexdump_ascii_key(int level, const char *title, const void *buf,
-			   size_t len)
-{
-	_wpa_hexdump_ascii(level, title, buf, len, wpa_debug_show_keys);
-}
-
-
 #ifdef CONFIG_DEBUG_FILE
 static char *last_path = NULL;
 #endif /* CONFIG_DEBUG_FILE */
@@ -644,7 +631,7 @@ void wpa_msg_register_ifname_cb(wpa_msg_get_ifname_func func)
 }
 
 
-void wpa_msg(void *ctx, int level, const char *fmt, ...)
+void _wpa_msg(void *ctx, int level, const char *fmt, ...)
 {
 	va_list ap;
 	char *buf;
@@ -682,7 +669,7 @@ void wpa_msg(void *ctx, int level, const char *fmt, ...)
 }
 
 
-void wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
+void _wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
 {
 	va_list ap;
 	char *buf;
diff --git a/src/utils/wpa_debug.h b/src/utils/wpa_debug.h
index 4c02ad3..854520b 100644
--- a/src/utils/wpa_debug.h
+++ b/src/utils/wpa_debug.h
@@ -11,6 +11,10 @@
 
 #include "wpabuf.h"
 
+extern void (*wpa_printf_hook)(int level, const char *fmt, va_list ap);
+extern void (*wpa_hexdump_hook)(int level, const char *title,
+				const void *buf, size_t len);
+extern void (*wpa_netlink_hook)(int tx, const void *data, size_t len);
 extern int wpa_debug_level;
 extern int wpa_debug_show_keys;
 extern int wpa_debug_timestamp;
@@ -51,6 +55,17 @@ void wpa_debug_close_file(void);
 void wpa_debug_setup_stdout(void);
 void wpa_debug_stop_log(void);
 
+/* internal */
+void _wpa_hexdump(int level, const char *title, const u8 *buf,
+		  size_t len, int show, int only_syslog);
+void _wpa_hexdump_ascii(int level, const char *title, const void *buf,
+			size_t len, int show);
+extern int wpa_debug_show_keys;
+
+#ifndef CONFIG_MSG_MIN_PRIORITY
+#define CONFIG_MSG_MIN_PRIORITY 0
+#endif
+
 /**
  * wpa_debug_printf_timestamp - Print timestamp for debug output
  *
@@ -71,9 +86,15 @@ void wpa_debug_print_timestamp(void);
  *
  * Note: New line '\n' is added to the end of the text when printing to stdout.
  */
-void wpa_printf(int level, const char *fmt, ...)
+void _wpa_printf(int level, const char *fmt, ...)
 PRINTF_FORMAT(2, 3);
 
+#define wpa_printf(level, ...)						\
+	do {								\
+		if (level >= CONFIG_MSG_MIN_PRIORITY)			\
+			_wpa_printf(level, __VA_ARGS__);		\
+	} while(0)
+
 /**
  * wpa_hexdump - conditional hex dump
  * @level: priority level (MSG_*) of the message
@@ -85,7 +106,13 @@ PRINTF_FORMAT(2, 3);
  * output may be directed to stdout, stderr, and/or syslog based on
  * configuration. The contents of buf is printed out has hex dump.
  */
-void wpa_hexdump(int level, const char *title, const void *buf, size_t len);
+static inline void wpa_hexdump(int level, const char *title, const void *buf, size_t len)
+{
+	if (level < CONFIG_MSG_MIN_PRIORITY)
+		return;
+
+	_wpa_hexdump(level, title, buf, len, 1, 1);
+}
 
 static inline void wpa_hexdump_buf(int level, const char *title,
 				   const struct wpabuf *buf)
@@ -107,7 +134,13 @@ static inline void wpa_hexdump_buf(int level, const char *title,
  * like wpa_hexdump(), but by default, does not include secret keys (passwords,
  * etc.) in debug output.
  */
-void wpa_hexdump_key(int level, const char *title, const void *buf, size_t len);
+static inline void wpa_hexdump_key(int level, const char *title, const u8 *buf, size_t len)
+{
+	if (level < CONFIG_MSG_MIN_PRIORITY)
+		return;
+
+	_wpa_hexdump(level, title, buf, len, wpa_debug_show_keys, 1);
+}
 
 static inline void wpa_hexdump_buf_key(int level, const char *title,
 				       const struct wpabuf *buf)
@@ -129,8 +162,14 @@ static inline void wpa_hexdump_buf_key(int level, const char *title,
  * the hex numbers and ASCII characters (for printable range) are shown. 16
  * bytes per line will be shown.
  */
-void wpa_hexdump_ascii(int level, const char *title, const void *buf,
-		       size_t len);
+static inline void wpa_hexdump_ascii(int level, const char *title,
+				     const u8 *buf, size_t len)
+{
+	if (level < CONFIG_MSG_MIN_PRIORITY)
+		return;
+
+	_wpa_hexdump_ascii(level, title, buf, len, 1);
+}
 
 /**
  * wpa_hexdump_ascii_key - conditional hex dump, hide keys
@@ -146,8 +185,14 @@ void wpa_hexdump_ascii(int level, const char *title, const void *buf,
  * bytes per line will be shown. This works like wpa_hexdump_ascii(), but by
  * default, does not include secret keys (passwords, etc.) in debug output.
  */
-void wpa_hexdump_ascii_key(int level, const char *title, const void *buf,
-			   size_t len);
+static inline void wpa_hexdump_ascii_key(int level, const char *title,
+					 const u8 *buf, size_t len)
+{
+	if (level < CONFIG_MSG_MIN_PRIORITY)
+		return;
+
+	_wpa_hexdump_ascii(level, title, buf, len, wpa_debug_show_keys);
+}
 
 /*
  * wpa_dbg() behaves like wpa_msg(), but it can be removed from build to reduce
@@ -184,7 +229,12 @@ void wpa_hexdump_ascii_key(int level, const char *title, const void *buf,
  *
  * Note: New line '\n' is added to the end of the text when printing to stdout.
  */
-void wpa_msg(void *ctx, int level, const char *fmt, ...) PRINTF_FORMAT(3, 4);
+void _wpa_msg(void *ctx, int level, const char *fmt, ...) PRINTF_FORMAT(3, 4);
+#define wpa_msg(ctx, level, ...)					\
+	do {								\
+		if (level >= CONFIG_MSG_MIN_PRIORITY)			\
+			_wpa_msg(ctx, level, __VA_ARGS__);		\
+	} while(0)
 
 /**
  * wpa_msg_ctrl - Conditional printf for ctrl_iface monitors
@@ -198,8 +248,13 @@ void wpa_msg(void *ctx, int level, const char *fmt, ...) PRINTF_FORMAT(3, 4);
  * attached ctrl_iface monitors. In other words, it can be used for frequent
  * events that do not need to be sent to syslog.
  */
-void wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
+void _wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
 PRINTF_FORMAT(3, 4);
+#define wpa_msg_ctrl(ctx, level, ...)					\
+	do {								\
+		if (level >= CONFIG_MSG_MIN_PRIORITY)			\
+			_wpa_msg_ctrl(ctx, level, __VA_ARGS__);		\
+	} while(0)
 
 /**
  * wpa_msg_global - Global printf for ctrl_iface monitors
diff --git a/tests/Makefile b/tests/Makefile
index 8ec154b..25fdf9e 100644
--- a/tests/Makefile
+++ b/tests/Makefile
@@ -1,10 +1,12 @@
-ALL=test-base64 test-md4 test-milenage \
-	test-rsa-sig-ver \
-	test-sha1 \
-	test-https test-https_server \
-	test-sha256 test-aes test-x509v3 test-list test-rc4 \
+RUN_TESTS= \
+	test-list \
+	test-md4 test-rc4 test-sha1 test-sha256 \
+	test-milenage test-aes \
+	test-crypto_module \
 	test-bss
 
+ALL=$(RUN_TESTS) test-base64 test-https test-https_server
+
 include ../src/build.rules
 
 ifdef LIBFUZZER
@@ -25,13 +27,27 @@ CFLAGS += -DCONFIG_IEEE80211R_AP
 CFLAGS += -DCONFIG_IEEE80211R
 CFLAGS += -DCONFIG_TDLS
 
+# test-crypto_module
+CFLAGS += -DCONFIG_MODULE_TESTS
+CFLAGS += -DCONFIG_DPP
+#CFLAGS += -DCONFIG_DPP2
+#CFLAGS += -DCONFIG_DPP3
+CFLAGS += -DCONFIG_ECC
+CFLAGS += -DCONFIG_HMAC_SHA256_KDF
+CFLAGS += -DCONFIG_HMAC_SHA384_KDF
+CFLAGS += -DCONFIG_MESH
+CFLAGS += -DCONFIG_SHA256
+CFLAGS += -DCONFIG_SHA384
+CFLAGS += -DEAP_PSK
+CFLAGS += -DEAP_FAST
+
 CFLAGS += -I../src
 CFLAGS += -I../src/utils
 
 SLIBS = ../src/utils/libutils.a
 
-DLIBS = ../src/crypto/libcrypto.a \
-	../src/tls/libtls.a
+DLIBS = ../src/tls/libtls.a \
+	../src/crypto/libcrypto.a
 
 _OBJS_VAR := LLIBS
 include ../src/objs.mk
@@ -43,12 +59,43 @@ include ../src/objs.mk
 LIBS = $(SLIBS) $(DLIBS)
 LLIBS = -Wl,--start-group $(DLIBS) -Wl,--end-group $(SLIBS)
 
+ifeq ($(CONFIG_TLS),mbedtls)
+CFLAGS += -DCONFIG_TLS_MBEDTLS
+LLIBS += -lmbedtls -lmbedx509 -lmbedcrypto
+else
+ifeq ($(CONFIG_TLS),openssl)
+CFLAGS += -DCONFIG_TLS_OPENSSL
+LLIBS += -lssl -lcrypto
+else
+ifeq ($(CONFIG_TLS),gnutls)
+CFLAGS += -DCONFIG_TLS_GNUTLS
+LLIBS += -lgnutls -lgpg-error -lgcrypt
+else
+ifeq ($(CONFIG_TLS),wolfssl)
+CFLAGS += -DCONFIG_TLS_WOLFSSL
+LLIBS += -lwolfssl -lm
+else
+CFLAGS += -DCONFIG_TLS_INTERNAL
+CFLAGS += -DCONFIG_TLS_INTERNAL_SERVER
+ALL += test-rsa-sig-ver
+ALL += test-x509v3
+clean-config_tls_internal:
+	rm -f test_x509v3_nist.out.*
+	rm -f test_x509v3_nist2.out.*
+endif
+endif
+endif
+endif
+
 # glibc < 2.17 needs -lrt for clock_gettime()
 LLIBS += -lrt
 
 test-aes: $(call BUILDOBJ,test-aes.o) $(LIBS)
 	$(LDO) $(LDFLAGS) -o $@ $^ $(LLIBS)
 
+test-crypto_module: $(call BUILDOBJ,test-crypto_module.o) $(LIBS)
+	$(LDO) $(LDFLAGS) -o $@ $< $(LLIBS)
+
 test-base64: $(call BUILDOBJ,test-base64.o) $(LIBS)
 	$(LDO) $(LDFLAGS) -o $@ $^ $(LLIBS)
 
@@ -141,18 +188,11 @@ test-bss: $(call BUILDOBJ,test-bss.o) $(WPA_OBJS) $(LIBS)
 	$(LDO) $(LDFLAGS) -o $@ $< $(LLIBS) $(WPA_CFLAGS) $(WPA_OBJS) $(LIBS)
 
 run-tests: $(ALL)
-	./test-aes
-	./test-list
-	./test-md4
-	./test-milenage
-	./test-rsa-sig-ver
-	./test-sha1
-	./test-sha256
-	./test-bss
+	@set -ex; for i in $(RUN_TESTS); do ./$$i; done
 	@echo
 	@echo All tests completed successfully.
 
-clean: common-clean
+clean: common-clean clean-config_tls_internal
 	rm -f *~
-	rm -f test_x509v3_nist.out.*
-	rm -f test_x509v3_nist2.out.*
+
+.PHONY: run-tests clean-config_tls_internal
diff --git a/tests/hwsim/example-hostapd.config b/tests/hwsim/example-hostapd.config
index 210b7fb..5f326da 100644
--- a/tests/hwsim/example-hostapd.config
+++ b/tests/hwsim/example-hostapd.config
@@ -4,6 +4,7 @@ CONFIG_DRIVER_NONE=y
 CONFIG_DRIVER_NL80211=y
 CONFIG_RSN_PREAUTH=y
 
+#CONFIG_TLS=mbedtls
 #CONFIG_TLS=internal
 #CONFIG_INTERNAL_LIBTOMMATH=y
 #CONFIG_INTERNAL_LIBTOMMATH_FAST=y
@@ -33,12 +34,7 @@ CONFIG_EAP_TNC=y
 CFLAGS += -DTNC_CONFIG_FILE=\"tnc/tnc_config\"
 LIBS += -rdynamic
 CONFIG_EAP_UNAUTH_TLS=y
-ifeq ($(CONFIG_TLS), openssl)
-CONFIG_EAP_PWD=y
-endif
-ifeq ($(CONFIG_TLS), wolfssl)
-CONFIG_EAP_PWD=y
-endif
+CONFIG_EAP_PWD=$(if $(filter openssl wolfssl mbedtls,$(CONFIG_TLS)),y,)
 CONFIG_EAP_EKE=y
 CONFIG_PKCS12=y
 CONFIG_RADIUS_SERVER=y
diff --git a/tests/hwsim/example-wpa_supplicant.config b/tests/hwsim/example-wpa_supplicant.config
index 123f397..c69b1f9 100644
--- a/tests/hwsim/example-wpa_supplicant.config
+++ b/tests/hwsim/example-wpa_supplicant.config
@@ -2,6 +2,7 @@
 
 CONFIG_TLS=openssl
 #CONFIG_TLS=wolfssl
+#CONFIG_TLS=mbedtls
 #CONFIG_TLS=internal
 #CONFIG_INTERNAL_LIBTOMMATH=y
 #CONFIG_INTERNAL_LIBTOMMATH_FAST=y
@@ -34,13 +35,7 @@ LIBS += -rdynamic
 CONFIG_EAP_FAST=y
 CONFIG_EAP_TEAP=y
 CONFIG_EAP_IKEV2=y
-
-ifeq ($(CONFIG_TLS), openssl)
-CONFIG_EAP_PWD=y
-endif
-ifeq ($(CONFIG_TLS), wolfssl)
-CONFIG_EAP_PWD=y
-endif
+CONFIG_EAP_PWD=$(if $(filter openssl wolfssl mbedtls,$(CONFIG_TLS)),y,)
 
 CONFIG_USIM_SIMULATOR=y
 CONFIG_SIM_SIMULATOR=y
diff --git a/tests/hwsim/test_ap_eap.py b/tests/hwsim/test_ap_eap.py
index f8e75b5..48e4ded 100644
--- a/tests/hwsim/test_ap_eap.py
+++ b/tests/hwsim/test_ap_eap.py
@@ -42,20 +42,42 @@ def check_eap_capa(dev, method):
     res = dev.get_capability("eap")
     if method not in res:
         raise HwsimSkip("EAP method %s not supported in the build" % method)
+    if method == "FAST" or method == "TEAP":
+        tls = dev.request("GET tls_library")
+        if tls.startswith("mbed TLS"):
+            raise HwsimSkip("EAP-%s not supported with this TLS library: " % method + tls)
 
 def check_subject_match_support(dev):
     tls = dev.request("GET tls_library")
-    if not tls.startswith("OpenSSL") and not tls.startswith("wolfSSL"):
+    if tls.startswith("OpenSSL"):
+        return
+    elif tls.startswith("wolfSSL"):
+        return
+    elif tls.startswith("mbed TLS"):
+        return
+    else:
         raise HwsimSkip("subject_match not supported with this TLS library: " + tls)
 
 def check_check_cert_subject_support(dev):
     tls = dev.request("GET tls_library")
-    if not tls.startswith("OpenSSL") and not tls.startswith("wolfSSL"):
+    if tls.startswith("OpenSSL"):
+        return
+    elif tls.startswith("wolfSSL"):
+        return
+    elif tls.startswith("mbed TLS"):
+        return
+    else:
         raise HwsimSkip("check_cert_subject not supported with this TLS library: " + tls)
 
 def check_altsubject_match_support(dev):
     tls = dev.request("GET tls_library")
-    if not tls.startswith("OpenSSL") and not tls.startswith("wolfSSL"):
+    if tls.startswith("OpenSSL"):
+        return
+    elif tls.startswith("wolfSSL"):
+        return
+    elif tls.startswith("mbed TLS"):
+        return
+    else:
         raise HwsimSkip("altsubject_match not supported with this TLS library: " + tls)
 
 def check_domain_match(dev):
@@ -70,7 +92,13 @@ def check_domain_suffix_match(dev):
 
 def check_domain_match_full(dev):
     tls = dev.request("GET tls_library")
-    if not tls.startswith("OpenSSL") and not tls.startswith("wolfSSL"):
+    if tls.startswith("OpenSSL"):
+        return
+    elif tls.startswith("wolfSSL"):
+        return
+    elif tls.startswith("mbed TLS"):
+        return
+    else:
         raise HwsimSkip("domain_suffix_match requires full match with this TLS library: " + tls)
 
 def check_cert_probe_support(dev):
@@ -79,8 +107,15 @@ def check_cert_probe_support(dev):
         raise HwsimSkip("Certificate probing not supported with this TLS library: " + tls)
 
 def check_ext_cert_check_support(dev):
+    if not openssl_imported:
+        raise HwsimSkip("OpenSSL python method not available")
+
     tls = dev.request("GET tls_library")
-    if not tls.startswith("OpenSSL"):
+    if tls.startswith("OpenSSL"):
+        return
+    elif tls.startswith("mbed TLS"):
+        return
+    else:
         raise HwsimSkip("ext_cert_check not supported with this TLS library: " + tls)
 
 def check_ocsp_support(dev):
@@ -91,14 +126,18 @@ def check_ocsp_support(dev):
     #    raise HwsimSkip("OCSP not supported with this TLS library: " + tls)
     #if tls.startswith("wolfSSL"):
     #    raise HwsimSkip("OCSP not supported with this TLS library: " + tls)
+    if tls.startswith("mbed TLS"):
+        raise HwsimSkip("OCSP not supported with this TLS library: " + tls)
 
 def check_pkcs5_v15_support(dev):
     tls = dev.request("GET tls_library")
-    if "BoringSSL" in tls or "GnuTLS" in tls:
+    if "BoringSSL" in tls or "GnuTLS" in tls or "mbed TLS" in tls:
         raise HwsimSkip("PKCS#5 v1.5 not supported with this TLS library: " + tls)
 
 def check_tls13_support(dev):
     tls = dev.request("GET tls_library")
+    if tls.startswith("mbed TLS"):
+        raise HwsimSkip("TLS v1.3 not supported")
     ok = ['run=OpenSSL 1.1.1', 'run=OpenSSL 3.0', 'run=OpenSSL 3.1',
           'run=OpenSSL 3.2', 'run=OpenSSL 3.3', 'wolfSSL']
     for s in ok:
@@ -122,11 +161,15 @@ def check_pkcs12_support(dev):
     #    raise HwsimSkip("PKCS#12 not supported with this TLS library: " + tls)
     if tls.startswith("wolfSSL"):
         raise HwsimSkip("PKCS#12 not supported with this TLS library: " + tls)
+    if tls.startswith("mbed TLS"):
+        raise HwsimSkip("PKCS#12 not supported with this TLS library: " + tls)
 
 def check_dh_dsa_support(dev):
     tls = dev.request("GET tls_library")
     if tls.startswith("internal"):
         raise HwsimSkip("DH DSA not supported with this TLS library: " + tls)
+    if tls.startswith("mbed TLS"):
+        raise HwsimSkip("DH DSA not supported with this TLS library: " + tls)
 
 def check_ec_support(dev):
     tls = dev.request("GET tls_library")
@@ -1741,7 +1784,7 @@ def test_ap_wpa2_eap_ttls_pap_subject_match(dev, apdev):
     eap_connect(dev[0], hapd, "TTLS", "pap user",
                 anonymous_identity="ttls", password="password",
                 ca_cert="auth_serv/ca.pem", phase2="auth=PAP",
-                subject_match="/C=FI/O=w1.fi/CN=server.w1.fi",
+                check_cert_subject="/C=FI/O=w1.fi/CN=server.w1.fi",
                 altsubject_match="EMAIL:noone@example.com;DNS:server.w1.fi;URI:http://example.com/")
     eap_reauth(dev[0], "TTLS")
 
@@ -2976,6 +3019,7 @@ def test_ap_wpa2_eap_tls_neg_domain_match(dev, apdev):
 
 def test_ap_wpa2_eap_tls_neg_subject_match(dev, apdev):
     """WPA2-Enterprise negative test - subject mismatch"""
+    check_subject_match_support(dev[0])
     params = hostapd.wpa2_eap_params(ssid="test-wpa2-eap")
     hostapd.add_ap(apdev[0], params)
     dev[0].connect("test-wpa2-eap", key_mgmt="WPA-EAP", eap="TTLS",
@@ -3036,6 +3080,7 @@ def test_ap_wpa2_eap_tls_neg_subject_match(dev, apdev):
 
 def test_ap_wpa2_eap_tls_neg_altsubject_match(dev, apdev):
     """WPA2-Enterprise negative test - altsubject mismatch"""
+    check_altsubject_match_support(dev[0])
     params = hostapd.wpa2_eap_params(ssid="test-wpa2-eap")
     hostapd.add_ap(apdev[0], params)
 
@@ -3582,7 +3627,7 @@ def test_ap_wpa2_eap_ikev2_oom(dev, apdev):
             dev[0].request("REMOVE_NETWORK all")
 
     tls = dev[0].request("GET tls_library")
-    if not tls.startswith("wolfSSL"):
+    if not tls.startswith("wolfSSL") and not tls.startswith("mbed TLS"):
         tests = [(1, "os_get_random;dh_init")]
     else:
         tests = [(1, "crypto_dh_init;dh_init")]
@@ -4896,7 +4941,7 @@ def test_ap_wpa2_eap_tls_intermediate_ca(dev, apdev, params):
     params["private_key"] = "auth_serv/iCA-server/server.key"
     hostapd.add_ap(apdev[0], params)
     tls = dev[0].request("GET tls_library")
-    if "GnuTLS" in tls or "wolfSSL" in tls:
+    if "GnuTLS" in tls or "wolfSSL" in tls or "mbed TLS" in tls:
         ca_cert = "auth_serv/iCA-user/ca-and-root.pem"
         client_cert = "auth_serv/iCA-user/user_and_ica.pem"
     else:
@@ -4962,6 +5007,7 @@ def test_ap_wpa2_eap_tls_intermediate_ca_ocsp_sha1(dev, apdev, params):
     run_ap_wpa2_eap_tls_intermediate_ca_ocsp(dev, apdev, params, "-sha1")
 
 def run_ap_wpa2_eap_tls_intermediate_ca_ocsp(dev, apdev, params, md):
+    check_ocsp_support(dev[0])
     params = int_eap_server_params()
     params["ca_cert"] = "auth_serv/iCA-server/ca-and-root.pem"
     params["server_cert"] = "auth_serv/iCA-server/server.pem"
@@ -4971,7 +5017,7 @@ def run_ap_wpa2_eap_tls_intermediate_ca_ocsp(dev, apdev, params, md):
     try:
         hostapd.add_ap(apdev[0], params)
         tls = dev[0].request("GET tls_library")
-        if "GnuTLS" in tls or "wolfSSL" in tls:
+        if "GnuTLS" in tls or "wolfSSL" in tls or "mbed TLS" in tls:
             ca_cert = "auth_serv/iCA-user/ca-and-root.pem"
             client_cert = "auth_serv/iCA-user/user_and_ica.pem"
         else:
@@ -5007,7 +5053,7 @@ def run_ap_wpa2_eap_tls_intermediate_ca_ocsp_revoked(dev, apdev, params, md):
     try:
         hostapd.add_ap(apdev[0], params)
         tls = dev[0].request("GET tls_library")
-        if "GnuTLS" in tls or "wolfSSL" in tls:
+        if "GnuTLS" in tls or "wolfSSL" in tls or "mbed TLS" in tls:
             ca_cert = "auth_serv/iCA-user/ca-and-root.pem"
             client_cert = "auth_serv/iCA-user/user_and_ica.pem"
         else:
@@ -5057,7 +5103,7 @@ def test_ap_wpa2_eap_tls_intermediate_ca_ocsp_multi_missing_resp(dev, apdev, par
     try:
         hostapd.add_ap(apdev[0], params)
         tls = dev[0].request("GET tls_library")
-        if "GnuTLS" in tls or "wolfSSL" in tls:
+        if "GnuTLS" in tls or "wolfSSL" in tls or "mbed TLS" in tls:
             ca_cert = "auth_serv/iCA-user/ca-and-root.pem"
             client_cert = "auth_serv/iCA-user/user_and_ica.pem"
         else:
@@ -5124,7 +5170,7 @@ def test_ap_wpa2_eap_tls_intermediate_ca_ocsp_multi(dev, apdev, params):
 
         hostapd.add_ap(apdev[0], params)
         tls = dev[0].request("GET tls_library")
-        if "GnuTLS" in tls or "wolfSSL" in tls:
+        if "GnuTLS" in tls or "wolfSSL" in tls or "mbed TLS" in tls:
             ca_cert = "auth_serv/iCA-user/ca-and-root.pem"
             client_cert = "auth_serv/iCA-user/user_and_ica.pem"
         else:
@@ -5382,6 +5428,7 @@ def test_ap_wpa2_eap_ttls_server_cert_eku_client_server(dev, apdev):
 
 def test_ap_wpa2_eap_ttls_server_pkcs12(dev, apdev):
     """WPA2-Enterprise using EAP-TTLS and server PKCS#12 file"""
+    check_pkcs12_support(dev[0])
     skip_with_fips(dev[0])
     params = int_eap_server_params()
     del params["server_cert"]
@@ -5394,6 +5441,7 @@ def test_ap_wpa2_eap_ttls_server_pkcs12(dev, apdev):
 
 def test_ap_wpa2_eap_ttls_server_pkcs12_extra(dev, apdev):
     """EAP-TTLS and server PKCS#12 file with extra certs"""
+    check_pkcs12_support(dev[0])
     skip_with_fips(dev[0])
     params = int_eap_server_params()
     del params["server_cert"]
@@ -5416,6 +5464,7 @@ def test_ap_wpa2_eap_ttls_dh_params_server(dev, apdev):
 
 def test_ap_wpa2_eap_ttls_dh_params_dsa_server(dev, apdev):
     """WPA2-Enterprise using EAP-TTLS and alternative server dhparams (DSA)"""
+    check_dh_dsa_support(dev[0])
     params = int_eap_server_params()
     params["dh_file"] = "auth_serv/dsaparam.pem"
     hapd = hostapd.add_ap(apdev[0], params)
@@ -5727,8 +5776,8 @@ def test_ap_wpa2_eap_non_ascii_identity2(dev, apdev):
 def test_openssl_cipher_suite_config_wpas(dev, apdev):
     """OpenSSL cipher suite configuration on wpa_supplicant"""
     tls = dev[0].request("GET tls_library")
-    if not tls.startswith("OpenSSL"):
-        raise HwsimSkip("TLS library is not OpenSSL: " + tls)
+    if not tls.startswith("OpenSSL") and not tls.startswith("mbed TLS"):
+        raise HwsimSkip("TLS library is not OpenSSL or mbed TLS: " + tls)
     params = hostapd.wpa2_eap_params(ssid="test-wpa2-eap")
     hapd = hostapd.add_ap(apdev[0], params)
     eap_connect(dev[0], hapd, "TTLS", "pap user",
@@ -5754,14 +5803,14 @@ def test_openssl_cipher_suite_config_wpas(dev, apdev):
 def test_openssl_cipher_suite_config_hapd(dev, apdev):
     """OpenSSL cipher suite configuration on hostapd"""
     tls = dev[0].request("GET tls_library")
-    if not tls.startswith("OpenSSL"):
-        raise HwsimSkip("wpa_supplicant TLS library is not OpenSSL: " + tls)
+    if not tls.startswith("OpenSSL") and not tls.startswith("mbed TLS"):
+        raise HwsimSkip("wpa_supplicant TLS library is not OpenSSL or mbed TLS: " + tls)
     params = int_eap_server_params()
     params['openssl_ciphers'] = "AES256"
     hapd = hostapd.add_ap(apdev[0], params)
     tls = hapd.request("GET tls_library")
-    if not tls.startswith("OpenSSL"):
-        raise HwsimSkip("hostapd TLS library is not OpenSSL: " + tls)
+    if not tls.startswith("OpenSSL") and not tls.startswith("mbed TLS"):
+        raise HwsimSkip("hostapd TLS library is not OpenSSL or mbed TLS: " + tls)
     eap_connect(dev[0], hapd, "TTLS", "pap user",
                 anonymous_identity="ttls", password="password",
                 ca_cert="auth_serv/ca.pem", phase2="auth=PAP")
@@ -6207,13 +6256,17 @@ def test_ap_wpa2_eap_tls_versions(dev, apdev):
             check_tls_ver(dev[0], hapd,
                           "tls_disable_tlsv1_0=1 tls_disable_tlsv1_1=1",
                           "TLSv1.2")
-    elif tls.startswith("internal"):
+    elif tls.startswith("internal") or tls.startswith("mbed TLS"):
         check_tls_ver(dev[0], hapd,
                       "tls_disable_tlsv1_0=1 tls_disable_tlsv1_1=1", "TLSv1.2")
-    check_tls_ver(dev[1], hapd,
-                  "tls_disable_tlsv1_0=1 tls_disable_tlsv1_1=0 tls_disable_tlsv1_2=1", "TLSv1.1")
-    check_tls_ver(dev[2], hapd,
-                  "tls_disable_tlsv1_0=0 tls_disable_tlsv1_1=1 tls_disable_tlsv1_2=1", "TLSv1")
+    if tls.startswith("mbed TLS"):
+        check_tls_ver(dev[2], hapd,
+                      "tls_disable_tlsv1_0=0 tls_disable_tlsv1_1=1 tls_disable_tlsv1_2=1", "TLSv1.0")
+    else:
+        check_tls_ver(dev[1], hapd,
+                      "tls_disable_tlsv1_0=1 tls_disable_tlsv1_1=0 tls_disable_tlsv1_2=1", "TLSv1.1")
+        check_tls_ver(dev[2], hapd,
+                      "tls_disable_tlsv1_0=0 tls_disable_tlsv1_1=1 tls_disable_tlsv1_2=1", "TLSv1")
     if "run=OpenSSL 1.1.1" in tls or "run=OpenSSL 3." in tls:
         check_tls_ver(dev[0], hapd,
                       "tls_disable_tlsv1_0=1 tls_disable_tlsv1_1=1 tls_disable_tlsv1_2=1 tls_disable_tlsv1_3=0", "TLSv1.3")
@@ -6235,6 +6288,11 @@ def test_ap_wpa2_eap_tls_versions_server(dev, apdev):
     tests = [("TLSv1", "[ENABLE-TLSv1.0][DISABLE-TLSv1.1][DISABLE-TLSv1.2][DISABLE-TLSv1.3]"),
              ("TLSv1.1", "[ENABLE-TLSv1.0][ENABLE-TLSv1.1][DISABLE-TLSv1.2][DISABLE-TLSv1.3]"),
              ("TLSv1.2", "[ENABLE-TLSv1.0][ENABLE-TLSv1.1][ENABLE-TLSv1.2][DISABLE-TLSv1.3]")]
+    tls = dev[0].request("GET tls_library")
+    if tls.startswith("mbed TLS"):
+        tests = [#("TLSv1.0", "[ENABLE-TLSv1.0][DISABLE-TLSv1.1][DISABLE-TLSv1.2][DISABLE-TLSv1.3]"),
+                 #("TLSv1.1", "[ENABLE-TLSv1.0][ENABLE-TLSv1.1][DISABLE-TLSv1.2][DISABLE-TLSv1.3]"),
+                 ("TLSv1.2", "[ENABLE-TLSv1.0][ENABLE-TLSv1.1][ENABLE-TLSv1.2][DISABLE-TLSv1.3]")]
     for exp, flags in tests:
         hapd.disable()
         hapd.set("tls_flags", flags)
@@ -7305,6 +7363,7 @@ def test_ap_wpa2_eap_assoc_rsn(dev, apdev):
 def test_eap_tls_ext_cert_check(dev, apdev):
     """EAP-TLS and external server certification validation"""
     # With internal server certificate chain validation
+    check_ext_cert_check_support(dev[0])
     id = dev[0].connect("test-wpa2-eap", key_mgmt="WPA-EAP", eap="TLS",
                         identity="tls user",
                         ca_cert="auth_serv/ca.pem",
@@ -7317,6 +7376,7 @@ def test_eap_tls_ext_cert_check(dev, apdev):
 def test_eap_ttls_ext_cert_check(dev, apdev):
     """EAP-TTLS and external server certification validation"""
     # Without internal server certificate chain validation
+    check_ext_cert_check_support(dev[0])
     id = dev[0].connect("test-wpa2-eap", key_mgmt="WPA-EAP", eap="TTLS",
                         identity="pap user", anonymous_identity="ttls",
                         password="password", phase2="auth=PAP",
@@ -7327,6 +7387,7 @@ def test_eap_ttls_ext_cert_check(dev, apdev):
 def test_eap_peap_ext_cert_check(dev, apdev):
     """EAP-PEAP and external server certification validation"""
     # With internal server certificate chain validation
+    check_ext_cert_check_support(dev[0])
     id = dev[0].connect("test-wpa2-eap", key_mgmt="WPA-EAP", eap="PEAP",
                         identity="user", anonymous_identity="peap",
                         ca_cert="auth_serv/ca.pem",
@@ -7337,6 +7398,7 @@ def test_eap_peap_ext_cert_check(dev, apdev):
 
 def test_eap_fast_ext_cert_check(dev, apdev):
     """EAP-FAST and external server certification validation"""
+    check_ext_cert_check_support(dev[0])
     check_eap_capa(dev[0], "FAST")
     # With internal server certificate chain validation
     dev[0].request("SET blob fast_pac_auth_ext ")
@@ -7351,10 +7413,6 @@ def test_eap_fast_ext_cert_check(dev, apdev):
     run_ext_cert_check(dev, apdev, id)
 
 def run_ext_cert_check(dev, apdev, net_id):
-    check_ext_cert_check_support(dev[0])
-    if not openssl_imported:
-        raise HwsimSkip("OpenSSL python method not available")
-
     params = hostapd.wpa2_eap_params(ssid="test-wpa2-eap")
     hapd = hostapd.add_ap(apdev[0], params)
 
diff --git a/tests/hwsim/test_ap_ft.py b/tests/hwsim/test_ap_ft.py
index bbbe8cf..cb5da5a 100644
--- a/tests/hwsim/test_ap_ft.py
+++ b/tests/hwsim/test_ap_ft.py
@@ -2543,11 +2543,11 @@ def test_ap_ft_ap_oom5(dev, apdev):
         # This will fail to roam
         dev[0].roam(bssid1, check_bssid=False)
 
-    with fail_test(hapd1, 1, "sha256_prf_bits;wpa_pmk_r1_to_ptk;wpa_ft_process_auth_req"):
+    with fail_test(hapd1, 1, "sha256_prf;wpa_pmk_r1_to_ptk;wpa_ft_process_auth_req"):
         # This will fail to roam
         dev[0].roam(bssid1, check_bssid=False)
 
-    with fail_test(hapd1, 3, "wpa_pmk_r1_to_ptk;wpa_ft_process_auth_req"):
+    with fail_test(hapd1, 2, "wpa_pmk_r1_to_ptk;wpa_ft_process_auth_req"):
         # This will fail to roam
         dev[0].roam(bssid1, check_bssid=False)
 
diff --git a/tests/hwsim/test_authsrv.py b/tests/hwsim/test_authsrv.py
index e0665bc..02ec301 100644
--- a/tests/hwsim/test_authsrv.py
+++ b/tests/hwsim/test_authsrv.py
@@ -156,9 +156,12 @@ def test_authsrv_oom(dev, apdev):
         if "FAIL" not in authsrv.request("ENABLE"):
             raise Exception("ENABLE succeeded during OOM")
 
-    with alloc_fail(authsrv, 1, "tls_init;authsrv_init"):
-        if "FAIL" not in authsrv.request("ENABLE"):
-            raise Exception("ENABLE succeeded during OOM")
+    # tls_mbedtls.c:tls_init() does not alloc memory (no alloc fail trigger)
+    tls = dev[0].request("GET tls_library")
+    if not tls.startswith("mbed TLS"):
+        with alloc_fail(authsrv, 1, "tls_init;authsrv_init"):
+            if "FAIL" not in authsrv.request("ENABLE"):
+                raise Exception("ENABLE succeeded during OOM")
 
     for count in range(1, 3):
         with alloc_fail(authsrv, count, "eap_sim_db_init;authsrv_init"):
diff --git a/tests/hwsim/test_dpp.py b/tests/hwsim/test_dpp.py
index 0a74b7e..a681ef9 100644
--- a/tests/hwsim/test_dpp.py
+++ b/tests/hwsim/test_dpp.py
@@ -39,7 +39,8 @@ def check_dpp_capab(dev, brainpool=False, min_ver=1):
         raise HwsimSkip("DPP not supported")
     if brainpool:
         tls = dev.request("GET tls_library")
-        if (not tls.startswith("OpenSSL") or "run=BoringSSL" in tls) and not tls.startswith("wolfSSL"):
+        if (not tls.startswith("OpenSSL") or "run=BoringSSL" in tls) and not tls.startswith("wolfSSL") \
+                                                                     and not tls.startswith("mbed TLS"):
             raise HwsimSkip("Crypto library does not support Brainpool curves: " + tls)
     capa = dev.request("GET_CAPABILITY dpp")
     ver = 1
@@ -3925,6 +3926,9 @@ def test_dpp_proto_auth_req_no_i_proto_key(dev, apdev):
 
 def test_dpp_proto_auth_req_invalid_i_proto_key(dev, apdev):
     """DPP protocol testing - invalid I-proto key in Auth Req"""
+    tls = dev[0].request("GET tls_library")
+    if tls.startswith("mbed TLS"):
+        raise HwsimSkip("mbed TLS crypto_ecdh_set_peerkey() properly detects invalid key; no response")
     run_dpp_proto_auth_req_missing(dev, 66, "Invalid Initiator Protocol Key")
 
 def test_dpp_proto_auth_req_no_i_nonce(dev, apdev):
@@ -4020,7 +4024,12 @@ def test_dpp_proto_auth_resp_no_r_proto_key(dev, apdev):
 
 def test_dpp_proto_auth_resp_invalid_r_proto_key(dev, apdev):
     """DPP protocol testing - invalid R-Proto Key in Auth Resp"""
-    run_dpp_proto_auth_resp_missing(dev, 67, "Invalid Responder Protocol Key")
+    tls = dev[0].request("GET tls_library")
+    if tls.startswith("mbed TLS"):
+        # mbed TLS crypto_ecdh_set_peerkey() properly detects invalid key
+        run_dpp_proto_auth_resp_missing(dev, 67, "Failed to derive ECDH shared secret")
+    else:
+        run_dpp_proto_auth_resp_missing(dev, 67, "Invalid Responder Protocol Key")
 
 def test_dpp_proto_auth_resp_no_r_nonce(dev, apdev):
     """DPP protocol testing - no R-nonce in Auth Resp"""
@@ -4382,11 +4391,17 @@ def test_dpp_proto_pkex_exchange_resp_invalid_status(dev, apdev):
 
 def test_dpp_proto_pkex_cr_req_invalid_bootstrap_key(dev, apdev):
     """DPP protocol testing - invalid Bootstrap Key in PKEX Commit-Reveal Request"""
+    tls = dev[0].request("GET tls_library")
+    if tls.startswith("mbed TLS"):
+        raise HwsimSkip("mbed TLS crypto_ecdh_set_peerkey() properly detects invalid key; no response")
     run_dpp_proto_pkex_req_missing(dev, 47,
                                    "Peer bootstrapping key is invalid")
 
 def test_dpp_proto_pkex_cr_resp_invalid_bootstrap_key(dev, apdev):
     """DPP protocol testing - invalid Bootstrap Key in PKEX Commit-Reveal Response"""
+    tls = dev[0].request("GET tls_library")
+    if tls.startswith("mbed TLS"):
+        raise HwsimSkip("mbed TLS crypto_ecdh_set_peerkey() properly detects invalid key; no response")
     run_dpp_proto_pkex_resp_missing(dev, 48,
                                     "Peer bootstrapping key is invalid")
 
diff --git a/tests/hwsim/test_erp.py b/tests/hwsim/test_erp.py
index d083993..262e9f0 100644
--- a/tests/hwsim/test_erp.py
+++ b/tests/hwsim/test_erp.py
@@ -12,7 +12,7 @@ import time
 
 import hostapd
 from utils import *
-from test_ap_eap import int_eap_server_params, check_tls13_support
+from test_ap_eap import int_eap_server_params, check_tls13_support, check_eap_capa
 from test_ap_psk import find_wpas_process, read_process_memory, verify_not_present, get_key_locations
 
 def test_erp_initiate_reauth_start(dev, apdev):
@@ -276,6 +276,7 @@ def test_erp_radius_eap_methods(dev, apdev):
     params['erp_domain'] = 'example.com'
     params['disable_pmksa_caching'] = '1'
     hapd = hostapd.add_ap(apdev[0], params)
+    tls = dev[0].request("GET tls_library")
 
     erp_test(dev[0], hapd, eap="AKA", identity="0232010000000000@example.com",
              password="90dca4eda45b53cf0f12d7c9c3bc6a89:cb9cccc4b9258e6dca4760379fb82581:000000000123")
@@ -289,7 +290,7 @@ def test_erp_radius_eap_methods(dev, apdev):
              password="5122250214c33e723a5dd523fc145fc0:981d464c7c52eb6e5036234984ad0bcf:000000000123")
     erp_test(dev[0], hapd, eap="EKE", identity="erp-eke@example.com",
              password="hello")
-    if "FAST" in eap_methods:
+    if "FAST" in eap_methods and check_eap_capa(dev[0], "FAST"):
         erp_test(dev[0], hapd, eap="FAST", identity="erp-fast@example.com",
                  password="password", ca_cert="auth_serv/ca.pem",
                  phase2="auth=GTC",
@@ -301,13 +302,14 @@ def test_erp_radius_eap_methods(dev, apdev):
              password="password")
     erp_test(dev[0], hapd, eap="PAX", identity="erp-pax@example.com",
              password_hex="0123456789abcdef0123456789abcdef")
-    if "MSCHAPV2" in eap_methods:
+    if "MSCHAPV2" in eap_methods and check_eap_capa(dev[0], "MSCHAPV2"):
         erp_test(dev[0], hapd, eap="PEAP", identity="erp-peap@example.com",
                  password="password", ca_cert="auth_serv/ca.pem",
                  phase2="auth=MSCHAPV2")
-        erp_test(dev[0], hapd, eap="TEAP", identity="erp-teap@example.com",
-                 password="password", ca_cert="auth_serv/ca.pem",
-                 phase2="auth=MSCHAPV2", pac_file="blob://teap_pac")
+        if check_eap_capa(dev[0], "TEAP"):
+            erp_test(dev[0], hapd, eap="TEAP", identity="erp-teap@example.com",
+                     password="password", ca_cert="auth_serv/ca.pem",
+                     phase2="auth=MSCHAPV2", pac_file="blob://teap_pac")
     erp_test(dev[0], hapd, eap="PSK", identity="erp-psk@example.com",
              password_hex="0123456789abcdef0123456789abcdef")
     if "PWD" in eap_methods:
@@ -640,7 +642,7 @@ def test_erp_local_errors(dev, apdev):
         dev[0].request("REMOVE_NETWORK all")
         dev[0].wait_disconnected()
 
-    for count in range(1, 6):
+    for count in range(1, 4):
         dev[0].request("ERP_FLUSH")
         with fail_test(dev[0], count, "hmac_sha256_kdf;eap_peer_erp_init"):
             dev[0].connect("test-wpa2-eap", key_mgmt="WPA-EAP", eap="TTLS",
diff --git a/tests/hwsim/test_fils.py b/tests/hwsim/test_fils.py
index 18eff3f..f9d35a4 100644
--- a/tests/hwsim/test_fils.py
+++ b/tests/hwsim/test_fils.py
@@ -1492,6 +1492,10 @@ def check_ec_group(dev, group):
     tls = dev.request("GET tls_library")
     if tls.startswith("wolfSSL"):
         return
+    elif tls.startswith("mbed TLS"):
+        if int(group) == 27:
+            raise HwsimSkip("Brainpool EC group 27 not supported by mbed TLS")
+        return
     if int(group) in [25]:
         if not (tls.startswith("OpenSSL") and ("build=OpenSSL 1.0.2" in tls or "build=OpenSSL 1.1" in tls or "build=OpenSSL 3." in tls) and ("run=OpenSSL 1.0.2" in tls or "run=OpenSSL 1.1" in tls or "run=OpenSSL 3." in tls)):
             raise HwsimSkip("EC group not supported")
diff --git a/tests/hwsim/test_pmksa_cache.py b/tests/hwsim/test_pmksa_cache.py
index 4a3b444..4f7f7f7 100644
--- a/tests/hwsim/test_pmksa_cache.py
+++ b/tests/hwsim/test_pmksa_cache.py
@@ -958,7 +958,7 @@ def test_pmksa_cache_preauth_wpas_oom(dev, apdev):
     eap_connect(dev[0], hapd, "PAX", "pax.user@example.com",
                 password_hex="0123456789abcdef0123456789abcdef",
                 bssid=apdev[0]['bssid'])
-    for i in range(1, 11):
+    for i in range(1, 10):
         with alloc_fail(dev[0], i, "rsn_preauth_init"):
             res = dev[0].request("PREAUTH f2:11:22:33:44:55").strip()
             logger.info("Iteration %d - PREAUTH command results: %s" % (i, res))
@@ -966,7 +966,7 @@ def test_pmksa_cache_preauth_wpas_oom(dev, apdev):
                 state = dev[0].request('GET_ALLOC_FAIL')
                 if state.startswith('0:'):
                     break
-                time.sleep(0.05)
+                time.sleep(0.10)
 
 def test_pmksa_cache_ctrl(dev, apdev):
     """PMKSA cache control interface operations"""
diff --git a/tests/hwsim/test_sae.py b/tests/hwsim/test_sae.py
index 04f4335..3f488e5 100644
--- a/tests/hwsim/test_sae.py
+++ b/tests/hwsim/test_sae.py
@@ -178,6 +178,11 @@ def test_sae_groups(dev, apdev):
     if tls.startswith("OpenSSL") and "run=OpenSSL 1." in tls:
         logger.info("Add Brainpool EC groups since OpenSSL is new enough")
         sae_groups += [27, 28, 29, 30]
+    if tls.startswith("mbed TLS"):
+        # secp224k1 and secp224r1 (26) have prime p = 1 mod 4, and mbedtls
+        # does not have code to derive y from compressed format for those curves
+        sae_groups = [19, 25, 20, 21, 1, 2, 5, 14, 15, 16, 22, 23, 24]
+        sae_groups += [27, 28, 29, 30]
     heavy_groups = [14, 15, 16]
     suitable_groups = [15, 16, 17, 18, 19, 20, 21]
     groups = [str(g) for g in sae_groups]
@@ -2234,6 +2239,8 @@ def run_sae_pwe_group(dev, apdev, group):
             logger.info("Add Brainpool EC groups since OpenSSL is new enough")
         elif tls.startswith("wolfSSL"):
             logger.info("Make sure Brainpool EC groups were enabled when compiling wolfSSL")
+        elif tls.startswith("mbed TLS"):
+            logger.info("Make sure Brainpool EC groups were enabled when compiling mbed TLS")
         else:
             raise HwsimSkip("Brainpool curve not supported")
     start_sae_pwe_ap(apdev[0], group, 2)
diff --git a/tests/hwsim/test_suite_b.py b/tests/hwsim/test_suite_b.py
index ddd1c2e..a44f329 100644
--- a/tests/hwsim/test_suite_b.py
+++ b/tests/hwsim/test_suite_b.py
@@ -27,6 +27,8 @@ def check_suite_b_tls_lib(dev, dhe=False, level128=False):
         return
     if tls.startswith("wolfSSL"):
         return
+    if tls.startswith("mbed TLS"):
+        return
     if not tls.startswith("OpenSSL"):
         raise HwsimSkip("TLS library not supported for Suite B: " + tls)
     supported = False
@@ -520,6 +522,7 @@ def test_suite_b_192_rsa_insufficient_dh(dev, apdev):
 
     dev[0].connect("test-suite-b", key_mgmt="WPA-EAP-SUITE-B-192",
                    ieee80211w="2",
+                   openssl_ciphers="DHE-RSA-AES256-GCM-SHA384",
                    phase1="tls_suiteb=1",
                    eap="TLS", identity="tls user",
                    ca_cert="auth_serv/rsa3072-ca.pem",
diff --git a/tests/hwsim/test_wpas_ctrl.py b/tests/hwsim/test_wpas_ctrl.py
index cf6d321..cbf136e 100644
--- a/tests/hwsim/test_wpas_ctrl.py
+++ b/tests/hwsim/test_wpas_ctrl.py
@@ -1856,7 +1856,7 @@ def _test_wpas_ctrl_oom(dev):
     tls = dev[0].request("GET tls_library")
     if not tls.startswith("internal"):
         tests.append(('NFC_GET_HANDOVER_SEL NDEF P2P-CR-TAG', 'FAIL',
-                      4, 'wpas_ctrl_nfc_get_handover_sel_p2p'))
+                      3, 'wpas_ctrl_nfc_get_handover_sel_p2p'))
     for cmd, exp, count, func in tests:
         with alloc_fail(dev[0], count, func):
             res = dev[0].request(cmd)
diff --git a/tests/hwsim/utils.py b/tests/hwsim/utils.py
index 7e36082..b23c1ee 100644
--- a/tests/hwsim/utils.py
+++ b/tests/hwsim/utils.py
@@ -145,7 +145,13 @@ def check_imsi_privacy_support(dev):
 
 def check_tls_tod(dev):
     tls = dev.request("GET tls_library")
-    if not tls.startswith("OpenSSL") and not tls.startswith("internal"):
+    if tls.startswith("OpenSSL"):
+        return
+    elif tls.startswith("internal"):
+        return
+    elif tls.startswith("mbed TLS"):
+        return
+    else:
         raise HwsimSkip("TLS TOD-TOFU/STRICT not supported with this TLS library: " + tls)
 
 def vht_supported():
diff --git a/tests/test-crypto_module.c b/tests/test-crypto_module.c
new file mode 100644
index 0000000..0f11561
--- /dev/null
+++ b/tests/test-crypto_module.c
@@ -0,0 +1,16 @@
+/*
+ * crypto module tests - test program
+ * Copyright (c) 2022, Glenn Strauss <gstrauss@gluelogic.com>
+ *
+ * This software may be distributed under the terms of the BSD license.
+ * See README for more details.
+ */
+
+#include "utils/includes.h"
+#include "utils/module_tests.h"
+#include "crypto/crypto_module_tests.c"
+
+int main(int argc, char *argv[])
+{
+	return crypto_module_tests();
+}
diff --git a/tests/test-https.c b/tests/test-https.c
index a72e56f..e9df82f 100644
--- a/tests/test-https.c
+++ b/tests/test-https.c
@@ -75,7 +75,7 @@ static int https_client(int s, const char *path)
 	struct tls_connection *conn;
 	struct wpabuf *in, *out, *appl;
 	int res = -1;
-	int need_more_data;
+	int need_more_data = 0;
 
 	os_memset(&conf, 0, sizeof(conf));
 	conf.event_cb = https_tls_event_cb;
@@ -93,8 +93,12 @@ static int https_client(int s, const char *path)
 
 	for (;;) {
 		appl = NULL;
+#ifdef CONFIG_TLS_INTERNAL_SERVER
 		out = tls_connection_handshake2(tls, conn, in, &appl,
 						&need_more_data);
+#else
+		out = tls_connection_handshake(tls, conn, in, &appl);
+#endif
 		wpabuf_free(in);
 		in = NULL;
 		if (out == NULL) {
@@ -152,11 +156,15 @@ static int https_client(int s, const char *path)
 
 	wpa_printf(MSG_INFO, "Reading HTTP response");
 	for (;;) {
-		int need_more_data;
+		int need_more_data = 0;
 		in = https_recv(s);
 		if (in == NULL)
 			goto done;
+#ifdef CONFIG_TLS_INTERNAL_SERVER
 		out = tls_connection_decrypt2(tls, conn, in, &need_more_data);
+#else
+		out = tls_connection_decrypt(tls, conn, in);
+#endif
 		if (need_more_data)
 			wpa_printf(MSG_DEBUG, "HTTP: Need more data");
 		wpabuf_free(in);
diff --git a/tests/test-https_server.c b/tests/test-https_server.c
index 33b4486..9dcca55 100644
--- a/tests/test-https_server.c
+++ b/tests/test-https_server.c
@@ -67,10 +67,12 @@ static struct wpabuf * https_recv(int s, int timeout_ms)
 }
 
 
+#ifdef CONFIG_TLS_INTERNAL_SERVER
 static void https_tls_log_cb(void *ctx, const char *msg)
 {
 	wpa_printf(MSG_DEBUG, "TLS: %s", msg);
 }
+#endif
 
 
 static int https_server(int s)
@@ -79,7 +81,7 @@ static int https_server(int s)
 	void *tls;
 	struct tls_connection_params params;
 	struct tls_connection *conn;
-	struct wpabuf *in, *out, *appl;
+	struct wpabuf *in = NULL, *out = NULL, *appl = NULL;
 	int res = -1;
 
 	os_memset(&conf, 0, sizeof(conf));
@@ -106,7 +108,9 @@ static int https_server(int s)
 		return -1;
 	}
 
+#ifdef CONFIG_TLS_INTERNAL_SERVER
 	tls_connection_set_log_cb(conn, https_tls_log_cb, NULL);
+#endif
 
 	for (;;) {
 		in = https_recv(s, 5000);
@@ -147,12 +151,16 @@ static int https_server(int s)
 
 	wpa_printf(MSG_INFO, "Reading HTTP request");
 	for (;;) {
-		int need_more_data;
+		int need_more_data = 0;
 
 		in = https_recv(s, 5000);
 		if (!in)
 			goto done;
+#ifdef CONFIG_TLS_INTERNAL_SERVER
 		out = tls_connection_decrypt2(tls, conn, in, &need_more_data);
+#else
+		out = tls_connection_decrypt(tls, conn, in);
+#endif
 		wpabuf_free(in);
 		in = NULL;
 		if (need_more_data) {
diff --git a/wpa_supplicant/Makefile b/wpa_supplicant/Makefile
index 743c8ac..c40e8d7 100644
--- a/wpa_supplicant/Makefile
+++ b/wpa_supplicant/Makefile
@@ -10,6 +10,7 @@ ALL += dbus/fi.w1.wpa_supplicant1.service
 EXTRA_TARGETS=dynamic_eap_methods
 
 CONFIG_FILE=.config
+-include $(if $(MULTICALL),../hostapd/.config)
 include ../src/build.rules
 
 ifdef CONFIG_BUILD_PASN_SO
@@ -190,6 +191,25 @@ ifdef CONFIG_EAPOL_TEST
 CFLAGS += -Werror -DEAPOL_TEST
 endif
 
+ifdef CONFIG_UBUS
+CFLAGS += -DUBUS_SUPPORT
+OBJS += ubus.o
+LIBS += -lubus
+NEED_ULOOP:=y
+endif
+
+ifdef CONFIG_UCODE
+CFLAGS += -DUCODE_SUPPORT
+OBJS += ../src/utils/ucode.o
+OBJS += ucode.o
+NEED_ULOOP:=y
+endif
+
+ifdef NEED_ULOOP
+OBJS += ../src/utils/uloop.o
+LIBS += -lubox
+endif
+
 ifdef CONFIG_CODE_COVERAGE
 CFLAGS += -O0 -fprofile-arcs -ftest-coverage -U_FORTIFY_SOURCE
 LIBS += -lgcov
@@ -389,7 +409,9 @@ endif
 ifdef CONFIG_IBSS_RSN
 NEED_RSN_AUTHENTICATOR=y
 CFLAGS += -DCONFIG_IBSS_RSN
+ifndef MULTICALL
 CFLAGS += -DCONFIG_NO_VLAN
+endif
 OBJS += ibss_rsn.o
 endif
 
@@ -981,6 +1003,10 @@ ifdef CONFIG_DYNAMIC_EAP_METHODS
 CFLAGS += -DCONFIG_DYNAMIC_EAP_METHODS
 LIBS += -ldl -rdynamic
 endif
+else
+  ifdef MULTICALL
+    OBJS += ../src/eap_common/eap_common.o
+  endif
 endif
 
 ifdef CONFIG_AP
@@ -988,9 +1014,11 @@ NEED_EAP_COMMON=y
 NEED_RSN_AUTHENTICATOR=y
 CFLAGS += -DCONFIG_AP
 OBJS += ap.o
+ifndef MULTICALL
 CFLAGS += -DCONFIG_NO_RADIUS
 CFLAGS += -DCONFIG_NO_ACCOUNTING
 CFLAGS += -DCONFIG_NO_VLAN
+endif
 OBJS += ../src/ap/hostapd.o
 OBJS += ../src/ap/wpa_auth_glue.o
 OBJS += ../src/ap/utils.o
@@ -1030,7 +1058,16 @@ ifdef CONFIG_FILS
 OBJS += ../src/ap/fils_hlp.o
 endif
 ifdef CONFIG_CTRL_IFACE
+ifdef CONFIG_CTRL_IFACE_MIB
+CFLAGS += -DCONFIG_CTRL_IFACE_MIB
+endif
 OBJS += ../src/ap/ctrl_iface_ap.o
+ifdef CONFIG_UBUS
+OBJS += ../src/ap/ubus.o
+endif
+ifdef CONFIG_UCODE
+OBJS += ../src/ap/ucode.o
+endif
 endif
 
 CFLAGS += -DEAP_SERVER -DEAP_SERVER_IDENTITY
@@ -1081,6 +1118,12 @@ endif
 ifdef CONFIG_HS20
 OBJS += ../src/ap/hs20.o
 endif
+else
+  ifdef MULTICALL
+    OBJS += ../src/eap_server/eap_server.o
+    OBJS += ../src/eap_server/eap_server_identity.o
+    OBJS += ../src/eap_server/eap_server_methods.o
+  endif
 endif
 
 ifdef CONFIG_MBO
@@ -1090,7 +1133,9 @@ NEED_GAS=y
 endif
 
 ifdef NEED_RSN_AUTHENTICATOR
+ifndef MULTICALL
 CFLAGS += -DCONFIG_NO_RADIUS
+endif
 NEED_AES_WRAP=y
 OBJS += ../src/ap/wpa_auth.o
 OBJS += ../src/ap/wpa_auth_ie.o
@@ -1189,6 +1234,7 @@ TLS_FUNCS=y
 endif
 
 ifeq ($(CONFIG_TLS), wolfssl)
+CFLAGS += -DCONFIG_TLS_WOLFSSL
 ifdef TLS_FUNCS
 CFLAGS += -DWOLFSSL_DER_LOAD
 OBJS += ../src/crypto/tls_wolfssl.o
@@ -1204,6 +1250,7 @@ LIBS_p += -lwolfssl -lm
 endif
 
 ifeq ($(CONFIG_TLS), openssl)
+CFLAGS += -DCONFIG_TLS_OPENSSL
 CFLAGS += -DCRYPTO_RSA_OAEP_SHA256
 ifdef TLS_FUNCS
 CFLAGS += -DEAP_TLS_OPENSSL
@@ -1230,7 +1277,28 @@ endif
 CFLAGS += -DTLS_DEFAULT_CIPHERS=\"$(CONFIG_TLS_DEFAULT_CIPHERS)\"
 endif
 
+ifeq ($(CONFIG_TLS), mbedtls)
+CFLAGS += -DCONFIG_TLS_MBEDTLS
+ifndef CONFIG_CRYPTO
+CONFIG_CRYPTO=mbedtls
+endif
+ifdef TLS_FUNCS
+OBJS += ../src/crypto/tls_mbedtls.o
+LIBS += -lmbedtls -lmbedx509
+endif
+OBJS += ../src/crypto/crypto_$(CONFIG_CRYPTO).o
+OBJS_p += ../src/crypto/crypto_$(CONFIG_CRYPTO).o
+OBJS_priv += ../src/crypto/crypto_$(CONFIG_CRYPTO).o
+ifeq ($(CONFIG_CRYPTO), mbedtls)
+LIBS += -lmbedcrypto
+LIBS_p += -lmbedcrypto
+# XXX: create a config option?
+CFLAGS += -DCRYPTO_RSA_OAEP_SHA256
+endif
+endif
+
 ifeq ($(CONFIG_TLS), gnutls)
+CFLAGS += -DCONFIG_TLS_GNUTLS
 ifndef CONFIG_CRYPTO
 # default to libgcrypt
 CONFIG_CRYPTO=gnutls
@@ -1261,6 +1329,7 @@ endif
 endif
 
 ifeq ($(CONFIG_TLS), internal)
+CFLAGS += -DCONFIG_TLS_INTERNAL
 ifndef CONFIG_CRYPTO
 CONFIG_CRYPTO=internal
 endif
@@ -1341,6 +1410,7 @@ endif
 endif
 
 ifeq ($(CONFIG_TLS), linux)
+CFLAGS += -DCONFIG_TLS_INTERNAL
 OBJS += ../src/crypto/crypto_linux.o
 OBJS_p += ../src/crypto/crypto_linux.o
 ifdef TLS_FUNCS
@@ -1422,9 +1492,11 @@ endif
 
 ifneq ($(CONFIG_TLS), openssl)
 ifneq ($(CONFIG_TLS), wolfssl)
+ifneq ($(CONFIG_TLS), mbedtls)
 NEED_INTERNAL_AES_WRAP=y
 endif
 endif
+endif
 ifdef CONFIG_OPENSSL_INTERNAL_AES_WRAP
 # Seems to be needed at least with BoringSSL
 NEED_INTERNAL_AES_WRAP=y
@@ -1438,9 +1510,11 @@ endif
 
 ifdef NEED_INTERNAL_AES_WRAP
 ifneq ($(CONFIG_TLS), linux)
+ifneq ($(CONFIG_TLS), mbedtls)
 AESOBJS += ../src/crypto/aes-unwrap.o
 endif
 endif
+endif
 ifdef NEED_AES_EAX
 AESOBJS += ../src/crypto/aes-eax.o
 NEED_AES_CTR=y
@@ -1450,35 +1524,45 @@ AESOBJS += ../src/crypto/aes-siv.o
 NEED_AES_CTR=y
 endif
 ifdef NEED_AES_CTR
+ifneq ($(CONFIG_TLS), mbedtls)
 AESOBJS += ../src/crypto/aes-ctr.o
 endif
+endif
 ifdef NEED_AES_ENCBLOCK
+ifneq ($(CONFIG_TLS), mbedtls)
 AESOBJS += ../src/crypto/aes-encblock.o
 endif
+endif
 NEED_AES_ENC=y
 ifneq ($(CONFIG_TLS), openssl)
 ifneq ($(CONFIG_TLS), linux)
 ifneq ($(CONFIG_TLS), wolfssl)
+ifneq ($(CONFIG_TLS), mbedtls)
 AESOBJS += ../src/crypto/aes-omac1.o
 endif
 endif
 endif
+endif
 ifdef NEED_AES_WRAP
 NEED_AES_ENC=y
 ifdef NEED_INTERNAL_AES_WRAP
+ifneq ($(CONFIG_TLS), mbedtls)
 AESOBJS += ../src/crypto/aes-wrap.o
 endif
 endif
+endif
 ifdef NEED_AES_CBC
 NEED_AES_ENC=y
 ifneq ($(CONFIG_TLS), openssl)
 ifneq ($(CONFIG_TLS), linux)
 ifneq ($(CONFIG_TLS), wolfssl)
+ifneq ($(CONFIG_TLS), mbedtls)
 AESOBJS += ../src/crypto/aes-cbc.o
 endif
 endif
 endif
 endif
+endif
 ifdef NEED_AES_ENC
 ifdef CONFIG_INTERNAL_AES
 AESOBJS += ../src/crypto/aes-internal-enc.o
@@ -1493,12 +1577,16 @@ ifneq ($(CONFIG_TLS), openssl)
 ifneq ($(CONFIG_TLS), linux)
 ifneq ($(CONFIG_TLS), gnutls)
 ifneq ($(CONFIG_TLS), wolfssl)
+ifneq ($(CONFIG_TLS), mbedtls)
 SHA1OBJS += ../src/crypto/sha1.o
 endif
 endif
 endif
 endif
+endif
+ifneq ($(CONFIG_TLS), mbedtls)
 SHA1OBJS += ../src/crypto/sha1-prf.o
+endif
 ifdef CONFIG_INTERNAL_SHA1
 SHA1OBJS += ../src/crypto/sha1-internal.o
 ifdef NEED_FIPS186_2_PRF
@@ -1510,29 +1598,37 @@ CFLAGS += -DCONFIG_NO_PBKDF2
 else
 ifneq ($(CONFIG_TLS), openssl)
 ifneq ($(CONFIG_TLS), wolfssl)
+ifneq ($(CONFIG_TLS), mbedtls)
 SHA1OBJS += ../src/crypto/sha1-pbkdf2.o
 endif
 endif
 endif
+endif
 ifdef NEED_T_PRF
+ifneq ($(CONFIG_TLS), mbedtls)
 SHA1OBJS += ../src/crypto/sha1-tprf.o
 endif
+endif
 ifdef NEED_TLS_PRF
+ifneq ($(CONFIG_TLS), mbedtls)
 SHA1OBJS += ../src/crypto/sha1-tlsprf.o
 endif
 endif
+endif
 
 ifndef CONFIG_FIPS
 ifneq ($(CONFIG_TLS), openssl)
 ifneq ($(CONFIG_TLS), linux)
 ifneq ($(CONFIG_TLS), gnutls)
 ifneq ($(CONFIG_TLS), wolfssl)
+ifneq ($(CONFIG_TLS), mbedtls)
 MD5OBJS += ../src/crypto/md5.o
 endif
 endif
 endif
 endif
 endif
+endif
 ifdef NEED_MD5
 ifdef CONFIG_INTERNAL_MD5
 MD5OBJS += ../src/crypto/md5-internal.o
@@ -1587,12 +1683,17 @@ ifneq ($(CONFIG_TLS), openssl)
 ifneq ($(CONFIG_TLS), linux)
 ifneq ($(CONFIG_TLS), gnutls)
 ifneq ($(CONFIG_TLS), wolfssl)
+ifneq ($(CONFIG_TLS), mbedtls)
 SHA256OBJS += ../src/crypto/sha256.o
 endif
 endif
 endif
 endif
+endif
+
+ifneq ($(CONFIG_TLS), mbedtls)
 SHA256OBJS += ../src/crypto/sha256-prf.o
+endif
 ifdef CONFIG_INTERNAL_SHA256
 SHA256OBJS += ../src/crypto/sha256-internal.o
 endif
@@ -1605,50 +1706,68 @@ CFLAGS += -DCONFIG_INTERNAL_SHA512
 SHA256OBJS += ../src/crypto/sha512-internal.o
 endif
 ifdef NEED_TLS_PRF_SHA256
+ifneq ($(CONFIG_TLS), mbedtls)
 SHA256OBJS += ../src/crypto/sha256-tlsprf.o
 endif
+endif
 ifdef NEED_TLS_PRF_SHA384
+ifneq ($(CONFIG_TLS), mbedtls)
 SHA256OBJS += ../src/crypto/sha384-tlsprf.o
 endif
+endif
 ifdef NEED_HMAC_SHA256_KDF
 CFLAGS += -DCONFIG_HMAC_SHA256_KDF
+ifneq ($(CONFIG_TLS), mbedtls)
 OBJS += ../src/crypto/sha256-kdf.o
 endif
+endif
 ifdef NEED_HMAC_SHA384_KDF
 CFLAGS += -DCONFIG_HMAC_SHA384_KDF
+ifneq ($(CONFIG_TLS), mbedtls)
 OBJS += ../src/crypto/sha384-kdf.o
 endif
+endif
 ifdef NEED_HMAC_SHA512_KDF
 CFLAGS += -DCONFIG_HMAC_SHA512_KDF
+ifneq ($(CONFIG_TLS), mbedtls)
 OBJS += ../src/crypto/sha512-kdf.o
 endif
+endif
 OBJS += $(SHA256OBJS)
 ifdef NEED_SHA384
 ifneq ($(CONFIG_TLS), openssl)
 ifneq ($(CONFIG_TLS), linux)
 ifneq ($(CONFIG_TLS), gnutls)
 ifneq ($(CONFIG_TLS), wolfssl)
+ifneq ($(CONFIG_TLS), mbedtls)
 OBJS += ../src/crypto/sha384.o
 endif
 endif
 endif
 endif
+endif
 CFLAGS += -DCONFIG_SHA384
+ifneq ($(CONFIG_TLS), mbedtls)
 OBJS += ../src/crypto/sha384-prf.o
 endif
+endif
 ifdef NEED_SHA512
 ifneq ($(CONFIG_TLS), openssl)
 ifneq ($(CONFIG_TLS), linux)
 ifneq ($(CONFIG_TLS), gnutls)
 ifneq ($(CONFIG_TLS), wolfssl)
+ifneq ($(CONFIG_TLS), mbedtls)
 OBJS += ../src/crypto/sha512.o
 endif
 endif
 endif
 endif
+endif
 CFLAGS += -DCONFIG_SHA512
+ifneq ($(CONFIG_TLS), mbedtls)
 OBJS += ../src/crypto/sha512-prf.o
 endif
+endif
 
 ifdef NEED_ASN1
 OBJS += ../src/tls/asn1.o
@@ -1823,10 +1942,12 @@ ifdef CONFIG_FIPS
 CFLAGS += -DCONFIG_FIPS
 ifneq ($(CONFIG_TLS), openssl)
 ifneq ($(CONFIG_TLS), wolfssl)
+ifneq ($(CONFIG_TLS), mbedtls)
 $(error CONFIG_FIPS=y requires CONFIG_TLS=openssl)
 endif
 endif
 endif
+endif
 
 OBJS += $(SHA1OBJS) $(DESOBJS)
 
@@ -2004,32 +2125,38 @@ wpa_priv: $(BCHECK) $(OBJS_priv)
 
 _OBJS_VAR := OBJS
 include ../src/objs.mk
+wpa_supplicant_multi.a: .config $(BCHECK) $(OBJS) $(EXTRA_progs)
+	$(Q)$(CC) -c -o wpa_supplicant_multi.o -Dmain=wpa_supplicant_main $(CFLAGS) main.c
+	@$(E) "  CC " $<
+	@rm -f $@
+	@$(AR) cr $@ wpa_supplicant_multi.o $(OBJS)
+
 wpa_supplicant: $(BCHECK) $(OBJS) $(EXTRA_progs)
-	$(Q)$(LDO) $(LDFLAGS) -o wpa_supplicant $(OBJS) $(LIBS) $(EXTRALIBS)
+	+$(Q)$(LDO) $(LDFLAGS) -o wpa_supplicant $(OBJS) $(LIBS) $(EXTRALIBS)
 	@$(E) "  LD " $@
 
 _OBJS_VAR := OBJS_t
 include ../src/objs.mk
 eapol_test: $(OBJS_t)
-	$(Q)$(LDO) $(LDFLAGS) -o eapol_test $(OBJS_t) $(LIBS)
+	+$(Q)$(LDO) $(LDFLAGS) -o eapol_test $(OBJS_t) $(LIBS)
 	@$(E) "  LD " $@
 
 _OBJS_VAR := OBJS_t2
 include ../src/objs.mk
 preauth_test: $(OBJS_t2)
-	$(Q)$(LDO) $(LDFLAGS) -o preauth_test $(OBJS_t2) $(LIBS)
+	+$(Q)$(LDO) $(LDFLAGS) -o preauth_test $(OBJS_t2) $(LIBS)
 	@$(E) "  LD " $@
 
 _OBJS_VAR := OBJS_p
 include ../src/objs.mk
 wpa_passphrase: $(OBJS_p)
-	$(Q)$(LDO) $(LDFLAGS) -o wpa_passphrase $(OBJS_p) $(LIBS_p) $(LIBS)
+	+$(Q)$(LDO) $(LDFLAGS) -o wpa_passphrase $(OBJS_p) $(LIBS_p) $(LIBS)
 	@$(E) "  LD " $@
 
 _OBJS_VAR := OBJS_c
 include ../src/objs.mk
 wpa_cli: $(OBJS_c)
-	$(Q)$(LDO) $(LDFLAGS) -o wpa_cli $(OBJS_c) $(LIBS_c)
+	+$(Q)$(LDO) $(LDFLAGS) -o wpa_cli $(OBJS_c) $(LIBS_c)
 	@$(E) "  LD " $@
 
 LIBCTRL += ../src/common/wpa_ctrl.o
@@ -2136,6 +2263,12 @@ eap_gpsk.so: $(SRC_EAP_GPSK)
 	$(Q)sed -e 's|\@BINDIR\@|$(BINDIR)|g' $< >$@
 	@$(E) "  sed" $<
 
+dump_cflags:
+	@printf "%s " "$(CFLAGS)"
+
+dump_ldflags:
+	@printf "%s " "$(LDFLAGS) $(LIBS) $(EXTRALIBS)"
+
 wpa_supplicant.exe: wpa_supplicant
 	mv -f $< $@
 wpa_cli.exe: wpa_cli
diff --git a/wpa_supplicant/ap.c b/wpa_supplicant/ap.c
index 18d78d1..a96d18a 100644
--- a/wpa_supplicant/ap.c
+++ b/wpa_supplicant/ap.c
@@ -1517,7 +1517,7 @@ int wpas_ap_wps_nfc_report_handover(struct wpa_supplicant *wpa_s,
 #endif /* CONFIG_WPS */
 
 
-#ifdef CONFIG_CTRL_IFACE
+#if defined(CONFIG_CTRL_IFACE) && defined(CONFIG_CTRL_IFACE_MIB)
 
 int ap_ctrl_iface_sta_first(struct wpa_supplicant *wpa_s,
 			    char *buf, size_t buflen)
@@ -1843,17 +1843,37 @@ int ap_switch_channel(struct wpa_supplicant *wpa_s,
 
 
 #ifdef CONFIG_CTRL_IFACE
+
+static int __ap_ctrl_iface_chanswitch(struct hostapd_iface *iface,
+				      struct csa_settings *settings)
+{
+#ifdef NEED_AP_MLME
+	if (!iface || !iface->bss[0])
+		return 0;
+
+	return hostapd_switch_channel(iface->bss[0], settings);
+#else
+	return -1;
+#endif
+}
+
+
 int ap_ctrl_iface_chanswitch(struct wpa_supplicant *wpa_s, const char *pos)
 {
 	struct csa_settings settings;
 	int ret = hostapd_parse_csa_settings(pos, &settings);
 
-	if (ret)
-		return ret;
+	if (!(wpa_s->ap_iface && wpa_s->ap_iface->bss[0]) &&
+	    !(wpa_s->ifmsh && wpa_s->ifmsh->bss[0]))
+		return -1;
 
 	settings.link_id = -1;
 
-	return ap_switch_channel(wpa_s, &settings);
+	ret = __ap_ctrl_iface_chanswitch(wpa_s->ap_iface, &settings);
+	if (ret)
+		return ret;
+
+	return __ap_ctrl_iface_chanswitch(wpa_s->ifmsh, &settings);
 }
 #endif /* CONFIG_CTRL_IFACE */
 
diff --git a/wpa_supplicant/bss.c b/wpa_supplicant/bss.c
index 35b62cb..adbd195 100644
--- a/wpa_supplicant/bss.c
+++ b/wpa_supplicant/bss.c
@@ -1625,9 +1625,12 @@ wpa_bss_parse_ml_rnr_ap_info(struct wpa_supplicant *wpa_s,
 				    (bss_params & (RNR_BSS_PARAM_SAME_SSID |
 						   RNR_BSS_PARAM_CO_LOCATED)) ||
 				    wpa_scan_res_match(wpa_s, 0, neigh_bss,
-						       ssid, 1, 0)) &&
+						       ssid, 1, 0))
+#if 0 /* MLD partner link should not be excluded */
 				   !wpa_bssid_ignore_is_listed(
-					   wpa_s, neigh_bss->bssid)) {
+					   wpa_s, neigh_bss->bssid)
+#endif
+				    ) {
 				struct mld_link *l;
 
 				bss->valid_links |= BIT(link_id);
diff --git a/wpa_supplicant/config.c b/wpa_supplicant/config.c
index 13043af..fac246f 100644
--- a/wpa_supplicant/config.c
+++ b/wpa_supplicant/config.c
@@ -18,6 +18,7 @@
 #include "eap_peer/eap.h"
 #include "p2p/p2p.h"
 #include "fst/fst.h"
+#include "ap/sta_info.h"
 #include "config.h"
 
 
@@ -2421,6 +2422,97 @@ static char * wpa_config_write_mac_value(const struct parse_data *data,
 #endif /* NO_CONFIG_WRITE */
 
 
+static int wpa_config_parse_mcast_rate(const struct parse_data *data,
+				       struct wpa_ssid *ssid, int line,
+				       const char *value)
+{
+	ssid->mcast_rate = (int)(strtod(value, NULL) * 10);
+
+	return 0;
+}
+
+#ifndef NO_CONFIG_WRITE
+static char * wpa_config_write_mcast_rate(const struct parse_data *data,
+					  struct wpa_ssid *ssid)
+{
+	char *value;
+	int res;
+
+	if (!ssid->mcast_rate == 0)
+		return NULL;
+
+	value = os_malloc(6); /* longest: 300.0 */
+	if (value == NULL)
+		return NULL;
+	res = os_snprintf(value, 5, "%.1f", (double)ssid->mcast_rate / 10);
+	if (res < 0) {
+		os_free(value);
+		return NULL;
+	}
+	return value;
+}
+#endif /* NO_CONFIG_WRITE */
+
+static int wpa_config_parse_rates(const struct parse_data *data,
+				  struct wpa_ssid *ssid, int line,
+				  const char *value)
+{
+	int i;
+	char *pos, *r, *sptr, *end;
+	double rate;
+
+	pos = (char *)value;
+	r = strtok_r(pos, ",", &sptr);
+	i = 0;
+	while (pos && i < WLAN_SUPP_RATES_MAX) {
+		rate = 0.0;
+		if (r)
+			rate = strtod(r, &end);
+		ssid->rates[i] = rate * 2;
+		if (*end != '\0' || rate * 2 != ssid->rates[i])
+			return 1;
+
+		i++;
+		r = strtok_r(NULL, ",", &sptr);
+	}
+
+	return 0;
+}
+
+#ifndef NO_CONFIG_WRITE
+static char * wpa_config_write_rates(const struct parse_data *data,
+				     struct wpa_ssid *ssid)
+{
+	char *value, *pos;
+	int res, i;
+
+	if (ssid->rates[0] <= 0)
+		return NULL;
+
+	value = os_malloc(6 * WLAN_SUPP_RATES_MAX + 1);
+	if (value == NULL)
+		return NULL;
+	pos = value;
+	for (i = 0; i < WLAN_SUPP_RATES_MAX - 1; i++) {
+		res = os_snprintf(pos, 6, "%.1f,", (double)ssid->rates[i] / 2);
+		if (res < 0) {
+			os_free(value);
+			return NULL;
+		}
+		pos += res;
+	}
+	res = os_snprintf(pos, 6, "%.1f",
+			  (double)ssid->rates[WLAN_SUPP_RATES_MAX - 1] / 2);
+	if (res < 0) {
+		os_free(value);
+		return NULL;
+	}
+
+	value[6 * WLAN_SUPP_RATES_MAX] = '\0';
+	return value;
+}
+#endif /* NO_CONFIG_WRITE */
+
 /* Helper macros for network block parser */
 
 #ifdef OFFSET
@@ -2640,6 +2732,7 @@ static const struct parse_data ssid_fields[] = {
 #else /* CONFIG_MESH */
 	{ INT_RANGE(mode, 0, 4) },
 #endif /* CONFIG_MESH */
+	{ INT_RANGE(noscan, 0, 1) },
 	{ INT_RANGE(proactive_key_caching, 0, 1) },
 	{ INT_RANGE(disabled, 0, 2) },
 	{ STR(id_str) },
@@ -2713,6 +2806,8 @@ static const struct parse_data ssid_fields[] = {
 	{ INT(ap_max_inactivity) },
 	{ INT(dtim_period) },
 	{ INT(beacon_int) },
+	{ FUNC(rates) },
+	{ FUNC(mcast_rate) },
 #ifdef CONFIG_MACSEC
 	{ INT_RANGE(macsec_policy, 0, 1) },
 	{ INT_RANGE(macsec_integ_only, 0, 1) },
@@ -4629,19 +4724,19 @@ struct wpa_config * wpa_config_alloc_empty(const char *ctrl_interface,
 	const struct hostapd_wmm_ac_params ac_bk =
 		{ aCWmin, aCWmax, 7, 0, 0 }; /* background traffic */
 	const struct hostapd_wmm_ac_params ac_be =
-		{ aCWmin, aCWmax, 3, 0, 0 }; /* best effort traffic */
+		{ aCWmin, aCWmin + 2, 3, 0, 0 }; /* best effort traffic */
 	const struct hostapd_wmm_ac_params ac_vi = /* video traffic */
-		{ aCWmin - 1, aCWmin, 2, 3008 / 32, 0 };
+		{ aCWmin - 1, aCWmin, 1, 3008 / 32, 0 };
 	const struct hostapd_wmm_ac_params ac_vo = /* voice traffic */
-		{ aCWmin - 2, aCWmin - 1, 2, 1504 / 32, 0 };
+		{ aCWmin - 2, aCWmin - 1, 1, 1504 / 32, 0 };
 	const struct hostapd_tx_queue_params txq_bk =
 		{ 7, ecw2cw(aCWmin), ecw2cw(aCWmax), 0 };
 	const struct hostapd_tx_queue_params txq_be =
-		{ 3, ecw2cw(aCWmin), 4 * (ecw2cw(aCWmin) + 1) - 1, 0 };
+		{ 3, ecw2cw(aCWmin), ecw2cw(aCWmax), 0 };
 	const struct hostapd_tx_queue_params txq_vi =
-		{ 1, (ecw2cw(aCWmin) + 1) / 2 - 1, ecw2cw(aCWmin), 30 };
+		{ 2, (ecw2cw(aCWmin) + 1) / 2 - 1, ecw2cw(aCWmin), 30 };
 	const struct hostapd_tx_queue_params txq_vo =
-		{ 1, (ecw2cw(aCWmin) + 1) / 4 - 1,
+		{ 2, (ecw2cw(aCWmin) + 1) / 4 - 1,
 		  (ecw2cw(aCWmin) + 1) / 2 - 1, 15 };
 
 #undef ecw2cw
@@ -5592,6 +5687,7 @@ static const struct global_parse_data global_fields[] = {
 #endif /* CONFIG_PASN */
 #ifdef CONFIG_TESTING_OPTIONS
 	{ INT_RANGE(mld_force_single_link, 0, 1), 0 },
+	{ INT_RANGE(mld_allowed_phy, 0, 7), 0 },
 	{ INT_RANGE(mld_connect_band_pref, 0, MLD_CONNECT_BAND_PREF_MAX), 0 },
 	{ FUNC(mld_connect_bssid_pref), 0 },
 #endif /* CONFIG_TESTING_OPTIONS */
diff --git a/wpa_supplicant/config.h b/wpa_supplicant/config.h
index 979f083..6e0d0f4 100644
--- a/wpa_supplicant/config.h
+++ b/wpa_supplicant/config.h
@@ -1813,6 +1813,7 @@ struct wpa_config {
 	u8 mld_connect_bssid_pref[ETH_ALEN];
 
 	int mld_force_single_link;
+	u8 mld_allowed_phy; /* bitmap of allowed phy for MLO connection */
 #endif /* CONFIG_TESTING_OPTIONS */
 
 	/* Cipher version type */
diff --git a/wpa_supplicant/config_file.c b/wpa_supplicant/config_file.c
index 20b309a..feb56b1 100644
--- a/wpa_supplicant/config_file.c
+++ b/wpa_supplicant/config_file.c
@@ -326,8 +326,13 @@ struct wpa_config * wpa_config_read(const char *name, struct wpa_config *cfgp,
 	while (cred_tail && cred_tail->next)
 		cred_tail = cred_tail->next;
 
+	if (!strncmp(name, "data:", 5)) {
+		f = fmemopen((void *)(name + 5), strlen(name + 5), "r");
+		name = "<inline>";
+	} else {
+		f = fopen(name, "r");
+	}
 	wpa_printf(MSG_DEBUG, "Reading configuration file '%s'", name);
-	f = fopen(name, "r");
 	if (f == NULL) {
 		wpa_printf(MSG_ERROR, "Failed to open config file '%s', "
 			   "error: %s", name, strerror(errno));
@@ -775,6 +780,7 @@ static void wpa_config_write_network(FILE *f, struct wpa_ssid *ssid)
 #endif /* IEEE8021X_EAPOL */
 	INT(mode);
 	INT(no_auto_peer);
+	INT(noscan);
 	INT(mesh_fwding);
 	INT(frequency);
 	INT(enable_edmg);
@@ -1620,6 +1626,8 @@ static void wpa_config_write_global(FILE *f, struct wpa_config *config)
 #ifdef CONFIG_TESTING_OPTIONS
 	if (config->mld_force_single_link)
 		fprintf(f, "mld_force_single_link=1\n");
+	if (config->mld_allowed_phy)
+		fprintf(f, "mld_allowed_phy=%u\n", config->mld_allowed_phy);
 	if (config->mld_connect_band_pref != MLD_CONNECT_BAND_PREF_AUTO)
 		fprintf(f, "mld_connect_band_pref=%d\n",
 			config->mld_connect_band_pref);
diff --git a/wpa_supplicant/config_ssid.h b/wpa_supplicant/config_ssid.h
index 71dba9e..3db66e4 100644
--- a/wpa_supplicant/config_ssid.h
+++ b/wpa_supplicant/config_ssid.h
@@ -884,6 +884,9 @@ struct wpa_ssid {
 	 */
 	void *parent_cred;
 
+	unsigned char rates[WLAN_SUPP_RATES_MAX];
+	double mcast_rate;
+
 #ifdef CONFIG_MACSEC
 	/**
 	 * macsec_policy - Determines the policy for MACsec secure session
@@ -1040,6 +1043,8 @@ struct wpa_ssid {
 	 */
 	int no_auto_peer;
 
+	int noscan;
+
 	/**
 	 * mesh_rssi_threshold - Set mesh parameter mesh_rssi_threshold (dBm)
 	 *
diff --git a/wpa_supplicant/ctrl_iface.c b/wpa_supplicant/ctrl_iface.c
index 56be854..75d130e 100644
--- a/wpa_supplicant/ctrl_iface.c
+++ b/wpa_supplicant/ctrl_iface.c
@@ -2357,7 +2357,7 @@ static int wpa_supplicant_ctrl_iface_status(struct wpa_supplicant *wpa_s,
 			pos += ret;
 		}
 
-#ifdef CONFIG_AP
+#if defined(CONFIG_AP) && defined(CONFIG_CTRL_IFACE_MIB)
 		if (wpa_s->ap_iface) {
 			pos += ap_ctrl_iface_wpa_get_status(wpa_s, pos,
 							    end - pos,
@@ -12692,6 +12692,7 @@ char * wpa_supplicant_ctrl_iface_process(struct wpa_supplicant *wpa_s,
 			reply_len = -1;
 	} else if (os_strncmp(buf, "NOTE ", 5) == 0) {
 		wpa_printf(MSG_INFO, "NOTE: %s", buf + 5);
+#ifdef CONFIG_CTRL_IFACE_MIB
 	} else if (os_strcmp(buf, "MIB") == 0) {
 		reply_len = wpa_sm_get_mib(wpa_s->wpa, reply, reply_size);
 		if (reply_len >= 0) {
@@ -12704,6 +12705,7 @@ char * wpa_supplicant_ctrl_iface_process(struct wpa_supplicant *wpa_s,
 				reply_size - reply_len);
 #endif /* CONFIG_MACSEC */
 		}
+#endif
 	} else if (os_strncmp(buf, "STATUS", 6) == 0) {
 		reply_len = wpa_supplicant_ctrl_iface_status(
 			wpa_s, buf + 6, reply, reply_size);
@@ -13192,6 +13194,7 @@ char * wpa_supplicant_ctrl_iface_process(struct wpa_supplicant *wpa_s,
 		reply_len = wpa_supplicant_ctrl_iface_bss(
 			wpa_s, buf + 4, reply, reply_size);
 #ifdef CONFIG_AP
+#ifdef CONFIG_CTRL_IFACE_MIB
 	} else if (os_strcmp(buf, "STA-FIRST") == 0) {
 		reply_len = ap_ctrl_iface_sta_first(wpa_s, reply, reply_size);
 	} else if (os_strncmp(buf, "STA ", 4) == 0) {
@@ -13200,12 +13203,15 @@ char * wpa_supplicant_ctrl_iface_process(struct wpa_supplicant *wpa_s,
 	} else if (os_strncmp(buf, "STA-NEXT ", 9) == 0) {
 		reply_len = ap_ctrl_iface_sta_next(wpa_s, buf + 9, reply,
 						   reply_size);
+#endif
+#ifdef CONFIG_CTRL_IFACE_MIB
 	} else if (os_strncmp(buf, "DEAUTHENTICATE ", 15) == 0) {
 		if (ap_ctrl_iface_sta_deauthenticate(wpa_s, buf + 15))
 			reply_len = -1;
 	} else if (os_strncmp(buf, "DISASSOCIATE ", 13) == 0) {
 		if (ap_ctrl_iface_sta_disassociate(wpa_s, buf + 13))
 			reply_len = -1;
+#endif
 	} else if (os_strncmp(buf, "CHAN_SWITCH ", 12) == 0) {
 		if (ap_ctrl_iface_chanswitch(wpa_s, buf + 12))
 			reply_len = -1;
@@ -13364,7 +13370,7 @@ char * wpa_supplicant_ctrl_iface_process(struct wpa_supplicant *wpa_s,
 		if (wpas_ctrl_iface_coloc_intf_report(wpa_s, buf + 18))
 			reply_len = -1;
 #endif /* CONFIG_WNM */
-#ifdef CONFIG_WNM_AP
+#if defined(CONFIG_AP) && defined(CONFIG_WNM_AP)
 	} else if (os_strncmp(buf, "DISASSOC_IMMINENT ", 18) == 0) {
 		if (ap_ctrl_iface_disassoc_imminent(wpa_s, buf + 18))
 			reply_len = -1;
@@ -13374,7 +13380,7 @@ char * wpa_supplicant_ctrl_iface_process(struct wpa_supplicant *wpa_s,
 	} else if (os_strncmp(buf, "BSS_TM_REQ ", 11) == 0) {
 		if (ap_ctrl_iface_bss_tm_req(wpa_s, buf + 11))
 			reply_len = -1;
-#endif /* CONFIG_WNM_AP */
+#endif /* CONFIG_AP && CONFIG_WNM_AP */
 	} else if (os_strcmp(buf, "FLUSH") == 0) {
 		wpa_supplicant_ctrl_iface_flush(wpa_s);
 	} else if (os_strncmp(buf, "RADIO_WORK ", 11) == 0) {
diff --git a/wpa_supplicant/defconfig b/wpa_supplicant/defconfig
index 52befd8..ace6c55 100644
--- a/wpa_supplicant/defconfig
+++ b/wpa_supplicant/defconfig
@@ -10,8 +10,8 @@
 # to override previous values of the variables.
 
 
-# Uncomment following two lines and fix the paths if you have installed OpenSSL
-# or GnuTLS in non-default location
+# Uncomment following two lines and fix the paths if you have installed TLS
+# libraries in a non-default location
 #CFLAGS += -I/usr/local/openssl/include
 #LIBS += -L/usr/local/openssl/lib
 
@@ -20,6 +20,7 @@
 # used to fix build issues on such systems (krb5.h not found).
 #CFLAGS += -I/usr/include/kerberos
 
+
 # Driver interface for generic Linux wireless extensions
 # Note: WEXT is deprecated in the current Linux kernel version and no new
 # functionality is added to it. nl80211-based interface is the new
@@ -329,6 +330,7 @@ CONFIG_BACKEND=file
 # openssl = OpenSSL (default)
 # gnutls = GnuTLS
 # internal = Internal TLSv1 implementation (experimental)
+# mbedtls = mbed TLS
 # linux = Linux kernel AF_ALG and internal TLSv1 implementation (experimental)
 # none = Empty template
 #CONFIG_TLS=openssl
diff --git a/wpa_supplicant/driver_i.h b/wpa_supplicant/driver_i.h
index cd74e31..ec33abd 100644
--- a/wpa_supplicant/driver_i.h
+++ b/wpa_supplicant/driver_i.h
@@ -324,6 +324,18 @@ static inline int wpa_drv_set_country(struct wpa_supplicant *wpa_s,
 	return 0;
 }
 
+static inline int wpa_drv_set_tx_queue_params(struct wpa_supplicant *wpa_s,
+					      int q, int aifs, int cw_min,
+					      int cw_max, int burst_time)
+{
+	int link_id = -1;
+	if (wpa_s->driver->set_tx_queue_params)
+		return wpa_s->driver->set_tx_queue_params(wpa_s->drv_priv, q,
+							  aifs, cw_min, cw_max,
+							  burst_time, link_id);
+	return 0;
+}
+
 static inline int wpa_drv_send_mlme(struct wpa_supplicant *wpa_s,
 				    const u8 *data, size_t data_len, int noack,
 				    unsigned int freq, unsigned int wait)
@@ -437,7 +449,7 @@ static inline int wpa_drv_if_add(struct wpa_supplicant *wpa_s,
 	if (wpa_s->driver->if_add)
 		return wpa_s->driver->if_add(wpa_s->drv_priv, type, ifname,
 					     addr, bss_ctx, NULL, force_ifname,
-					     if_addr, bridge, 0, 0);
+					     if_addr, bridge, 0, 0, -1, 0);
 	return -1;
 }
 
@@ -1249,4 +1261,15 @@ wpas_drv_nan_cancel_subscribe(struct wpa_supplicant *wpa_s, int subscribe_id)
 						   subscribe_id);
 }
 
+static inline struct hostapd_multi_hw_info *
+wpas_drv_get_multi_hw_info(struct wpa_supplicant *wpa_s,
+			   unsigned int *num_multi_hws)
+{
+	if (!wpa_s->driver->get_multi_hw_info)
+		return NULL;
+
+	return wpa_s->driver->get_multi_hw_info(wpa_s->drv_priv,
+						num_multi_hws);
+}
+
 #endif /* DRIVER_I_H */
diff --git a/wpa_supplicant/eapol_test.c b/wpa_supplicant/eapol_test.c
index 0c17aae..3d35757 100644
--- a/wpa_supplicant/eapol_test.c
+++ b/wpa_supplicant/eapol_test.c
@@ -31,7 +31,12 @@
 #include "ctrl_iface.h"
 #include "pcsc_funcs.h"
 #include "wpas_glue.h"
+#include "drivers/driver.h"
 
+void (*wpa_supplicant_event)(void *ctx, enum wpa_event_type event,
+			     union wpa_event_data *data);
+void (*wpa_supplicant_event_global)(void *ctx, enum wpa_event_type event,
+			     union wpa_event_data *data);
 
 const struct wpa_driver_ops *const wpa_drivers[] = { NULL };
 
@@ -1328,6 +1333,10 @@ static void usage(void)
 	       "option several times.\n");
 }
 
+extern void supplicant_event(void *ctx, enum wpa_event_type event,
+			     union wpa_event_data *data);
+extern void supplicant_event_global(void *ctx, enum wpa_event_type event,
+			     union wpa_event_data *data);
 
 int main(int argc, char *argv[])
 {
@@ -1351,6 +1360,8 @@ int main(int argc, char *argv[])
 	if (os_program_init())
 		return -1;
 
+	wpa_supplicant_event = supplicant_event;
+	wpa_supplicant_event_global = supplicant_event_global;
 	hostapd_logger_register_cb(hostapd_logger_cb);
 
 	os_memset(&eapol_test, 0, sizeof(eapol_test));
diff --git a/wpa_supplicant/events.c b/wpa_supplicant/events.c
index 7947b6f..8d86f2e 100644
--- a/wpa_supplicant/events.c
+++ b/wpa_supplicant/events.c
@@ -1718,6 +1718,13 @@ struct wpa_ssid * wpa_scan_res_match(struct wpa_supplicant *wpa_s,
 		return NULL;
 	}
 
+	if (wpa_s->conf->freq_list &&
+	    !int_array_includes(wpa_s->conf->freq_list, bss->freq)) {
+		if (debug_print)
+			wpa_dbg(wpa_s, MSG_DEBUG, "  skip - channel disallowed");
+		return NULL;
+	}
+
 	if (wnm_is_bss_excluded(wpa_s, bss)) {
 		if (debug_print)
 			wpa_dbg(wpa_s, MSG_DEBUG, "   skip - BSSID excluded");
@@ -1918,15 +1925,16 @@ static int wpa_supplicant_connect_ml_missing(struct wpa_supplicant *wpa_s,
 
 	if (wpa_bss_parse_basic_ml_element(wpa_s, selected, NULL,
 					   &missing_links, ssid,
-					   &ap_mld_id) ||
-	    !missing_links)
+					   &ap_mld_id))
 		return 0;
 
 	removed_links = wpa_bss_parse_reconf_ml_element(wpa_s, selected);
 	missing_links &= ~removed_links;
 
+	/* FIXME Always do ML probe for the sake of stability.
 	if (!missing_links)
 		return 0;
+	*/
 
 	wpa_dbg(wpa_s, MSG_DEBUG,
 		"MLD: Doing an ML probe for missing links 0x%04x",
@@ -2388,6 +2396,9 @@ static int wpa_supplicant_need_to_roam(struct wpa_supplicant *wpa_s,
 	if (current_bss == selected)
 		return 0;
 
+	if (wpa_s->valid_links && ether_addr_equal(selected->mld_addr, wpa_s->bssid))
+		return 0; /* same AP MLD but different links */
+
 	if (selected->last_update_idx > current_bss->last_update_idx)
 		return 1; /* current BSS not seen in the last scan */
 
@@ -4181,6 +4192,10 @@ static int wpa_drv_get_mlo_info(struct wpa_supplicant *wpa_s)
 		os_memcpy(wpa_s->links[i].addr, mlo.links[i].addr, ETH_ALEN);
 		os_memcpy(wpa_s->links[i].bssid, mlo.links[i].bssid, ETH_ALEN);
 		wpa_s->links[i].freq = mlo.links[i].freq;
+		wpa_s->links[i].center_freq1 = mlo.links[i].center_freq1;
+		wpa_s->links[i].center_freq2 = mlo.links[i].center_freq2;
+		wpa_s->links[i].width = mlo.links[i].width;
+		wpa_s->links[i].punct_bitmap = mlo.links[i].punct_bitmap;
 		wpa_supplicant_update_link_bss(wpa_s, i, mlo.links[i].bssid);
 	}
 
@@ -4250,6 +4265,20 @@ out:
 	return wpa_sm_set_mlo_params(wpa_s->wpa, &wpa_mlo);
 }
 
+static void wpa_supplicant_tx_queue_params(struct wpa_supplicant *wpa_s){
+	struct hostapd_tx_queue_params *p;
+
+	for (int i = 0; i < NUM_TX_QUEUES; i++){
+		p = &wpa_s->conf->tx_queue[i];
+		if(wpa_drv_set_tx_queue_params(wpa_s, i, p->aifs,
+						      p->cwmin, p->cwmax,
+						      p->burst)) {
+			wpa_printf(MSG_DEBUG, "Failed to set TX queue "
+				   "parameters for queue %d.", i);
+			/* Continue anyway */
+		}
+	}
+}
 
 static void wpa_supplicant_event_assoc(struct wpa_supplicant *wpa_s,
 				       union wpa_event_data *data)
@@ -4579,6 +4608,8 @@ static void wpa_supplicant_event_assoc(struct wpa_supplicant *wpa_s,
 
 	if (wpa_s->current_ssid && wpa_s->current_ssid->enable_4addr_mode)
 		wpa_supplicant_set_4addr_mode(wpa_s);
+
+	wpa_supplicant_tx_queue_params(wpa_s);
 }
 
 
@@ -6133,8 +6164,8 @@ static int wpas_pasn_auth(struct wpa_supplicant *wpa_s,
 #endif /* CONFIG_PASN */
 
 
-void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
-			  union wpa_event_data *data)
+void supplicant_event(void *ctx, enum wpa_event_type event,
+		      union wpa_event_data *data)
 {
 	struct wpa_supplicant *wpa_s = ctx;
 	int resched;
@@ -6169,6 +6200,7 @@ void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
 		event_to_string(event), event);
 #endif /* CONFIG_NO_STDOUT_DEBUG */
 
+	wpas_ucode_event(wpa_s, event, data);
 	switch (event) {
 	case EVENT_AUTH:
 #ifdef CONFIG_FST
@@ -7097,7 +7129,7 @@ void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
 }
 
 
-void wpa_supplicant_event_global(void *ctx, enum wpa_event_type event,
+void supplicant_event_global(void *ctx, enum wpa_event_type event,
 				 union wpa_event_data *data)
 {
 	struct wpa_supplicant *wpa_s;
diff --git a/wpa_supplicant/main.c b/wpa_supplicant/main.c
index 9229eb5..ee152c5 100644
--- a/wpa_supplicant/main.c
+++ b/wpa_supplicant/main.c
@@ -12,6 +12,7 @@
 #endif /* __linux__ */
 
 #include "common.h"
+#include "build_features.h"
 #include "crypto/crypto.h"
 #include "fst/fst.h"
 #include "wpa_supplicant_i.h"
@@ -202,7 +203,7 @@ int main(int argc, char *argv[])
 
 	for (;;) {
 		c = getopt(argc, argv,
-			   "b:Bc:C:D:de:f:g:G:hi:I:KLMm:No:O:p:P:qsTtuvW");
+			   "b:Bc:C:D:de:f:g:G:hi:I:KLMm:nNo:O:p:P:qsTtuv::W");
 		if (c < 0)
 			break;
 		switch (c) {
@@ -267,6 +268,9 @@ int main(int argc, char *argv[])
 			params.conf_p2p_dev = optarg;
 			break;
 #endif /* CONFIG_P2P */
+		case 'n':
+			iface_count = 0;
+			break;
 		case 'o':
 			params.override_driver = optarg;
 			break;
@@ -302,8 +306,12 @@ int main(int argc, char *argv[])
 			break;
 #endif /* CONFIG_CTRL_IFACE_DBUS_NEW */
 		case 'v':
-			printf("%s\n", wpa_supplicant_version);
-			exitcode = 0;
+			if (optarg) {
+				exitcode = !has_feature(optarg);
+			} else {
+				printf("%s\n", wpa_supplicant_version);
+				exitcode = 0;
+			}
 			goto out;
 		case 'W':
 			params.wait_for_monitor++;
diff --git a/wpa_supplicant/mesh.c b/wpa_supplicant/mesh.c
index 85c1ea8..dabbb03 100644
--- a/wpa_supplicant/mesh.c
+++ b/wpa_supplicant/mesh.c
@@ -506,6 +506,8 @@ static int wpa_supplicant_mesh_init(struct wpa_supplicant *wpa_s,
 			   frequency);
 		goto out_free;
 	}
+	if (conf->noscan)
+		ssid->noscan = 1;
 
 	if (ssid->mesh_basic_rates == NULL) {
 		/*
@@ -630,6 +632,7 @@ int wpa_supplicant_join_mesh(struct wpa_supplicant *wpa_s,
 
 	params->meshid = ssid->ssid;
 	params->meshid_len = ssid->ssid_len;
+	params->mcast_rate = ssid->mcast_rate;
 	ibss_mesh_setup_freq(wpa_s, ssid, &params->freq);
 	wpa_s->mesh_ht_enabled = !!params->freq.ht_enabled;
 	wpa_s->mesh_vht_enabled = !!params->freq.vht_enabled;
diff --git a/wpa_supplicant/sme.c b/wpa_supplicant/sme.c
index b7faf53..dfcf320 100644
--- a/wpa_supplicant/sme.c
+++ b/wpa_supplicant/sme.c
@@ -207,7 +207,8 @@ static struct wpabuf * sme_auth_build_sae_commit(struct wpa_supplicant *wpa_s,
 	if (wpa_key_mgmt_sae_ext_key(key_mgmt) &&
 	    sae_pwe != SAE_PWE_FORCE_HUNT_AND_PECK)
 		use_pt = 1;
-	if (bss && is_6ghz_freq(bss->freq) &&
+
+	if (bss && (is_6ghz_freq(bss->freq) || !is_zero_ether_addr(bss->mld_addr)) &&
 	    sae_pwe != SAE_PWE_FORCE_HUNT_AND_PECK)
 		use_pt = 1;
 #ifdef CONFIG_SAE_PK
@@ -446,8 +447,11 @@ static struct wpa_bss * wpas_ml_connect_pref(struct wpa_supplicant *wpa_s,
 	}
 
 	for_each_link(wpa_s->valid_links, i) {
-		if (wpa_s->mlo_assoc_link_id == i)
+		if (wpa_s->mlo_assoc_link_id == i) {
+			if (bss->freq >= low && bss->freq <= high)
+				return bss;
 			continue;
+		}
 
 		if (wpa_s->links[i].freq >= low && wpa_s->links[i].freq <= high)
 			goto found;
@@ -523,6 +527,16 @@ static int wpas_sme_ml_auth(struct wpa_supplicant *wpa_s,
 }
 
 
+#ifdef CONFIG_TESTING_OPTIONS
+static bool check_mld_allowed_phy(struct wpa_supplicant *wpa_s, int freq)
+{
+	return ((wpa_s->conf->mld_allowed_phy & BIT(0)) && IS_2P4GHZ(freq)) ||
+	       ((wpa_s->conf->mld_allowed_phy & BIT(1)) && IS_5GHZ(freq)) ||
+	       ((wpa_s->conf->mld_allowed_phy & BIT(2)) && is_6ghz_freq(freq));
+}
+#endif /* CONFIG_TESTING_OPTIONS */
+
+
 static void wpas_sme_set_mlo_links(struct wpa_supplicant *wpa_s,
 				   struct wpa_bss *bss, struct wpa_ssid *ssid)
 {
@@ -534,6 +548,11 @@ static void wpas_sme_set_mlo_links(struct wpa_supplicant *wpa_s,
 	for_each_link(bss->valid_links, i) {
 		const u8 *bssid = bss->mld_links[i].bssid;
 
+#ifdef CONFIG_TESTING_OPTIONS
+		if (!check_mld_allowed_phy(wpa_s, bss->mld_links[i].freq))
+			continue;
+#endif /* CONFIG_TESTING_OPTIONS */
+
 		wpa_s->valid_links |= BIT(i);
 		os_memcpy(wpa_s->links[i].bssid, bssid, ETH_ALEN);
 		wpa_s->links[i].freq = bss->mld_links[i].freq;
@@ -587,6 +606,9 @@ static void sme_send_authentication(struct wpa_supplicant *wpa_s,
 	if ((wpa_s->drv_flags2 & WPA_DRIVER_FLAGS2_MLO) &&
 	    !wpa_bss_parse_basic_ml_element(wpa_s, bss, wpa_s->ap_mld_addr,
 					    NULL, ssid, NULL) &&
+#ifdef CONFIG_TESTING_OPTIONS
+	    wpa_s->conf->mld_allowed_phy &&
+#endif /* CONFIG_TESTING_OPTIONS */
 	    bss->valid_links) {
 		wpa_printf(MSG_DEBUG, "MLD: In authentication");
 		wpas_sme_set_mlo_links(wpa_s, bss, ssid);
diff --git a/wpa_supplicant/ubus.c b/wpa_supplicant/ubus.c
new file mode 100644
index 0000000..1c477f0
--- /dev/null
+++ b/wpa_supplicant/ubus.c
@@ -0,0 +1,280 @@
+/*
+ * wpa_supplicant / ubus support
+ * Copyright (c) 2018, Daniel Golle <daniel@makrotopia.org>
+ * Copyright (c) 2013, Felix Fietkau <nbd@nbd.name>
+ *
+ * This software may be distributed under the terms of the BSD license.
+ * See README for more details.
+ */
+
+#include "utils/includes.h"
+#include "utils/common.h"
+#include "utils/eloop.h"
+#include "utils/wpabuf.h"
+#include "common/ieee802_11_defs.h"
+#include "wpa_supplicant_i.h"
+#include "wps_supplicant.h"
+#include "ubus.h"
+
+static struct ubus_context *ctx;
+static struct blob_buf b;
+static int ctx_ref;
+
+static inline struct wpa_global *get_wpa_global_from_object(struct ubus_object *obj)
+{
+	return container_of(obj, struct wpa_global, ubus_global);
+}
+
+static inline struct wpa_supplicant *get_wpas_from_object(struct ubus_object *obj)
+{
+	return container_of(obj, struct wpa_supplicant, ubus.obj);
+}
+
+static void ubus_reconnect_timeout(void *eloop_data, void *user_ctx)
+{
+	if (ubus_reconnect(ctx, NULL)) {
+		eloop_register_timeout(1, 0, ubus_reconnect_timeout, ctx, NULL);
+		return;
+	}
+
+	ubus_add_uloop(ctx);
+}
+
+static void wpas_ubus_connection_lost(struct ubus_context *ctx)
+{
+	uloop_fd_delete(&ctx->sock);
+	eloop_register_timeout(1, 0, ubus_reconnect_timeout, ctx, NULL);
+}
+
+static bool wpas_ubus_init(void)
+{
+	if (ctx)
+		return true;
+
+	eloop_add_uloop();
+	ctx = ubus_connect(NULL);
+	if (!ctx)
+		return false;
+
+	ctx->connection_lost = wpas_ubus_connection_lost;
+	ubus_add_uloop(ctx);
+
+	return true;
+}
+
+static void wpas_ubus_ref_inc(void)
+{
+	ctx_ref++;
+}
+
+static void wpas_ubus_ref_dec(void)
+{
+	ctx_ref--;
+	if (!ctx)
+		return;
+
+	if (ctx_ref)
+		return;
+
+	uloop_fd_delete(&ctx->sock);
+	ubus_free(ctx);
+	ctx = NULL;
+}
+
+static int
+wpas_bss_get_features(struct ubus_context *ctx, struct ubus_object *obj,
+			struct ubus_request_data *req, const char *method,
+			struct blob_attr *msg)
+{
+	struct wpa_supplicant *wpa_s = get_wpas_from_object(obj);
+
+	blob_buf_init(&b, 0);
+	blobmsg_add_u8(&b, "ht_supported", ht_supported(wpa_s->hw.modes));
+	blobmsg_add_u8(&b, "vht_supported", vht_supported(wpa_s->hw.modes));
+	ubus_send_reply(ctx, req, b.head);
+
+	return 0;
+}
+
+static int
+wpas_bss_reload(struct ubus_context *ctx, struct ubus_object *obj,
+		struct ubus_request_data *req, const char *method,
+		struct blob_attr *msg)
+{
+	struct wpa_supplicant *wpa_s = get_wpas_from_object(obj);
+
+	if (wpa_supplicant_reload_configuration(wpa_s))
+		return UBUS_STATUS_UNKNOWN_ERROR;
+	else
+		return 0;
+}
+
+#ifdef CONFIG_WPS
+enum {
+	WPS_START_MULTI_AP,
+	__WPS_START_MAX
+};
+
+static const struct blobmsg_policy wps_start_policy[] = {
+	[WPS_START_MULTI_AP] = { "multi_ap", BLOBMSG_TYPE_BOOL },
+};
+
+static int
+wpas_bss_wps_start(struct ubus_context *ctx, struct ubus_object *obj,
+			struct ubus_request_data *req, const char *method,
+			struct blob_attr *msg)
+{
+	int rc;
+	struct wpa_supplicant *wpa_s = get_wpas_from_object(obj);
+	struct blob_attr *tb[__WPS_START_MAX], *cur;
+	int multi_ap = 0;
+
+	blobmsg_parse(wps_start_policy, __WPS_START_MAX, tb, blobmsg_data(msg), blobmsg_data_len(msg));
+
+	if (tb[WPS_START_MULTI_AP])
+		multi_ap = blobmsg_get_bool(tb[WPS_START_MULTI_AP]);
+
+	rc = wpas_wps_start_pbc(wpa_s, NULL, 0, multi_ap);
+
+	if (rc != 0)
+		return UBUS_STATUS_NOT_SUPPORTED;
+
+	return 0;
+}
+
+static int
+wpas_bss_wps_cancel(struct ubus_context *ctx, struct ubus_object *obj,
+			struct ubus_request_data *req, const char *method,
+			struct blob_attr *msg)
+{
+	int rc;
+	struct wpa_supplicant *wpa_s = get_wpas_from_object(obj);
+
+	rc = wpas_wps_cancel(wpa_s);
+
+	if (rc != 0)
+		return UBUS_STATUS_NOT_SUPPORTED;
+
+	return 0;
+}
+#endif
+
+static const struct ubus_method bss_methods[] = {
+	UBUS_METHOD_NOARG("reload", wpas_bss_reload),
+	UBUS_METHOD_NOARG("get_features", wpas_bss_get_features),
+#ifdef CONFIG_WPS
+	UBUS_METHOD_NOARG("wps_start", wpas_bss_wps_start),
+	UBUS_METHOD_NOARG("wps_cancel", wpas_bss_wps_cancel),
+#endif
+};
+
+static struct ubus_object_type bss_object_type =
+	UBUS_OBJECT_TYPE("wpas_bss", bss_methods);
+
+void wpas_ubus_add_bss(struct wpa_supplicant *wpa_s)
+{
+	struct ubus_object *obj = &wpa_s->ubus.obj;
+	char *name;
+	int ret;
+
+	if (!wpas_ubus_init())
+		return;
+
+	if (asprintf(&name, "wpa_supplicant.%s", wpa_s->ifname) < 0)
+		return;
+
+	obj->name = name;
+	obj->type = &bss_object_type;
+	obj->methods = bss_object_type.methods;
+	obj->n_methods = bss_object_type.n_methods;
+	ret = ubus_add_object(ctx, obj);
+	wpas_ubus_ref_inc();
+}
+
+void wpas_ubus_free_bss(struct wpa_supplicant *wpa_s)
+{
+	struct ubus_object *obj = &wpa_s->ubus.obj;
+	char *name = (char *) obj->name;
+
+	if (!ctx)
+		return;
+
+	if (obj->id) {
+		ubus_remove_object(ctx, obj);
+		wpas_ubus_ref_dec();
+	}
+
+	free(name);
+}
+
+#ifdef CONFIG_WPS
+void wpas_ubus_notify(struct wpa_supplicant *wpa_s, const struct wps_credential *cred)
+{
+	u16 auth_type;
+	char *ifname, *encryption, *ssid, *key;
+	size_t ifname_len;
+
+	if (!cred)
+		return;
+
+	auth_type = cred->auth_type;
+
+	if (auth_type == (WPS_AUTH_WPAPSK | WPS_AUTH_WPA2PSK))
+		auth_type = WPS_AUTH_WPA2PSK;
+
+	if (auth_type != WPS_AUTH_OPEN &&
+	    auth_type != WPS_AUTH_WPAPSK &&
+	    auth_type != WPS_AUTH_WPA2PSK) {
+		wpa_printf(MSG_DEBUG, "WPS: Ignored credentials for "
+			   "unsupported authentication type 0x%x",
+			   auth_type);
+		return;
+	}
+
+	if (auth_type == WPS_AUTH_WPAPSK || auth_type == WPS_AUTH_WPA2PSK) {
+		if (cred->key_len < 8 || cred->key_len > 2 * PMK_LEN) {
+			wpa_printf(MSG_ERROR, "WPS: Reject PSK credential with "
+				   "invalid Network Key length %lu",
+				   (unsigned long) cred->key_len);
+			return;
+		}
+	}
+
+	blob_buf_init(&b, 0);
+
+	ifname_len = strlen(wpa_s->ifname);
+	ifname = blobmsg_alloc_string_buffer(&b, "ifname", ifname_len + 1);
+	memcpy(ifname, wpa_s->ifname, ifname_len + 1);
+	ifname[ifname_len] = '\0';
+	blobmsg_add_string_buffer(&b);
+
+	switch (auth_type) {
+		case WPS_AUTH_WPA2PSK:
+			encryption = "psk2";
+			break;
+		case WPS_AUTH_WPAPSK:
+			encryption = "psk";
+			break;
+		default:
+			encryption = "none";
+			break;
+	}
+
+	blobmsg_add_string(&b, "encryption", encryption);
+
+	ssid = blobmsg_alloc_string_buffer(&b, "ssid", cred->ssid_len + 1);
+	memcpy(ssid, cred->ssid, cred->ssid_len);
+	ssid[cred->ssid_len] = '\0';
+	blobmsg_add_string_buffer(&b);
+
+	if (cred->key_len > 0) {
+		key = blobmsg_alloc_string_buffer(&b, "key", cred->key_len + 1);
+		memcpy(key, cred->key, cred->key_len);
+		key[cred->key_len] = '\0';
+		blobmsg_add_string_buffer(&b);
+	}
+
+//	ubus_notify(ctx, &wpa_s->ubus.obj, "wps_credentials", b.head, -1);
+	ubus_send_event(ctx, "wps_credentials", b.head);
+}
+#endif /* CONFIG_WPS */
diff --git a/wpa_supplicant/ubus.h b/wpa_supplicant/ubus.h
new file mode 100644
index 0000000..f6681cb
--- /dev/null
+++ b/wpa_supplicant/ubus.h
@@ -0,0 +1,55 @@
+/*
+ * wpa_supplicant / ubus support
+ * Copyright (c) 2018, Daniel Golle <daniel@makrotopia.org>
+ * Copyright (c) 2013, Felix Fietkau <nbd@nbd.name>
+ *
+ * This software may be distributed under the terms of the BSD license.
+ * See README for more details.
+ */
+#ifndef __WPAS_UBUS_H
+#define __WPAS_UBUS_H
+
+struct wpa_supplicant;
+struct wpa_global;
+
+#include "wps_supplicant.h"
+
+#ifdef UBUS_SUPPORT
+#include <libubus.h>
+
+struct wpas_ubus_bss {
+	struct ubus_object obj;
+};
+
+void wpas_ubus_add_bss(struct wpa_supplicant *wpa_s);
+void wpas_ubus_free_bss(struct wpa_supplicant *wpa_s);
+
+#ifdef CONFIG_WPS
+void wpas_ubus_notify(struct wpa_supplicant *wpa_s, const struct wps_credential *cred);
+#endif
+
+#else
+struct wpas_ubus_bss {};
+
+static inline void wpas_ubus_add_bss(struct wpa_supplicant *wpa_s)
+{
+}
+
+static inline void wpas_ubus_free_bss(struct wpa_supplicant *wpa_s)
+{
+}
+
+static inline void wpas_ubus_notify(struct wpa_supplicant *wpa_s, struct wps_credential *cred)
+{
+}
+
+static inline void wpas_ubus_add(struct wpa_global *global)
+{
+}
+
+static inline void wpas_ubus_free(struct wpa_global *global)
+{
+}
+#endif
+
+#endif
diff --git a/wpa_supplicant/ucode.c b/wpa_supplicant/ucode.c
new file mode 100644
index 0000000..d98cb85
--- /dev/null
+++ b/wpa_supplicant/ucode.c
@@ -0,0 +1,421 @@
+#include "utils/includes.h"
+#include "utils/common.h"
+#include "utils/ucode.h"
+#include "drivers/driver.h"
+#include "ap/hostapd.h"
+#include "wpa_supplicant_i.h"
+#include "wps_supplicant.h"
+#include "bss.h"
+#include "ucode.h"
+#include "driver_i.h"
+#include "common/ieee802_11_common.h"
+
+static struct wpa_global *wpa_global;
+static uc_resource_type_t *global_type, *iface_type;
+static uc_value_t *global, *iface_registry;
+static uc_vm_t *vm;
+
+static int
+wpas_ucode_get_radio_idx(struct wpa_supplicant *wpa_s, int freq)
+{
+	struct hostapd_multi_hw_info *multi_hw_info, *hw_info;
+	unsigned int num_multi_hws;
+	int i;
+
+	multi_hw_info = wpas_drv_get_multi_hw_info(wpa_s, &num_multi_hws);
+	if (!multi_hw_info)
+		return 0;
+
+	for (i = 0; i < num_multi_hws; i++) {
+		hw_info = &multi_hw_info[i];
+
+		if (hw_info->start_freq <= freq && hw_info->end_freq >= freq)
+			return hw_info->hw_idx;
+	}
+
+	return 0;
+}
+
+static uc_value_t *
+wpas_ucode_iface_get_uval(struct wpa_supplicant *wpa_s)
+{
+	uc_value_t *val;
+
+	if (wpa_s->ucode.idx)
+		return wpa_ucode_registry_get(iface_registry, wpa_s->ucode.idx);
+
+	val = uc_resource_new(iface_type, wpa_s);
+	wpa_s->ucode.idx = wpa_ucode_registry_add(iface_registry, val);
+
+	return val;
+}
+
+static void
+wpas_ucode_update_interfaces(void)
+{
+	uc_value_t *ifs = ucv_object_new(vm);
+	struct wpa_supplicant *wpa_s;
+	int i;
+
+	for (wpa_s = wpa_global->ifaces; wpa_s; wpa_s = wpa_s->next)
+		ucv_object_add(ifs, wpa_s->ifname, ucv_get(wpas_ucode_iface_get_uval(wpa_s)));
+
+	ucv_object_add(ucv_prototype_get(global), "interfaces", ucv_get(ifs));
+	ucv_gc(vm);
+}
+
+void wpas_ucode_add_bss(struct wpa_supplicant *wpa_s)
+{
+	uc_value_t *val;
+
+	if (wpa_ucode_call_prepare("iface_add"))
+		return;
+
+	uc_value_push(ucv_get(ucv_string_new(wpa_s->ifname)));
+	uc_value_push(ucv_get(wpas_ucode_iface_get_uval(wpa_s)));
+	ucv_put(wpa_ucode_call(2));
+	ucv_gc(vm);
+}
+
+void wpas_ucode_free_bss(struct wpa_supplicant *wpa_s)
+{
+	uc_value_t *val;
+
+	val = wpa_ucode_registry_remove(iface_registry, wpa_s->ucode.idx);
+	if (!val)
+		return;
+
+	wpa_s->ucode.idx = 0;
+	if (wpa_ucode_call_prepare("iface_remove"))
+		return;
+
+	uc_value_push(ucv_get(ucv_string_new(wpa_s->ifname)));
+	uc_value_push(ucv_get(val));
+	ucv_put(wpa_ucode_call(2));
+	ucv_gc(vm);
+}
+
+void wpas_ucode_update_state(struct wpa_supplicant *wpa_s)
+{
+	const char *state;
+	uc_value_t *val;
+
+	val = wpa_ucode_registry_get(iface_registry, wpa_s->ucode.idx);
+	if (!val)
+		return;
+
+	if (wpa_ucode_call_prepare("state"))
+		return;
+
+	state = wpa_supplicant_state_txt(wpa_s->wpa_state);
+	uc_value_push(ucv_get(ucv_string_new(wpa_s->ifname)));
+	uc_value_push(ucv_get(val));
+	uc_value_push(ucv_get(ucv_string_new(state)));
+	ucv_put(wpa_ucode_call(3));
+	ucv_gc(vm);
+}
+
+void wpas_ucode_event(struct wpa_supplicant *wpa_s, int event, union wpa_event_data *data)
+{
+	const char *state;
+	uc_value_t *val;
+	enum oper_chan_width oper_chwidth;
+	int control_freq, center_freq1, bw320_offset = 1, radio_idx;
+
+	if (event != EVENT_CH_SWITCH_STARTED &&
+	    event != EVENT_LINK_CH_SWITCH_STARTED)
+		return;
+
+	val = wpa_ucode_registry_get(iface_registry, wpa_s->ucode.idx);
+	if (!val)
+		return;
+
+	if (wpa_ucode_call_prepare("event"))
+		return;
+
+	uc_value_push(ucv_get(ucv_string_new(wpa_s->ifname)));
+	uc_value_push(ucv_get(val));
+	uc_value_push(ucv_get(ucv_string_new(event_to_string(event))));
+	val = ucv_object_new(vm);
+	uc_value_push(ucv_get(val));
+
+	if (event == EVENT_CH_SWITCH_STARTED ||
+	    event == EVENT_LINK_CH_SWITCH_STARTED) {
+		if (wpa_s->wpa_state < WPA_COMPLETED) {
+			wpa_printf(MSG_INFO,
+				   "ucode: mtk: receive channel switch event"
+				   "before association finished, reconnect\n");
+			wpa_supplicant_reconnect(wpa_s);
+			return;
+		}
+
+		control_freq = data->ch_switch.freq;
+		center_freq1 = data->ch_switch.cf1;
+
+		switch (data->ch_switch.ch_width) {
+		case CHAN_WIDTH_80:
+			oper_chwidth = CONF_OPER_CHWIDTH_80MHZ;
+			break;
+		case CHAN_WIDTH_80P80:
+			oper_chwidth = CONF_OPER_CHWIDTH_80P80MHZ;
+			break;
+		case CHAN_WIDTH_160:
+			oper_chwidth = CONF_OPER_CHWIDTH_160MHZ;
+			break;
+		case CHAN_WIDTH_320:
+			oper_chwidth = CONF_OPER_CHWIDTH_320MHZ;
+			break;
+		case CHAN_WIDTH_20_NOHT:
+		case CHAN_WIDTH_20:
+		case CHAN_WIDTH_40:
+		default:
+			oper_chwidth = CONF_OPER_CHWIDTH_USE_HT;
+			break;
+		}
+
+		/* Check bandwidth 320 MHz-2 */
+		if (oper_chwidth == CONF_OPER_CHWIDTH_320MHZ &&
+		    (center_freq1 == 6265) || center_freq1 == 6585 ||
+		     center_freq1 == 6905)
+			bw320_offset = 2;
+
+		radio_idx = wpas_ucode_get_radio_idx(wpa_s, control_freq);
+
+		ucv_object_add(val, "csa_count", ucv_int64_new(data->ch_switch.count));
+		ucv_object_add(val, "frequency", ucv_int64_new(data->ch_switch.freq));
+		ucv_object_add(val, "sec_chan_offset", ucv_int64_new(data->ch_switch.ch_offset));
+		ucv_object_add(val, "center_freq1", ucv_int64_new(center_freq1));
+		ucv_object_add(val, "center_freq2", ucv_int64_new(data->ch_switch.cf2));
+		ucv_object_add(val, "ch_width", ucv_int64_new(oper_chwidth));
+		ucv_object_add(val, "bw320_offset", ucv_int64_new(bw320_offset));
+		ucv_object_add(val, "punct_bitmap", ucv_int64_new(data->ch_switch.punct_bitmap));
+		ucv_object_add(val, "radio_idx", ucv_int64_new(radio_idx));
+	}
+
+	ucv_put(wpa_ucode_call(4));
+	ucv_gc(vm);
+}
+
+static const char *obj_stringval(uc_value_t *obj, const char *name)
+{
+	uc_value_t *val = ucv_object_get(obj, name, NULL);
+
+	return ucv_string_get(val);
+}
+
+static uc_value_t *
+uc_wpas_add_iface(uc_vm_t *vm, size_t nargs)
+{
+	uc_value_t *info = uc_fn_arg(0);
+	uc_value_t *driver = ucv_object_get(info, "driver", NULL);
+	uc_value_t *ifname = ucv_object_get(info, "iface", NULL);
+	uc_value_t *bridge = ucv_object_get(info, "bridge", NULL);
+	uc_value_t *config = ucv_object_get(info, "config", NULL);
+	uc_value_t *ctrl = ucv_object_get(info, "ctrl", NULL);
+	struct wpa_interface iface;
+	int ret = -1;
+
+	if (ucv_type(info) != UC_OBJECT)
+		goto out;
+
+	iface = (struct wpa_interface){
+		.driver = "nl80211",
+		.ifname = ucv_string_get(ifname),
+		.bridge_ifname = ucv_string_get(bridge),
+		.confname = ucv_string_get(config),
+		.ctrl_interface = ucv_string_get(ctrl),
+	};
+
+	if (driver) {
+		const char *drvname;
+		if (ucv_type(driver) != UC_STRING)
+			goto out;
+
+		iface.driver = NULL;
+		drvname = ucv_string_get(driver);
+		for (int i = 0; wpa_drivers[i]; i++) {
+			if (!strcmp(drvname, wpa_drivers[i]->name))
+				iface.driver = wpa_drivers[i]->name;
+		}
+
+		if (!iface.driver)
+			goto out;
+	}
+
+	if (!iface.ifname || !iface.confname)
+		goto out;
+
+	ret = wpa_supplicant_add_iface(wpa_global, &iface, 0) ? 0 : -1;
+	wpas_ucode_update_interfaces();
+
+out:
+	return ucv_int64_new(ret);
+}
+
+static uc_value_t *
+uc_wpas_remove_iface(uc_vm_t *vm, size_t nargs)
+{
+	struct wpa_supplicant *wpa_s = NULL;
+	uc_value_t *ifname_arg = uc_fn_arg(0);
+	const char *ifname = ucv_string_get(ifname_arg);
+	int ret = -1;
+
+	if (!ifname)
+		goto out;
+
+	for (wpa_s = wpa_global->ifaces; wpa_s; wpa_s = wpa_s->next)
+		if (!strcmp(wpa_s->ifname, ifname))
+			break;
+
+	if (!wpa_s)
+		goto out;
+
+	ret = wpa_supplicant_remove_iface(wpa_global, wpa_s, 0);
+	wpas_ucode_update_interfaces();
+
+out:
+	return ucv_int64_new(ret);
+}
+
+static uc_value_t *
+uc_wpas_iface_status(uc_vm_t *vm, size_t nargs)
+{
+	struct wpa_supplicant *wpa_s = uc_fn_thisval("wpas.iface");
+	struct wpa_bss *bss;
+	uc_value_t *ret, *val, *link_obj = uc_fn_arg(0);
+	struct wpa_channel_info ci;
+	u8 op_class, channel;
+	enum chan_width chwidth;
+	enum oper_chan_width oper_chwidth = CONF_OPER_CHWIDTH_USE_HT;
+	int center_freq1, bw320_offset = 1, is_24ghz, radio_idx;
+	enum hostapd_hw_mode hw_mode;
+	int link_id = ucv_int64_get(link_obj);
+	u32 freq;
+	u16 punct_bitmap;
+
+	if (!wpa_s)
+		return NULL;
+
+	ret = ucv_object_new(vm);
+
+	val = ucv_string_new(wpa_supplicant_state_txt(wpa_s->wpa_state));
+	ucv_object_add(ret, "state", ucv_get(val));
+
+	bss = link_id == -1 ? wpa_s->current_bss : wpa_s->links[link_id].bss;
+	if (bss) {
+		int sec_chan = 0;
+
+		hw_mode = ieee80211_freq_to_chan(bss->freq, &channel);
+		is_24ghz = hw_mode == HOSTAPD_MODE_IEEE80211G ||
+			   hw_mode == HOSTAPD_MODE_IEEE80211B;
+		radio_idx = wpas_ucode_get_radio_idx(wpa_s, bss->freq);
+
+		if (wpa_s->valid_links) {
+			freq = wpa_s->links[link_id].freq;
+			center_freq1 = wpa_s->links[link_id].center_freq1;
+			chwidth = wpa_s->links[link_id].width;
+			punct_bitmap = wpa_s->links[link_id].punct_bitmap;
+		} else {
+			wpa_drv_channel_info(wpa_s, &ci);
+			freq = ci.frequency;
+			center_freq1 = ci.center_frq1;
+			chwidth = ci.chanwidth;
+			punct_bitmap = ci.punct_bitmap;
+		}
+
+		if (bss->freq != center_freq1) {
+			if (is_24ghz)
+				sec_chan = (bss->freq < center_freq1) ? 1 : -1;
+			else
+				sec_chan = (bss->freq / 20) & 1 ? 1 : -1;
+		}
+
+		if (!ieee80211_chaninfo_to_channel(freq, chwidth, sec_chan,
+						   &op_class, &channel))
+			oper_chwidth = op_class_to_ch_width(op_class);
+
+		if (oper_chwidth == CONF_OPER_CHWIDTH_320MHZ &&
+		    (center_freq1 == 6265) || center_freq1 == 6585 ||
+		     center_freq1 == 6905) {
+			/* Bandwidth 320 MHz-2 */
+			bw320_offset = 2;
+		}
+
+		ucv_object_add(ret, "sec_chan_offset", ucv_int64_new(sec_chan));
+		ucv_object_add(ret, "frequency", ucv_int64_new(freq));
+		ucv_object_add(ret, "ch_width", ucv_int64_new(oper_chwidth));
+		ucv_object_add(ret, "bw320_offset", ucv_int64_new(bw320_offset));
+		ucv_object_add(ret, "radio_idx", ucv_int64_new(radio_idx));
+		ucv_object_add(ret, "punct_bitmap", ucv_int64_new(punct_bitmap));
+	}
+
+#ifdef CONFIG_MESH
+	if (wpa_s->ifmsh) {
+		struct hostapd_iface *ifmsh = wpa_s->ifmsh;
+
+		ucv_object_add(ret, "sec_chan_offset", ucv_int64_new(ifmsh->conf->secondary_channel));
+		ucv_object_add(ret, "frequency", ucv_int64_new(ifmsh->freq));
+	}
+#endif
+
+	return ret;
+}
+
+static uc_value_t *
+uc_wpas_iface_get_valid_links(uc_vm_t *vm, size_t nargs)
+{
+	struct wpa_supplicant *wpa_s = uc_fn_thisval("wpas.iface");
+	uc_value_t *ret;
+
+	if (!wpa_s)
+		return NULL;
+
+	ret = ucv_object_new(vm);
+	ucv_object_add(ret, "valid_links", ucv_uint64_new(wpa_s->valid_links));
+
+	return ret;
+}
+
+int wpas_ucode_init(struct wpa_global *gl)
+{
+	static const uc_function_list_t global_fns[] = {
+		{ "printf",	uc_wpa_printf },
+		{ "getpid", uc_wpa_getpid },
+		{ "add_iface", uc_wpas_add_iface },
+		{ "remove_iface", uc_wpas_remove_iface },
+		{ "udebug_set", uc_wpa_udebug_set },
+	};
+	static const uc_function_list_t iface_fns[] = {
+		{ "status", uc_wpas_iface_status },
+		{ "get_valid_links", uc_wpas_iface_get_valid_links },
+	};
+	uc_value_t *data, *proto;
+
+	wpa_global = gl;
+	vm = wpa_ucode_create_vm();
+
+	global_type = uc_type_declare(vm, "wpas.global", global_fns, NULL);
+	iface_type = uc_type_declare(vm, "wpas.iface", iface_fns, NULL);
+
+	iface_registry = ucv_array_new(vm);
+	uc_vm_registry_set(vm, "wpas.iface_registry", iface_registry);
+
+	global = wpa_ucode_global_init("wpas", global_type);
+
+	if (wpa_ucode_run(HOSTAPD_UC_PATH "wpa_supplicant.uc"))
+		goto free_vm;
+
+	ucv_gc(vm);
+	return 0;
+
+free_vm:
+	wpa_ucode_free_vm();
+	return -1;
+}
+
+void wpas_ucode_free(void)
+{
+	if (wpa_ucode_call_prepare("shutdown") == 0)
+		ucv_put(wpa_ucode_call(0));
+	wpa_ucode_free_vm();
+}
diff --git a/wpa_supplicant/ucode.h b/wpa_supplicant/ucode.h
new file mode 100644
index 0000000..a429a0e
--- /dev/null
+++ b/wpa_supplicant/ucode.h
@@ -0,0 +1,49 @@
+#ifndef __WPAS_UCODE_H
+#define __WPAS_UCODE_H
+
+#include "utils/ucode.h"
+
+struct wpa_global;
+union wpa_event_data;
+struct wpa_supplicant;
+
+struct wpas_ucode_bss {
+#ifdef UCODE_SUPPORT
+	unsigned int idx;
+#endif
+};
+
+#ifdef UCODE_SUPPORT
+int wpas_ucode_init(struct wpa_global *gl);
+void wpas_ucode_free(void);
+void wpas_ucode_add_bss(struct wpa_supplicant *wpa_s);
+void wpas_ucode_free_bss(struct wpa_supplicant *wpa_s);
+void wpas_ucode_update_state(struct wpa_supplicant *wpa_s);
+void wpas_ucode_event(struct wpa_supplicant *wpa_s, int event, union wpa_event_data *data);
+#else
+static inline int wpas_ucode_init(struct wpa_global *gl)
+{
+	return -EINVAL;
+}
+static inline void wpas_ucode_free(void)
+{
+}
+static inline void wpas_ucode_add_bss(struct wpa_supplicant *wpa_s)
+{
+}
+
+static inline void wpas_ucode_free_bss(struct wpa_supplicant *wpa_s)
+{
+}
+
+static inline void wpas_ucode_update_state(struct wpa_supplicant *wpa_s)
+{
+}
+
+static inline void wpas_ucode_event(struct wpa_supplicant *wpa_s, int event, union wpa_event_data *data)
+{
+}
+
+#endif
+
+#endif
diff --git a/wpa_supplicant/wpa_cli.c b/wpa_supplicant/wpa_cli.c
index af00e79..b239410 100644
--- a/wpa_supplicant/wpa_cli.c
+++ b/wpa_supplicant/wpa_cli.c
@@ -26,6 +26,15 @@
 #include <cutils/properties.h>
 #endif /* ANDROID */
 
+#ifndef CONFIG_P2P
+#define CONFIG_P2P
+#endif
+#ifndef CONFIG_AP
+#define CONFIG_AP
+#endif
+#ifndef CONFIG_MESH
+#define CONFIG_MESH
+#endif
 
 static const char *const wpa_cli_version =
 "wpa_cli v" VERSION_STR "\n"
diff --git a/wpa_supplicant/wpa_priv.c b/wpa_supplicant/wpa_priv.c
index 88f3f2a..92efe56 100644
--- a/wpa_supplicant/wpa_priv.c
+++ b/wpa_supplicant/wpa_priv.c
@@ -1042,8 +1042,8 @@ static void wpa_priv_send_ft_response(struct wpa_priv_interface *iface,
 }
 
 
-void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
-			  union wpa_event_data *data)
+static void supplicant_event(void *ctx, enum wpa_event_type event,
+			     union wpa_event_data *data)
 {
 	struct wpa_priv_interface *iface = ctx;
 
@@ -1106,7 +1106,7 @@ void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
 }
 
 
-void wpa_supplicant_event_global(void *ctx, enum wpa_event_type event,
+void supplicant_event_global(void *ctx, enum wpa_event_type event,
 				 union wpa_event_data *data)
 {
 	struct wpa_priv_global *global = ctx;
@@ -1220,6 +1220,8 @@ int main(int argc, char *argv[])
 	if (os_program_init())
 		return -1;
 
+	wpa_supplicant_event = supplicant_event;
+	wpa_supplicant_event_global = supplicant_event_global;
 	wpa_priv_fd_workaround();
 
 	os_memset(&global, 0, sizeof(global));
diff --git a/wpa_supplicant/wpa_supplicant.c b/wpa_supplicant/wpa_supplicant.c
index 60b0db0..da471c9 100644
--- a/wpa_supplicant/wpa_supplicant.c
+++ b/wpa_supplicant/wpa_supplicant.c
@@ -1151,6 +1151,7 @@ void wpa_supplicant_set_state(struct wpa_supplicant *wpa_s,
 		sme_sched_obss_scan(wpa_s, 0);
 	}
 	wpa_s->wpa_state = state;
+	wpas_ucode_update_state(wpa_s);
 
 #ifdef CONFIG_BGSCAN
 	if (state == WPA_COMPLETED && wpa_s->current_ssid != wpa_s->bgscan_ssid)
@@ -2848,7 +2849,7 @@ static int drv_supports_vht(struct wpa_supplicant *wpa_s,
 }
 
 
-static bool ibss_mesh_is_80mhz_avail(int channel, struct hostapd_hw_modes *mode)
+static bool ibss_mesh_is_80mhz_avail(int channel, struct hostapd_hw_modes *mode, bool dfs_enabled)
 {
 	int i;
 
@@ -2857,7 +2858,10 @@ static bool ibss_mesh_is_80mhz_avail(int channel, struct hostapd_hw_modes *mode)
 
 		chan = hw_get_channel_chan(mode, i, NULL);
 		if (!chan ||
-		    chan->flag & (HOSTAPD_CHAN_DISABLED | HOSTAPD_CHAN_NO_IR))
+		    chan->flag & HOSTAPD_CHAN_DISABLED)
+			return false;
+		
+		if (!dfs_enabled && chan->flag & (HOSTAPD_CHAN_RADAR | HOSTAPD_CHAN_NO_IR))
 			return false;
 	}
 
@@ -2917,7 +2921,7 @@ static bool ibss_mesh_can_use_vht(struct wpa_supplicant *wpa_s,
 				  const struct wpa_ssid *ssid,
 				  struct hostapd_hw_modes *mode)
 {
-	if (mode->mode != HOSTAPD_MODE_IEEE80211A)
+	if (mode->mode != HOSTAPD_MODE_IEEE80211A && !(ssid->noscan))
 		return false;
 
 	if (!drv_supports_vht(wpa_s, ssid))
@@ -2984,13 +2988,13 @@ static void ibss_mesh_select_40mhz(struct wpa_supplicant *wpa_s,
 				   const struct wpa_ssid *ssid,
 				   struct hostapd_hw_modes *mode,
 				   struct hostapd_freq_params *freq,
-				   int obss_scan) {
+				   int obss_scan, bool dfs_enabled) {
 	int chan_idx;
 	struct hostapd_channel_data *pri_chan = NULL, *sec_chan = NULL;
 	int i, res;
 	unsigned int j;
 	static const int ht40plus[] = {
-		36, 44, 52, 60, 100, 108, 116, 124, 132, 140,
+		1, 2, 3, 4, 5, 6, 7, 36, 44, 52, 60, 100, 108, 116, 124, 132, 140,
 		149, 157, 165, 173, 184, 192
 	};
 	int ht40 = -1;
@@ -3008,8 +3012,11 @@ static void ibss_mesh_select_40mhz(struct wpa_supplicant *wpa_s,
 		return;
 
 	/* Check primary channel flags */
-	if (pri_chan->flag & (HOSTAPD_CHAN_DISABLED | HOSTAPD_CHAN_NO_IR))
+	if (pri_chan->flag & HOSTAPD_CHAN_DISABLED)
 		return;
+	if (pri_chan->flag & (HOSTAPD_CHAN_RADAR | HOSTAPD_CHAN_NO_IR))
+		if (!dfs_enabled)
+			return;
 
 #ifdef CONFIG_HT_OVERRIDES
 	if (ssid->disable_ht40)
@@ -3035,8 +3042,11 @@ static void ibss_mesh_select_40mhz(struct wpa_supplicant *wpa_s,
 		return;
 
 	/* Check secondary channel flags */
-	if (sec_chan->flag & (HOSTAPD_CHAN_DISABLED | HOSTAPD_CHAN_NO_IR))
+	if (sec_chan->flag & HOSTAPD_CHAN_DISABLED)
 		return;
+	if (sec_chan->flag & (HOSTAPD_CHAN_RADAR | HOSTAPD_CHAN_NO_IR))
+		if (!dfs_enabled)
+			return;
 
 	if (ht40 == -1) {
 		if (!(pri_chan->flag & HOSTAPD_CHAN_HT40MINUS))
@@ -3112,7 +3122,7 @@ static bool ibss_mesh_select_80_160mhz(struct wpa_supplicant *wpa_s,
 				       const struct wpa_ssid *ssid,
 				       struct hostapd_hw_modes *mode,
 				       struct hostapd_freq_params *freq,
-				       int ieee80211_mode, bool is_6ghz) {
+				       int ieee80211_mode, bool is_6ghz, bool dfs_enabled) {
 	static const int bw80[] = {
 		5180, 5260, 5500, 5580, 5660, 5745, 5825,
 		5955, 6035, 6115, 6195, 6275, 6355, 6435,
@@ -3162,7 +3172,7 @@ static bool ibss_mesh_select_80_160mhz(struct wpa_supplicant *wpa_s,
 		goto skip_80mhz;
 
 	/* Use 40 MHz if channel not usable */
-	if (!ibss_mesh_is_80mhz_avail(channel, mode))
+	if (!ibss_mesh_is_80mhz_avail(channel, mode, dfs_enabled))
 		goto skip_80mhz;
 
 	chwidth = CONF_OPER_CHWIDTH_80MHZ;
@@ -3176,7 +3186,7 @@ static bool ibss_mesh_select_80_160mhz(struct wpa_supplicant *wpa_s,
 	if ((mode->he_capab[ieee80211_mode].phy_cap[
 		     HE_PHYCAP_CHANNEL_WIDTH_SET_IDX] &
 	     HE_PHYCAP_CHANNEL_WIDTH_SET_160MHZ_IN_5G) && is_6ghz &&
-	    ibss_mesh_is_80mhz_avail(channel + 16, mode)) {
+	    ibss_mesh_is_80mhz_avail(channel + 16, mode, dfs_enabled)) {
 		for (j = 0; j < ARRAY_SIZE(bw160); j++) {
 			if (freq->freq == bw160[j]) {
 				chwidth = CONF_OPER_CHWIDTH_160MHZ;
@@ -3193,9 +3203,9 @@ static bool ibss_mesh_select_80_160mhz(struct wpa_supplicant *wpa_s,
 	if ((mode->eht_capab[ieee80211_mode].phy_cap[
 		     EHT_PHYCAP_320MHZ_IN_6GHZ_SUPPORT_IDX] &
 	     EHT_PHYCAP_320MHZ_IN_6GHZ_SUPPORT_MASK) && is_6ghz &&
-	    ibss_mesh_is_80mhz_avail(channel + 16, mode) &&
-	    ibss_mesh_is_80mhz_avail(channel + 32, mode) &&
-	    ibss_mesh_is_80mhz_avail(channel + 48, mode)) {
+	    ibss_mesh_is_80mhz_avail(channel + 16, mode, dfs_enabled) &&
+	    ibss_mesh_is_80mhz_avail(channel + 32, mode, dfs_enabled) &&
+	    ibss_mesh_is_80mhz_avail(channel + 48, mode, dfs_enabled)) {
 		for (j = 0; j < ARRAY_SIZE(bw320); j += 2) {
 			if (freq->freq >= bw320[j] &&
 			    freq->freq <= bw320[j + 1]) {
@@ -3224,10 +3234,12 @@ static bool ibss_mesh_select_80_160mhz(struct wpa_supplicant *wpa_s,
 				if (!chan)
 					continue;
 
-				if (chan->flag & (HOSTAPD_CHAN_DISABLED |
-						  HOSTAPD_CHAN_NO_IR |
-						  HOSTAPD_CHAN_RADAR))
+				if (chan->flag & HOSTAPD_CHAN_DISABLED)
 					continue;
+				if (chan->flag & (HOSTAPD_CHAN_RADAR |
+						  HOSTAPD_CHAN_NO_IR))
+					if (!dfs_enabled)
+						continue;
 
 				/* Found a suitable second segment for 80+80 */
 				chwidth = CONF_OPER_CHWIDTH_80P80MHZ;
@@ -3279,12 +3291,17 @@ void ibss_mesh_setup_freq(struct wpa_supplicant *wpa_s,
 	int ieee80211_mode = wpas_mode_to_ieee80211_mode(ssid->mode);
 	enum hostapd_hw_mode hw_mode;
 	struct hostapd_hw_modes *mode = NULL;
-	int obss_scan = 1;
+	int obss_scan = !(ssid->noscan);
 	u8 channel;
 	bool is_6ghz, is_24ghz;
+	bool dfs_enabled = wpa_s->conf->country[0] && (wpa_s->drv_flags & WPA_DRIVER_FLAGS_RADAR);
 
 	freq->freq = ssid->frequency;
 
+	if (ssid->fixed_freq) {
+		obss_scan = 0;
+	}
+
 	if (ssid->mode == WPAS_MODE_IBSS && !ssid->fixed_freq) {
 		struct wpa_bss *bss = ibss_find_existing_bss(wpa_s, ssid);
 
@@ -3322,11 +3339,13 @@ void ibss_mesh_setup_freq(struct wpa_supplicant *wpa_s,
 		freq->he_enabled = ibss_mesh_can_use_he(wpa_s, ssid, mode,
 							ieee80211_mode);
 	freq->channel = channel;
+	if (mode->mode == HOSTAPD_MODE_IEEE80211G && ssid->noscan)
+		ibss_mesh_select_40mhz(wpa_s, ssid, mode, freq, obss_scan, dfs_enabled);
 	/* Setup higher BW only for 5 GHz */
 	if (mode->mode == HOSTAPD_MODE_IEEE80211A) {
-		ibss_mesh_select_40mhz(wpa_s, ssid, mode, freq, obss_scan);
+		ibss_mesh_select_40mhz(wpa_s, ssid, mode, freq, obss_scan, dfs_enabled);
 		if (!ibss_mesh_select_80_160mhz(wpa_s, ssid, mode, freq,
-						ieee80211_mode, is_6ghz))
+						ieee80211_mode, is_6ghz, dfs_enabled))
 			freq->he_enabled = freq->vht_enabled = false;
 	}
 
@@ -4484,6 +4503,12 @@ static void wpas_start_assoc_cb(struct wpa_radio_work *work, int deinit)
 			params.beacon_int = ssid->beacon_int;
 		else
 			params.beacon_int = wpa_s->conf->beacon_int;
+		int i = 0;
+		while (i < WLAN_SUPP_RATES_MAX) {
+			params.rates[i] = ssid->rates[i];
+			i++;
+		}
+		params.mcast_rate = ssid->mcast_rate;
 	}
 
 	if (bss && ssid->enable_edmg)
@@ -6137,7 +6162,7 @@ wpa_supplicant_alloc(struct wpa_supplicant *parent)
 	if (wpa_s == NULL)
 		return NULL;
 	wpa_s->scan_req = INITIAL_SCAN_REQ;
-	wpa_s->scan_interval = 5;
+	wpa_s->scan_interval = 1;
 	wpa_s->new_connection = 1;
 	wpa_s->parent = parent ? parent : wpa_s;
 	wpa_s->p2pdev = wpa_s->parent;
@@ -7853,7 +7878,6 @@ struct wpa_interface * wpa_supplicant_match_iface(struct wpa_global *global,
 	return NULL;
 }
 
-
 /**
  * wpa_supplicant_match_existing - Match existing interfaces
  * @global: Pointer to global data from wpa_supplicant_init()
@@ -7888,6 +7912,11 @@ static int wpa_supplicant_match_existing(struct wpa_global *global)
 
 #endif /* CONFIG_MATCH_IFACE */
 
+extern void supplicant_event(void *ctx, enum wpa_event_type event,
+			     union wpa_event_data *data);
+
+extern void supplicant_event_global(void *ctx, enum wpa_event_type event,
+ 				 union wpa_event_data *data);
 
 /**
  * wpa_supplicant_add_iface - Add a new network interface
@@ -7970,6 +7999,9 @@ struct wpa_supplicant * wpa_supplicant_add_iface(struct wpa_global *global,
 	}
 #endif /* CONFIG_P2P */
 
+	wpas_ubus_add_bss(wpa_s);
+	wpas_ucode_add_bss(wpa_s);
+
 	return wpa_s;
 }
 
@@ -7996,6 +8028,9 @@ int wpa_supplicant_remove_iface(struct wpa_global *global,
 	struct wpa_supplicant *parent = wpa_s->parent;
 #endif /* CONFIG_MESH */
 
+	wpas_ucode_free_bss(wpa_s);
+	wpas_ubus_free_bss(wpa_s);
+
 	/* Remove interface from the global list of interfaces */
 	prev = global->ifaces;
 	if (prev == wpa_s) {
@@ -8144,6 +8179,8 @@ struct wpa_global * wpa_supplicant_init(struct wpa_params *params)
 #ifndef CONFIG_NO_WPA_MSG
 	wpa_msg_register_ifname_cb(wpa_supplicant_msg_ifname_cb);
 #endif /* CONFIG_NO_WPA_MSG */
+	wpa_supplicant_event = supplicant_event;
+	wpa_supplicant_event_global = supplicant_event_global;
 
 	if (params->wpa_debug_file_path)
 		wpa_debug_open_file(params->wpa_debug_file_path);
@@ -8302,6 +8339,7 @@ struct wpa_global * wpa_supplicant_init(struct wpa_params *params)
 
 	eloop_register_timeout(WPA_SUPPLICANT_CLEANUP_INTERVAL, 0,
 			       wpas_periodic, global, NULL);
+	wpas_ucode_init(global);
 
 	return global;
 }
@@ -8374,6 +8412,8 @@ void wpa_supplicant_deinit(struct wpa_global *global)
 
 	wpas_notify_supplicant_deinitialized(global);
 
+	wpas_ucode_free();
+
 	eap_peer_unregister_methods();
 #ifdef CONFIG_AP
 	eap_server_unregister_methods();
diff --git a/wpa_supplicant/wpa_supplicant_i.h b/wpa_supplicant/wpa_supplicant_i.h
index 1f41c14..1c1e69d 100644
--- a/wpa_supplicant/wpa_supplicant_i.h
+++ b/wpa_supplicant/wpa_supplicant_i.h
@@ -21,6 +21,8 @@
 #include "config_ssid.h"
 #include "wmm_ac.h"
 #include "pasn/pasn_common.h"
+#include "ubus.h"
+#include "ucode.h"
 
 extern const char *const wpa_supplicant_version;
 extern const char *const wpa_supplicant_license;
@@ -319,6 +321,8 @@ struct wpa_global {
 #endif /* CONFIG_WIFI_DISPLAY */
 
 	struct psk_list_entry *add_psk; /* From group formation */
+
+	struct ubus_object ubus_global;
 };
 
 
@@ -693,6 +697,8 @@ struct wpa_supplicant {
 	unsigned char own_addr[ETH_ALEN];
 	unsigned char perm_addr[ETH_ALEN];
 	char ifname[100];
+	struct wpas_ubus_bss ubus;
+	struct wpas_ucode_bss ucode;
 #ifdef CONFIG_MATCH_IFACE
 	int matched;
 #endif /* CONFIG_MATCH_IFACE */
@@ -734,7 +740,9 @@ struct wpa_supplicant {
 	struct {
 		u8 addr[ETH_ALEN];
 		u8 bssid[ETH_ALEN];
-		unsigned int freq;
+		unsigned int freq, center_freq1, center_freq2;
+		enum chan_width width;
+		u16 punct_bitmap;
 		struct wpa_bss *bss;
 		bool disabled;
 	} links[MAX_NUM_MLD_LINKS];
diff --git a/wpa_supplicant/wps_supplicant.c b/wpa_supplicant/wps_supplicant.c
index 7b9cf7f..03748f4 100644
--- a/wpa_supplicant/wps_supplicant.c
+++ b/wpa_supplicant/wps_supplicant.c
@@ -33,6 +33,7 @@
 #include "p2p/p2p.h"
 #include "p2p_supplicant.h"
 #include "wps_supplicant.h"
+#include "ubus.h"
 
 
 #ifndef WPS_PIN_SCAN_IGNORE_SEL_REG
@@ -401,6 +402,8 @@ static int wpa_supplicant_wps_cred(void *ctx,
 	wpa_hexdump_key(MSG_DEBUG, "WPS: Received Credential attribute",
 			cred->cred_attr, cred->cred_attr_len);
 
+	wpas_ubus_notify(wpa_s, cred);
+
 	if (wpa_s->conf->wps_cred_processing == 1)
 		return 0;
 
diff --git a/wpa_supplicant/wps_supplicant.h b/wpa_supplicant/wps_supplicant.h
index aae3f7c..30b4e91 100644
--- a/wpa_supplicant/wps_supplicant.h
+++ b/wpa_supplicant/wps_supplicant.h
@@ -9,6 +9,7 @@
 #ifndef WPS_SUPPLICANT_H
 #define WPS_SUPPLICANT_H
 
+struct wpa_bss;
 struct wpa_scan_results;
 
 #ifdef CONFIG_WPS
@@ -16,8 +17,6 @@ struct wpa_scan_results;
 #include "wps/wps.h"
 #include "wps/wps_defs.h"
 
-struct wpa_bss;
-
 struct wps_new_ap_settings {
 	const char *ssid_hex;
 	const char *auth;
